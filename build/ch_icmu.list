
build/ch_icmu.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002d9 	.word	0x080002d9
 8000008:	080002db 	.word	0x080002db
 800000c:	080002db 	.word	0x080002db
 8000010:	080002db 	.word	0x080002db
 8000014:	080002db 	.word	0x080002db
 8000018:	080002db 	.word	0x080002db
 800001c:	080002db 	.word	0x080002db
 8000020:	080002db 	.word	0x080002db
 8000024:	080002db 	.word	0x080002db
 8000028:	080002db 	.word	0x080002db
 800002c:	08014321 	.word	0x08014321
 8000030:	080002db 	.word	0x080002db
 8000034:	080002db 	.word	0x080002db
 8000038:	080002db 	.word	0x080002db
 800003c:	080002db 	.word	0x080002db
 8000040:	080002db 	.word	0x080002db
 8000044:	080002db 	.word	0x080002db
 8000048:	080002db 	.word	0x080002db
 800004c:	080002db 	.word	0x080002db
 8000050:	080002db 	.word	0x080002db
 8000054:	080002db 	.word	0x080002db
 8000058:	080002db 	.word	0x080002db
 800005c:	080002db 	.word	0x080002db
 8000060:	080002db 	.word	0x080002db
 8000064:	080002db 	.word	0x080002db
 8000068:	080002db 	.word	0x080002db
 800006c:	0800bdc1 	.word	0x0800bdc1
 8000070:	0800be21 	.word	0x0800be21
 8000074:	0800be81 	.word	0x0800be81
 8000078:	0800bee1 	.word	0x0800bee1
 800007c:	0800bf41 	.word	0x0800bf41
 8000080:	0800bfa1 	.word	0x0800bfa1
 8000084:	0800c001 	.word	0x0800c001
 8000088:	080002db 	.word	0x080002db
 800008c:	080002db 	.word	0x080002db
 8000090:	080002db 	.word	0x080002db
 8000094:	080002db 	.word	0x080002db
 8000098:	080002db 	.word	0x080002db
 800009c:	080002db 	.word	0x080002db
 80000a0:	080002db 	.word	0x080002db
 80000a4:	0800e261 	.word	0x0800e261
 80000a8:	080002db 	.word	0x080002db
 80000ac:	0800e291 	.word	0x0800e291
 80000b0:	0800e191 	.word	0x0800e191
 80000b4:	080002db 	.word	0x080002db
 80000b8:	080002db 	.word	0x080002db
 80000bc:	080002db 	.word	0x080002db
 80000c0:	080002db 	.word	0x080002db
 80000c4:	080002db 	.word	0x080002db
 80000c8:	080002db 	.word	0x080002db
 80000cc:	080002db 	.word	0x080002db
 80000d0:	080002db 	.word	0x080002db
 80000d4:	080002db 	.word	0x080002db
 80000d8:	0800e941 	.word	0x0800e941
 80000dc:	080002db 	.word	0x080002db
 80000e0:	080002db 	.word	0x080002db
 80000e4:	080002db 	.word	0x080002db
 80000e8:	080002db 	.word	0x080002db
 80000ec:	080002db 	.word	0x080002db
 80000f0:	080002db 	.word	0x080002db
 80000f4:	080002db 	.word	0x080002db
 80000f8:	080002db 	.word	0x080002db
 80000fc:	0800c061 	.word	0x0800c061
 8000100:	080002db 	.word	0x080002db
 8000104:	080002db 	.word	0x080002db
 8000108:	080002db 	.word	0x080002db
 800010c:	080002db 	.word	0x080002db
 8000110:	080002db 	.word	0x080002db
 8000114:	080002db 	.word	0x080002db
 8000118:	080002db 	.word	0x080002db
 800011c:	080002db 	.word	0x080002db
 8000120:	0800c0c1 	.word	0x0800c0c1
 8000124:	0800c121 	.word	0x0800c121
 8000128:	0800c181 	.word	0x0800c181
 800012c:	0800c1e1 	.word	0x0800c1e1
 8000130:	0800c241 	.word	0x0800c241
 8000134:	080002db 	.word	0x080002db
 8000138:	080002db 	.word	0x080002db
 800013c:	080002db 	.word	0x080002db
 8000140:	080002db 	.word	0x080002db
 8000144:	080002db 	.word	0x080002db
 8000148:	080002db 	.word	0x080002db
 800014c:	0800d241 	.word	0x0800d241
 8000150:	0800c2a1 	.word	0x0800c2a1
 8000154:	0800c301 	.word	0x0800c301
 8000158:	0800c361 	.word	0x0800c361
 800015c:	080002db 	.word	0x080002db
 8000160:	080002db 	.word	0x080002db
 8000164:	080002db 	.word	0x080002db
 8000168:	080002db 	.word	0x080002db
 800016c:	080002db 	.word	0x080002db
 8000170:	080002db 	.word	0x080002db
 8000174:	0800d271 	.word	0x0800d271
 8000178:	080002db 	.word	0x080002db
 800017c:	080002db 	.word	0x080002db
 8000180:	080002db 	.word	0x080002db
 8000184:	080002db 	.word	0x080002db
 8000188:	080002db 	.word	0x080002db
 800018c:	080002db 	.word	0x080002db
 8000190:	080002db 	.word	0x080002db
 8000194:	080002db 	.word	0x080002db
 8000198:	080002db 	.word	0x080002db
 800019c:	080002db 	.word	0x080002db
 80001a0:	080002db 	.word	0x080002db
 80001a4:	080002db 	.word	0x080002db
 80001a8:	080002db 	.word	0x080002db
 80001ac:	080002db 	.word	0x080002db
 80001b0:	080002db 	.word	0x080002db
 80001b4:	080002db 	.word	0x080002db
 80001b8:	080002db 	.word	0x080002db
 80001bc:	080002db 	.word	0x080002db
 80001c0:	080002db 	.word	0x080002db
 80001c4:	080002db 	.word	0x080002db
 80001c8:	080002db 	.word	0x080002db
 80001cc:	080002db 	.word	0x080002db
 80001d0:	080002db 	.word	0x080002db
 80001d4:	080002db 	.word	0x080002db
 80001d8:	080002db 	.word	0x080002db
 80001dc:	080002db 	.word	0x080002db

Disassembly of section .text:

08000200 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000200:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000202:	4827      	ldr	r0, [pc, #156]	; (80002a0 <endfiniloop+0x4>)
                msr     MSP, r0
 8000204:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000208:	4826      	ldr	r0, [pc, #152]	; (80002a4 <endfiniloop+0x8>)
                msr     PSP, r0
 800020a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 800020e:	4826      	ldr	r0, [pc, #152]	; (80002a8 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 8000210:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 8000214:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000218:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 800021a:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 800021c:	f380 8814 	msr	CONTROL, r0
                isb
 8000220:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000224:	f008 fbf4 	bl	8008a10 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000228:	f00e fc7a 	bl	800eb20 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800022c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000230:	491e      	ldr	r1, [pc, #120]	; (80002ac <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 8000232:	4a1b      	ldr	r2, [pc, #108]	; (80002a0 <endfiniloop+0x4>)

08000234 <msloop>:
msloop:
                cmp     r1, r2
 8000234:	4291      	cmp	r1, r2
                itt     lo
 8000236:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000238:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 800023c:	e7fa      	bcc.n	8000234 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800023e:	491c      	ldr	r1, [pc, #112]	; (80002b0 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 8000240:	4a18      	ldr	r2, [pc, #96]	; (80002a4 <endfiniloop+0x8>)

08000242 <psloop>:
psloop:
                cmp     r1, r2
 8000242:	4291      	cmp	r1, r2
                itt     lo
 8000244:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000246:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800024a:	e7fa      	bcc.n	8000242 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 800024c:	4919      	ldr	r1, [pc, #100]	; (80002b4 <endfiniloop+0x18>)
                ldr     r2, =_data_start
 800024e:	4a1a      	ldr	r2, [pc, #104]	; (80002b8 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
 8000250:	4b1a      	ldr	r3, [pc, #104]	; (80002bc <endfiniloop+0x20>)

08000252 <dloop>:
dloop:
                cmp     r2, r3
 8000252:	429a      	cmp	r2, r3
                ittt    lo
 8000254:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000256:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800025a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800025e:	e7f8      	bcc.n	8000252 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000260:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000262:	4917      	ldr	r1, [pc, #92]	; (80002c0 <endfiniloop+0x24>)
                ldr     r2, =_bss_end
 8000264:	4a17      	ldr	r2, [pc, #92]	; (80002c4 <endfiniloop+0x28>)

08000266 <bloop>:
bloop:
                cmp     r1, r2
 8000266:	4291      	cmp	r1, r2
                itt     lo
 8000268:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800026a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800026e:	e7fa      	bcc.n	8000266 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000270:	f008 fbe6 	bl	8008a40 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000274:	f008 fbd4 	bl	8008a20 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8000278:	4c13      	ldr	r4, [pc, #76]	; (80002c8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
 800027a:	4d14      	ldr	r5, [pc, #80]	; (80002cc <endfiniloop+0x30>)

0800027c <initloop>:
initloop:
                cmp     r4, r5
 800027c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800027e:	da03      	bge.n	8000288 <endinitloop>
                ldr     r1, [r4], #4
 8000280:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000284:	4788      	blx	r1
                b       initloop
 8000286:	e7f9      	b.n	800027c <initloop>

08000288 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000288:	f008 fa82 	bl	8008790 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800028c:	4c10      	ldr	r4, [pc, #64]	; (80002d0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
 800028e:	4d11      	ldr	r5, [pc, #68]	; (80002d4 <endfiniloop+0x38>)

08000290 <finiloop>:
finiloop:
                cmp     r4, r5
 8000290:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000292:	da03      	bge.n	800029c <endfiniloop>
                ldr     r1, [r4], #4
 8000294:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000298:	4788      	blx	r1
                b       finiloop
 800029a:	e7f9      	b.n	8000290 <finiloop>

0800029c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800029c:	f008 bbc8 	b.w	8008a30 <__default_exit>
                ldr     r0, =__main_stack_end__
 80002a0:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 80002a4:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 80002a8:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 80002ac:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80002b0:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
 80002b4:	080190a4 	.word	0x080190a4
                ldr     r2, =_data_start
 80002b8:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 80002bc:	20000d5c 	.word	0x20000d5c
                ldr     r1, =_bss_start
 80002c0:	20000d60 	.word	0x20000d60
                ldr     r2, =_bss_end
 80002c4:	200032c8 	.word	0x200032c8
                ldr     r4, =__init_array_start
 80002c8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end
 80002cc:	080001e4 	.word	0x080001e4
                ldr     r4, =__fini_array_start
 80002d0:	080001e4 	.word	0x080001e4
                ldr     r5, =__fini_array_end
 80002d4:	080001e4 	.word	0x080001e4

080002d8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002d8:	e792      	b.n	8000200 <_crt0_entry>

080002da <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80002da:	f000 f800 	bl	80002de <_unhandled_exception>

080002de <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002de:	e7fe      	b.n	80002de <_unhandled_exception>

080002e0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002e8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ea:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f0 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80002f0:	f00e fffe 	bl	800f2f0 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002f4:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002f6:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002fa:	4628      	mov	r0, r5
                blx     r4
 80002fc:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80002fe:	2000      	movs	r0, #0
                bl      chThdExit
 8000300:	f010 f9a6 	bl	8010650 <chThdExit>

08000304 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 8000304:	f00e ffdc 	bl	800f2c0 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 8000308:	f00f fe6a 	bl	800ffe0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 800030c:	f00e fff0 	bl	800f2f0 <_dbg_check_unlock>

08000310 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000310:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000312:	e7fe      	b.n	8000312 <_port_exit_from_isr+0x2>

08000314 <memcpy>:
 8000314:	4684      	mov	ip, r0
 8000316:	ea41 0300 	orr.w	r3, r1, r0
 800031a:	f013 0303 	ands.w	r3, r3, #3
 800031e:	d16d      	bne.n	80003fc <memcpy+0xe8>
 8000320:	3a40      	subs	r2, #64	; 0x40
 8000322:	d341      	bcc.n	80003a8 <memcpy+0x94>
 8000324:	f851 3b04 	ldr.w	r3, [r1], #4
 8000328:	f840 3b04 	str.w	r3, [r0], #4
 800032c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000330:	f840 3b04 	str.w	r3, [r0], #4
 8000334:	f851 3b04 	ldr.w	r3, [r1], #4
 8000338:	f840 3b04 	str.w	r3, [r0], #4
 800033c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000340:	f840 3b04 	str.w	r3, [r0], #4
 8000344:	f851 3b04 	ldr.w	r3, [r1], #4
 8000348:	f840 3b04 	str.w	r3, [r0], #4
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	f851 3b04 	ldr.w	r3, [r1], #4
 8000368:	f840 3b04 	str.w	r3, [r0], #4
 800036c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000370:	f840 3b04 	str.w	r3, [r0], #4
 8000374:	f851 3b04 	ldr.w	r3, [r1], #4
 8000378:	f840 3b04 	str.w	r3, [r0], #4
 800037c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000380:	f840 3b04 	str.w	r3, [r0], #4
 8000384:	f851 3b04 	ldr.w	r3, [r1], #4
 8000388:	f840 3b04 	str.w	r3, [r0], #4
 800038c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000390:	f840 3b04 	str.w	r3, [r0], #4
 8000394:	f851 3b04 	ldr.w	r3, [r1], #4
 8000398:	f840 3b04 	str.w	r3, [r0], #4
 800039c:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a0:	f840 3b04 	str.w	r3, [r0], #4
 80003a4:	3a40      	subs	r2, #64	; 0x40
 80003a6:	d2bd      	bcs.n	8000324 <memcpy+0x10>
 80003a8:	3230      	adds	r2, #48	; 0x30
 80003aa:	d311      	bcc.n	80003d0 <memcpy+0xbc>
 80003ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b0:	f840 3b04 	str.w	r3, [r0], #4
 80003b4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b8:	f840 3b04 	str.w	r3, [r0], #4
 80003bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c0:	f840 3b04 	str.w	r3, [r0], #4
 80003c4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c8:	f840 3b04 	str.w	r3, [r0], #4
 80003cc:	3a10      	subs	r2, #16
 80003ce:	d2ed      	bcs.n	80003ac <memcpy+0x98>
 80003d0:	320c      	adds	r2, #12
 80003d2:	d305      	bcc.n	80003e0 <memcpy+0xcc>
 80003d4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d8:	f840 3b04 	str.w	r3, [r0], #4
 80003dc:	3a04      	subs	r2, #4
 80003de:	d2f9      	bcs.n	80003d4 <memcpy+0xc0>
 80003e0:	3204      	adds	r2, #4
 80003e2:	d008      	beq.n	80003f6 <memcpy+0xe2>
 80003e4:	07d2      	lsls	r2, r2, #31
 80003e6:	bf1c      	itt	ne
 80003e8:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003ec:	f800 3b01 	strbne.w	r3, [r0], #1
 80003f0:	d301      	bcc.n	80003f6 <memcpy+0xe2>
 80003f2:	880b      	ldrh	r3, [r1, #0]
 80003f4:	8003      	strh	r3, [r0, #0]
 80003f6:	4660      	mov	r0, ip
 80003f8:	4770      	bx	lr
 80003fa:	bf00      	nop
 80003fc:	2a08      	cmp	r2, #8
 80003fe:	d313      	bcc.n	8000428 <memcpy+0x114>
 8000400:	078b      	lsls	r3, r1, #30
 8000402:	d08d      	beq.n	8000320 <memcpy+0xc>
 8000404:	f010 0303 	ands.w	r3, r0, #3
 8000408:	d08a      	beq.n	8000320 <memcpy+0xc>
 800040a:	f1c3 0304 	rsb	r3, r3, #4
 800040e:	1ad2      	subs	r2, r2, r3
 8000410:	07db      	lsls	r3, r3, #31
 8000412:	bf1c      	itt	ne
 8000414:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000418:	f800 3b01 	strbne.w	r3, [r0], #1
 800041c:	d380      	bcc.n	8000320 <memcpy+0xc>
 800041e:	f831 3b02 	ldrh.w	r3, [r1], #2
 8000422:	f820 3b02 	strh.w	r3, [r0], #2
 8000426:	e77b      	b.n	8000320 <memcpy+0xc>
 8000428:	3a04      	subs	r2, #4
 800042a:	d3d9      	bcc.n	80003e0 <memcpy+0xcc>
 800042c:	3a01      	subs	r2, #1
 800042e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000432:	f800 3b01 	strb.w	r3, [r0], #1
 8000436:	d2f9      	bcs.n	800042c <memcpy+0x118>
 8000438:	780b      	ldrb	r3, [r1, #0]
 800043a:	7003      	strb	r3, [r0, #0]
 800043c:	784b      	ldrb	r3, [r1, #1]
 800043e:	7043      	strb	r3, [r0, #1]
 8000440:	788b      	ldrb	r3, [r1, #2]
 8000442:	7083      	strb	r3, [r0, #2]
 8000444:	4660      	mov	r0, ip
 8000446:	4770      	bx	lr
	...
 8000460:	eba2 0003 	sub.w	r0, r2, r3
 8000464:	4770      	bx	lr
 8000466:	bf00      	nop

08000468 <strcmp>:
 8000468:	7802      	ldrb	r2, [r0, #0]
 800046a:	780b      	ldrb	r3, [r1, #0]
 800046c:	2a01      	cmp	r2, #1
 800046e:	bf28      	it	cs
 8000470:	429a      	cmpcs	r2, r3
 8000472:	d1f5      	bne.n	8000460 <memcpy+0x14c>
 8000474:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000478:	ea40 0401 	orr.w	r4, r0, r1
 800047c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000480:	f06f 0c00 	mvn.w	ip, #0
 8000484:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000488:	b312      	cbz	r2, 80004d0 <strcmp+0x68>
 800048a:	ea80 0401 	eor.w	r4, r0, r1
 800048e:	f014 0f07 	tst.w	r4, #7
 8000492:	d16a      	bne.n	800056a <strcmp+0x102>
 8000494:	f000 0407 	and.w	r4, r0, #7
 8000498:	f020 0007 	bic.w	r0, r0, #7
 800049c:	f004 0503 	and.w	r5, r4, #3
 80004a0:	f021 0107 	bic.w	r1, r1, #7
 80004a4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 80004a8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 80004ac:	f014 0f04 	tst.w	r4, #4
 80004b0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 80004b4:	fa0c f405 	lsl.w	r4, ip, r5
 80004b8:	ea62 0204 	orn	r2, r2, r4
 80004bc:	ea66 0604 	orn	r6, r6, r4
 80004c0:	d00a      	beq.n	80004d8 <strcmp+0x70>
 80004c2:	ea63 0304 	orn	r3, r3, r4
 80004c6:	4662      	mov	r2, ip
 80004c8:	ea67 0704 	orn	r7, r7, r4
 80004cc:	4666      	mov	r6, ip
 80004ce:	e003      	b.n	80004d8 <strcmp+0x70>
 80004d0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 80004d4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 80004d8:	fa82 f54c 	uadd8	r5, r2, ip
 80004dc:	ea82 0406 	eor.w	r4, r2, r6
 80004e0:	faa4 f48c 	sel	r4, r4, ip
 80004e4:	bb6c      	cbnz	r4, 8000542 <strcmp+0xda>
 80004e6:	fa83 f54c 	uadd8	r5, r3, ip
 80004ea:	ea83 0507 	eor.w	r5, r3, r7
 80004ee:	faa5 f58c 	sel	r5, r5, ip
 80004f2:	b995      	cbnz	r5, 800051a <strcmp+0xb2>
 80004f4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 80004f8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 80004fc:	fa82 f54c 	uadd8	r5, r2, ip
 8000500:	ea82 0406 	eor.w	r4, r2, r6
 8000504:	faa4 f48c 	sel	r4, r4, ip
 8000508:	fa83 f54c 	uadd8	r5, r3, ip
 800050c:	ea83 0507 	eor.w	r5, r3, r7
 8000510:	faa5 f58c 	sel	r5, r5, ip
 8000514:	4325      	orrs	r5, r4
 8000516:	d0db      	beq.n	80004d0 <strcmp+0x68>
 8000518:	b99c      	cbnz	r4, 8000542 <strcmp+0xda>
 800051a:	ba2d      	rev	r5, r5
 800051c:	fab5 f485 	clz	r4, r5
 8000520:	f024 0407 	bic.w	r4, r4, #7
 8000524:	fa27 f104 	lsr.w	r1, r7, r4
 8000528:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800052c:	fa23 f304 	lsr.w	r3, r3, r4
 8000530:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8000534:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000538:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800053c:	eba0 0001 	sub.w	r0, r0, r1
 8000540:	4770      	bx	lr
 8000542:	ba24      	rev	r4, r4
 8000544:	fab4 f484 	clz	r4, r4
 8000548:	f024 0407 	bic.w	r4, r4, #7
 800054c:	fa26 f104 	lsr.w	r1, r6, r4
 8000550:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000554:	fa22 f204 	lsr.w	r2, r2, r4
 8000558:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800055c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000560:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000564:	eba0 0001 	sub.w	r0, r0, r1
 8000568:	4770      	bx	lr
 800056a:	f014 0f03 	tst.w	r4, #3
 800056e:	d13c      	bne.n	80005ea <strcmp+0x182>
 8000570:	f010 0403 	ands.w	r4, r0, #3
 8000574:	d128      	bne.n	80005c8 <strcmp+0x160>
 8000576:	f850 2b08 	ldr.w	r2, [r0], #8
 800057a:	f851 3b08 	ldr.w	r3, [r1], #8
 800057e:	fa82 f54c 	uadd8	r5, r2, ip
 8000582:	ea82 0503 	eor.w	r5, r2, r3
 8000586:	faa5 f58c 	sel	r5, r5, ip
 800058a:	b95d      	cbnz	r5, 80005a4 <strcmp+0x13c>
 800058c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000590:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000594:	fa82 f54c 	uadd8	r5, r2, ip
 8000598:	ea82 0503 	eor.w	r5, r2, r3
 800059c:	faa5 f58c 	sel	r5, r5, ip
 80005a0:	2d00      	cmp	r5, #0
 80005a2:	d0e8      	beq.n	8000576 <strcmp+0x10e>
 80005a4:	ba2d      	rev	r5, r5
 80005a6:	fab5 f485 	clz	r4, r5
 80005aa:	f024 0407 	bic.w	r4, r4, #7
 80005ae:	fa23 f104 	lsr.w	r1, r3, r4
 80005b2:	fa22 f204 	lsr.w	r2, r2, r4
 80005b6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 80005ba:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80005be:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80005c2:	eba0 0001 	sub.w	r0, r0, r1
 80005c6:	4770      	bx	lr
 80005c8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 80005cc:	f020 0003 	bic.w	r0, r0, #3
 80005d0:	f850 2b08 	ldr.w	r2, [r0], #8
 80005d4:	f021 0103 	bic.w	r1, r1, #3
 80005d8:	f851 3b08 	ldr.w	r3, [r1], #8
 80005dc:	fa0c f404 	lsl.w	r4, ip, r4
 80005e0:	ea62 0204 	orn	r2, r2, r4
 80005e4:	ea63 0304 	orn	r3, r3, r4
 80005e8:	e7c9      	b.n	800057e <strcmp+0x116>
 80005ea:	f010 0403 	ands.w	r4, r0, #3
 80005ee:	d01a      	beq.n	8000626 <strcmp+0x1be>
 80005f0:	eba1 0104 	sub.w	r1, r1, r4
 80005f4:	f020 0003 	bic.w	r0, r0, #3
 80005f8:	07e4      	lsls	r4, r4, #31
 80005fa:	f850 2b04 	ldr.w	r2, [r0], #4
 80005fe:	d006      	beq.n	800060e <strcmp+0x1a6>
 8000600:	d20f      	bcs.n	8000622 <strcmp+0x1ba>
 8000602:	788b      	ldrb	r3, [r1, #2]
 8000604:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 8000608:	1ae4      	subs	r4, r4, r3
 800060a:	d106      	bne.n	800061a <strcmp+0x1b2>
 800060c:	b12b      	cbz	r3, 800061a <strcmp+0x1b2>
 800060e:	78cb      	ldrb	r3, [r1, #3]
 8000610:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 8000614:	1ae4      	subs	r4, r4, r3
 8000616:	d100      	bne.n	800061a <strcmp+0x1b2>
 8000618:	b91b      	cbnz	r3, 8000622 <strcmp+0x1ba>
 800061a:	4620      	mov	r0, r4
 800061c:	f85d 4b10 	ldr.w	r4, [sp], #16
 8000620:	4770      	bx	lr
 8000622:	f101 0104 	add.w	r1, r1, #4
 8000626:	f850 2b04 	ldr.w	r2, [r0], #4
 800062a:	07cc      	lsls	r4, r1, #31
 800062c:	f021 0103 	bic.w	r1, r1, #3
 8000630:	f851 3b04 	ldr.w	r3, [r1], #4
 8000634:	d848      	bhi.n	80006c8 <strcmp+0x260>
 8000636:	d224      	bcs.n	8000682 <strcmp+0x21a>
 8000638:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 800063c:	fa82 f54c 	uadd8	r5, r2, ip
 8000640:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000644:	faa5 f58c 	sel	r5, r5, ip
 8000648:	d10a      	bne.n	8000660 <strcmp+0x1f8>
 800064a:	b965      	cbnz	r5, 8000666 <strcmp+0x1fe>
 800064c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000650:	ea84 0402 	eor.w	r4, r4, r2
 8000654:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000658:	d10e      	bne.n	8000678 <strcmp+0x210>
 800065a:	f850 2b04 	ldr.w	r2, [r0], #4
 800065e:	e7eb      	b.n	8000638 <strcmp+0x1d0>
 8000660:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000664:	e055      	b.n	8000712 <strcmp+0x2aa>
 8000666:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800066a:	d14d      	bne.n	8000708 <strcmp+0x2a0>
 800066c:	7808      	ldrb	r0, [r1, #0]
 800066e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000672:	f1c0 0000 	rsb	r0, r0, #0
 8000676:	4770      	bx	lr
 8000678:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800067c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000680:	e047      	b.n	8000712 <strcmp+0x2aa>
 8000682:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000686:	fa82 f54c 	uadd8	r5, r2, ip
 800068a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800068e:	faa5 f58c 	sel	r5, r5, ip
 8000692:	d10a      	bne.n	80006aa <strcmp+0x242>
 8000694:	b965      	cbnz	r5, 80006b0 <strcmp+0x248>
 8000696:	f851 3b04 	ldr.w	r3, [r1], #4
 800069a:	ea84 0402 	eor.w	r4, r4, r2
 800069e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 80006a2:	d10c      	bne.n	80006be <strcmp+0x256>
 80006a4:	f850 2b04 	ldr.w	r2, [r0], #4
 80006a8:	e7eb      	b.n	8000682 <strcmp+0x21a>
 80006aa:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80006ae:	e030      	b.n	8000712 <strcmp+0x2aa>
 80006b0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 80006b4:	d128      	bne.n	8000708 <strcmp+0x2a0>
 80006b6:	880b      	ldrh	r3, [r1, #0]
 80006b8:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80006bc:	e029      	b.n	8000712 <strcmp+0x2aa>
 80006be:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80006c2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 80006c6:	e024      	b.n	8000712 <strcmp+0x2aa>
 80006c8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 80006cc:	fa82 f54c 	uadd8	r5, r2, ip
 80006d0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 80006d4:	faa5 f58c 	sel	r5, r5, ip
 80006d8:	d10a      	bne.n	80006f0 <strcmp+0x288>
 80006da:	b965      	cbnz	r5, 80006f6 <strcmp+0x28e>
 80006dc:	f851 3b04 	ldr.w	r3, [r1], #4
 80006e0:	ea84 0402 	eor.w	r4, r4, r2
 80006e4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 80006e8:	d109      	bne.n	80006fe <strcmp+0x296>
 80006ea:	f850 2b04 	ldr.w	r2, [r0], #4
 80006ee:	e7eb      	b.n	80006c8 <strcmp+0x260>
 80006f0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80006f4:	e00d      	b.n	8000712 <strcmp+0x2aa>
 80006f6:	f015 0fff 	tst.w	r5, #255	; 0xff
 80006fa:	d105      	bne.n	8000708 <strcmp+0x2a0>
 80006fc:	680b      	ldr	r3, [r1, #0]
 80006fe:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8000702:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000706:	e004      	b.n	8000712 <strcmp+0x2aa>
 8000708:	f04f 0000 	mov.w	r0, #0
 800070c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000710:	4770      	bx	lr
 8000712:	ba12      	rev	r2, r2
 8000714:	ba1b      	rev	r3, r3
 8000716:	fa82 f44c 	uadd8	r4, r2, ip
 800071a:	ea82 0403 	eor.w	r4, r2, r3
 800071e:	faa4 f58c 	sel	r5, r4, ip
 8000722:	fab5 f485 	clz	r4, r5
 8000726:	fa02 f204 	lsl.w	r2, r2, r4
 800072a:	fa03 f304 	lsl.w	r3, r3, r4
 800072e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8000732:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000736:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 800073a:	4770      	bx	lr

0800073c <__aeabi_uldivmod>:
 800073c:	b953      	cbnz	r3, 8000754 <__aeabi_uldivmod+0x18>
 800073e:	b94a      	cbnz	r2, 8000754 <__aeabi_uldivmod+0x18>
 8000740:	2900      	cmp	r1, #0
 8000742:	bf08      	it	eq
 8000744:	2800      	cmpeq	r0, #0
 8000746:	bf1c      	itt	ne
 8000748:	f04f 31ff 	movne.w	r1, #4294967295
 800074c:	f04f 30ff 	movne.w	r0, #4294967295
 8000750:	f000 b972 	b.w	8000a38 <__aeabi_idiv0>
 8000754:	f1ad 0c08 	sub.w	ip, sp, #8
 8000758:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 800075c:	f000 f806 	bl	800076c <__udivmoddi4>
 8000760:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000764:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000768:	b004      	add	sp, #16
 800076a:	4770      	bx	lr

0800076c <__udivmoddi4>:
 800076c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000770:	9e08      	ldr	r6, [sp, #32]
 8000772:	4604      	mov	r4, r0
 8000774:	4688      	mov	r8, r1
 8000776:	2b00      	cmp	r3, #0
 8000778:	d14b      	bne.n	8000812 <__udivmoddi4+0xa6>
 800077a:	428a      	cmp	r2, r1
 800077c:	4615      	mov	r5, r2
 800077e:	d967      	bls.n	8000850 <__udivmoddi4+0xe4>
 8000780:	fab2 f282 	clz	r2, r2
 8000784:	b14a      	cbz	r2, 800079a <__udivmoddi4+0x2e>
 8000786:	f1c2 0720 	rsb	r7, r2, #32
 800078a:	fa01 f302 	lsl.w	r3, r1, r2
 800078e:	fa20 f707 	lsr.w	r7, r0, r7
 8000792:	4095      	lsls	r5, r2
 8000794:	ea47 0803 	orr.w	r8, r7, r3
 8000798:	4094      	lsls	r4, r2
 800079a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800079e:	0c23      	lsrs	r3, r4, #16
 80007a0:	fbb8 f7fe 	udiv	r7, r8, lr
 80007a4:	fa1f fc85 	uxth.w	ip, r5
 80007a8:	fb0e 8817 	mls	r8, lr, r7, r8
 80007ac:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80007b0:	fb07 f10c 	mul.w	r1, r7, ip
 80007b4:	4299      	cmp	r1, r3
 80007b6:	d909      	bls.n	80007cc <__udivmoddi4+0x60>
 80007b8:	18eb      	adds	r3, r5, r3
 80007ba:	f107 30ff 	add.w	r0, r7, #4294967295
 80007be:	f080 811b 	bcs.w	80009f8 <__udivmoddi4+0x28c>
 80007c2:	4299      	cmp	r1, r3
 80007c4:	f240 8118 	bls.w	80009f8 <__udivmoddi4+0x28c>
 80007c8:	3f02      	subs	r7, #2
 80007ca:	442b      	add	r3, r5
 80007cc:	1a5b      	subs	r3, r3, r1
 80007ce:	b2a4      	uxth	r4, r4
 80007d0:	fbb3 f0fe 	udiv	r0, r3, lr
 80007d4:	fb0e 3310 	mls	r3, lr, r0, r3
 80007d8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80007dc:	fb00 fc0c 	mul.w	ip, r0, ip
 80007e0:	45a4      	cmp	ip, r4
 80007e2:	d909      	bls.n	80007f8 <__udivmoddi4+0x8c>
 80007e4:	192c      	adds	r4, r5, r4
 80007e6:	f100 33ff 	add.w	r3, r0, #4294967295
 80007ea:	f080 8107 	bcs.w	80009fc <__udivmoddi4+0x290>
 80007ee:	45a4      	cmp	ip, r4
 80007f0:	f240 8104 	bls.w	80009fc <__udivmoddi4+0x290>
 80007f4:	3802      	subs	r0, #2
 80007f6:	442c      	add	r4, r5
 80007f8:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 80007fc:	eba4 040c 	sub.w	r4, r4, ip
 8000800:	2700      	movs	r7, #0
 8000802:	b11e      	cbz	r6, 800080c <__udivmoddi4+0xa0>
 8000804:	40d4      	lsrs	r4, r2
 8000806:	2300      	movs	r3, #0
 8000808:	e9c6 4300 	strd	r4, r3, [r6]
 800080c:	4639      	mov	r1, r7
 800080e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000812:	428b      	cmp	r3, r1
 8000814:	d909      	bls.n	800082a <__udivmoddi4+0xbe>
 8000816:	2e00      	cmp	r6, #0
 8000818:	f000 80eb 	beq.w	80009f2 <__udivmoddi4+0x286>
 800081c:	2700      	movs	r7, #0
 800081e:	e9c6 0100 	strd	r0, r1, [r6]
 8000822:	4638      	mov	r0, r7
 8000824:	4639      	mov	r1, r7
 8000826:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800082a:	fab3 f783 	clz	r7, r3
 800082e:	2f00      	cmp	r7, #0
 8000830:	d147      	bne.n	80008c2 <__udivmoddi4+0x156>
 8000832:	428b      	cmp	r3, r1
 8000834:	d302      	bcc.n	800083c <__udivmoddi4+0xd0>
 8000836:	4282      	cmp	r2, r0
 8000838:	f200 80fa 	bhi.w	8000a30 <__udivmoddi4+0x2c4>
 800083c:	1a84      	subs	r4, r0, r2
 800083e:	eb61 0303 	sbc.w	r3, r1, r3
 8000842:	2001      	movs	r0, #1
 8000844:	4698      	mov	r8, r3
 8000846:	2e00      	cmp	r6, #0
 8000848:	d0e0      	beq.n	800080c <__udivmoddi4+0xa0>
 800084a:	e9c6 4800 	strd	r4, r8, [r6]
 800084e:	e7dd      	b.n	800080c <__udivmoddi4+0xa0>
 8000850:	b902      	cbnz	r2, 8000854 <__udivmoddi4+0xe8>
 8000852:	deff      	udf	#255	; 0xff
 8000854:	fab2 f282 	clz	r2, r2
 8000858:	2a00      	cmp	r2, #0
 800085a:	f040 808f 	bne.w	800097c <__udivmoddi4+0x210>
 800085e:	1b49      	subs	r1, r1, r5
 8000860:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000864:	fa1f f885 	uxth.w	r8, r5
 8000868:	2701      	movs	r7, #1
 800086a:	fbb1 fcfe 	udiv	ip, r1, lr
 800086e:	0c23      	lsrs	r3, r4, #16
 8000870:	fb0e 111c 	mls	r1, lr, ip, r1
 8000874:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000878:	fb08 f10c 	mul.w	r1, r8, ip
 800087c:	4299      	cmp	r1, r3
 800087e:	d907      	bls.n	8000890 <__udivmoddi4+0x124>
 8000880:	18eb      	adds	r3, r5, r3
 8000882:	f10c 30ff 	add.w	r0, ip, #4294967295
 8000886:	d202      	bcs.n	800088e <__udivmoddi4+0x122>
 8000888:	4299      	cmp	r1, r3
 800088a:	f200 80cd 	bhi.w	8000a28 <__udivmoddi4+0x2bc>
 800088e:	4684      	mov	ip, r0
 8000890:	1a59      	subs	r1, r3, r1
 8000892:	b2a3      	uxth	r3, r4
 8000894:	fbb1 f0fe 	udiv	r0, r1, lr
 8000898:	fb0e 1410 	mls	r4, lr, r0, r1
 800089c:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 80008a0:	fb08 f800 	mul.w	r8, r8, r0
 80008a4:	45a0      	cmp	r8, r4
 80008a6:	d907      	bls.n	80008b8 <__udivmoddi4+0x14c>
 80008a8:	192c      	adds	r4, r5, r4
 80008aa:	f100 33ff 	add.w	r3, r0, #4294967295
 80008ae:	d202      	bcs.n	80008b6 <__udivmoddi4+0x14a>
 80008b0:	45a0      	cmp	r8, r4
 80008b2:	f200 80b6 	bhi.w	8000a22 <__udivmoddi4+0x2b6>
 80008b6:	4618      	mov	r0, r3
 80008b8:	eba4 0408 	sub.w	r4, r4, r8
 80008bc:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80008c0:	e79f      	b.n	8000802 <__udivmoddi4+0x96>
 80008c2:	f1c7 0c20 	rsb	ip, r7, #32
 80008c6:	40bb      	lsls	r3, r7
 80008c8:	fa22 fe0c 	lsr.w	lr, r2, ip
 80008cc:	ea4e 0e03 	orr.w	lr, lr, r3
 80008d0:	fa01 f407 	lsl.w	r4, r1, r7
 80008d4:	fa20 f50c 	lsr.w	r5, r0, ip
 80008d8:	fa21 f30c 	lsr.w	r3, r1, ip
 80008dc:	ea4f 481e 	mov.w	r8, lr, lsr #16
 80008e0:	4325      	orrs	r5, r4
 80008e2:	fbb3 f9f8 	udiv	r9, r3, r8
 80008e6:	0c2c      	lsrs	r4, r5, #16
 80008e8:	fb08 3319 	mls	r3, r8, r9, r3
 80008ec:	fa1f fa8e 	uxth.w	sl, lr
 80008f0:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 80008f4:	fb09 f40a 	mul.w	r4, r9, sl
 80008f8:	429c      	cmp	r4, r3
 80008fa:	fa02 f207 	lsl.w	r2, r2, r7
 80008fe:	fa00 f107 	lsl.w	r1, r0, r7
 8000902:	d90b      	bls.n	800091c <__udivmoddi4+0x1b0>
 8000904:	eb1e 0303 	adds.w	r3, lr, r3
 8000908:	f109 30ff 	add.w	r0, r9, #4294967295
 800090c:	f080 8087 	bcs.w	8000a1e <__udivmoddi4+0x2b2>
 8000910:	429c      	cmp	r4, r3
 8000912:	f240 8084 	bls.w	8000a1e <__udivmoddi4+0x2b2>
 8000916:	f1a9 0902 	sub.w	r9, r9, #2
 800091a:	4473      	add	r3, lr
 800091c:	1b1b      	subs	r3, r3, r4
 800091e:	b2ad      	uxth	r5, r5
 8000920:	fbb3 f0f8 	udiv	r0, r3, r8
 8000924:	fb08 3310 	mls	r3, r8, r0, r3
 8000928:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 800092c:	fb00 fa0a 	mul.w	sl, r0, sl
 8000930:	45a2      	cmp	sl, r4
 8000932:	d908      	bls.n	8000946 <__udivmoddi4+0x1da>
 8000934:	eb1e 0404 	adds.w	r4, lr, r4
 8000938:	f100 33ff 	add.w	r3, r0, #4294967295
 800093c:	d26b      	bcs.n	8000a16 <__udivmoddi4+0x2aa>
 800093e:	45a2      	cmp	sl, r4
 8000940:	d969      	bls.n	8000a16 <__udivmoddi4+0x2aa>
 8000942:	3802      	subs	r0, #2
 8000944:	4474      	add	r4, lr
 8000946:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800094a:	fba0 8902 	umull	r8, r9, r0, r2
 800094e:	eba4 040a 	sub.w	r4, r4, sl
 8000952:	454c      	cmp	r4, r9
 8000954:	46c2      	mov	sl, r8
 8000956:	464b      	mov	r3, r9
 8000958:	d354      	bcc.n	8000a04 <__udivmoddi4+0x298>
 800095a:	d051      	beq.n	8000a00 <__udivmoddi4+0x294>
 800095c:	2e00      	cmp	r6, #0
 800095e:	d069      	beq.n	8000a34 <__udivmoddi4+0x2c8>
 8000960:	ebb1 050a 	subs.w	r5, r1, sl
 8000964:	eb64 0403 	sbc.w	r4, r4, r3
 8000968:	fa04 fc0c 	lsl.w	ip, r4, ip
 800096c:	40fd      	lsrs	r5, r7
 800096e:	40fc      	lsrs	r4, r7
 8000970:	ea4c 0505 	orr.w	r5, ip, r5
 8000974:	e9c6 5400 	strd	r5, r4, [r6]
 8000978:	2700      	movs	r7, #0
 800097a:	e747      	b.n	800080c <__udivmoddi4+0xa0>
 800097c:	f1c2 0320 	rsb	r3, r2, #32
 8000980:	fa20 f703 	lsr.w	r7, r0, r3
 8000984:	4095      	lsls	r5, r2
 8000986:	fa01 f002 	lsl.w	r0, r1, r2
 800098a:	fa21 f303 	lsr.w	r3, r1, r3
 800098e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000992:	4338      	orrs	r0, r7
 8000994:	0c01      	lsrs	r1, r0, #16
 8000996:	fbb3 f7fe 	udiv	r7, r3, lr
 800099a:	fa1f f885 	uxth.w	r8, r5
 800099e:	fb0e 3317 	mls	r3, lr, r7, r3
 80009a2:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80009a6:	fb07 f308 	mul.w	r3, r7, r8
 80009aa:	428b      	cmp	r3, r1
 80009ac:	fa04 f402 	lsl.w	r4, r4, r2
 80009b0:	d907      	bls.n	80009c2 <__udivmoddi4+0x256>
 80009b2:	1869      	adds	r1, r5, r1
 80009b4:	f107 3cff 	add.w	ip, r7, #4294967295
 80009b8:	d22f      	bcs.n	8000a1a <__udivmoddi4+0x2ae>
 80009ba:	428b      	cmp	r3, r1
 80009bc:	d92d      	bls.n	8000a1a <__udivmoddi4+0x2ae>
 80009be:	3f02      	subs	r7, #2
 80009c0:	4429      	add	r1, r5
 80009c2:	1acb      	subs	r3, r1, r3
 80009c4:	b281      	uxth	r1, r0
 80009c6:	fbb3 f0fe 	udiv	r0, r3, lr
 80009ca:	fb0e 3310 	mls	r3, lr, r0, r3
 80009ce:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80009d2:	fb00 f308 	mul.w	r3, r0, r8
 80009d6:	428b      	cmp	r3, r1
 80009d8:	d907      	bls.n	80009ea <__udivmoddi4+0x27e>
 80009da:	1869      	adds	r1, r5, r1
 80009dc:	f100 3cff 	add.w	ip, r0, #4294967295
 80009e0:	d217      	bcs.n	8000a12 <__udivmoddi4+0x2a6>
 80009e2:	428b      	cmp	r3, r1
 80009e4:	d915      	bls.n	8000a12 <__udivmoddi4+0x2a6>
 80009e6:	3802      	subs	r0, #2
 80009e8:	4429      	add	r1, r5
 80009ea:	1ac9      	subs	r1, r1, r3
 80009ec:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 80009f0:	e73b      	b.n	800086a <__udivmoddi4+0xfe>
 80009f2:	4637      	mov	r7, r6
 80009f4:	4630      	mov	r0, r6
 80009f6:	e709      	b.n	800080c <__udivmoddi4+0xa0>
 80009f8:	4607      	mov	r7, r0
 80009fa:	e6e7      	b.n	80007cc <__udivmoddi4+0x60>
 80009fc:	4618      	mov	r0, r3
 80009fe:	e6fb      	b.n	80007f8 <__udivmoddi4+0x8c>
 8000a00:	4541      	cmp	r1, r8
 8000a02:	d2ab      	bcs.n	800095c <__udivmoddi4+0x1f0>
 8000a04:	ebb8 0a02 	subs.w	sl, r8, r2
 8000a08:	eb69 020e 	sbc.w	r2, r9, lr
 8000a0c:	3801      	subs	r0, #1
 8000a0e:	4613      	mov	r3, r2
 8000a10:	e7a4      	b.n	800095c <__udivmoddi4+0x1f0>
 8000a12:	4660      	mov	r0, ip
 8000a14:	e7e9      	b.n	80009ea <__udivmoddi4+0x27e>
 8000a16:	4618      	mov	r0, r3
 8000a18:	e795      	b.n	8000946 <__udivmoddi4+0x1da>
 8000a1a:	4667      	mov	r7, ip
 8000a1c:	e7d1      	b.n	80009c2 <__udivmoddi4+0x256>
 8000a1e:	4681      	mov	r9, r0
 8000a20:	e77c      	b.n	800091c <__udivmoddi4+0x1b0>
 8000a22:	3802      	subs	r0, #2
 8000a24:	442c      	add	r4, r5
 8000a26:	e747      	b.n	80008b8 <__udivmoddi4+0x14c>
 8000a28:	f1ac 0c02 	sub.w	ip, ip, #2
 8000a2c:	442b      	add	r3, r5
 8000a2e:	e72f      	b.n	8000890 <__udivmoddi4+0x124>
 8000a30:	4638      	mov	r0, r7
 8000a32:	e708      	b.n	8000846 <__udivmoddi4+0xda>
 8000a34:	4637      	mov	r7, r6
 8000a36:	e6e9      	b.n	800080c <__udivmoddi4+0xa0>

08000a38 <__aeabi_idiv0>:
 8000a38:	4770      	bx	lr
 8000a3a:	bf00      	nop
 8000a3c:	0000      	movs	r0, r0
	...

08000a40 <test_execute>:
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 *
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream, const testsuite_t *tsp) {
 8000a40:	b500      	push	{lr}
 8000a42:	b085      	sub	sp, #20
 8000a44:	9001      	str	r0, [sp, #4]
 8000a46:	9100      	str	r1, [sp, #0]
  int tseq, tcase;

  test_chp = stream;
 8000a48:	4a6f      	ldr	r2, [pc, #444]	; (8000c08 <test_execute+0x1c8>)
 8000a4a:	9b01      	ldr	r3, [sp, #4]
 8000a4c:	6013      	str	r3, [r2, #0]
  test_println("");
 8000a4e:	486f      	ldr	r0, [pc, #444]	; (8000c0c <test_execute+0x1cc>)
 8000a50:	f014 fdde 	bl	8015610 <test_println>
  if (tsp->name != NULL) {
 8000a54:	9b00      	ldr	r3, [sp, #0]
 8000a56:	681b      	ldr	r3, [r3, #0]
 8000a58:	2b00      	cmp	r3, #0
 8000a5a:	d008      	beq.n	8000a6e <test_execute+0x2e>
    test_print("*** ");
 8000a5c:	486c      	ldr	r0, [pc, #432]	; (8000c10 <test_execute+0x1d0>)
 8000a5e:	f014 fdb7 	bl	80155d0 <test_print>
    test_println(tsp->name);
 8000a62:	9b00      	ldr	r3, [sp, #0]
 8000a64:	681b      	ldr	r3, [r3, #0]
 8000a66:	4618      	mov	r0, r3
 8000a68:	f014 fdd2 	bl	8015610 <test_println>
 8000a6c:	e002      	b.n	8000a74 <test_execute+0x34>
  }
  else {
    test_println("*** Test Suite");
 8000a6e:	4869      	ldr	r0, [pc, #420]	; (8000c14 <test_execute+0x1d4>)
 8000a70:	f014 fdce 	bl	8015610 <test_println>
  }
  test_println("***");
 8000a74:	4868      	ldr	r0, [pc, #416]	; (8000c18 <test_execute+0x1d8>)
 8000a76:	f014 fdcb 	bl	8015610 <test_println>
  test_print("*** Compiled:     ");
 8000a7a:	4868      	ldr	r0, [pc, #416]	; (8000c1c <test_execute+0x1dc>)
 8000a7c:	f014 fda8 	bl	80155d0 <test_print>
  test_println(__DATE__ " - " __TIME__);
 8000a80:	4867      	ldr	r0, [pc, #412]	; (8000c20 <test_execute+0x1e0>)
 8000a82:	f014 fdc5 	bl	8015610 <test_println>
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
 8000a86:	4867      	ldr	r0, [pc, #412]	; (8000c24 <test_execute+0x1e4>)
 8000a88:	f014 fda2 	bl	80155d0 <test_print>
  test_println(PLATFORM_NAME);
 8000a8c:	4866      	ldr	r0, [pc, #408]	; (8000c28 <test_execute+0x1e8>)
 8000a8e:	f014 fdbf 	bl	8015610 <test_println>
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
 8000a92:	4866      	ldr	r0, [pc, #408]	; (8000c2c <test_execute+0x1ec>)
 8000a94:	f014 fd9c 	bl	80155d0 <test_print>
  test_println(BOARD_NAME);
 8000a98:	4865      	ldr	r0, [pc, #404]	; (8000c30 <test_execute+0x1f0>)
 8000a9a:	f014 fdb9 	bl	8015610 <test_println>
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");
 8000a9e:	485b      	ldr	r0, [pc, #364]	; (8000c0c <test_execute+0x1cc>)
 8000aa0:	f014 fdb6 	bl	8015610 <test_println>

  test_global_fail = false;
 8000aa4:	4b63      	ldr	r3, [pc, #396]	; (8000c34 <test_execute+0x1f4>)
 8000aa6:	2200      	movs	r2, #0
 8000aa8:	701a      	strb	r2, [r3, #0]
  tseq = 0;
 8000aaa:	2300      	movs	r3, #0
 8000aac:	9303      	str	r3, [sp, #12]
 8000aae:	e088      	b.n	8000bc2 <test_execute+0x182>
  while (tsp->sequences[tseq] != NULL) {
#if TEST_SHOW_SEQUENCES == TRUE
    print_fat_line();
 8000ab0:	f014 fca6 	bl	8015400 <print_fat_line.lto_priv.259>
    test_print("=== Test Sequence ");
 8000ab4:	4860      	ldr	r0, [pc, #384]	; (8000c38 <test_execute+0x1f8>)
 8000ab6:	f014 fd8b 	bl	80155d0 <test_print>
    test_printn(tseq + 1);
 8000aba:	9b03      	ldr	r3, [sp, #12]
 8000abc:	3301      	adds	r3, #1
 8000abe:	4618      	mov	r0, r3
 8000ac0:	f014 fd3e 	bl	8015540 <test_printn>
    test_print(" (");
 8000ac4:	485d      	ldr	r0, [pc, #372]	; (8000c3c <test_execute+0x1fc>)
 8000ac6:	f014 fd83 	bl	80155d0 <test_print>
    test_print(tsp->sequences[tseq]->name);
 8000aca:	9b00      	ldr	r3, [sp, #0]
 8000acc:	685a      	ldr	r2, [r3, #4]
 8000ace:	9b03      	ldr	r3, [sp, #12]
 8000ad0:	009b      	lsls	r3, r3, #2
 8000ad2:	4413      	add	r3, r2
 8000ad4:	681b      	ldr	r3, [r3, #0]
 8000ad6:	681b      	ldr	r3, [r3, #0]
 8000ad8:	4618      	mov	r0, r3
 8000ada:	f014 fd79 	bl	80155d0 <test_print>
    test_println(")");
 8000ade:	4858      	ldr	r0, [pc, #352]	; (8000c40 <test_execute+0x200>)
 8000ae0:	f014 fd96 	bl	8015610 <test_println>
#endif
    tcase = 0;
 8000ae4:	2300      	movs	r3, #0
 8000ae6:	9302      	str	r3, [sp, #8]
 8000ae8:	e05b      	b.n	8000ba2 <test_execute+0x162>
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
      print_line();
 8000aea:	f014 fc61 	bl	80153b0 <print_line.lto_priv.255>
      test_print("--- Test Case ");
 8000aee:	4855      	ldr	r0, [pc, #340]	; (8000c44 <test_execute+0x204>)
 8000af0:	f014 fd6e 	bl	80155d0 <test_print>
      test_printn(tseq + 1);
 8000af4:	9b03      	ldr	r3, [sp, #12]
 8000af6:	3301      	adds	r3, #1
 8000af8:	4618      	mov	r0, r3
 8000afa:	f014 fd21 	bl	8015540 <test_printn>
      test_print(".");
 8000afe:	4852      	ldr	r0, [pc, #328]	; (8000c48 <test_execute+0x208>)
 8000b00:	f014 fd66 	bl	80155d0 <test_print>
      test_printn(tcase + 1);
 8000b04:	9b02      	ldr	r3, [sp, #8]
 8000b06:	3301      	adds	r3, #1
 8000b08:	4618      	mov	r0, r3
 8000b0a:	f014 fd19 	bl	8015540 <test_printn>
      test_print(" (");
 8000b0e:	484b      	ldr	r0, [pc, #300]	; (8000c3c <test_execute+0x1fc>)
 8000b10:	f014 fd5e 	bl	80155d0 <test_print>
      test_print(tsp->sequences[tseq]->cases[tcase]->name);
 8000b14:	9b00      	ldr	r3, [sp, #0]
 8000b16:	685a      	ldr	r2, [r3, #4]
 8000b18:	9b03      	ldr	r3, [sp, #12]
 8000b1a:	009b      	lsls	r3, r3, #2
 8000b1c:	4413      	add	r3, r2
 8000b1e:	681b      	ldr	r3, [r3, #0]
 8000b20:	685a      	ldr	r2, [r3, #4]
 8000b22:	9b02      	ldr	r3, [sp, #8]
 8000b24:	009b      	lsls	r3, r3, #2
 8000b26:	4413      	add	r3, r2
 8000b28:	681b      	ldr	r3, [r3, #0]
 8000b2a:	681b      	ldr	r3, [r3, #0]
 8000b2c:	4618      	mov	r0, r3
 8000b2e:	f014 fd4f 	bl	80155d0 <test_print>
      test_println(")");
 8000b32:	4843      	ldr	r0, [pc, #268]	; (8000c40 <test_execute+0x200>)
 8000b34:	f014 fd6c 	bl	8015610 <test_println>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
 8000b38:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8000b3c:	f014 fbe0 	bl	8015300 <osalThreadSleep.lto_priv.258>
#endif
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 8000b40:	9b00      	ldr	r3, [sp, #0]
 8000b42:	685a      	ldr	r2, [r3, #4]
 8000b44:	9b03      	ldr	r3, [sp, #12]
 8000b46:	009b      	lsls	r3, r3, #2
 8000b48:	4413      	add	r3, r2
 8000b4a:	681b      	ldr	r3, [r3, #0]
 8000b4c:	685a      	ldr	r2, [r3, #4]
 8000b4e:	9b02      	ldr	r3, [sp, #8]
 8000b50:	009b      	lsls	r3, r3, #2
 8000b52:	4413      	add	r3, r2
 8000b54:	681b      	ldr	r3, [r3, #0]
 8000b56:	4618      	mov	r0, r3
 8000b58:	f014 fc0a 	bl	8015370 <execute_test.lto_priv.257>
      if (test_local_fail) {
 8000b5c:	4b3b      	ldr	r3, [pc, #236]	; (8000c4c <test_execute+0x20c>)
 8000b5e:	781b      	ldrb	r3, [r3, #0]
 8000b60:	2b00      	cmp	r3, #0
 8000b62:	d018      	beq.n	8000b96 <test_execute+0x156>
        test_print("--- Result: FAILURE (#");
 8000b64:	483a      	ldr	r0, [pc, #232]	; (8000c50 <test_execute+0x210>)
 8000b66:	f014 fd33 	bl	80155d0 <test_print>
        test_printn(test_step);
 8000b6a:	4b3a      	ldr	r3, [pc, #232]	; (8000c54 <test_execute+0x214>)
 8000b6c:	681b      	ldr	r3, [r3, #0]
 8000b6e:	4618      	mov	r0, r3
 8000b70:	f014 fce6 	bl	8015540 <test_printn>
        test_print(" [");
 8000b74:	4838      	ldr	r0, [pc, #224]	; (8000c58 <test_execute+0x218>)
 8000b76:	f014 fd2b 	bl	80155d0 <test_print>
        print_tokens();
 8000b7a:	f014 fbd9 	bl	8015330 <print_tokens.lto_priv.256>
        test_print("] \"");
 8000b7e:	4837      	ldr	r0, [pc, #220]	; (8000c5c <test_execute+0x21c>)
 8000b80:	f014 fd26 	bl	80155d0 <test_print>
        test_print(test_failure_message);
 8000b84:	4b36      	ldr	r3, [pc, #216]	; (8000c60 <test_execute+0x220>)
 8000b86:	681b      	ldr	r3, [r3, #0]
 8000b88:	4618      	mov	r0, r3
 8000b8a:	f014 fd21 	bl	80155d0 <test_print>
        test_println("\")");
 8000b8e:	4835      	ldr	r0, [pc, #212]	; (8000c64 <test_execute+0x224>)
 8000b90:	f014 fd3e 	bl	8015610 <test_println>
 8000b94:	e002      	b.n	8000b9c <test_execute+0x15c>
      }
      else {
        test_println("--- Result: SUCCESS");
 8000b96:	4834      	ldr	r0, [pc, #208]	; (8000c68 <test_execute+0x228>)
 8000b98:	f014 fd3a 	bl	8015610 <test_println>
      }
      tcase++;
 8000b9c:	9b02      	ldr	r3, [sp, #8]
 8000b9e:	3301      	adds	r3, #1
 8000ba0:	9302      	str	r3, [sp, #8]
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
 8000ba2:	9b00      	ldr	r3, [sp, #0]
 8000ba4:	685a      	ldr	r2, [r3, #4]
 8000ba6:	9b03      	ldr	r3, [sp, #12]
 8000ba8:	009b      	lsls	r3, r3, #2
 8000baa:	4413      	add	r3, r2
 8000bac:	681b      	ldr	r3, [r3, #0]
 8000bae:	685a      	ldr	r2, [r3, #4]
 8000bb0:	9b02      	ldr	r3, [sp, #8]
 8000bb2:	009b      	lsls	r3, r3, #2
 8000bb4:	4413      	add	r3, r2
 8000bb6:	681b      	ldr	r3, [r3, #0]
 8000bb8:	2b00      	cmp	r3, #0
 8000bba:	d196      	bne.n	8000aea <test_execute+0xaa>
    }
    tseq++;
 8000bbc:	9b03      	ldr	r3, [sp, #12]
 8000bbe:	3301      	adds	r3, #1
 8000bc0:	9303      	str	r3, [sp, #12]
  while (tsp->sequences[tseq] != NULL) {
 8000bc2:	9b00      	ldr	r3, [sp, #0]
 8000bc4:	685a      	ldr	r2, [r3, #4]
 8000bc6:	9b03      	ldr	r3, [sp, #12]
 8000bc8:	009b      	lsls	r3, r3, #2
 8000bca:	4413      	add	r3, r2
 8000bcc:	681b      	ldr	r3, [r3, #0]
 8000bce:	2b00      	cmp	r3, #0
 8000bd0:	f47f af6e 	bne.w	8000ab0 <test_execute+0x70>
  }
  print_line();
 8000bd4:	f014 fbec 	bl	80153b0 <print_line.lto_priv.255>
  test_println("");
 8000bd8:	480c      	ldr	r0, [pc, #48]	; (8000c0c <test_execute+0x1cc>)
 8000bda:	f014 fd19 	bl	8015610 <test_println>
  test_print("Final result: ");
 8000bde:	4823      	ldr	r0, [pc, #140]	; (8000c6c <test_execute+0x22c>)
 8000be0:	f014 fcf6 	bl	80155d0 <test_print>
  if (test_global_fail)
 8000be4:	4b13      	ldr	r3, [pc, #76]	; (8000c34 <test_execute+0x1f4>)
 8000be6:	781b      	ldrb	r3, [r3, #0]
 8000be8:	2b00      	cmp	r3, #0
 8000bea:	d003      	beq.n	8000bf4 <test_execute+0x1b4>
    test_println("FAILURE");
 8000bec:	4820      	ldr	r0, [pc, #128]	; (8000c70 <test_execute+0x230>)
 8000bee:	f014 fd0f 	bl	8015610 <test_println>
 8000bf2:	e002      	b.n	8000bfa <test_execute+0x1ba>
  else
    test_println("SUCCESS");
 8000bf4:	481f      	ldr	r0, [pc, #124]	; (8000c74 <test_execute+0x234>)
 8000bf6:	f014 fd0b 	bl	8015610 <test_println>

#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END
#endif

  return (msg_t)test_global_fail;
 8000bfa:	4b0e      	ldr	r3, [pc, #56]	; (8000c34 <test_execute+0x1f4>)
 8000bfc:	781b      	ldrb	r3, [r3, #0]
}
 8000bfe:	4618      	mov	r0, r3
 8000c00:	b005      	add	sp, #20
 8000c02:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c06:	bf00      	nop
 8000c08:	200019a8 	.word	0x200019a8
 8000c0c:	08018d94 	.word	0x08018d94
 8000c10:	080171dc 	.word	0x080171dc
 8000c14:	080171e4 	.word	0x080171e4
 8000c18:	080171f4 	.word	0x080171f4
 8000c1c:	080171f8 	.word	0x080171f8
 8000c20:	0801720c 	.word	0x0801720c
 8000c24:	08017224 	.word	0x08017224
 8000c28:	08017238 	.word	0x08017238
 8000c2c:	08017264 	.word	0x08017264
 8000c30:	08017278 	.word	0x08017278
 8000c34:	2000198c 	.word	0x2000198c
 8000c38:	080172a0 	.word	0x080172a0
 8000c3c:	080172b4 	.word	0x080172b4
 8000c40:	080172b8 	.word	0x080172b8
 8000c44:	080172bc 	.word	0x080172bc
 8000c48:	080172cc 	.word	0x080172cc
 8000c4c:	2000198d 	.word	0x2000198d
 8000c50:	080172d0 	.word	0x080172d0
 8000c54:	20001988 	.word	0x20001988
 8000c58:	080172e8 	.word	0x080172e8
 8000c5c:	080172ec 	.word	0x080172ec
 8000c60:	20001990 	.word	0x20001990
 8000c64:	080172f0 	.word	0x080172f0
 8000c68:	080172f4 	.word	0x080172f4
 8000c6c:	08017308 	.word	0x08017308
 8000c70:	08017318 	.word	0x08017318
 8000c74:	08017300 	.word	0x08017300
	...

08000c80 <port_lock.lto_priv.18>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000c80:	b082      	sub	sp, #8
 8000c82:	2320      	movs	r3, #32
 8000c84:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000c86:	9b01      	ldr	r3, [sp, #4]
 8000c88:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000c8c:	b002      	add	sp, #8
 8000c8e:	4770      	bx	lr

08000c90 <port_unlock.lto_priv.8>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000c90:	b082      	sub	sp, #8
 8000c92:	2300      	movs	r3, #0
 8000c94:	9301      	str	r3, [sp, #4]
 8000c96:	9b01      	ldr	r3, [sp, #4]
 8000c98:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000c9c:	b002      	add	sp, #8
 8000c9e:	4770      	bx	lr

08000ca0 <st_lld_get_counter.lto_priv.115>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000ca0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000ca4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8000ca6:	4618      	mov	r0, r3
 8000ca8:	4770      	bx	lr
 8000caa:	bf00      	nop
 8000cac:	0000      	movs	r0, r0
	...

08000cb0 <port_timer_get_time.lto_priv.110>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8000cb0:	b508      	push	{r3, lr}

  return stGetCounter();
 8000cb2:	f7ff fff5 	bl	8000ca0 <st_lld_get_counter.lto_priv.115>
 8000cb6:	4603      	mov	r3, r0
}
 8000cb8:	4618      	mov	r0, r3
 8000cba:	bd08      	pop	{r3, pc}
 8000cbc:	0000      	movs	r0, r0
	...

08000cc0 <chSysLock.lto_priv.74>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8000cc0:	b508      	push	{r3, lr}

  port_lock();
 8000cc2:	f7ff ffdd 	bl	8000c80 <port_lock.lto_priv.18>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000cc6:	f00e fafb 	bl	800f2c0 <_dbg_check_lock>
}
 8000cca:	bd08      	pop	{r3, pc}
 8000ccc:	0000      	movs	r0, r0
	...

08000cd0 <chSysUnlock.lto_priv.38>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000cd0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8000cd2:	f00e fb0d 	bl	800f2f0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000cd6:	4b09      	ldr	r3, [pc, #36]	; (8000cfc <chSysUnlock.lto_priv.38+0x2c>)
 8000cd8:	681b      	ldr	r3, [r3, #0]
 8000cda:	4a08      	ldr	r2, [pc, #32]	; (8000cfc <chSysUnlock.lto_priv.38+0x2c>)
 8000cdc:	4293      	cmp	r3, r2
 8000cde:	d00a      	beq.n	8000cf6 <chSysUnlock.lto_priv.38+0x26>
 8000ce0:	4b06      	ldr	r3, [pc, #24]	; (8000cfc <chSysUnlock.lto_priv.38+0x2c>)
 8000ce2:	699b      	ldr	r3, [r3, #24]
 8000ce4:	689a      	ldr	r2, [r3, #8]
 8000ce6:	4b05      	ldr	r3, [pc, #20]	; (8000cfc <chSysUnlock.lto_priv.38+0x2c>)
 8000ce8:	681b      	ldr	r3, [r3, #0]
 8000cea:	689b      	ldr	r3, [r3, #8]
 8000cec:	429a      	cmp	r2, r3
 8000cee:	d202      	bcs.n	8000cf6 <chSysUnlock.lto_priv.38+0x26>
 8000cf0:	4803      	ldr	r0, [pc, #12]	; (8000d00 <chSysUnlock.lto_priv.38+0x30>)
 8000cf2:	f00e f975 	bl	800efe0 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8000cf6:	f7ff ffcb 	bl	8000c90 <port_unlock.lto_priv.8>
}
 8000cfa:	bd08      	pop	{r3, pc}
 8000cfc:	20001090 	.word	0x20001090
 8000d00:	08017374 	.word	0x08017374
	...

08000d10 <chVTGetSystemTimeX.lto_priv.105>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8000d10:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8000d12:	f7ff ffcd 	bl	8000cb0 <port_timer_get_time.lto_priv.110>
 8000d16:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000d18:	4618      	mov	r0, r3
 8000d1a:	bd08      	pop	{r3, pc}
 8000d1c:	0000      	movs	r0, r0
	...

08000d20 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8000d20:	b500      	push	{lr}
 8000d22:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8000d24:	f7ff ffcc 	bl	8000cc0 <chSysLock.lto_priv.74>
  systime = chVTGetSystemTimeX();
 8000d28:	f7ff fff2 	bl	8000d10 <chVTGetSystemTimeX.lto_priv.105>
 8000d2c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8000d2e:	f7ff ffcf 	bl	8000cd0 <chSysUnlock.lto_priv.38>

  return systime;
 8000d32:	9b01      	ldr	r3, [sp, #4]
}
 8000d34:	4618      	mov	r0, r3
 8000d36:	b003      	add	sp, #12
 8000d38:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d3c:	0000      	movs	r0, r0
	...

08000d40 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8000d40:	b500      	push	{lr}
 8000d42:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8000d44:	2300      	movs	r3, #0
 8000d46:	9301      	str	r3, [sp, #4]
 8000d48:	e00f      	b.n	8000d6a <test_terminate_threads+0x2a>
    if (threads[i])
 8000d4a:	4a0b      	ldr	r2, [pc, #44]	; (8000d78 <test_terminate_threads+0x38>)
 8000d4c:	9b01      	ldr	r3, [sp, #4]
 8000d4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000d52:	2b00      	cmp	r3, #0
 8000d54:	d006      	beq.n	8000d64 <test_terminate_threads+0x24>
      chThdTerminate(threads[i]);
 8000d56:	4a08      	ldr	r2, [pc, #32]	; (8000d78 <test_terminate_threads+0x38>)
 8000d58:	9b01      	ldr	r3, [sp, #4]
 8000d5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000d5e:	4618      	mov	r0, r3
 8000d60:	f00f fd3e 	bl	80107e0 <chThdTerminate>
  for (i = 0; i < MAX_THREADS; i++)
 8000d64:	9b01      	ldr	r3, [sp, #4]
 8000d66:	3301      	adds	r3, #1
 8000d68:	9301      	str	r3, [sp, #4]
 8000d6a:	9b01      	ldr	r3, [sp, #4]
 8000d6c:	2b04      	cmp	r3, #4
 8000d6e:	d9ec      	bls.n	8000d4a <test_terminate_threads+0xa>
}
 8000d70:	b003      	add	sp, #12
 8000d72:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d76:	bf00      	nop
 8000d78:	20002018 	.word	0x20002018
 8000d7c:	00000000 	.word	0x00000000

08000d80 <test_wait_threads>:

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8000d80:	b500      	push	{lr}
 8000d82:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8000d84:	2300      	movs	r3, #0
 8000d86:	9301      	str	r3, [sp, #4]
 8000d88:	e014      	b.n	8000db4 <test_wait_threads+0x34>
    if (threads[i] != NULL) {
 8000d8a:	4a0d      	ldr	r2, [pc, #52]	; (8000dc0 <test_wait_threads+0x40>)
 8000d8c:	9b01      	ldr	r3, [sp, #4]
 8000d8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000d92:	2b00      	cmp	r3, #0
 8000d94:	d00b      	beq.n	8000dae <test_wait_threads+0x2e>
      chThdWait(threads[i]);
 8000d96:	4a0a      	ldr	r2, [pc, #40]	; (8000dc0 <test_wait_threads+0x40>)
 8000d98:	9b01      	ldr	r3, [sp, #4]
 8000d9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000d9e:	4618      	mov	r0, r3
 8000da0:	f00f fca6 	bl	80106f0 <chThdWait>
      threads[i] = NULL;
 8000da4:	4a06      	ldr	r2, [pc, #24]	; (8000dc0 <test_wait_threads+0x40>)
 8000da6:	9b01      	ldr	r3, [sp, #4]
 8000da8:	2100      	movs	r1, #0
 8000daa:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  for (i = 0; i < MAX_THREADS; i++)
 8000dae:	9b01      	ldr	r3, [sp, #4]
 8000db0:	3301      	adds	r3, #1
 8000db2:	9301      	str	r3, [sp, #4]
 8000db4:	9b01      	ldr	r3, [sp, #4]
 8000db6:	2b04      	cmp	r3, #4
 8000db8:	d9e7      	bls.n	8000d8a <test_wait_threads+0xa>
    }
}
 8000dba:	b003      	add	sp, #12
 8000dbc:	f85d fb04 	ldr.w	pc, [sp], #4
 8000dc0:	20002018 	.word	0x20002018
	...

08000dd0 <test_wait_tick>:

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 8000dd0:	b508      	push	{r3, lr}

  chThdSleep(1);
 8000dd2:	2001      	movs	r0, #1
 8000dd4:	f00f fd1c 	bl	8010810 <chThdSleep>
  return chVTGetSystemTime();
 8000dd8:	f7ff ffa2 	bl	8000d20 <chVTGetSystemTime>
 8000ddc:	4603      	mov	r3, r0
}
 8000dde:	4618      	mov	r0, r3
 8000de0:	bd08      	pop	{r3, pc}
 8000de2:	bf00      	nop
	...

08000df0 <rt_test_001_001_execute.lto_priv.743>:
 * <h2>Test Steps</h2>
 * - [1.1.1] Prints the version string.
 * .
 */

static void rt_test_001_001_execute(void) {
 8000df0:	b508      	push	{r3, lr}

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
 8000df2:	4b1b      	ldr	r3, [pc, #108]	; (8000e60 <rt_test_001_001_execute.lto_priv.743+0x70>)
 8000df4:	2201      	movs	r2, #1
 8000df6:	601a      	str	r2, [r3, #0]
  {
#if defined(PORT_ARCHITECTURE_NAME)
    test_print("--- Architecture:                       ");
 8000df8:	481a      	ldr	r0, [pc, #104]	; (8000e64 <rt_test_001_001_execute.lto_priv.743+0x74>)
 8000dfa:	f014 fbe9 	bl	80155d0 <test_print>
    test_println(PORT_ARCHITECTURE_NAME);
 8000dfe:	481a      	ldr	r0, [pc, #104]	; (8000e68 <rt_test_001_001_execute.lto_priv.743+0x78>)
 8000e00:	f014 fc06 	bl	8015610 <test_println>
#endif
#if defined(PORT_CORE_VARIANT_NAME)
    test_print("--- Core Variant:                       ");
 8000e04:	4819      	ldr	r0, [pc, #100]	; (8000e6c <rt_test_001_001_execute.lto_priv.743+0x7c>)
 8000e06:	f014 fbe3 	bl	80155d0 <test_print>
    test_println(PORT_CORE_VARIANT_NAME);
 8000e0a:	4819      	ldr	r0, [pc, #100]	; (8000e70 <rt_test_001_001_execute.lto_priv.743+0x80>)
 8000e0c:	f014 fc00 	bl	8015610 <test_println>
#endif
#if defined(PORT_COMPILER_NAME)
    test_print("--- Compiler:                           ");
 8000e10:	4818      	ldr	r0, [pc, #96]	; (8000e74 <rt_test_001_001_execute.lto_priv.743+0x84>)
 8000e12:	f014 fbdd 	bl	80155d0 <test_print>
    test_println(PORT_COMPILER_NAME);
 8000e16:	4818      	ldr	r0, [pc, #96]	; (8000e78 <rt_test_001_001_execute.lto_priv.743+0x88>)
 8000e18:	f014 fbfa 	bl	8015610 <test_println>
#endif
#if defined(PORT_INFO)
    test_print("--- Port Info:                          ");
 8000e1c:	4817      	ldr	r0, [pc, #92]	; (8000e7c <rt_test_001_001_execute.lto_priv.743+0x8c>)
 8000e1e:	f014 fbd7 	bl	80155d0 <test_print>
    test_println(PORT_INFO);
 8000e22:	4817      	ldr	r0, [pc, #92]	; (8000e80 <rt_test_001_001_execute.lto_priv.743+0x90>)
 8000e24:	f014 fbf4 	bl	8015610 <test_println>
#endif
#if defined(PORT_NATURAL_ALIGN)
    test_print("--- Natural alignment:                  ");
 8000e28:	4816      	ldr	r0, [pc, #88]	; (8000e84 <rt_test_001_001_execute.lto_priv.743+0x94>)
 8000e2a:	f014 fbd1 	bl	80155d0 <test_print>
    test_printn(PORT_NATURAL_ALIGN);
 8000e2e:	2004      	movs	r0, #4
 8000e30:	f014 fb86 	bl	8015540 <test_printn>
    test_println("");
 8000e34:	4814      	ldr	r0, [pc, #80]	; (8000e88 <rt_test_001_001_execute.lto_priv.743+0x98>)
 8000e36:	f014 fbeb 	bl	8015610 <test_println>
#endif
#if defined(PORT_STACK_ALIGN)
    test_print("--- Stack alignment:                    ");
 8000e3a:	4814      	ldr	r0, [pc, #80]	; (8000e8c <rt_test_001_001_execute.lto_priv.743+0x9c>)
 8000e3c:	f014 fbc8 	bl	80155d0 <test_print>
    test_printn(PORT_STACK_ALIGN);
 8000e40:	2008      	movs	r0, #8
 8000e42:	f014 fb7d 	bl	8015540 <test_printn>
    test_println("");
 8000e46:	4810      	ldr	r0, [pc, #64]	; (8000e88 <rt_test_001_001_execute.lto_priv.743+0x98>)
 8000e48:	f014 fbe2 	bl	8015610 <test_println>
#endif
#if defined(PORT_WORKING_AREA_ALIGN)
    test_print("--- Working area alignment:             ");
 8000e4c:	4810      	ldr	r0, [pc, #64]	; (8000e90 <rt_test_001_001_execute.lto_priv.743+0xa0>)
 8000e4e:	f014 fbbf 	bl	80155d0 <test_print>
    test_printn(PORT_WORKING_AREA_ALIGN);
 8000e52:	2008      	movs	r0, #8
 8000e54:	f014 fb74 	bl	8015540 <test_printn>
    test_println("");
 8000e58:	480b      	ldr	r0, [pc, #44]	; (8000e88 <rt_test_001_001_execute.lto_priv.743+0x98>)
 8000e5a:	f014 fbd9 	bl	8015610 <test_println>
#endif
  }
}
 8000e5e:	bd08      	pop	{r3, pc}
 8000e60:	20001988 	.word	0x20001988
 8000e64:	08017380 	.word	0x08017380
 8000e68:	080173ac 	.word	0x080173ac
 8000e6c:	080173b8 	.word	0x080173b8
 8000e70:	080173e4 	.word	0x080173e4
 8000e74:	080173f0 	.word	0x080173f0
 8000e78:	0801741c 	.word	0x0801741c
 8000e7c:	08017464 	.word	0x08017464
 8000e80:	08017490 	.word	0x08017490
 8000e84:	080174a8 	.word	0x080174a8
 8000e88:	08018d94 	.word	0x08018d94
 8000e8c:	080174d4 	.word	0x080174d4
 8000e90:	08017500 	.word	0x08017500
	...

08000ea0 <rt_test_001_002_execute.lto_priv.744>:
 * <h2>Test Steps</h2>
 * - [1.2.1] Prints the version string.
 * .
 */

static void rt_test_001_002_execute(void) {
 8000ea0:	b508      	push	{r3, lr}

  /* [1.2.1] Prints the version string.*/
  test_set_step(1);
 8000ea2:	4b18      	ldr	r3, [pc, #96]	; (8000f04 <rt_test_001_002_execute.lto_priv.744+0x64>)
 8000ea4:	2201      	movs	r2, #1
 8000ea6:	601a      	str	r2, [r3, #0]
  {
    test_println("--- Product:                            ChibiOS/RT");
 8000ea8:	4817      	ldr	r0, [pc, #92]	; (8000f08 <rt_test_001_002_execute.lto_priv.744+0x68>)
 8000eaa:	f014 fbb1 	bl	8015610 <test_println>
    test_print("--- Stable Flag:                        ");
 8000eae:	4817      	ldr	r0, [pc, #92]	; (8000f0c <rt_test_001_002_execute.lto_priv.744+0x6c>)
 8000eb0:	f014 fb8e 	bl	80155d0 <test_print>
    test_printn(CH_KERNEL_STABLE);
 8000eb4:	2001      	movs	r0, #1
 8000eb6:	f014 fb43 	bl	8015540 <test_printn>
    test_println("");
 8000eba:	4815      	ldr	r0, [pc, #84]	; (8000f10 <rt_test_001_002_execute.lto_priv.744+0x70>)
 8000ebc:	f014 fba8 	bl	8015610 <test_println>
    test_print("--- Version String:                     ");
 8000ec0:	4814      	ldr	r0, [pc, #80]	; (8000f14 <rt_test_001_002_execute.lto_priv.744+0x74>)
 8000ec2:	f014 fb85 	bl	80155d0 <test_print>
    test_println(CH_KERNEL_VERSION);
 8000ec6:	4814      	ldr	r0, [pc, #80]	; (8000f18 <rt_test_001_002_execute.lto_priv.744+0x78>)
 8000ec8:	f014 fba2 	bl	8015610 <test_println>
    test_print("--- Major Number:                       ");
 8000ecc:	4813      	ldr	r0, [pc, #76]	; (8000f1c <rt_test_001_002_execute.lto_priv.744+0x7c>)
 8000ece:	f014 fb7f 	bl	80155d0 <test_print>
    test_printn(CH_KERNEL_MAJOR);
 8000ed2:	2006      	movs	r0, #6
 8000ed4:	f014 fb34 	bl	8015540 <test_printn>
    test_println("");
 8000ed8:	480d      	ldr	r0, [pc, #52]	; (8000f10 <rt_test_001_002_execute.lto_priv.744+0x70>)
 8000eda:	f014 fb99 	bl	8015610 <test_println>
    test_print("--- Minor Number:                       ");
 8000ede:	4810      	ldr	r0, [pc, #64]	; (8000f20 <rt_test_001_002_execute.lto_priv.744+0x80>)
 8000ee0:	f014 fb76 	bl	80155d0 <test_print>
    test_printn(CH_KERNEL_MINOR);
 8000ee4:	2000      	movs	r0, #0
 8000ee6:	f014 fb2b 	bl	8015540 <test_printn>
    test_println("");
 8000eea:	4809      	ldr	r0, [pc, #36]	; (8000f10 <rt_test_001_002_execute.lto_priv.744+0x70>)
 8000eec:	f014 fb90 	bl	8015610 <test_println>
    test_print("--- Patch Number:                       ");
 8000ef0:	480c      	ldr	r0, [pc, #48]	; (8000f24 <rt_test_001_002_execute.lto_priv.744+0x84>)
 8000ef2:	f014 fb6d 	bl	80155d0 <test_print>
    test_printn(CH_KERNEL_PATCH);
 8000ef6:	2001      	movs	r0, #1
 8000ef8:	f014 fb22 	bl	8015540 <test_printn>
    test_println("");
 8000efc:	4804      	ldr	r0, [pc, #16]	; (8000f10 <rt_test_001_002_execute.lto_priv.744+0x70>)
 8000efe:	f014 fb87 	bl	8015610 <test_println>
  }
}
 8000f02:	bd08      	pop	{r3, pc}
 8000f04:	20001988 	.word	0x20001988
 8000f08:	0801753c 	.word	0x0801753c
 8000f0c:	08017570 	.word	0x08017570
 8000f10:	08018d94 	.word	0x08018d94
 8000f14:	0801759c 	.word	0x0801759c
 8000f18:	080175c8 	.word	0x080175c8
 8000f1c:	080175d0 	.word	0x080175d0
 8000f20:	080175fc 	.word	0x080175fc
 8000f24:	08017628 	.word	0x08017628
	...

08000f30 <rt_test_001_003_execute.lto_priv.745>:
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void rt_test_001_003_execute(void) {
 8000f30:	b508      	push	{r3, lr}

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
 8000f32:	4bc8      	ldr	r3, [pc, #800]	; (8001254 <rt_test_001_003_execute.lto_priv.745+0x324>)
 8000f34:	2201      	movs	r2, #1
 8000f36:	601a      	str	r2, [r3, #0]
  {
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
 8000f38:	48c7      	ldr	r0, [pc, #796]	; (8001258 <rt_test_001_003_execute.lto_priv.745+0x328>)
 8000f3a:	f014 fb49 	bl	80155d0 <test_print>
    test_printn(CH_CFG_ST_RESOLUTION);
 8000f3e:	2020      	movs	r0, #32
 8000f40:	f014 fafe 	bl	8015540 <test_printn>
    test_println("");
 8000f44:	48c5      	ldr	r0, [pc, #788]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000f46:	f014 fb63 	bl	8015610 <test_println>
    test_print("--- CH_CFG_ST_FREQUENCY:                ");
 8000f4a:	48c5      	ldr	r0, [pc, #788]	; (8001260 <rt_test_001_003_execute.lto_priv.745+0x330>)
 8000f4c:	f014 fb40 	bl	80155d0 <test_print>
    test_printn(CH_CFG_ST_FREQUENCY);
 8000f50:	f242 7010 	movw	r0, #10000	; 0x2710
 8000f54:	f014 faf4 	bl	8015540 <test_printn>
    test_println("");
 8000f58:	48c0      	ldr	r0, [pc, #768]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000f5a:	f014 fb59 	bl	8015610 <test_println>
    test_print("--- CH_CFG_INTERVALS_SIZE:              ");
 8000f5e:	48c1      	ldr	r0, [pc, #772]	; (8001264 <rt_test_001_003_execute.lto_priv.745+0x334>)
 8000f60:	f014 fb36 	bl	80155d0 <test_print>
    test_printn(CH_CFG_INTERVALS_SIZE);
 8000f64:	2020      	movs	r0, #32
 8000f66:	f014 faeb 	bl	8015540 <test_printn>
    test_println("");
 8000f6a:	48bc      	ldr	r0, [pc, #752]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000f6c:	f014 fb50 	bl	8015610 <test_println>
    test_print("--- CH_CFG_TIME_TYPES_SIZE:             ");
 8000f70:	48bd      	ldr	r0, [pc, #756]	; (8001268 <rt_test_001_003_execute.lto_priv.745+0x338>)
 8000f72:	f014 fb2d 	bl	80155d0 <test_print>
    test_printn(CH_CFG_TIME_TYPES_SIZE);
 8000f76:	2020      	movs	r0, #32
 8000f78:	f014 fae2 	bl	8015540 <test_printn>
    test_println("");
 8000f7c:	48b7      	ldr	r0, [pc, #732]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000f7e:	f014 fb47 	bl	8015610 <test_println>
    test_print("--- CH_CFG_ST_TIMEDELTA:                ");
 8000f82:	48ba      	ldr	r0, [pc, #744]	; (800126c <rt_test_001_003_execute.lto_priv.745+0x33c>)
 8000f84:	f014 fb24 	bl	80155d0 <test_print>
    test_printn(CH_CFG_ST_TIMEDELTA);
 8000f88:	2002      	movs	r0, #2
 8000f8a:	f014 fad9 	bl	8015540 <test_printn>
    test_println("");
 8000f8e:	48b3      	ldr	r0, [pc, #716]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000f90:	f014 fb3e 	bl	8015610 <test_println>
    test_print("--- CH_CFG_TIME_QUANTUM:                ");
 8000f94:	48b6      	ldr	r0, [pc, #728]	; (8001270 <rt_test_001_003_execute.lto_priv.745+0x340>)
 8000f96:	f014 fb1b 	bl	80155d0 <test_print>
    test_printn(CH_CFG_TIME_QUANTUM);
 8000f9a:	2000      	movs	r0, #0
 8000f9c:	f014 fad0 	bl	8015540 <test_printn>
    test_println("");
 8000fa0:	48ae      	ldr	r0, [pc, #696]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000fa2:	f014 fb35 	bl	8015610 <test_println>
    test_print("--- CH_CFG_MEMCORE_SIZE:                ");
 8000fa6:	48b3      	ldr	r0, [pc, #716]	; (8001274 <rt_test_001_003_execute.lto_priv.745+0x344>)
 8000fa8:	f014 fb12 	bl	80155d0 <test_print>
    test_printn(CH_CFG_MEMCORE_SIZE);
 8000fac:	2000      	movs	r0, #0
 8000fae:	f014 fac7 	bl	8015540 <test_printn>
    test_println("");
 8000fb2:	48aa      	ldr	r0, [pc, #680]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000fb4:	f014 fb2c 	bl	8015610 <test_println>
    test_print("--- CH_CFG_NO_IDLE_THREAD:              ");
 8000fb8:	48af      	ldr	r0, [pc, #700]	; (8001278 <rt_test_001_003_execute.lto_priv.745+0x348>)
 8000fba:	f014 fb09 	bl	80155d0 <test_print>
    test_printn(CH_CFG_NO_IDLE_THREAD);
 8000fbe:	2000      	movs	r0, #0
 8000fc0:	f014 fabe 	bl	8015540 <test_printn>
    test_println("");
 8000fc4:	48a5      	ldr	r0, [pc, #660]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000fc6:	f014 fb23 	bl	8015610 <test_println>
    test_print("--- CH_CFG_OPTIMIZE_SPEED:              ");
 8000fca:	48ac      	ldr	r0, [pc, #688]	; (800127c <rt_test_001_003_execute.lto_priv.745+0x34c>)
 8000fcc:	f014 fb00 	bl	80155d0 <test_print>
    test_printn(CH_CFG_OPTIMIZE_SPEED);
 8000fd0:	2001      	movs	r0, #1
 8000fd2:	f014 fab5 	bl	8015540 <test_printn>
    test_println("");
 8000fd6:	48a1      	ldr	r0, [pc, #644]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000fd8:	f014 fb1a 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_TM:                      ");
 8000fdc:	48a8      	ldr	r0, [pc, #672]	; (8001280 <rt_test_001_003_execute.lto_priv.745+0x350>)
 8000fde:	f014 faf7 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_TM);
 8000fe2:	2001      	movs	r0, #1
 8000fe4:	f014 faac 	bl	8015540 <test_printn>
    test_println("");
 8000fe8:	489c      	ldr	r0, [pc, #624]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000fea:	f014 fb11 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_REGISTRY:                ");
 8000fee:	48a5      	ldr	r0, [pc, #660]	; (8001284 <rt_test_001_003_execute.lto_priv.745+0x354>)
 8000ff0:	f014 faee 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_REGISTRY);
 8000ff4:	2001      	movs	r0, #1
 8000ff6:	f014 faa3 	bl	8015540 <test_printn>
    test_println("");
 8000ffa:	4898      	ldr	r0, [pc, #608]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8000ffc:	f014 fb08 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_WAITEXIT:                ");
 8001000:	48a1      	ldr	r0, [pc, #644]	; (8001288 <rt_test_001_003_execute.lto_priv.745+0x358>)
 8001002:	f014 fae5 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_WAITEXIT);
 8001006:	2001      	movs	r0, #1
 8001008:	f014 fa9a 	bl	8015540 <test_printn>
    test_println("");
 800100c:	4893      	ldr	r0, [pc, #588]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800100e:	f014 faff 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES:              ");
 8001012:	489e      	ldr	r0, [pc, #632]	; (800128c <rt_test_001_003_execute.lto_priv.745+0x35c>)
 8001014:	f014 fadc 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES);
 8001018:	2001      	movs	r0, #1
 800101a:	f014 fa91 	bl	8015540 <test_printn>
    test_println("");
 800101e:	488f      	ldr	r0, [pc, #572]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001020:	f014 faf6 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES_PRIORITY:     ");
 8001024:	489a      	ldr	r0, [pc, #616]	; (8001290 <rt_test_001_003_execute.lto_priv.745+0x360>)
 8001026:	f014 fad3 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES_PRIORITY);
 800102a:	2000      	movs	r0, #0
 800102c:	f014 fa88 	bl	8015540 <test_printn>
    test_println("");
 8001030:	488a      	ldr	r0, [pc, #552]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001032:	f014 faed 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES:                 ");
 8001036:	4897      	ldr	r0, [pc, #604]	; (8001294 <rt_test_001_003_execute.lto_priv.745+0x364>)
 8001038:	f014 faca 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_MUTEXES);
 800103c:	2001      	movs	r0, #1
 800103e:	f014 fa7f 	bl	8015540 <test_printn>
    test_println("");
 8001042:	4886      	ldr	r0, [pc, #536]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001044:	f014 fae4 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES_RECURSIVE:       ");
 8001048:	4893      	ldr	r0, [pc, #588]	; (8001298 <rt_test_001_003_execute.lto_priv.745+0x368>)
 800104a:	f014 fac1 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_MUTEXES_RECURSIVE);
 800104e:	2000      	movs	r0, #0
 8001050:	f014 fa76 	bl	8015540 <test_printn>
    test_println("");   
 8001054:	4881      	ldr	r0, [pc, #516]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001056:	f014 fadb 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS:                ");
 800105a:	4890      	ldr	r0, [pc, #576]	; (800129c <rt_test_001_003_execute.lto_priv.745+0x36c>)
 800105c:	f014 fab8 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_CONDVARS);
 8001060:	2001      	movs	r0, #1
 8001062:	f014 fa6d 	bl	8015540 <test_printn>
    test_println("");
 8001066:	487d      	ldr	r0, [pc, #500]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001068:	f014 fad2 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS_TIMEOUT:        ");
 800106c:	488c      	ldr	r0, [pc, #560]	; (80012a0 <rt_test_001_003_execute.lto_priv.745+0x370>)
 800106e:	f014 faaf 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_CONDVARS_TIMEOUT);
 8001072:	2001      	movs	r0, #1
 8001074:	f014 fa64 	bl	8015540 <test_printn>
    test_println("");
 8001078:	4878      	ldr	r0, [pc, #480]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800107a:	f014 fac9 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_EVENTS:                  ");
 800107e:	4889      	ldr	r0, [pc, #548]	; (80012a4 <rt_test_001_003_execute.lto_priv.745+0x374>)
 8001080:	f014 faa6 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_EVENTS);
 8001084:	2001      	movs	r0, #1
 8001086:	f014 fa5b 	bl	8015540 <test_printn>
    test_println("");
 800108a:	4874      	ldr	r0, [pc, #464]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800108c:	f014 fac0 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_EVENTS_TIMEOUT:          ");
 8001090:	4885      	ldr	r0, [pc, #532]	; (80012a8 <rt_test_001_003_execute.lto_priv.745+0x378>)
 8001092:	f014 fa9d 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_EVENTS_TIMEOUT);
 8001096:	2001      	movs	r0, #1
 8001098:	f014 fa52 	bl	8015540 <test_printn>
    test_println("");
 800109c:	486f      	ldr	r0, [pc, #444]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800109e:	f014 fab7 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES:                ");
 80010a2:	4882      	ldr	r0, [pc, #520]	; (80012ac <rt_test_001_003_execute.lto_priv.745+0x37c>)
 80010a4:	f014 fa94 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_MESSAGES);
 80010a8:	2001      	movs	r0, #1
 80010aa:	f014 fa49 	bl	8015540 <test_printn>
    test_println("");
 80010ae:	486b      	ldr	r0, [pc, #428]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 80010b0:	f014 faae 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES_PRIORITY:       ");
 80010b4:	487e      	ldr	r0, [pc, #504]	; (80012b0 <rt_test_001_003_execute.lto_priv.745+0x380>)
 80010b6:	f014 fa8b 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_MESSAGES_PRIORITY);
 80010ba:	2000      	movs	r0, #0
 80010bc:	f014 fa40 	bl	8015540 <test_printn>
    test_println("");
 80010c0:	4866      	ldr	r0, [pc, #408]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 80010c2:	f014 faa5 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_MAILBOXES:               ");
 80010c6:	487b      	ldr	r0, [pc, #492]	; (80012b4 <rt_test_001_003_execute.lto_priv.745+0x384>)
 80010c8:	f014 fa82 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_MAILBOXES);
 80010cc:	2001      	movs	r0, #1
 80010ce:	f014 fa37 	bl	8015540 <test_printn>
    test_println("");
 80010d2:	4862      	ldr	r0, [pc, #392]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 80010d4:	f014 fa9c 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_MEMCORE:                 ");
 80010d8:	4877      	ldr	r0, [pc, #476]	; (80012b8 <rt_test_001_003_execute.lto_priv.745+0x388>)
 80010da:	f014 fa79 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_MEMCORE);
 80010de:	2001      	movs	r0, #1
 80010e0:	f014 fa2e 	bl	8015540 <test_printn>
    test_println("");
 80010e4:	485d      	ldr	r0, [pc, #372]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 80010e6:	f014 fa93 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_HEAP:                    ");
 80010ea:	4874      	ldr	r0, [pc, #464]	; (80012bc <rt_test_001_003_execute.lto_priv.745+0x38c>)
 80010ec:	f014 fa70 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_HEAP);
 80010f0:	2001      	movs	r0, #1
 80010f2:	f014 fa25 	bl	8015540 <test_printn>
    test_println("");
 80010f6:	4859      	ldr	r0, [pc, #356]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 80010f8:	f014 fa8a 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_MEMPOOLS:                ");
 80010fc:	4870      	ldr	r0, [pc, #448]	; (80012c0 <rt_test_001_003_execute.lto_priv.745+0x390>)
 80010fe:	f014 fa67 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_MEMPOOLS);
 8001102:	2001      	movs	r0, #1
 8001104:	f014 fa1c 	bl	8015540 <test_printn>
    test_println("");
 8001108:	4854      	ldr	r0, [pc, #336]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800110a:	f014 fa81 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_OBJ_FIFOS:               ");
 800110e:	486d      	ldr	r0, [pc, #436]	; (80012c4 <rt_test_001_003_execute.lto_priv.745+0x394>)
 8001110:	f014 fa5e 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_OBJ_FIFOS);
 8001114:	2001      	movs	r0, #1
 8001116:	f014 fa13 	bl	8015540 <test_printn>
    test_println("");
 800111a:	4850      	ldr	r0, [pc, #320]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800111c:	f014 fa78 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_DYNAMIC:                 ");
 8001120:	4869      	ldr	r0, [pc, #420]	; (80012c8 <rt_test_001_003_execute.lto_priv.745+0x398>)
 8001122:	f014 fa55 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_DYNAMIC);
 8001126:	2001      	movs	r0, #1
 8001128:	f014 fa0a 	bl	8015540 <test_printn>
    test_println("");
 800112c:	484b      	ldr	r0, [pc, #300]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800112e:	f014 fa6f 	bl	8015610 <test_println>
    test_print("--- CH_CFG_USE_FACTORY:                 ");
 8001132:	4866      	ldr	r0, [pc, #408]	; (80012cc <rt_test_001_003_execute.lto_priv.745+0x39c>)
 8001134:	f014 fa4c 	bl	80155d0 <test_print>
    test_printn(CH_CFG_USE_FACTORY);
 8001138:	2001      	movs	r0, #1
 800113a:	f014 fa01 	bl	8015540 <test_printn>
    test_println("");
 800113e:	4847      	ldr	r0, [pc, #284]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001140:	f014 fa66 	bl	8015610 <test_println>
    test_print("--- CH_CFG_FACTORY_MAX_NAMES_LENGTH:    ");
 8001144:	4862      	ldr	r0, [pc, #392]	; (80012d0 <rt_test_001_003_execute.lto_priv.745+0x3a0>)
 8001146:	f014 fa43 	bl	80155d0 <test_print>
    test_printn(CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 800114a:	2008      	movs	r0, #8
 800114c:	f014 f9f8 	bl	8015540 <test_printn>
    test_println("");
 8001150:	4842      	ldr	r0, [pc, #264]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001152:	f014 fa5d 	bl	8015610 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJECTS_REGISTRY:    ");
 8001156:	485f      	ldr	r0, [pc, #380]	; (80012d4 <rt_test_001_003_execute.lto_priv.745+0x3a4>)
 8001158:	f014 fa3a 	bl	80155d0 <test_print>
    test_printn(CH_CFG_FACTORY_OBJECTS_REGISTRY);
 800115c:	2001      	movs	r0, #1
 800115e:	f014 f9ef 	bl	8015540 <test_printn>
    test_println("");
 8001162:	483e      	ldr	r0, [pc, #248]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001164:	f014 fa54 	bl	8015610 <test_println>
    test_print("--- CH_CFG_FACTORY_GENERIC_BUFFERS:     ");
 8001168:	485b      	ldr	r0, [pc, #364]	; (80012d8 <rt_test_001_003_execute.lto_priv.745+0x3a8>)
 800116a:	f014 fa31 	bl	80155d0 <test_print>
    test_printn(CH_CFG_FACTORY_GENERIC_BUFFERS);
 800116e:	2001      	movs	r0, #1
 8001170:	f014 f9e6 	bl	8015540 <test_printn>
    test_println("");
 8001174:	4839      	ldr	r0, [pc, #228]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001176:	f014 fa4b 	bl	8015610 <test_println>
    test_print("--- CH_CFG_FACTORY_SEMAPHORES:          ");
 800117a:	4858      	ldr	r0, [pc, #352]	; (80012dc <rt_test_001_003_execute.lto_priv.745+0x3ac>)
 800117c:	f014 fa28 	bl	80155d0 <test_print>
    test_printn(CH_CFG_FACTORY_SEMAPHORES);
 8001180:	2001      	movs	r0, #1
 8001182:	f014 f9dd 	bl	8015540 <test_printn>
    test_println("");
 8001186:	4835      	ldr	r0, [pc, #212]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001188:	f014 fa42 	bl	8015610 <test_println>
    test_print("--- CH_CFG_FACTORY_MAILBOXES:           ");
 800118c:	4854      	ldr	r0, [pc, #336]	; (80012e0 <rt_test_001_003_execute.lto_priv.745+0x3b0>)
 800118e:	f014 fa1f 	bl	80155d0 <test_print>
    test_printn(CH_CFG_FACTORY_MAILBOXES);
 8001192:	2001      	movs	r0, #1
 8001194:	f014 f9d4 	bl	8015540 <test_printn>
    test_println("");
 8001198:	4830      	ldr	r0, [pc, #192]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800119a:	f014 fa39 	bl	8015610 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJ_FIFOS:           ");
 800119e:	4851      	ldr	r0, [pc, #324]	; (80012e4 <rt_test_001_003_execute.lto_priv.745+0x3b4>)
 80011a0:	f014 fa16 	bl	80155d0 <test_print>
    test_printn(CH_CFG_FACTORY_OBJ_FIFOS);
 80011a4:	2001      	movs	r0, #1
 80011a6:	f014 f9cb 	bl	8015540 <test_printn>
    test_println("");
 80011aa:	482c      	ldr	r0, [pc, #176]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 80011ac:	f014 fa30 	bl	8015610 <test_println>
    test_print("--- CH_DBG_STATISTICS:                  ");
 80011b0:	484d      	ldr	r0, [pc, #308]	; (80012e8 <rt_test_001_003_execute.lto_priv.745+0x3b8>)
 80011b2:	f014 fa0d 	bl	80155d0 <test_print>
    test_printn(CH_DBG_STATISTICS);
 80011b6:	2000      	movs	r0, #0
 80011b8:	f014 f9c2 	bl	8015540 <test_printn>
    test_println("");
 80011bc:	4827      	ldr	r0, [pc, #156]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 80011be:	f014 fa27 	bl	8015610 <test_println>
    test_print("--- CH_DBG_SYSTEM_STATE_CHECK:          ");
 80011c2:	484a      	ldr	r0, [pc, #296]	; (80012ec <rt_test_001_003_execute.lto_priv.745+0x3bc>)
 80011c4:	f014 fa04 	bl	80155d0 <test_print>
    test_printn(CH_DBG_SYSTEM_STATE_CHECK);
 80011c8:	2001      	movs	r0, #1
 80011ca:	f014 f9b9 	bl	8015540 <test_printn>
    test_println("");
 80011ce:	4823      	ldr	r0, [pc, #140]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 80011d0:	f014 fa1e 	bl	8015610 <test_println>
    test_print("--- CH_DBG_ENABLE_CHECKS:               ");
 80011d4:	4846      	ldr	r0, [pc, #280]	; (80012f0 <rt_test_001_003_execute.lto_priv.745+0x3c0>)
 80011d6:	f014 f9fb 	bl	80155d0 <test_print>
    test_printn(CH_DBG_ENABLE_CHECKS);
 80011da:	2001      	movs	r0, #1
 80011dc:	f014 f9b0 	bl	8015540 <test_printn>
    test_println("");
 80011e0:	481e      	ldr	r0, [pc, #120]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 80011e2:	f014 fa15 	bl	8015610 <test_println>
    test_print("--- CH_DBG_ENABLE_ASSERTS:              ");
 80011e6:	4843      	ldr	r0, [pc, #268]	; (80012f4 <rt_test_001_003_execute.lto_priv.745+0x3c4>)
 80011e8:	f014 f9f2 	bl	80155d0 <test_print>
    test_printn(CH_DBG_ENABLE_ASSERTS);
 80011ec:	2001      	movs	r0, #1
 80011ee:	f014 f9a7 	bl	8015540 <test_printn>
    test_println("");
 80011f2:	481a      	ldr	r0, [pc, #104]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 80011f4:	f014 fa0c 	bl	8015610 <test_println>
    test_print("--- CH_DBG_TRACE_MASK:                  ");
 80011f8:	483f      	ldr	r0, [pc, #252]	; (80012f8 <rt_test_001_003_execute.lto_priv.745+0x3c8>)
 80011fa:	f014 f9e9 	bl	80155d0 <test_print>
    test_printn(CH_DBG_TRACE_MASK);
 80011fe:	200f      	movs	r0, #15
 8001200:	f014 f99e 	bl	8015540 <test_printn>
    test_println("");
 8001204:	4815      	ldr	r0, [pc, #84]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001206:	f014 fa03 	bl	8015610 <test_println>
    test_print("--- CH_DBG_TRACE_BUFFER_SIZE:           ");
 800120a:	483c      	ldr	r0, [pc, #240]	; (80012fc <rt_test_001_003_execute.lto_priv.745+0x3cc>)
 800120c:	f014 f9e0 	bl	80155d0 <test_print>
    test_printn(CH_DBG_TRACE_BUFFER_SIZE);
 8001210:	2080      	movs	r0, #128	; 0x80
 8001212:	f014 f995 	bl	8015540 <test_printn>
    test_println("");
 8001216:	4811      	ldr	r0, [pc, #68]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 8001218:	f014 f9fa 	bl	8015610 <test_println>
    test_print("--- CH_DBG_ENABLE_STACK_CHECK:          ");
 800121c:	4838      	ldr	r0, [pc, #224]	; (8001300 <rt_test_001_003_execute.lto_priv.745+0x3d0>)
 800121e:	f014 f9d7 	bl	80155d0 <test_print>
    test_printn(CH_DBG_ENABLE_STACK_CHECK);
 8001222:	2001      	movs	r0, #1
 8001224:	f014 f98c 	bl	8015540 <test_printn>
    test_println("");
 8001228:	480c      	ldr	r0, [pc, #48]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800122a:	f014 f9f1 	bl	8015610 <test_println>
    test_print("--- CH_DBG_FILL_THREADS:                ");
 800122e:	4835      	ldr	r0, [pc, #212]	; (8001304 <rt_test_001_003_execute.lto_priv.745+0x3d4>)
 8001230:	f014 f9ce 	bl	80155d0 <test_print>
    test_printn(CH_DBG_FILL_THREADS);
 8001234:	2001      	movs	r0, #1
 8001236:	f014 f983 	bl	8015540 <test_printn>
    test_println("");
 800123a:	4808      	ldr	r0, [pc, #32]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800123c:	f014 f9e8 	bl	8015610 <test_println>
    test_print("--- CH_DBG_THREADS_PROFILING:           ");
 8001240:	4831      	ldr	r0, [pc, #196]	; (8001308 <rt_test_001_003_execute.lto_priv.745+0x3d8>)
 8001242:	f014 f9c5 	bl	80155d0 <test_print>
    test_printn(CH_DBG_THREADS_PROFILING);
 8001246:	2000      	movs	r0, #0
 8001248:	f014 f97a 	bl	8015540 <test_printn>
    test_println("");
 800124c:	4803      	ldr	r0, [pc, #12]	; (800125c <rt_test_001_003_execute.lto_priv.745+0x32c>)
 800124e:	f014 f9df 	bl	8015610 <test_println>
  }
}
 8001252:	bd08      	pop	{r3, pc}
 8001254:	20001988 	.word	0x20001988
 8001258:	08017664 	.word	0x08017664
 800125c:	08018d94 	.word	0x08018d94
 8001260:	08017690 	.word	0x08017690
 8001264:	080176bc 	.word	0x080176bc
 8001268:	080176e8 	.word	0x080176e8
 800126c:	08017714 	.word	0x08017714
 8001270:	08017740 	.word	0x08017740
 8001274:	0801776c 	.word	0x0801776c
 8001278:	08017798 	.word	0x08017798
 800127c:	080177c4 	.word	0x080177c4
 8001280:	080177f0 	.word	0x080177f0
 8001284:	0801781c 	.word	0x0801781c
 8001288:	08017848 	.word	0x08017848
 800128c:	08017874 	.word	0x08017874
 8001290:	080178a0 	.word	0x080178a0
 8001294:	080178cc 	.word	0x080178cc
 8001298:	080178f8 	.word	0x080178f8
 800129c:	08017924 	.word	0x08017924
 80012a0:	08017950 	.word	0x08017950
 80012a4:	0801797c 	.word	0x0801797c
 80012a8:	080179a8 	.word	0x080179a8
 80012ac:	080179d4 	.word	0x080179d4
 80012b0:	08017a00 	.word	0x08017a00
 80012b4:	08017a2c 	.word	0x08017a2c
 80012b8:	08017a58 	.word	0x08017a58
 80012bc:	08017a84 	.word	0x08017a84
 80012c0:	08017ab0 	.word	0x08017ab0
 80012c4:	08017adc 	.word	0x08017adc
 80012c8:	08017b08 	.word	0x08017b08
 80012cc:	08017b34 	.word	0x08017b34
 80012d0:	08017b60 	.word	0x08017b60
 80012d4:	08017b8c 	.word	0x08017b8c
 80012d8:	08017bb8 	.word	0x08017bb8
 80012dc:	08017be4 	.word	0x08017be4
 80012e0:	08017c10 	.word	0x08017c10
 80012e4:	08017c3c 	.word	0x08017c3c
 80012e8:	08017c68 	.word	0x08017c68
 80012ec:	08017c94 	.word	0x08017c94
 80012f0:	08017cc0 	.word	0x08017cc0
 80012f4:	08017cec 	.word	0x08017cec
 80012f8:	08017d18 	.word	0x08017d18
 80012fc:	08017d44 	.word	0x08017d44
 8001300:	08017d70 	.word	0x08017d70
 8001304:	08017d9c 	.word	0x08017d9c
 8001308:	08017dc8 	.word	0x08017dc8
 800130c:	00000000 	.word	0x00000000

08001310 <port_get_irq_status>:
static inline syssts_t port_get_irq_status(void) {
 8001310:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8001312:	f3ef 8311 	mrs	r3, BASEPRI
 8001316:	9300      	str	r3, [sp, #0]
  return(result);
 8001318:	9b00      	ldr	r3, [sp, #0]
  sts = (syssts_t)__get_BASEPRI();
 800131a:	9301      	str	r3, [sp, #4]
  return sts;
 800131c:	9b01      	ldr	r3, [sp, #4]
}
 800131e:	4618      	mov	r0, r3
 8001320:	b002      	add	sp, #8
 8001322:	4770      	bx	lr
	...

08001330 <port_irq_enabled>:
static inline bool port_irq_enabled(syssts_t sts) {
 8001330:	b082      	sub	sp, #8
 8001332:	9001      	str	r0, [sp, #4]
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 8001334:	9b01      	ldr	r3, [sp, #4]
 8001336:	2b00      	cmp	r3, #0
 8001338:	bf0c      	ite	eq
 800133a:	2301      	moveq	r3, #1
 800133c:	2300      	movne	r3, #0
 800133e:	b2db      	uxtb	r3, r3
}
 8001340:	4618      	mov	r0, r3
 8001342:	b002      	add	sp, #8
 8001344:	4770      	bx	lr
 8001346:	bf00      	nop
	...

08001350 <port_lock.lto_priv.19>:
static inline void port_lock(void) {
 8001350:	b082      	sub	sp, #8
 8001352:	2320      	movs	r3, #32
 8001354:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001356:	9b01      	ldr	r3, [sp, #4]
 8001358:	f383 8811 	msr	BASEPRI, r3
}
 800135c:	b002      	add	sp, #8
 800135e:	4770      	bx	lr

08001360 <port_unlock.lto_priv.9>:
static inline void port_unlock(void) {
 8001360:	b082      	sub	sp, #8
 8001362:	2300      	movs	r3, #0
 8001364:	9301      	str	r3, [sp, #4]
 8001366:	9b01      	ldr	r3, [sp, #4]
 8001368:	f383 8811 	msr	BASEPRI, r3
}
 800136c:	b002      	add	sp, #8
 800136e:	4770      	bx	lr

08001370 <port_lock_from_isr.lto_priv.6>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001370:	b508      	push	{r3, lr}

  port_lock();
 8001372:	f7ff ffed 	bl	8001350 <port_lock.lto_priv.19>
}
 8001376:	bd08      	pop	{r3, pc}
	...

08001380 <port_unlock_from_isr.lto_priv.4>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001380:	b508      	push	{r3, lr}

  port_unlock();
 8001382:	f7ff ffed 	bl	8001360 <port_unlock.lto_priv.9>
}
 8001386:	bd08      	pop	{r3, pc}
	...

08001390 <port_disable>:
  __ASM volatile ("cpsid i" : : : "memory");
 8001390:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8001392:	4770      	bx	lr
	...

080013a0 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 * @note    Interrupt sources above kernel level remains enabled.
 * @note    In this port it raises/lowers the base priority to kernel level.
 */
static inline void port_suspend(void) {
 80013a0:	b082      	sub	sp, #8
 80013a2:	2320      	movs	r3, #32
 80013a4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80013a6:	9b01      	ldr	r3, [sp, #4]
 80013a8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 80013ac:	b662      	cpsie	i
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
  __enable_irq();
#else
  __disable_irq();
#endif
}
 80013ae:	b002      	add	sp, #8
 80013b0:	4770      	bx	lr
 80013b2:	bf00      	nop
	...

080013c0 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 80013c0:	b082      	sub	sp, #8
 80013c2:	2300      	movs	r3, #0
 80013c4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80013c6:	9b01      	ldr	r3, [sp, #4]
 80013c8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 80013cc:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 80013ce:	b002      	add	sp, #8
 80013d0:	4770      	bx	lr
 80013d2:	bf00      	nop
	...

080013e0 <st_lld_get_counter.lto_priv.116>:
  return (systime_t)STM32_ST_TIM->CNT;
 80013e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80013e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80013e6:	4618      	mov	r0, r3
 80013e8:	4770      	bx	lr
 80013ea:	bf00      	nop
 80013ec:	0000      	movs	r0, r0
	...

080013f0 <port_timer_get_time.lto_priv.111>:
static inline systime_t port_timer_get_time(void) {
 80013f0:	b508      	push	{r3, lr}
  return stGetCounter();
 80013f2:	f7ff fff5 	bl	80013e0 <st_lld_get_counter.lto_priv.116>
 80013f6:	4603      	mov	r3, r0
}
 80013f8:	4618      	mov	r0, r3
 80013fa:	bd08      	pop	{r3, pc}
 80013fc:	0000      	movs	r0, r0
	...

08001400 <chSysDisable>:
static inline void chSysDisable(void) {
 8001400:	b508      	push	{r3, lr}
  port_disable();
 8001402:	f7ff ffc5 	bl	8001390 <port_disable>
  _dbg_check_disable();
 8001406:	f00d ff13 	bl	800f230 <_dbg_check_disable>
}
 800140a:	bd08      	pop	{r3, pc}
 800140c:	0000      	movs	r0, r0
	...

08001410 <chSysSuspend>:
static inline void chSysSuspend(void) {
 8001410:	b508      	push	{r3, lr}
  port_suspend();
 8001412:	f7ff ffc5 	bl	80013a0 <port_suspend>
  _dbg_check_suspend();
 8001416:	f00d ff23 	bl	800f260 <_dbg_check_suspend>
}
 800141a:	bd08      	pop	{r3, pc}
 800141c:	0000      	movs	r0, r0
	...

08001420 <chSysEnable>:
static inline void chSysEnable(void) {
 8001420:	b508      	push	{r3, lr}
  _dbg_check_enable();
 8001422:	f00d ff35 	bl	800f290 <_dbg_check_enable>
  port_enable();
 8001426:	f7ff ffcb 	bl	80013c0 <port_enable>
}
 800142a:	bd08      	pop	{r3, pc}
 800142c:	0000      	movs	r0, r0
	...

08001430 <chSysLock.lto_priv.75>:
static inline void chSysLock(void) {
 8001430:	b508      	push	{r3, lr}
  port_lock();
 8001432:	f7ff ff8d 	bl	8001350 <port_lock.lto_priv.19>
  _dbg_check_lock();
 8001436:	f00d ff43 	bl	800f2c0 <_dbg_check_lock>
}
 800143a:	bd08      	pop	{r3, pc}
 800143c:	0000      	movs	r0, r0
	...

08001440 <chSysUnlock.lto_priv.39>:
static inline void chSysUnlock(void) {
 8001440:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8001442:	f00d ff55 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001446:	4b09      	ldr	r3, [pc, #36]	; (800146c <chSysUnlock.lto_priv.39+0x2c>)
 8001448:	681b      	ldr	r3, [r3, #0]
 800144a:	4a08      	ldr	r2, [pc, #32]	; (800146c <chSysUnlock.lto_priv.39+0x2c>)
 800144c:	4293      	cmp	r3, r2
 800144e:	d00a      	beq.n	8001466 <chSysUnlock.lto_priv.39+0x26>
 8001450:	4b06      	ldr	r3, [pc, #24]	; (800146c <chSysUnlock.lto_priv.39+0x2c>)
 8001452:	699b      	ldr	r3, [r3, #24]
 8001454:	689a      	ldr	r2, [r3, #8]
 8001456:	4b05      	ldr	r3, [pc, #20]	; (800146c <chSysUnlock.lto_priv.39+0x2c>)
 8001458:	681b      	ldr	r3, [r3, #0]
 800145a:	689b      	ldr	r3, [r3, #8]
 800145c:	429a      	cmp	r2, r3
 800145e:	d202      	bcs.n	8001466 <chSysUnlock.lto_priv.39+0x26>
 8001460:	4803      	ldr	r0, [pc, #12]	; (8001470 <chSysUnlock.lto_priv.39+0x30>)
 8001462:	f00d fdbd 	bl	800efe0 <chSysHalt>
  port_unlock();
 8001466:	f7ff ff7b 	bl	8001360 <port_unlock.lto_priv.9>
}
 800146a:	bd08      	pop	{r3, pc}
 800146c:	20001090 	.word	0x20001090
 8001470:	08017efc 	.word	0x08017efc
	...

08001480 <chSysLockFromISR.lto_priv.2>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001480:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001482:	f7ff ff75 	bl	8001370 <port_lock_from_isr.lto_priv.6>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8001486:	f00d ff4b 	bl	800f320 <_dbg_check_lock_from_isr>
}
 800148a:	bd08      	pop	{r3, pc}
 800148c:	0000      	movs	r0, r0
	...

08001490 <chSysUnlockFromISR.lto_priv.0>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001490:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8001492:	f00d ff5d 	bl	800f350 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001496:	f7ff ff73 	bl	8001380 <port_unlock_from_isr.lto_priv.4>
}
 800149a:	bd08      	pop	{r3, pc}
 800149c:	0000      	movs	r0, r0
	...

080014a0 <chSysUnconditionalLock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "s-locked".
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {
 80014a0:	b508      	push	{r3, lr}

  if (port_irq_enabled(port_get_irq_status())) {
 80014a2:	f7ff ff35 	bl	8001310 <port_get_irq_status>
 80014a6:	4603      	mov	r3, r0
 80014a8:	4618      	mov	r0, r3
 80014aa:	f7ff ff41 	bl	8001330 <port_irq_enabled>
 80014ae:	4603      	mov	r3, r0
 80014b0:	2b00      	cmp	r3, #0
 80014b2:	d001      	beq.n	80014b8 <chSysUnconditionalLock+0x18>
    chSysLock();
 80014b4:	f7ff ffbc 	bl	8001430 <chSysLock.lto_priv.75>
  }
}
 80014b8:	bd08      	pop	{r3, pc}
 80014ba:	bf00      	nop
 80014bc:	0000      	movs	r0, r0
	...

080014c0 <chSysUnconditionalUnlock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "normal".
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {
 80014c0:	b508      	push	{r3, lr}

  if (!port_irq_enabled(port_get_irq_status())) {
 80014c2:	f7ff ff25 	bl	8001310 <port_get_irq_status>
 80014c6:	4603      	mov	r3, r0
 80014c8:	4618      	mov	r0, r3
 80014ca:	f7ff ff31 	bl	8001330 <port_irq_enabled>
 80014ce:	4603      	mov	r3, r0
 80014d0:	f083 0301 	eor.w	r3, r3, #1
 80014d4:	b2db      	uxtb	r3, r3
 80014d6:	2b00      	cmp	r3, #0
 80014d8:	d001      	beq.n	80014de <chSysUnconditionalUnlock+0x1e>
    chSysUnlock();
 80014da:	f7ff ffb1 	bl	8001440 <chSysUnlock.lto_priv.39>
  }
}
 80014de:	bd08      	pop	{r3, pc}

080014e0 <chVTObjectInit>:
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 80014e0:	b082      	sub	sp, #8
 80014e2:	9001      	str	r0, [sp, #4]
  vtp->func = NULL;
 80014e4:	9b01      	ldr	r3, [sp, #4]
 80014e6:	2200      	movs	r2, #0
 80014e8:	60da      	str	r2, [r3, #12]
}
 80014ea:	b002      	add	sp, #8
 80014ec:	4770      	bx	lr
 80014ee:	bf00      	nop

080014f0 <chVTGetSystemTimeX.lto_priv.106>:
static inline systime_t chVTGetSystemTimeX(void) {
 80014f0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 80014f2:	f7ff ff7d 	bl	80013f0 <port_timer_get_time.lto_priv.111>
 80014f6:	4603      	mov	r3, r0
}
 80014f8:	4618      	mov	r0, r3
 80014fa:	bd08      	pop	{r3, pc}
 80014fc:	0000      	movs	r0, r0
	...

08001500 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8001500:	b500      	push	{lr}
 8001502:	b083      	sub	sp, #12
 8001504:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8001506:	f00d ff7b 	bl	800f400 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
 800150a:	9b01      	ldr	r3, [sp, #4]
 800150c:	68db      	ldr	r3, [r3, #12]
 800150e:	2b00      	cmp	r3, #0
 8001510:	bf14      	ite	ne
 8001512:	2301      	movne	r3, #1
 8001514:	2300      	moveq	r3, #0
 8001516:	b2db      	uxtb	r3, r3
}
 8001518:	4618      	mov	r0, r3
 800151a:	b003      	add	sp, #12
 800151c:	f85d fb04 	ldr.w	pc, [sp], #4

08001520 <chVTIsArmed>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(const virtual_timer_t *vtp) {
 8001520:	b500      	push	{lr}
 8001522:	b085      	sub	sp, #20
 8001524:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 8001526:	f7ff ff83 	bl	8001430 <chSysLock.lto_priv.75>
  b = chVTIsArmedI(vtp);
 800152a:	9801      	ldr	r0, [sp, #4]
 800152c:	f7ff ffe8 	bl	8001500 <chVTIsArmedI>
 8001530:	4603      	mov	r3, r0
 8001532:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 8001536:	f7ff ff83 	bl	8001440 <chSysUnlock.lto_priv.39>

  return b;
 800153a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800153e:	4618      	mov	r0, r3
 8001540:	b005      	add	sp, #20
 8001542:	f85d fb04 	ldr.w	pc, [sp], #4
 8001546:	bf00      	nop
	...

08001550 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 8001550:	b500      	push	{lr}
 8001552:	b083      	sub	sp, #12
 8001554:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 8001556:	9801      	ldr	r0, [sp, #4]
 8001558:	f7ff ffd2 	bl	8001500 <chVTIsArmedI>
 800155c:	4603      	mov	r3, r0
 800155e:	2b00      	cmp	r3, #0
 8001560:	d002      	beq.n	8001568 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 8001562:	9801      	ldr	r0, [sp, #4]
 8001564:	f00e f9dc 	bl	800f920 <chVTDoResetI>
  }
}
 8001568:	b003      	add	sp, #12
 800156a:	f85d fb04 	ldr.w	pc, [sp], #4
 800156e:	bf00      	nop

08001570 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {
 8001570:	b500      	push	{lr}
 8001572:	b085      	sub	sp, #20
 8001574:	9003      	str	r0, [sp, #12]
 8001576:	9102      	str	r1, [sp, #8]
 8001578:	9201      	str	r2, [sp, #4]
 800157a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800157c:	9803      	ldr	r0, [sp, #12]
 800157e:	f7ff ffe7 	bl	8001550 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8001582:	9b00      	ldr	r3, [sp, #0]
 8001584:	9a01      	ldr	r2, [sp, #4]
 8001586:	9902      	ldr	r1, [sp, #8]
 8001588:	9803      	ldr	r0, [sp, #12]
 800158a:	f00e f919 	bl	800f7c0 <chVTDoSetI>
}
 800158e:	b005      	add	sp, #20
 8001590:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080015a0 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, sysinterval_t delay,
                           vtfunc_t vtfunc, void *par) {
 80015a0:	b500      	push	{lr}
 80015a2:	b085      	sub	sp, #20
 80015a4:	9003      	str	r0, [sp, #12]
 80015a6:	9102      	str	r1, [sp, #8]
 80015a8:	9201      	str	r2, [sp, #4]
 80015aa:	9300      	str	r3, [sp, #0]

  chSysLock();
 80015ac:	f7ff ff40 	bl	8001430 <chSysLock.lto_priv.75>
  chVTSetI(vtp, delay, vtfunc, par);
 80015b0:	9b00      	ldr	r3, [sp, #0]
 80015b2:	9a01      	ldr	r2, [sp, #4]
 80015b4:	9902      	ldr	r1, [sp, #8]
 80015b6:	9803      	ldr	r0, [sp, #12]
 80015b8:	f7ff ffda 	bl	8001570 <chVTSetI>
  chSysUnlock();
 80015bc:	f7ff ff40 	bl	8001440 <chSysUnlock.lto_priv.39>
}
 80015c0:	b005      	add	sp, #20
 80015c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80015c6:	bf00      	nop
	...

080015d0 <vtcb>:
/****************************************************************************
 * Shared code.
 ****************************************************************************/

/* Timer callback for testing system functions in ISR context.*/
static void vtcb(void *p) {
 80015d0:	b500      	push	{lr}
 80015d2:	b085      	sub	sp, #20
 80015d4:	9001      	str	r0, [sp, #4]
  syssts_t sts;

  (void)p;

  /* Testing normal case.*/
  chSysLockFromISR();
 80015d6:	f7ff ff53 	bl	8001480 <chSysLockFromISR.lto_priv.2>
  chSysUnlockFromISR();
 80015da:	f7ff ff59 	bl	8001490 <chSysUnlockFromISR.lto_priv.0>

  /* Reentrant case.*/
  chSysLockFromISR();
 80015de:	f7ff ff4f 	bl	8001480 <chSysLockFromISR.lto_priv.2>
  sts = chSysGetStatusAndLockX();
 80015e2:	f00d fd9d 	bl	800f120 <chSysGetStatusAndLockX>
 80015e6:	9003      	str	r0, [sp, #12]
  chSysRestoreStatusX(sts);
 80015e8:	9803      	ldr	r0, [sp, #12]
 80015ea:	f00d fdb9 	bl	800f160 <chSysRestoreStatusX>
  chSysUnlockFromISR();
 80015ee:	f7ff ff4f 	bl	8001490 <chSysUnlockFromISR.lto_priv.0>
}
 80015f2:	b005      	add	sp, #20
 80015f4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001600 <rt_test_002_001_execute.lto_priv.746>:
 * - [2.1.3] Testing Registry List integrity.
 * - [2.1.4] Testing Port-defined integrity.
 * .
 */

static void rt_test_002_001_execute(void) {
 8001600:	b500      	push	{lr}
 8001602:	b083      	sub	sp, #12
  bool result;

  /* [2.1.1] Testing Ready List integrity.*/
  test_set_step(1);
 8001604:	4b41      	ldr	r3, [pc, #260]	; (800170c <rt_test_002_001_execute.lto_priv.746+0x10c>)
 8001606:	2201      	movs	r2, #1
 8001608:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 800160a:	f7ff ff11 	bl	8001430 <chSysLock.lto_priv.75>
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 800160e:	2001      	movs	r0, #1
 8001610:	f00d fcf6 	bl	800f000 <chSysIntegrityCheckI>
 8001614:	4603      	mov	r3, r0
 8001616:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
 800161a:	f7ff ff11 	bl	8001440 <chSysUnlock.lto_priv.39>
    test_assert(result == false, "ready list check failed");
 800161e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001622:	2b00      	cmp	r3, #0
 8001624:	bf14      	ite	ne
 8001626:	2301      	movne	r3, #1
 8001628:	2300      	moveq	r3, #0
 800162a:	b2db      	uxtb	r3, r3
 800162c:	f083 0301 	eor.w	r3, r3, #1
 8001630:	b2db      	uxtb	r3, r3
 8001632:	f003 0301 	and.w	r3, r3, #1
 8001636:	b2db      	uxtb	r3, r3
 8001638:	4935      	ldr	r1, [pc, #212]	; (8001710 <rt_test_002_001_execute.lto_priv.746+0x110>)
 800163a:	4618      	mov	r0, r3
 800163c:	f013 ff20 	bl	8015480 <_test_assert>
 8001640:	4603      	mov	r3, r0
 8001642:	2b00      	cmp	r3, #0
 8001644:	d15f      	bne.n	8001706 <rt_test_002_001_execute.lto_priv.746+0x106>
  }

  /* [2.1.2] Testing Virtual Timers List integrity.*/
  test_set_step(2);
 8001646:	4b31      	ldr	r3, [pc, #196]	; (800170c <rt_test_002_001_execute.lto_priv.746+0x10c>)
 8001648:	2202      	movs	r2, #2
 800164a:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 800164c:	f7ff fef0 	bl	8001430 <chSysLock.lto_priv.75>
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8001650:	2002      	movs	r0, #2
 8001652:	f00d fcd5 	bl	800f000 <chSysIntegrityCheckI>
 8001656:	4603      	mov	r3, r0
 8001658:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
 800165c:	f7ff fef0 	bl	8001440 <chSysUnlock.lto_priv.39>
    test_assert(result == false, "virtual timers list check failed");
 8001660:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001664:	2b00      	cmp	r3, #0
 8001666:	bf14      	ite	ne
 8001668:	2301      	movne	r3, #1
 800166a:	2300      	moveq	r3, #0
 800166c:	b2db      	uxtb	r3, r3
 800166e:	f083 0301 	eor.w	r3, r3, #1
 8001672:	b2db      	uxtb	r3, r3
 8001674:	f003 0301 	and.w	r3, r3, #1
 8001678:	b2db      	uxtb	r3, r3
 800167a:	4926      	ldr	r1, [pc, #152]	; (8001714 <rt_test_002_001_execute.lto_priv.746+0x114>)
 800167c:	4618      	mov	r0, r3
 800167e:	f013 feff 	bl	8015480 <_test_assert>
 8001682:	4603      	mov	r3, r0
 8001684:	2b00      	cmp	r3, #0
 8001686:	d13e      	bne.n	8001706 <rt_test_002_001_execute.lto_priv.746+0x106>
  }

  /* [2.1.3] Testing Registry List integrity.*/
  test_set_step(3);
 8001688:	4b20      	ldr	r3, [pc, #128]	; (800170c <rt_test_002_001_execute.lto_priv.746+0x10c>)
 800168a:	2203      	movs	r2, #3
 800168c:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 800168e:	f7ff fecf 	bl	8001430 <chSysLock.lto_priv.75>
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8001692:	2004      	movs	r0, #4
 8001694:	f00d fcb4 	bl	800f000 <chSysIntegrityCheckI>
 8001698:	4603      	mov	r3, r0
 800169a:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
 800169e:	f7ff fecf 	bl	8001440 <chSysUnlock.lto_priv.39>
    test_assert(result == false, "registry list check failed");
 80016a2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80016a6:	2b00      	cmp	r3, #0
 80016a8:	bf14      	ite	ne
 80016aa:	2301      	movne	r3, #1
 80016ac:	2300      	moveq	r3, #0
 80016ae:	b2db      	uxtb	r3, r3
 80016b0:	f083 0301 	eor.w	r3, r3, #1
 80016b4:	b2db      	uxtb	r3, r3
 80016b6:	f003 0301 	and.w	r3, r3, #1
 80016ba:	b2db      	uxtb	r3, r3
 80016bc:	4916      	ldr	r1, [pc, #88]	; (8001718 <rt_test_002_001_execute.lto_priv.746+0x118>)
 80016be:	4618      	mov	r0, r3
 80016c0:	f013 fede 	bl	8015480 <_test_assert>
 80016c4:	4603      	mov	r3, r0
 80016c6:	2b00      	cmp	r3, #0
 80016c8:	d11d      	bne.n	8001706 <rt_test_002_001_execute.lto_priv.746+0x106>
  }

  /* [2.1.4] Testing Port-defined integrity.*/
  test_set_step(4);
 80016ca:	4b10      	ldr	r3, [pc, #64]	; (800170c <rt_test_002_001_execute.lto_priv.746+0x10c>)
 80016cc:	2204      	movs	r2, #4
 80016ce:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 80016d0:	f7ff feae 	bl	8001430 <chSysLock.lto_priv.75>
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 80016d4:	2008      	movs	r0, #8
 80016d6:	f00d fc93 	bl	800f000 <chSysIntegrityCheckI>
 80016da:	4603      	mov	r3, r0
 80016dc:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
 80016e0:	f7ff feae 	bl	8001440 <chSysUnlock.lto_priv.39>
    test_assert(result == false, "port layer check failed");
 80016e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80016e8:	2b00      	cmp	r3, #0
 80016ea:	bf14      	ite	ne
 80016ec:	2301      	movne	r3, #1
 80016ee:	2300      	moveq	r3, #0
 80016f0:	b2db      	uxtb	r3, r3
 80016f2:	f083 0301 	eor.w	r3, r3, #1
 80016f6:	b2db      	uxtb	r3, r3
 80016f8:	f003 0301 	and.w	r3, r3, #1
 80016fc:	b2db      	uxtb	r3, r3
 80016fe:	4907      	ldr	r1, [pc, #28]	; (800171c <rt_test_002_001_execute.lto_priv.746+0x11c>)
 8001700:	4618      	mov	r0, r3
 8001702:	f013 febd 	bl	8015480 <_test_assert>
  }
}
 8001706:	b003      	add	sp, #12
 8001708:	f85d fb04 	ldr.w	pc, [sp], #4
 800170c:	20001988 	.word	0x20001988
 8001710:	08017e1c 	.word	0x08017e1c
 8001714:	08017e34 	.word	0x08017e34
 8001718:	08017e58 	.word	0x08017e58
 800171c:	08017e74 	.word	0x08017e74

08001720 <rt_test_002_002_execute.lto_priv.747>:
 * - [2.2.4] Testing chSysUnconditionalUnlock().
 * - [2.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void rt_test_002_002_execute(void) {
 8001720:	b500      	push	{lr}
 8001722:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* [2.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 8001724:	4b28      	ldr	r3, [pc, #160]	; (80017c8 <rt_test_002_002_execute.lto_priv.747+0xa8>)
 8001726:	2201      	movs	r2, #1
 8001728:	601a      	str	r2, [r3, #0]
  {
    sts = chSysGetStatusAndLockX();
 800172a:	f00d fcf9 	bl	800f120 <chSysGetStatusAndLockX>
 800172e:	9005      	str	r0, [sp, #20]
    chSysRestoreStatusX(sts);
 8001730:	9805      	ldr	r0, [sp, #20]
 8001732:	f00d fd15 	bl	800f160 <chSysRestoreStatusX>
  }

  /* [2.2.2] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), reentrant case.*/
  test_set_step(2);
 8001736:	4b24      	ldr	r3, [pc, #144]	; (80017c8 <rt_test_002_002_execute.lto_priv.747+0xa8>)
 8001738:	2202      	movs	r2, #2
 800173a:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 800173c:	f7ff fe78 	bl	8001430 <chSysLock.lto_priv.75>
    sts = chSysGetStatusAndLockX();
 8001740:	f00d fcee 	bl	800f120 <chSysGetStatusAndLockX>
 8001744:	9005      	str	r0, [sp, #20]
    chSysRestoreStatusX(sts);
 8001746:	9805      	ldr	r0, [sp, #20]
 8001748:	f00d fd0a 	bl	800f160 <chSysRestoreStatusX>
    chSysUnlock();
 800174c:	f7ff fe78 	bl	8001440 <chSysUnlock.lto_priv.39>
  }

  /* [2.2.3] Testing chSysUnconditionalLock().*/
  test_set_step(3);
 8001750:	4b1d      	ldr	r3, [pc, #116]	; (80017c8 <rt_test_002_002_execute.lto_priv.747+0xa8>)
 8001752:	2203      	movs	r2, #3
 8001754:	601a      	str	r2, [r3, #0]
  {
    chSysUnconditionalLock();
 8001756:	f7ff fea3 	bl	80014a0 <chSysUnconditionalLock>
    chSysUnconditionalLock();
 800175a:	f7ff fea1 	bl	80014a0 <chSysUnconditionalLock>
    chSysUnlock();
 800175e:	f7ff fe6f 	bl	8001440 <chSysUnlock.lto_priv.39>
  }

  /* [2.2.4] Testing chSysUnconditionalUnlock().*/
  test_set_step(4);
 8001762:	4b19      	ldr	r3, [pc, #100]	; (80017c8 <rt_test_002_002_execute.lto_priv.747+0xa8>)
 8001764:	2204      	movs	r2, #4
 8001766:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8001768:	f7ff fe62 	bl	8001430 <chSysLock.lto_priv.75>
    chSysUnconditionalUnlock();
 800176c:	f7ff fea8 	bl	80014c0 <chSysUnconditionalUnlock>
    chSysUnconditionalUnlock();
 8001770:	f7ff fea6 	bl	80014c0 <chSysUnconditionalUnlock>
  }

  /* [2.2.5] Testing from ISR context using a virtual timer.*/
  test_set_step(5);
 8001774:	4b14      	ldr	r3, [pc, #80]	; (80017c8 <rt_test_002_002_execute.lto_priv.747+0xa8>)
 8001776:	2205      	movs	r2, #5
 8001778:	601a      	str	r2, [r3, #0]
  {
    chVTObjectInit(&vt);
 800177a:	466b      	mov	r3, sp
 800177c:	4618      	mov	r0, r3
 800177e:	f7ff feaf 	bl	80014e0 <chVTObjectInit>
    chVTSet(&vt, 1, vtcb, NULL);
 8001782:	4668      	mov	r0, sp
 8001784:	2300      	movs	r3, #0
 8001786:	4a11      	ldr	r2, [pc, #68]	; (80017cc <rt_test_002_002_execute.lto_priv.747+0xac>)
 8001788:	2101      	movs	r1, #1
 800178a:	f7ff ff09 	bl	80015a0 <chVTSet>
    chThdSleep(10);
 800178e:	200a      	movs	r0, #10
 8001790:	f00f f83e 	bl	8010810 <chThdSleep>

    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 8001794:	466b      	mov	r3, sp
 8001796:	4618      	mov	r0, r3
 8001798:	f7ff fec2 	bl	8001520 <chVTIsArmed>
 800179c:	4603      	mov	r3, r0
 800179e:	2b00      	cmp	r3, #0
 80017a0:	bf14      	ite	ne
 80017a2:	2301      	movne	r3, #1
 80017a4:	2300      	moveq	r3, #0
 80017a6:	b2db      	uxtb	r3, r3
 80017a8:	f083 0301 	eor.w	r3, r3, #1
 80017ac:	b2db      	uxtb	r3, r3
 80017ae:	f003 0301 	and.w	r3, r3, #1
 80017b2:	b2db      	uxtb	r3, r3
 80017b4:	4906      	ldr	r1, [pc, #24]	; (80017d0 <rt_test_002_002_execute.lto_priv.747+0xb0>)
 80017b6:	4618      	mov	r0, r3
 80017b8:	f013 fe62 	bl	8015480 <_test_assert>
 80017bc:	4603      	mov	r3, r0
 80017be:	2b00      	cmp	r3, #0
  }
}
 80017c0:	b007      	add	sp, #28
 80017c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80017c6:	bf00      	nop
 80017c8:	20001988 	.word	0x20001988
 80017cc:	080015d1 	.word	0x080015d1
 80017d0:	08017e9c 	.word	0x08017e9c
	...

080017e0 <rt_test_002_003_execute.lto_priv.748>:
 * <h2>Test Steps</h2>
 * - [2.3.1] Testing chSysSuspend(), chSysDisable() and chSysEnable().
 * .
 */

static void rt_test_002_003_execute(void) {
 80017e0:	b508      	push	{r3, lr}

  /* [2.3.1] Testing chSysSuspend(), chSysDisable() and
     chSysEnable().*/
  test_set_step(1);
 80017e2:	4b06      	ldr	r3, [pc, #24]	; (80017fc <rt_test_002_003_execute.lto_priv.748+0x1c>)
 80017e4:	2201      	movs	r2, #1
 80017e6:	601a      	str	r2, [r3, #0]
  {
    chSysSuspend();
 80017e8:	f7ff fe12 	bl	8001410 <chSysSuspend>
    chSysDisable();
 80017ec:	f7ff fe08 	bl	8001400 <chSysDisable>
    chSysSuspend();
 80017f0:	f7ff fe0e 	bl	8001410 <chSysSuspend>
    chSysEnable();
 80017f4:	f7ff fe14 	bl	8001420 <chSysEnable>
  }
}
 80017f8:	bd08      	pop	{r3, pc}
 80017fa:	bf00      	nop
 80017fc:	20001988 	.word	0x20001988

08001800 <rt_test_002_004_execute.lto_priv.749>:
 * - [2.4.1] A System Tick Counter increment is expected, the test
 *   simply hangs if it does not happen.
 * .
 */

static void rt_test_002_004_execute(void) {
 8001800:	b500      	push	{lr}
 8001802:	b083      	sub	sp, #12

  /* [2.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 8001804:	4b07      	ldr	r3, [pc, #28]	; (8001824 <rt_test_002_004_execute.lto_priv.749+0x24>)
 8001806:	2201      	movs	r2, #1
 8001808:	601a      	str	r2, [r3, #0]
  {
    systime_t time = chVTGetSystemTimeX();
 800180a:	f7ff fe71 	bl	80014f0 <chVTGetSystemTimeX.lto_priv.106>
 800180e:	9001      	str	r0, [sp, #4]
    while (time == chVTGetSystemTimeX()) {
 8001810:	f7ff fe6e 	bl	80014f0 <chVTGetSystemTimeX.lto_priv.106>
 8001814:	4602      	mov	r2, r0
 8001816:	9b01      	ldr	r3, [sp, #4]
 8001818:	4293      	cmp	r3, r2
 800181a:	d0f9      	beq.n	8001810 <rt_test_002_004_execute.lto_priv.749+0x10>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
 800181c:	b003      	add	sp, #12
 800181e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001822:	bf00      	nop
 8001824:	20001988 	.word	0x20001988
	...

08001830 <chTimeAddX.lto_priv.120>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8001830:	b082      	sub	sp, #8
 8001832:	9001      	str	r0, [sp, #4]
 8001834:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)((systime_t)-1));
#endif

  return systime + (systime_t)interval;
 8001836:	9a01      	ldr	r2, [sp, #4]
 8001838:	9b00      	ldr	r3, [sp, #0]
 800183a:	4413      	add	r3, r2
}
 800183c:	4618      	mov	r0, r3
 800183e:	b002      	add	sp, #8
 8001840:	4770      	bx	lr
 8001842:	bf00      	nop
	...

08001850 <port_lock.lto_priv.20>:
static inline void port_lock(void) {
 8001850:	b082      	sub	sp, #8
 8001852:	2320      	movs	r3, #32
 8001854:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001856:	9b01      	ldr	r3, [sp, #4]
 8001858:	f383 8811 	msr	BASEPRI, r3
}
 800185c:	b002      	add	sp, #8
 800185e:	4770      	bx	lr

08001860 <port_unlock.lto_priv.10>:
static inline void port_unlock(void) {
 8001860:	b082      	sub	sp, #8
 8001862:	2300      	movs	r3, #0
 8001864:	9301      	str	r3, [sp, #4]
 8001866:	9b01      	ldr	r3, [sp, #4]
 8001868:	f383 8811 	msr	BASEPRI, r3
}
 800186c:	b002      	add	sp, #8
 800186e:	4770      	bx	lr

08001870 <st_lld_get_counter.lto_priv.117>:
  return (systime_t)STM32_ST_TIM->CNT;
 8001870:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001874:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8001876:	4618      	mov	r0, r3
 8001878:	4770      	bx	lr
 800187a:	bf00      	nop
 800187c:	0000      	movs	r0, r0
	...

08001880 <port_timer_get_time.lto_priv.112>:
static inline systime_t port_timer_get_time(void) {
 8001880:	b508      	push	{r3, lr}
  return stGetCounter();
 8001882:	f7ff fff5 	bl	8001870 <st_lld_get_counter.lto_priv.117>
 8001886:	4603      	mov	r3, r0
}
 8001888:	4618      	mov	r0, r3
 800188a:	bd08      	pop	{r3, pc}
 800188c:	0000      	movs	r0, r0
	...

08001890 <chSysLock.lto_priv.76>:
static inline void chSysLock(void) {
 8001890:	b508      	push	{r3, lr}
  port_lock();
 8001892:	f7ff ffdd 	bl	8001850 <port_lock.lto_priv.20>
  _dbg_check_lock();
 8001896:	f00d fd13 	bl	800f2c0 <_dbg_check_lock>
}
 800189a:	bd08      	pop	{r3, pc}
 800189c:	0000      	movs	r0, r0
	...

080018a0 <chSysUnlock.lto_priv.40>:
static inline void chSysUnlock(void) {
 80018a0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80018a2:	f00d fd25 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80018a6:	4b09      	ldr	r3, [pc, #36]	; (80018cc <chSysUnlock.lto_priv.40+0x2c>)
 80018a8:	681b      	ldr	r3, [r3, #0]
 80018aa:	4a08      	ldr	r2, [pc, #32]	; (80018cc <chSysUnlock.lto_priv.40+0x2c>)
 80018ac:	4293      	cmp	r3, r2
 80018ae:	d00a      	beq.n	80018c6 <chSysUnlock.lto_priv.40+0x26>
 80018b0:	4b06      	ldr	r3, [pc, #24]	; (80018cc <chSysUnlock.lto_priv.40+0x2c>)
 80018b2:	699b      	ldr	r3, [r3, #24]
 80018b4:	689a      	ldr	r2, [r3, #8]
 80018b6:	4b05      	ldr	r3, [pc, #20]	; (80018cc <chSysUnlock.lto_priv.40+0x2c>)
 80018b8:	681b      	ldr	r3, [r3, #0]
 80018ba:	689b      	ldr	r3, [r3, #8]
 80018bc:	429a      	cmp	r2, r3
 80018be:	d202      	bcs.n	80018c6 <chSysUnlock.lto_priv.40+0x26>
 80018c0:	4803      	ldr	r0, [pc, #12]	; (80018d0 <chSysUnlock.lto_priv.40+0x30>)
 80018c2:	f00d fb8d 	bl	800efe0 <chSysHalt>
  port_unlock();
 80018c6:	f7ff ffcb 	bl	8001860 <port_unlock.lto_priv.10>
}
 80018ca:	bd08      	pop	{r3, pc}
 80018cc:	20001090 	.word	0x20001090
 80018d0:	08018028 	.word	0x08018028
	...

080018e0 <chVTGetSystemTimeX.lto_priv.107>:
static inline systime_t chVTGetSystemTimeX(void) {
 80018e0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 80018e2:	f7ff ffcd 	bl	8001880 <port_timer_get_time.lto_priv.112>
 80018e6:	4603      	mov	r3, r0
}
 80018e8:	4618      	mov	r0, r3
 80018ea:	bd08      	pop	{r3, pc}
 80018ec:	0000      	movs	r0, r0
	...

080018f0 <chThdGetSelfX.lto_priv.97>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80018f0:	4b01      	ldr	r3, [pc, #4]	; (80018f8 <chThdGetSelfX.lto_priv.97+0x8>)
 80018f2:	699b      	ldr	r3, [r3, #24]
}
 80018f4:	4618      	mov	r0, r3
 80018f6:	4770      	bx	lr
 80018f8:	20001090 	.word	0x20001090
 80018fc:	00000000 	.word	0x00000000

08001900 <chThdGetPriorityX.lto_priv.89>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8001900:	b508      	push	{r3, lr}

  return chThdGetSelfX()->prio;
 8001902:	f7ff fff5 	bl	80018f0 <chThdGetSelfX.lto_priv.97>
 8001906:	4603      	mov	r3, r0
 8001908:	689b      	ldr	r3, [r3, #8]
}
 800190a:	4618      	mov	r0, r3
 800190c:	bd08      	pop	{r3, pc}
 800190e:	bf00      	nop

08001910 <thread>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {
 8001910:	b500      	push	{lr}
 8001912:	b083      	sub	sp, #12
 8001914:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 8001916:	9b01      	ldr	r3, [sp, #4]
 8001918:	781b      	ldrb	r3, [r3, #0]
 800191a:	4618      	mov	r0, r3
 800191c:	f013 fe90 	bl	8015640 <test_emit_token>
}
 8001920:	b003      	add	sp, #12
 8001922:	f85d fb04 	ldr.w	pc, [sp], #4
 8001926:	bf00      	nop
	...

08001930 <rt_test_003_001_execute.lto_priv.750>:
 * - [3.1.5] Function chThdSleepUntil() is tested with a timeline of
 *   "now" + 100 ticks.
 * .
 */

static void rt_test_003_001_execute(void) {
 8001930:	b510      	push	{r4, lr}
 8001932:	b082      	sub	sp, #8
  systime_t time;

  /* [3.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
 8001934:	4b49      	ldr	r3, [pc, #292]	; (8001a5c <rt_test_003_001_execute.lto_priv.750+0x12c>)
 8001936:	2201      	movs	r2, #1
 8001938:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
 800193a:	f7ff ffd1 	bl	80018e0 <chVTGetSystemTimeX.lto_priv.107>
 800193e:	9001      	str	r0, [sp, #4]
    chThdSleep(100);
 8001940:	2064      	movs	r0, #100	; 0x64
 8001942:	f00e ff65 	bl	8010810 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, 100),
 8001946:	2164      	movs	r1, #100	; 0x64
 8001948:	9801      	ldr	r0, [sp, #4]
 800194a:	f7ff ff71 	bl	8001830 <chTimeAddX.lto_priv.120>
 800194e:	4604      	mov	r4, r0
 8001950:	2167      	movs	r1, #103	; 0x67
 8001952:	9801      	ldr	r0, [sp, #4]
 8001954:	f7ff ff6c 	bl	8001830 <chTimeAddX.lto_priv.120>
 8001958:	4603      	mov	r3, r0
 800195a:	4a41      	ldr	r2, [pc, #260]	; (8001a60 <rt_test_003_001_execute.lto_priv.750+0x130>)
 800195c:	4619      	mov	r1, r3
 800195e:	4620      	mov	r0, r4
 8001960:	f013 fdd6 	bl	8015510 <_test_assert_time_window>
 8001964:	4603      	mov	r3, r0
 8001966:	2b00      	cmp	r3, #0
 8001968:	d176      	bne.n	8001a58 <rt_test_003_001_execute.lto_priv.750+0x128>
  }

  /* [3.1.2] The current system time is read then a sleep is performed
     for 100000 microseconds and on exit the system time is verified
     again.*/
  test_set_step(2);
 800196a:	4b3c      	ldr	r3, [pc, #240]	; (8001a5c <rt_test_003_001_execute.lto_priv.750+0x12c>)
 800196c:	2202      	movs	r2, #2
 800196e:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
 8001970:	f7ff ffb6 	bl	80018e0 <chVTGetSystemTimeX.lto_priv.107>
 8001974:	9001      	str	r0, [sp, #4]
    chThdSleepMicroseconds(100000);
 8001976:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800197a:	f00e ff49 	bl	8010810 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_US2I(100000)),
 800197e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8001982:	9801      	ldr	r0, [sp, #4]
 8001984:	f7ff ff54 	bl	8001830 <chTimeAddX.lto_priv.120>
 8001988:	4604      	mov	r4, r0
 800198a:	f240 31eb 	movw	r1, #1003	; 0x3eb
 800198e:	9801      	ldr	r0, [sp, #4]
 8001990:	f7ff ff4e 	bl	8001830 <chTimeAddX.lto_priv.120>
 8001994:	4603      	mov	r3, r0
 8001996:	4a32      	ldr	r2, [pc, #200]	; (8001a60 <rt_test_003_001_execute.lto_priv.750+0x130>)
 8001998:	4619      	mov	r1, r3
 800199a:	4620      	mov	r0, r4
 800199c:	f013 fdb8 	bl	8015510 <_test_assert_time_window>
 80019a0:	4603      	mov	r3, r0
 80019a2:	2b00      	cmp	r3, #0
 80019a4:	d158      	bne.n	8001a58 <rt_test_003_001_execute.lto_priv.750+0x128>
  }

  /* [3.1.3] The current system time is read then a sleep is performed
     for 100 milliseconds and on exit the system time is verified
     again.*/
  test_set_step(3);
 80019a6:	4b2d      	ldr	r3, [pc, #180]	; (8001a5c <rt_test_003_001_execute.lto_priv.750+0x12c>)
 80019a8:	2203      	movs	r2, #3
 80019aa:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
 80019ac:	f7ff ff98 	bl	80018e0 <chVTGetSystemTimeX.lto_priv.107>
 80019b0:	9001      	str	r0, [sp, #4]
    chThdSleepMilliseconds(100);
 80019b2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80019b6:	f00e ff2b 	bl	8010810 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(100)),
 80019ba:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80019be:	9801      	ldr	r0, [sp, #4]
 80019c0:	f7ff ff36 	bl	8001830 <chTimeAddX.lto_priv.120>
 80019c4:	4604      	mov	r4, r0
 80019c6:	f240 31eb 	movw	r1, #1003	; 0x3eb
 80019ca:	9801      	ldr	r0, [sp, #4]
 80019cc:	f7ff ff30 	bl	8001830 <chTimeAddX.lto_priv.120>
 80019d0:	4603      	mov	r3, r0
 80019d2:	4a23      	ldr	r2, [pc, #140]	; (8001a60 <rt_test_003_001_execute.lto_priv.750+0x130>)
 80019d4:	4619      	mov	r1, r3
 80019d6:	4620      	mov	r0, r4
 80019d8:	f013 fd9a 	bl	8015510 <_test_assert_time_window>
 80019dc:	4603      	mov	r3, r0
 80019de:	2b00      	cmp	r3, #0
 80019e0:	d13a      	bne.n	8001a58 <rt_test_003_001_execute.lto_priv.750+0x128>
                            "out of time window");
  }

  /* [3.1.4] The current system time is read then a sleep is performed
     for 1 second and on exit the system time is verified again.*/
  test_set_step(4);
 80019e2:	4b1e      	ldr	r3, [pc, #120]	; (8001a5c <rt_test_003_001_execute.lto_priv.750+0x12c>)
 80019e4:	2204      	movs	r2, #4
 80019e6:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
 80019e8:	f7ff ff7a 	bl	80018e0 <chVTGetSystemTimeX.lto_priv.107>
 80019ec:	9001      	str	r0, [sp, #4]
    chThdSleepSeconds(1);
 80019ee:	f242 7010 	movw	r0, #10000	; 0x2710
 80019f2:	f00e ff0d 	bl	8010810 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_S2I(1)),
 80019f6:	f242 7110 	movw	r1, #10000	; 0x2710
 80019fa:	9801      	ldr	r0, [sp, #4]
 80019fc:	f7ff ff18 	bl	8001830 <chTimeAddX.lto_priv.120>
 8001a00:	4604      	mov	r4, r0
 8001a02:	f242 7113 	movw	r1, #10003	; 0x2713
 8001a06:	9801      	ldr	r0, [sp, #4]
 8001a08:	f7ff ff12 	bl	8001830 <chTimeAddX.lto_priv.120>
 8001a0c:	4603      	mov	r3, r0
 8001a0e:	4a14      	ldr	r2, [pc, #80]	; (8001a60 <rt_test_003_001_execute.lto_priv.750+0x130>)
 8001a10:	4619      	mov	r1, r3
 8001a12:	4620      	mov	r0, r4
 8001a14:	f013 fd7c 	bl	8015510 <_test_assert_time_window>
 8001a18:	4603      	mov	r3, r0
 8001a1a:	2b00      	cmp	r3, #0
 8001a1c:	d11c      	bne.n	8001a58 <rt_test_003_001_execute.lto_priv.750+0x128>
                            "out of time window");
  }

  /* [3.1.5] Function chThdSleepUntil() is tested with a timeline of
     "now" + 100 ticks.*/
  test_set_step(5);
 8001a1e:	4b0f      	ldr	r3, [pc, #60]	; (8001a5c <rt_test_003_001_execute.lto_priv.750+0x12c>)
 8001a20:	2205      	movs	r2, #5
 8001a22:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
 8001a24:	f7ff ff5c 	bl	80018e0 <chVTGetSystemTimeX.lto_priv.107>
 8001a28:	9001      	str	r0, [sp, #4]
    chThdSleepUntil(chTimeAddX(time, 100));
 8001a2a:	2164      	movs	r1, #100	; 0x64
 8001a2c:	9801      	ldr	r0, [sp, #4]
 8001a2e:	f7ff feff 	bl	8001830 <chTimeAddX.lto_priv.120>
 8001a32:	4603      	mov	r3, r0
 8001a34:	4618      	mov	r0, r3
 8001a36:	f00e fefb 	bl	8010830 <chThdSleepUntil>
    test_assert_time_window(chTimeAddX(time, 100),
 8001a3a:	2164      	movs	r1, #100	; 0x64
 8001a3c:	9801      	ldr	r0, [sp, #4]
 8001a3e:	f7ff fef7 	bl	8001830 <chTimeAddX.lto_priv.120>
 8001a42:	4604      	mov	r4, r0
 8001a44:	2167      	movs	r1, #103	; 0x67
 8001a46:	9801      	ldr	r0, [sp, #4]
 8001a48:	f7ff fef2 	bl	8001830 <chTimeAddX.lto_priv.120>
 8001a4c:	4603      	mov	r3, r0
 8001a4e:	4a04      	ldr	r2, [pc, #16]	; (8001a60 <rt_test_003_001_execute.lto_priv.750+0x130>)
 8001a50:	4619      	mov	r1, r3
 8001a52:	4620      	mov	r0, r4
 8001a54:	f013 fd5c 	bl	8015510 <_test_assert_time_window>
                            chTimeAddX(time, 100 + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
  }
}
 8001a58:	b002      	add	sp, #8
 8001a5a:	bd10      	pop	{r4, pc}
 8001a5c:	20001988 	.word	0x20001988
 8001a60:	08017f08 	.word	0x08017f08
	...

08001a70 <rt_test_003_002_execute.lto_priv.751>:
 * - [3.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void rt_test_003_002_execute(void) {
 8001a70:	b510      	push	{r4, lr}
 8001a72:	b082      	sub	sp, #8

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 8001a74:	4b91      	ldr	r3, [pc, #580]	; (8001cbc <rt_test_003_002_execute.lto_priv.751+0x24c>)
 8001a76:	2201      	movs	r2, #1
 8001a78:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8001a7a:	4b91      	ldr	r3, [pc, #580]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001a7c:	681c      	ldr	r4, [r3, #0]
 8001a7e:	f7ff ff3f 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001a82:	4603      	mov	r3, r0
 8001a84:	1f5a      	subs	r2, r3, #5
 8001a86:	4b8f      	ldr	r3, [pc, #572]	; (8001cc4 <rt_test_003_002_execute.lto_priv.751+0x254>)
 8001a88:	9300      	str	r3, [sp, #0]
 8001a8a:	4b8f      	ldr	r3, [pc, #572]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001a8c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001a90:	4620      	mov	r0, r4
 8001a92:	f00e fd25 	bl	80104e0 <chThdCreateStatic>
 8001a96:	4602      	mov	r2, r0
 8001a98:	4b8c      	ldr	r3, [pc, #560]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001a9a:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8001a9c:	4b88      	ldr	r3, [pc, #544]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001a9e:	685c      	ldr	r4, [r3, #4]
 8001aa0:	f7ff ff2e 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001aa4:	4603      	mov	r3, r0
 8001aa6:	1f1a      	subs	r2, r3, #4
 8001aa8:	4b89      	ldr	r3, [pc, #548]	; (8001cd0 <rt_test_003_002_execute.lto_priv.751+0x260>)
 8001aaa:	9300      	str	r3, [sp, #0]
 8001aac:	4b86      	ldr	r3, [pc, #536]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001aae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001ab2:	4620      	mov	r0, r4
 8001ab4:	f00e fd14 	bl	80104e0 <chThdCreateStatic>
 8001ab8:	4602      	mov	r2, r0
 8001aba:	4b84      	ldr	r3, [pc, #528]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001abc:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8001abe:	4b80      	ldr	r3, [pc, #512]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001ac0:	689c      	ldr	r4, [r3, #8]
 8001ac2:	f7ff ff1d 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001ac6:	4603      	mov	r3, r0
 8001ac8:	1eda      	subs	r2, r3, #3
 8001aca:	4b82      	ldr	r3, [pc, #520]	; (8001cd4 <rt_test_003_002_execute.lto_priv.751+0x264>)
 8001acc:	9300      	str	r3, [sp, #0]
 8001ace:	4b7e      	ldr	r3, [pc, #504]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001ad0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001ad4:	4620      	mov	r0, r4
 8001ad6:	f00e fd03 	bl	80104e0 <chThdCreateStatic>
 8001ada:	4602      	mov	r2, r0
 8001adc:	4b7b      	ldr	r3, [pc, #492]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001ade:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8001ae0:	4b77      	ldr	r3, [pc, #476]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001ae2:	68dc      	ldr	r4, [r3, #12]
 8001ae4:	f7ff ff0c 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001ae8:	4603      	mov	r3, r0
 8001aea:	1e9a      	subs	r2, r3, #2
 8001aec:	4b7a      	ldr	r3, [pc, #488]	; (8001cd8 <rt_test_003_002_execute.lto_priv.751+0x268>)
 8001aee:	9300      	str	r3, [sp, #0]
 8001af0:	4b75      	ldr	r3, [pc, #468]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001af2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001af6:	4620      	mov	r0, r4
 8001af8:	f00e fcf2 	bl	80104e0 <chThdCreateStatic>
 8001afc:	4602      	mov	r2, r0
 8001afe:	4b73      	ldr	r3, [pc, #460]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001b00:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8001b02:	4b6f      	ldr	r3, [pc, #444]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001b04:	691c      	ldr	r4, [r3, #16]
 8001b06:	f7ff fefb 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001b0a:	4603      	mov	r3, r0
 8001b0c:	1e5a      	subs	r2, r3, #1
 8001b0e:	4b73      	ldr	r3, [pc, #460]	; (8001cdc <rt_test_003_002_execute.lto_priv.751+0x26c>)
 8001b10:	9300      	str	r3, [sp, #0]
 8001b12:	4b6d      	ldr	r3, [pc, #436]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001b14:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001b18:	4620      	mov	r0, r4
 8001b1a:	f00e fce1 	bl	80104e0 <chThdCreateStatic>
 8001b1e:	4602      	mov	r2, r0
 8001b20:	4b6a      	ldr	r3, [pc, #424]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001b22:	611a      	str	r2, [r3, #16]
    test_wait_threads();
 8001b24:	f7ff f92c 	bl	8000d80 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8001b28:	496d      	ldr	r1, [pc, #436]	; (8001ce0 <rt_test_003_002_execute.lto_priv.751+0x270>)
 8001b2a:	486e      	ldr	r0, [pc, #440]	; (8001ce4 <rt_test_003_002_execute.lto_priv.751+0x274>)
 8001b2c:	f013 fcc0 	bl	80154b0 <_test_assert_sequence>
 8001b30:	4603      	mov	r3, r0
 8001b32:	2b00      	cmp	r3, #0
 8001b34:	f040 80bf 	bne.w	8001cb6 <rt_test_003_002_execute.lto_priv.751+0x246>
  }

  /* [3.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
 8001b38:	4b60      	ldr	r3, [pc, #384]	; (8001cbc <rt_test_003_002_execute.lto_priv.751+0x24c>)
 8001b3a:	2202      	movs	r2, #2
 8001b3c:	601a      	str	r2, [r3, #0]
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8001b3e:	4b60      	ldr	r3, [pc, #384]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001b40:	691c      	ldr	r4, [r3, #16]
 8001b42:	f7ff fedd 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001b46:	4603      	mov	r3, r0
 8001b48:	1e5a      	subs	r2, r3, #1
 8001b4a:	4b64      	ldr	r3, [pc, #400]	; (8001cdc <rt_test_003_002_execute.lto_priv.751+0x26c>)
 8001b4c:	9300      	str	r3, [sp, #0]
 8001b4e:	4b5e      	ldr	r3, [pc, #376]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001b50:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001b54:	4620      	mov	r0, r4
 8001b56:	f00e fcc3 	bl	80104e0 <chThdCreateStatic>
 8001b5a:	4602      	mov	r2, r0
 8001b5c:	4b5b      	ldr	r3, [pc, #364]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001b5e:	611a      	str	r2, [r3, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8001b60:	4b57      	ldr	r3, [pc, #348]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001b62:	68dc      	ldr	r4, [r3, #12]
 8001b64:	f7ff fecc 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001b68:	4603      	mov	r3, r0
 8001b6a:	1e9a      	subs	r2, r3, #2
 8001b6c:	4b5a      	ldr	r3, [pc, #360]	; (8001cd8 <rt_test_003_002_execute.lto_priv.751+0x268>)
 8001b6e:	9300      	str	r3, [sp, #0]
 8001b70:	4b55      	ldr	r3, [pc, #340]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001b72:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001b76:	4620      	mov	r0, r4
 8001b78:	f00e fcb2 	bl	80104e0 <chThdCreateStatic>
 8001b7c:	4602      	mov	r2, r0
 8001b7e:	4b53      	ldr	r3, [pc, #332]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001b80:	60da      	str	r2, [r3, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8001b82:	4b4f      	ldr	r3, [pc, #316]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001b84:	689c      	ldr	r4, [r3, #8]
 8001b86:	f7ff febb 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001b8a:	4603      	mov	r3, r0
 8001b8c:	1eda      	subs	r2, r3, #3
 8001b8e:	4b51      	ldr	r3, [pc, #324]	; (8001cd4 <rt_test_003_002_execute.lto_priv.751+0x264>)
 8001b90:	9300      	str	r3, [sp, #0]
 8001b92:	4b4d      	ldr	r3, [pc, #308]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001b94:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001b98:	4620      	mov	r0, r4
 8001b9a:	f00e fca1 	bl	80104e0 <chThdCreateStatic>
 8001b9e:	4602      	mov	r2, r0
 8001ba0:	4b4a      	ldr	r3, [pc, #296]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001ba2:	609a      	str	r2, [r3, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8001ba4:	4b46      	ldr	r3, [pc, #280]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001ba6:	685c      	ldr	r4, [r3, #4]
 8001ba8:	f7ff feaa 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001bac:	4603      	mov	r3, r0
 8001bae:	1f1a      	subs	r2, r3, #4
 8001bb0:	4b47      	ldr	r3, [pc, #284]	; (8001cd0 <rt_test_003_002_execute.lto_priv.751+0x260>)
 8001bb2:	9300      	str	r3, [sp, #0]
 8001bb4:	4b44      	ldr	r3, [pc, #272]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001bb6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001bba:	4620      	mov	r0, r4
 8001bbc:	f00e fc90 	bl	80104e0 <chThdCreateStatic>
 8001bc0:	4602      	mov	r2, r0
 8001bc2:	4b42      	ldr	r3, [pc, #264]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001bc4:	605a      	str	r2, [r3, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8001bc6:	4b3e      	ldr	r3, [pc, #248]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001bc8:	681c      	ldr	r4, [r3, #0]
 8001bca:	f7ff fe99 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001bce:	4603      	mov	r3, r0
 8001bd0:	1f5a      	subs	r2, r3, #5
 8001bd2:	4b3c      	ldr	r3, [pc, #240]	; (8001cc4 <rt_test_003_002_execute.lto_priv.751+0x254>)
 8001bd4:	9300      	str	r3, [sp, #0]
 8001bd6:	4b3c      	ldr	r3, [pc, #240]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001bd8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001bdc:	4620      	mov	r0, r4
 8001bde:	f00e fc7f 	bl	80104e0 <chThdCreateStatic>
 8001be2:	4602      	mov	r2, r0
 8001be4:	4b39      	ldr	r3, [pc, #228]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001be6:	601a      	str	r2, [r3, #0]
    test_wait_threads();
 8001be8:	f7ff f8ca 	bl	8000d80 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8001bec:	493c      	ldr	r1, [pc, #240]	; (8001ce0 <rt_test_003_002_execute.lto_priv.751+0x270>)
 8001bee:	483d      	ldr	r0, [pc, #244]	; (8001ce4 <rt_test_003_002_execute.lto_priv.751+0x274>)
 8001bf0:	f013 fc5e 	bl	80154b0 <_test_assert_sequence>
 8001bf4:	4603      	mov	r3, r0
 8001bf6:	2b00      	cmp	r3, #0
 8001bf8:	d15d      	bne.n	8001cb6 <rt_test_003_002_execute.lto_priv.751+0x246>
  }

  /* [3.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
 8001bfa:	4b30      	ldr	r3, [pc, #192]	; (8001cbc <rt_test_003_002_execute.lto_priv.751+0x24c>)
 8001bfc:	2203      	movs	r2, #3
 8001bfe:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8001c00:	4b2f      	ldr	r3, [pc, #188]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001c02:	685c      	ldr	r4, [r3, #4]
 8001c04:	f7ff fe7c 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001c08:	4603      	mov	r3, r0
 8001c0a:	1f1a      	subs	r2, r3, #4
 8001c0c:	4b30      	ldr	r3, [pc, #192]	; (8001cd0 <rt_test_003_002_execute.lto_priv.751+0x260>)
 8001c0e:	9300      	str	r3, [sp, #0]
 8001c10:	4b2d      	ldr	r3, [pc, #180]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001c12:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001c16:	4620      	mov	r0, r4
 8001c18:	f00e fc62 	bl	80104e0 <chThdCreateStatic>
 8001c1c:	4602      	mov	r2, r0
 8001c1e:	4b2b      	ldr	r3, [pc, #172]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001c20:	605a      	str	r2, [r3, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8001c22:	4b27      	ldr	r3, [pc, #156]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001c24:	681c      	ldr	r4, [r3, #0]
 8001c26:	f7ff fe6b 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001c2a:	4603      	mov	r3, r0
 8001c2c:	1f5a      	subs	r2, r3, #5
 8001c2e:	4b25      	ldr	r3, [pc, #148]	; (8001cc4 <rt_test_003_002_execute.lto_priv.751+0x254>)
 8001c30:	9300      	str	r3, [sp, #0]
 8001c32:	4b25      	ldr	r3, [pc, #148]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001c34:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001c38:	4620      	mov	r0, r4
 8001c3a:	f00e fc51 	bl	80104e0 <chThdCreateStatic>
 8001c3e:	4602      	mov	r2, r0
 8001c40:	4b22      	ldr	r3, [pc, #136]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001c42:	601a      	str	r2, [r3, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8001c44:	4b1e      	ldr	r3, [pc, #120]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001c46:	691c      	ldr	r4, [r3, #16]
 8001c48:	f7ff fe5a 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001c4c:	4603      	mov	r3, r0
 8001c4e:	1e5a      	subs	r2, r3, #1
 8001c50:	4b22      	ldr	r3, [pc, #136]	; (8001cdc <rt_test_003_002_execute.lto_priv.751+0x26c>)
 8001c52:	9300      	str	r3, [sp, #0]
 8001c54:	4b1c      	ldr	r3, [pc, #112]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001c56:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001c5a:	4620      	mov	r0, r4
 8001c5c:	f00e fc40 	bl	80104e0 <chThdCreateStatic>
 8001c60:	4602      	mov	r2, r0
 8001c62:	4b1a      	ldr	r3, [pc, #104]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001c64:	611a      	str	r2, [r3, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8001c66:	4b16      	ldr	r3, [pc, #88]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001c68:	68dc      	ldr	r4, [r3, #12]
 8001c6a:	f7ff fe49 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001c6e:	4603      	mov	r3, r0
 8001c70:	1e9a      	subs	r2, r3, #2
 8001c72:	4b19      	ldr	r3, [pc, #100]	; (8001cd8 <rt_test_003_002_execute.lto_priv.751+0x268>)
 8001c74:	9300      	str	r3, [sp, #0]
 8001c76:	4b14      	ldr	r3, [pc, #80]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001c78:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001c7c:	4620      	mov	r0, r4
 8001c7e:	f00e fc2f 	bl	80104e0 <chThdCreateStatic>
 8001c82:	4602      	mov	r2, r0
 8001c84:	4b11      	ldr	r3, [pc, #68]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001c86:	60da      	str	r2, [r3, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8001c88:	4b0d      	ldr	r3, [pc, #52]	; (8001cc0 <rt_test_003_002_execute.lto_priv.751+0x250>)
 8001c8a:	689c      	ldr	r4, [r3, #8]
 8001c8c:	f7ff fe38 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001c90:	4603      	mov	r3, r0
 8001c92:	1eda      	subs	r2, r3, #3
 8001c94:	4b0f      	ldr	r3, [pc, #60]	; (8001cd4 <rt_test_003_002_execute.lto_priv.751+0x264>)
 8001c96:	9300      	str	r3, [sp, #0]
 8001c98:	4b0b      	ldr	r3, [pc, #44]	; (8001cc8 <rt_test_003_002_execute.lto_priv.751+0x258>)
 8001c9a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001c9e:	4620      	mov	r0, r4
 8001ca0:	f00e fc1e 	bl	80104e0 <chThdCreateStatic>
 8001ca4:	4602      	mov	r2, r0
 8001ca6:	4b09      	ldr	r3, [pc, #36]	; (8001ccc <rt_test_003_002_execute.lto_priv.751+0x25c>)
 8001ca8:	609a      	str	r2, [r3, #8]
    test_wait_threads();
 8001caa:	f7ff f869 	bl	8000d80 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8001cae:	490c      	ldr	r1, [pc, #48]	; (8001ce0 <rt_test_003_002_execute.lto_priv.751+0x270>)
 8001cb0:	480c      	ldr	r0, [pc, #48]	; (8001ce4 <rt_test_003_002_execute.lto_priv.751+0x274>)
 8001cb2:	f013 fbfd 	bl	80154b0 <_test_assert_sequence>
  }
}
 8001cb6:	b002      	add	sp, #8
 8001cb8:	bd10      	pop	{r4, pc}
 8001cba:	bf00      	nop
 8001cbc:	20001988 	.word	0x20001988
 8001cc0:	08017360 	.word	0x08017360
 8001cc4:	08017f50 	.word	0x08017f50
 8001cc8:	08001911 	.word	0x08001911
 8001ccc:	20002018 	.word	0x20002018
 8001cd0:	0801622c 	.word	0x0801622c
 8001cd4:	08017f2c 	.word	0x08017f2c
 8001cd8:	08017f30 	.word	0x08017f30
 8001cdc:	08017f34 	.word	0x08017f34
 8001ce0:	08017f38 	.word	0x08017f38
 8001ce4:	08017f4c 	.word	0x08017f4c
	...

08001cf0 <rt_test_003_003_execute.lto_priv.752>:
 * - [3.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void rt_test_003_003_execute(void) {
 8001cf0:	b500      	push	{lr}
 8001cf2:	b083      	sub	sp, #12
  tprio_t prio, p1;

  /* [3.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8001cf4:	4b28      	ldr	r3, [pc, #160]	; (8001d98 <rt_test_003_003_execute.lto_priv.752+0xa8>)
 8001cf6:	2201      	movs	r2, #1
 8001cf8:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 8001cfa:	f7ff fe01 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001cfe:	9001      	str	r0, [sp, #4]
    p1 = chThdSetPriority(prio + 1);
 8001d00:	9b01      	ldr	r3, [sp, #4]
 8001d02:	3301      	adds	r3, #1
 8001d04:	4618      	mov	r0, r3
 8001d06:	f00e fd33 	bl	8010770 <chThdSetPriority>
 8001d0a:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio, "unexpected returned priority level");
 8001d0c:	9a00      	ldr	r2, [sp, #0]
 8001d0e:	9b01      	ldr	r3, [sp, #4]
 8001d10:	429a      	cmp	r2, r3
 8001d12:	bf0c      	ite	eq
 8001d14:	2301      	moveq	r3, #1
 8001d16:	2300      	movne	r3, #0
 8001d18:	b2db      	uxtb	r3, r3
 8001d1a:	4920      	ldr	r1, [pc, #128]	; (8001d9c <rt_test_003_003_execute.lto_priv.752+0xac>)
 8001d1c:	4618      	mov	r0, r3
 8001d1e:	f013 fbaf 	bl	8015480 <_test_assert>
 8001d22:	4603      	mov	r3, r0
 8001d24:	2b00      	cmp	r3, #0
 8001d26:	d133      	bne.n	8001d90 <rt_test_003_003_execute.lto_priv.752+0xa0>
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 8001d28:	f7ff fdea 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001d2c:	4602      	mov	r2, r0
 8001d2e:	9b01      	ldr	r3, [sp, #4]
 8001d30:	3301      	adds	r3, #1
 8001d32:	429a      	cmp	r2, r3
 8001d34:	bf0c      	ite	eq
 8001d36:	2301      	moveq	r3, #1
 8001d38:	2300      	movne	r3, #0
 8001d3a:	b2db      	uxtb	r3, r3
 8001d3c:	4918      	ldr	r1, [pc, #96]	; (8001da0 <rt_test_003_003_execute.lto_priv.752+0xb0>)
 8001d3e:	4618      	mov	r0, r3
 8001d40:	f013 fb9e 	bl	8015480 <_test_assert>
 8001d44:	4603      	mov	r3, r0
 8001d46:	2b00      	cmp	r3, #0
 8001d48:	d122      	bne.n	8001d90 <rt_test_003_003_execute.lto_priv.752+0xa0>
  }

  /* [3.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8001d4a:	4b13      	ldr	r3, [pc, #76]	; (8001d98 <rt_test_003_003_execute.lto_priv.752+0xa8>)
 8001d4c:	2202      	movs	r2, #2
 8001d4e:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(p1);
 8001d50:	9800      	ldr	r0, [sp, #0]
 8001d52:	f00e fd0d 	bl	8010770 <chThdSetPriority>
 8001d56:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8001d58:	9b01      	ldr	r3, [sp, #4]
 8001d5a:	3301      	adds	r3, #1
 8001d5c:	9a00      	ldr	r2, [sp, #0]
 8001d5e:	429a      	cmp	r2, r3
 8001d60:	bf0c      	ite	eq
 8001d62:	2301      	moveq	r3, #1
 8001d64:	2300      	movne	r3, #0
 8001d66:	b2db      	uxtb	r3, r3
 8001d68:	490c      	ldr	r1, [pc, #48]	; (8001d9c <rt_test_003_003_execute.lto_priv.752+0xac>)
 8001d6a:	4618      	mov	r0, r3
 8001d6c:	f013 fb88 	bl	8015480 <_test_assert>
 8001d70:	4603      	mov	r3, r0
 8001d72:	2b00      	cmp	r3, #0
 8001d74:	d10c      	bne.n	8001d90 <rt_test_003_003_execute.lto_priv.752+0xa0>
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8001d76:	f7ff fdc3 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001d7a:	4602      	mov	r2, r0
 8001d7c:	9b01      	ldr	r3, [sp, #4]
 8001d7e:	4293      	cmp	r3, r2
 8001d80:	bf0c      	ite	eq
 8001d82:	2301      	moveq	r3, #1
 8001d84:	2300      	movne	r3, #0
 8001d86:	b2db      	uxtb	r3, r3
 8001d88:	4905      	ldr	r1, [pc, #20]	; (8001da0 <rt_test_003_003_execute.lto_priv.752+0xb0>)
 8001d8a:	4618      	mov	r0, r3
 8001d8c:	f013 fb78 	bl	8015480 <_test_assert>
  }
}
 8001d90:	b003      	add	sp, #12
 8001d92:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d96:	bf00      	nop
 8001d98:	20001988 	.word	0x20001988
 8001d9c:	08017f64 	.word	0x08017f64
 8001da0:	08017f88 	.word	0x08017f88
	...

08001db0 <rt_test_003_004_execute.lto_priv.753>:
 * - [3.4.3] Raising thread priority above the boosted level.
 * - [3.4.4] Restoring original conditions.
 * .
 */

static void rt_test_003_004_execute(void) {
 8001db0:	b500      	push	{lr}
 8001db2:	b083      	sub	sp, #12
  tprio_t prio, p1;

  /* [3.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
 8001db4:	4b54      	ldr	r3, [pc, #336]	; (8001f08 <rt_test_003_004_execute.lto_priv.753+0x158>)
 8001db6:	2201      	movs	r2, #1
 8001db8:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 8001dba:	f7ff fda1 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001dbe:	9001      	str	r0, [sp, #4]
    chThdGetSelfX()->prio += 2;
 8001dc0:	f7ff fd96 	bl	80018f0 <chThdGetSelfX.lto_priv.97>
 8001dc4:	4603      	mov	r3, r0
 8001dc6:	689a      	ldr	r2, [r3, #8]
 8001dc8:	3202      	adds	r2, #2
 8001dca:	609a      	str	r2, [r3, #8]
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
 8001dcc:	f7ff fd98 	bl	8001900 <chThdGetPriorityX.lto_priv.89>
 8001dd0:	4602      	mov	r2, r0
 8001dd2:	9b01      	ldr	r3, [sp, #4]
 8001dd4:	3302      	adds	r3, #2
 8001dd6:	429a      	cmp	r2, r3
 8001dd8:	bf0c      	ite	eq
 8001dda:	2301      	moveq	r3, #1
 8001ddc:	2300      	movne	r3, #0
 8001dde:	b2db      	uxtb	r3, r3
 8001de0:	494a      	ldr	r1, [pc, #296]	; (8001f0c <rt_test_003_004_execute.lto_priv.753+0x15c>)
 8001de2:	4618      	mov	r0, r3
 8001de4:	f013 fb4c 	bl	8015480 <_test_assert>
 8001de8:	4603      	mov	r3, r0
 8001dea:	2b00      	cmp	r3, #0
 8001dec:	f040 8088 	bne.w	8001f00 <rt_test_003_004_execute.lto_priv.753+0x150>
  }

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8001df0:	4b45      	ldr	r3, [pc, #276]	; (8001f08 <rt_test_003_004_execute.lto_priv.753+0x158>)
 8001df2:	2202      	movs	r2, #2
 8001df4:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(prio + 1);
 8001df6:	9b01      	ldr	r3, [sp, #4]
 8001df8:	3301      	adds	r3, #1
 8001dfa:	4618      	mov	r0, r3
 8001dfc:	f00e fcb8 	bl	8010770 <chThdSetPriority>
 8001e00:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio, "unexpected returned priority level");
 8001e02:	9a00      	ldr	r2, [sp, #0]
 8001e04:	9b01      	ldr	r3, [sp, #4]
 8001e06:	429a      	cmp	r2, r3
 8001e08:	bf0c      	ite	eq
 8001e0a:	2301      	moveq	r3, #1
 8001e0c:	2300      	movne	r3, #0
 8001e0e:	b2db      	uxtb	r3, r3
 8001e10:	493f      	ldr	r1, [pc, #252]	; (8001f10 <rt_test_003_004_execute.lto_priv.753+0x160>)
 8001e12:	4618      	mov	r0, r3
 8001e14:	f013 fb34 	bl	8015480 <_test_assert>
 8001e18:	4603      	mov	r3, r0
 8001e1a:	2b00      	cmp	r3, #0
 8001e1c:	d170      	bne.n	8001f00 <rt_test_003_004_execute.lto_priv.753+0x150>
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 8001e1e:	f7ff fd67 	bl	80018f0 <chThdGetSelfX.lto_priv.97>
 8001e22:	4603      	mov	r3, r0
 8001e24:	689a      	ldr	r2, [r3, #8]
 8001e26:	9b01      	ldr	r3, [sp, #4]
 8001e28:	3302      	adds	r3, #2
 8001e2a:	429a      	cmp	r2, r3
 8001e2c:	bf0c      	ite	eq
 8001e2e:	2301      	moveq	r3, #1
 8001e30:	2300      	movne	r3, #0
 8001e32:	b2db      	uxtb	r3, r3
 8001e34:	4935      	ldr	r1, [pc, #212]	; (8001f0c <rt_test_003_004_execute.lto_priv.753+0x15c>)
 8001e36:	4618      	mov	r0, r3
 8001e38:	f013 fb22 	bl	8015480 <_test_assert>
 8001e3c:	4603      	mov	r3, r0
 8001e3e:	2b00      	cmp	r3, #0
 8001e40:	d15e      	bne.n	8001f00 <rt_test_003_004_execute.lto_priv.753+0x150>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 8001e42:	f7ff fd55 	bl	80018f0 <chThdGetSelfX.lto_priv.97>
 8001e46:	4603      	mov	r3, r0
 8001e48:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001e4a:	9b01      	ldr	r3, [sp, #4]
 8001e4c:	3301      	adds	r3, #1
 8001e4e:	429a      	cmp	r2, r3
 8001e50:	bf0c      	ite	eq
 8001e52:	2301      	moveq	r3, #1
 8001e54:	2300      	movne	r3, #0
 8001e56:	b2db      	uxtb	r3, r3
 8001e58:	492e      	ldr	r1, [pc, #184]	; (8001f14 <rt_test_003_004_execute.lto_priv.753+0x164>)
 8001e5a:	4618      	mov	r0, r3
 8001e5c:	f013 fb10 	bl	8015480 <_test_assert>
 8001e60:	4603      	mov	r3, r0
 8001e62:	2b00      	cmp	r3, #0
 8001e64:	d14c      	bne.n	8001f00 <rt_test_003_004_execute.lto_priv.753+0x150>
  }

  /* [3.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 8001e66:	4b28      	ldr	r3, [pc, #160]	; (8001f08 <rt_test_003_004_execute.lto_priv.753+0x158>)
 8001e68:	2203      	movs	r2, #3
 8001e6a:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(prio + 3);
 8001e6c:	9b01      	ldr	r3, [sp, #4]
 8001e6e:	3303      	adds	r3, #3
 8001e70:	4618      	mov	r0, r3
 8001e72:	f00e fc7d 	bl	8010770 <chThdSetPriority>
 8001e76:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8001e78:	9b01      	ldr	r3, [sp, #4]
 8001e7a:	3301      	adds	r3, #1
 8001e7c:	9a00      	ldr	r2, [sp, #0]
 8001e7e:	429a      	cmp	r2, r3
 8001e80:	bf0c      	ite	eq
 8001e82:	2301      	moveq	r3, #1
 8001e84:	2300      	movne	r3, #0
 8001e86:	b2db      	uxtb	r3, r3
 8001e88:	4921      	ldr	r1, [pc, #132]	; (8001f10 <rt_test_003_004_execute.lto_priv.753+0x160>)
 8001e8a:	4618      	mov	r0, r3
 8001e8c:	f013 faf8 	bl	8015480 <_test_assert>
 8001e90:	4603      	mov	r3, r0
 8001e92:	2b00      	cmp	r3, #0
 8001e94:	d134      	bne.n	8001f00 <rt_test_003_004_execute.lto_priv.753+0x150>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 8001e96:	f7ff fd2b 	bl	80018f0 <chThdGetSelfX.lto_priv.97>
 8001e9a:	4603      	mov	r3, r0
 8001e9c:	689a      	ldr	r2, [r3, #8]
 8001e9e:	9b01      	ldr	r3, [sp, #4]
 8001ea0:	3303      	adds	r3, #3
 8001ea2:	429a      	cmp	r2, r3
 8001ea4:	bf0c      	ite	eq
 8001ea6:	2301      	moveq	r3, #1
 8001ea8:	2300      	movne	r3, #0
 8001eaa:	b2db      	uxtb	r3, r3
 8001eac:	4917      	ldr	r1, [pc, #92]	; (8001f0c <rt_test_003_004_execute.lto_priv.753+0x15c>)
 8001eae:	4618      	mov	r0, r3
 8001eb0:	f013 fae6 	bl	8015480 <_test_assert>
 8001eb4:	4603      	mov	r3, r0
 8001eb6:	2b00      	cmp	r3, #0
 8001eb8:	d122      	bne.n	8001f00 <rt_test_003_004_execute.lto_priv.753+0x150>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 8001eba:	f7ff fd19 	bl	80018f0 <chThdGetSelfX.lto_priv.97>
 8001ebe:	4603      	mov	r3, r0
 8001ec0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001ec2:	9b01      	ldr	r3, [sp, #4]
 8001ec4:	3303      	adds	r3, #3
 8001ec6:	429a      	cmp	r2, r3
 8001ec8:	bf0c      	ite	eq
 8001eca:	2301      	moveq	r3, #1
 8001ecc:	2300      	movne	r3, #0
 8001ece:	b2db      	uxtb	r3, r3
 8001ed0:	4911      	ldr	r1, [pc, #68]	; (8001f18 <rt_test_003_004_execute.lto_priv.753+0x168>)
 8001ed2:	4618      	mov	r0, r3
 8001ed4:	f013 fad4 	bl	8015480 <_test_assert>
 8001ed8:	4603      	mov	r3, r0
 8001eda:	2b00      	cmp	r3, #0
 8001edc:	d110      	bne.n	8001f00 <rt_test_003_004_execute.lto_priv.753+0x150>
  }

  /* [3.4.4] Restoring original conditions.*/
  test_set_step(4);
 8001ede:	4b0a      	ldr	r3, [pc, #40]	; (8001f08 <rt_test_003_004_execute.lto_priv.753+0x158>)
 8001ee0:	2204      	movs	r2, #4
 8001ee2:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8001ee4:	f7ff fcd4 	bl	8001890 <chSysLock.lto_priv.76>
    chThdGetSelfX()->prio = prio;
 8001ee8:	f7ff fd02 	bl	80018f0 <chThdGetSelfX.lto_priv.97>
 8001eec:	4602      	mov	r2, r0
 8001eee:	9b01      	ldr	r3, [sp, #4]
 8001ef0:	6093      	str	r3, [r2, #8]
    chThdGetSelfX()->realprio = prio;
 8001ef2:	f7ff fcfd 	bl	80018f0 <chThdGetSelfX.lto_priv.97>
 8001ef6:	4602      	mov	r2, r0
 8001ef8:	9b01      	ldr	r3, [sp, #4]
 8001efa:	63d3      	str	r3, [r2, #60]	; 0x3c
    chSysUnlock();
 8001efc:	f7ff fcd0 	bl	80018a0 <chSysUnlock.lto_priv.40>
  }
}
 8001f00:	b003      	add	sp, #12
 8001f02:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f06:	bf00      	nop
 8001f08:	20001988 	.word	0x20001988
 8001f0c:	08017f88 	.word	0x08017f88
 8001f10:	08017f64 	.word	0x08017f64
 8001f14:	08017fb4 	.word	0x08017fb4
 8001f18:	08017fdc 	.word	0x08017fdc
 8001f1c:	00000000 	.word	0x00000000

08001f20 <chTimeAddX.lto_priv.121>:
                                   sysinterval_t interval) {
 8001f20:	b082      	sub	sp, #8
 8001f22:	9001      	str	r0, [sp, #4]
 8001f24:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
 8001f26:	9a01      	ldr	r2, [sp, #4]
 8001f28:	9b00      	ldr	r3, [sp, #0]
 8001f2a:	4413      	add	r3, r2
}
 8001f2c:	4618      	mov	r0, r3
 8001f2e:	b002      	add	sp, #8
 8001f30:	4770      	bx	lr
 8001f32:	bf00      	nop
	...

08001f40 <port_lock.lto_priv.21>:
static inline void port_lock(void) {
 8001f40:	b082      	sub	sp, #8
 8001f42:	2320      	movs	r3, #32
 8001f44:	9301      	str	r3, [sp, #4]
 8001f46:	9b01      	ldr	r3, [sp, #4]
 8001f48:	f383 8811 	msr	BASEPRI, r3
}
 8001f4c:	b002      	add	sp, #8
 8001f4e:	4770      	bx	lr

08001f50 <port_unlock.lto_priv.11>:
static inline void port_unlock(void) {
 8001f50:	b082      	sub	sp, #8
 8001f52:	2300      	movs	r3, #0
 8001f54:	9301      	str	r3, [sp, #4]
 8001f56:	9b01      	ldr	r3, [sp, #4]
 8001f58:	f383 8811 	msr	BASEPRI, r3
}
 8001f5c:	b002      	add	sp, #8
 8001f5e:	4770      	bx	lr

08001f60 <st_lld_get_counter.lto_priv.118>:
  return (systime_t)STM32_ST_TIM->CNT;
 8001f60:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001f64:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8001f66:	4618      	mov	r0, r3
 8001f68:	4770      	bx	lr
 8001f6a:	bf00      	nop
 8001f6c:	0000      	movs	r0, r0
	...

08001f70 <port_timer_get_time.lto_priv.113>:
static inline systime_t port_timer_get_time(void) {
 8001f70:	b508      	push	{r3, lr}
  return stGetCounter();
 8001f72:	f7ff fff5 	bl	8001f60 <st_lld_get_counter.lto_priv.118>
 8001f76:	4603      	mov	r3, r0
}
 8001f78:	4618      	mov	r0, r3
 8001f7a:	bd08      	pop	{r3, pc}
 8001f7c:	0000      	movs	r0, r0
	...

08001f80 <chSysLock.lto_priv.77>:
static inline void chSysLock(void) {
 8001f80:	b508      	push	{r3, lr}
  port_lock();
 8001f82:	f7ff ffdd 	bl	8001f40 <port_lock.lto_priv.21>
  _dbg_check_lock();
 8001f86:	f00d f99b 	bl	800f2c0 <_dbg_check_lock>
}
 8001f8a:	bd08      	pop	{r3, pc}
 8001f8c:	0000      	movs	r0, r0
	...

08001f90 <chSysUnlock.lto_priv.41>:
static inline void chSysUnlock(void) {
 8001f90:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8001f92:	f00d f9ad 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001f96:	4b09      	ldr	r3, [pc, #36]	; (8001fbc <chSysUnlock.lto_priv.41+0x2c>)
 8001f98:	681b      	ldr	r3, [r3, #0]
 8001f9a:	4a08      	ldr	r2, [pc, #32]	; (8001fbc <chSysUnlock.lto_priv.41+0x2c>)
 8001f9c:	4293      	cmp	r3, r2
 8001f9e:	d00a      	beq.n	8001fb6 <chSysUnlock.lto_priv.41+0x26>
 8001fa0:	4b06      	ldr	r3, [pc, #24]	; (8001fbc <chSysUnlock.lto_priv.41+0x2c>)
 8001fa2:	699b      	ldr	r3, [r3, #24]
 8001fa4:	689a      	ldr	r2, [r3, #8]
 8001fa6:	4b05      	ldr	r3, [pc, #20]	; (8001fbc <chSysUnlock.lto_priv.41+0x2c>)
 8001fa8:	681b      	ldr	r3, [r3, #0]
 8001faa:	689b      	ldr	r3, [r3, #8]
 8001fac:	429a      	cmp	r2, r3
 8001fae:	d202      	bcs.n	8001fb6 <chSysUnlock.lto_priv.41+0x26>
 8001fb0:	4803      	ldr	r0, [pc, #12]	; (8001fc0 <chSysUnlock.lto_priv.41+0x30>)
 8001fb2:	f00d f815 	bl	800efe0 <chSysHalt>
  port_unlock();
 8001fb6:	f7ff ffcb 	bl	8001f50 <port_unlock.lto_priv.11>
}
 8001fba:	bd08      	pop	{r3, pc}
 8001fbc:	20001090 	.word	0x20001090
 8001fc0:	08018078 	.word	0x08018078
	...

08001fd0 <chVTGetSystemTimeX.lto_priv.108>:
static inline systime_t chVTGetSystemTimeX(void) {
 8001fd0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8001fd2:	f7ff ffcd 	bl	8001f70 <port_timer_get_time.lto_priv.113>
 8001fd6:	4603      	mov	r3, r0
}
 8001fd8:	4618      	mov	r0, r3
 8001fda:	bd08      	pop	{r3, pc}
 8001fdc:	0000      	movs	r0, r0
	...

08001fe0 <chThdGetSelfX.lto_priv.98>:
  return ch.rlist.current;
 8001fe0:	4b01      	ldr	r3, [pc, #4]	; (8001fe8 <chThdGetSelfX.lto_priv.98+0x8>)
 8001fe2:	699b      	ldr	r3, [r3, #24]
}
 8001fe4:	4618      	mov	r0, r3
 8001fe6:	4770      	bx	lr
 8001fe8:	20001090 	.word	0x20001090
 8001fec:	00000000 	.word	0x00000000

08001ff0 <chThdGetPriorityX.lto_priv.90>:
static inline tprio_t chThdGetPriorityX(void) {
 8001ff0:	b508      	push	{r3, lr}
  return chThdGetSelfX()->prio;
 8001ff2:	f7ff fff5 	bl	8001fe0 <chThdGetSelfX.lto_priv.98>
 8001ff6:	4603      	mov	r3, r0
 8001ff8:	689b      	ldr	r3, [r3, #8]
}
 8001ffa:	4618      	mov	r0, r3
 8001ffc:	bd08      	pop	{r3, pc}
 8001ffe:	bf00      	nop

08002000 <thread1.lto_priv.125>:
 * Shared code.
 ****************************************************************************/

static thread_reference_t tr1;

static THD_FUNCTION(thread1, p) {
 8002000:	b500      	push	{lr}
 8002002:	b083      	sub	sp, #12
 8002004:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002006:	f7ff ffbb 	bl	8001f80 <chSysLock.lto_priv.77>
  chThdResumeI(&tr1, MSG_OK);
 800200a:	2100      	movs	r1, #0
 800200c:	4807      	ldr	r0, [pc, #28]	; (800202c <thread1.lto_priv.125+0x2c>)
 800200e:	f00e fc57 	bl	80108c0 <chThdResumeI>
  chSchRescheduleS();
 8002012:	f00d ff4d 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 8002016:	f7ff ffbb 	bl	8001f90 <chSysUnlock.lto_priv.41>
  test_emit_token(*(char *)p);
 800201a:	9b01      	ldr	r3, [sp, #4]
 800201c:	781b      	ldrb	r3, [r3, #0]
 800201e:	4618      	mov	r0, r3
 8002020:	f013 fb0e 	bl	8015640 <test_emit_token>
}
 8002024:	b003      	add	sp, #12
 8002026:	f85d fb04 	ldr.w	pc, [sp], #4
 800202a:	bf00      	nop
 800202c:	2000202c 	.word	0x2000202c

08002030 <rt_test_004_001_setup.lto_priv.754>:
 *   the state of the reference are tested.
 * .
 */

static void rt_test_004_001_setup(void) {
  tr1 = NULL;
 8002030:	4b01      	ldr	r3, [pc, #4]	; (8002038 <rt_test_004_001_setup.lto_priv.754+0x8>)
 8002032:	2200      	movs	r2, #0
 8002034:	601a      	str	r2, [r3, #0]
}
 8002036:	4770      	bx	lr
 8002038:	2000202c 	.word	0x2000202c
 800203c:	00000000 	.word	0x00000000

08002040 <rt_test_004_001_execute.lto_priv.755>:

static void rt_test_004_001_execute(void) {
 8002040:	b510      	push	{r4, lr}
 8002042:	b084      	sub	sp, #16
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 8002044:	4b3c      	ldr	r3, [pc, #240]	; (8002138 <rt_test_004_001_execute.lto_priv.755+0xf8>)
 8002046:	2201      	movs	r2, #1
 8002048:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 800204a:	4b3c      	ldr	r3, [pc, #240]	; (800213c <rt_test_004_001_execute.lto_priv.755+0xfc>)
 800204c:	681c      	ldr	r4, [r3, #0]
 800204e:	f7ff ffcf 	bl	8001ff0 <chThdGetPriorityX.lto_priv.90>
 8002052:	4603      	mov	r3, r0
 8002054:	1e5a      	subs	r2, r3, #1
 8002056:	4b3a      	ldr	r3, [pc, #232]	; (8002140 <rt_test_004_001_execute.lto_priv.755+0x100>)
 8002058:	9300      	str	r3, [sp, #0]
 800205a:	4b3a      	ldr	r3, [pc, #232]	; (8002144 <rt_test_004_001_execute.lto_priv.755+0x104>)
 800205c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002060:	4620      	mov	r0, r4
 8002062:	f00e fa3d 	bl	80104e0 <chThdCreateStatic>
 8002066:	4602      	mov	r2, r0
 8002068:	4b37      	ldr	r3, [pc, #220]	; (8002148 <rt_test_004_001_execute.lto_priv.755+0x108>)
 800206a:	601a      	str	r2, [r3, #0]
    chSysLock();
 800206c:	f7ff ff88 	bl	8001f80 <chSysLock.lto_priv.77>
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
 8002070:	f04f 31ff 	mov.w	r1, #4294967295
 8002074:	4835      	ldr	r0, [pc, #212]	; (800214c <rt_test_004_001_execute.lto_priv.755+0x10c>)
 8002076:	f00e fbfb 	bl	8010870 <chThdSuspendTimeoutS>
 800207a:	9003      	str	r0, [sp, #12]
    chSysUnlock();
 800207c:	f7ff ff88 	bl	8001f90 <chSysUnlock.lto_priv.41>
    test_assert(NULL == tr1, "not NULL");
 8002080:	4b32      	ldr	r3, [pc, #200]	; (800214c <rt_test_004_001_execute.lto_priv.755+0x10c>)
 8002082:	681b      	ldr	r3, [r3, #0]
 8002084:	2b00      	cmp	r3, #0
 8002086:	bf0c      	ite	eq
 8002088:	2301      	moveq	r3, #1
 800208a:	2300      	movne	r3, #0
 800208c:	b2db      	uxtb	r3, r3
 800208e:	4930      	ldr	r1, [pc, #192]	; (8002150 <rt_test_004_001_execute.lto_priv.755+0x110>)
 8002090:	4618      	mov	r0, r3
 8002092:	f013 f9f5 	bl	8015480 <_test_assert>
 8002096:	4603      	mov	r3, r0
 8002098:	2b00      	cmp	r3, #0
 800209a:	d14b      	bne.n	8002134 <rt_test_004_001_execute.lto_priv.755+0xf4>
    test_assert(MSG_OK == msg,"wrong returned message");
 800209c:	9b03      	ldr	r3, [sp, #12]
 800209e:	2b00      	cmp	r3, #0
 80020a0:	bf0c      	ite	eq
 80020a2:	2301      	moveq	r3, #1
 80020a4:	2300      	movne	r3, #0
 80020a6:	b2db      	uxtb	r3, r3
 80020a8:	492a      	ldr	r1, [pc, #168]	; (8002154 <rt_test_004_001_execute.lto_priv.755+0x114>)
 80020aa:	4618      	mov	r0, r3
 80020ac:	f013 f9e8 	bl	8015480 <_test_assert>
 80020b0:	4603      	mov	r3, r0
 80020b2:	2b00      	cmp	r3, #0
 80020b4:	d13e      	bne.n	8002134 <rt_test_004_001_execute.lto_priv.755+0xf4>
    test_wait_threads();
 80020b6:	f7fe fe63 	bl	8000d80 <test_wait_threads>
  }

  /* [4.1.2] The function chThdSuspendTimeoutS() is invoked, the thread
     is not resumed so a timeout must occur. On return the message and
     the state of the reference are tested.*/
  test_set_step(2);
 80020ba:	4b1f      	ldr	r3, [pc, #124]	; (8002138 <rt_test_004_001_execute.lto_priv.755+0xf8>)
 80020bc:	2202      	movs	r2, #2
 80020be:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 80020c0:	f7ff ff5e 	bl	8001f80 <chSysLock.lto_priv.77>
    time = chVTGetSystemTimeX();
 80020c4:	f7ff ff84 	bl	8001fd0 <chVTGetSystemTimeX.lto_priv.108>
 80020c8:	9002      	str	r0, [sp, #8]
    msg = chThdSuspendTimeoutS(&tr1, TIME_MS2I(1000));
 80020ca:	f242 7110 	movw	r1, #10000	; 0x2710
 80020ce:	481f      	ldr	r0, [pc, #124]	; (800214c <rt_test_004_001_execute.lto_priv.755+0x10c>)
 80020d0:	f00e fbce 	bl	8010870 <chThdSuspendTimeoutS>
 80020d4:	9003      	str	r0, [sp, #12]
    chSysUnlock();
 80020d6:	f7ff ff5b 	bl	8001f90 <chSysUnlock.lto_priv.41>
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(1000)),
 80020da:	f242 7110 	movw	r1, #10000	; 0x2710
 80020de:	9802      	ldr	r0, [sp, #8]
 80020e0:	f7ff ff1e 	bl	8001f20 <chTimeAddX.lto_priv.121>
 80020e4:	4604      	mov	r4, r0
 80020e6:	f242 7113 	movw	r1, #10003	; 0x2713
 80020ea:	9802      	ldr	r0, [sp, #8]
 80020ec:	f7ff ff18 	bl	8001f20 <chTimeAddX.lto_priv.121>
 80020f0:	4603      	mov	r3, r0
 80020f2:	4a19      	ldr	r2, [pc, #100]	; (8002158 <rt_test_004_001_execute.lto_priv.755+0x118>)
 80020f4:	4619      	mov	r1, r3
 80020f6:	4620      	mov	r0, r4
 80020f8:	f013 fa0a 	bl	8015510 <_test_assert_time_window>
 80020fc:	4603      	mov	r3, r0
 80020fe:	2b00      	cmp	r3, #0
 8002100:	d118      	bne.n	8002134 <rt_test_004_001_execute.lto_priv.755+0xf4>
                            chTimeAddX(time, TIME_MS2I(1000) + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
 8002102:	4b12      	ldr	r3, [pc, #72]	; (800214c <rt_test_004_001_execute.lto_priv.755+0x10c>)
 8002104:	681b      	ldr	r3, [r3, #0]
 8002106:	2b00      	cmp	r3, #0
 8002108:	bf0c      	ite	eq
 800210a:	2301      	moveq	r3, #1
 800210c:	2300      	movne	r3, #0
 800210e:	b2db      	uxtb	r3, r3
 8002110:	490f      	ldr	r1, [pc, #60]	; (8002150 <rt_test_004_001_execute.lto_priv.755+0x110>)
 8002112:	4618      	mov	r0, r3
 8002114:	f013 f9b4 	bl	8015480 <_test_assert>
 8002118:	4603      	mov	r3, r0
 800211a:	2b00      	cmp	r3, #0
 800211c:	d10a      	bne.n	8002134 <rt_test_004_001_execute.lto_priv.755+0xf4>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 800211e:	9b03      	ldr	r3, [sp, #12]
 8002120:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002124:	bf0c      	ite	eq
 8002126:	2301      	moveq	r3, #1
 8002128:	2300      	movne	r3, #0
 800212a:	b2db      	uxtb	r3, r3
 800212c:	4909      	ldr	r1, [pc, #36]	; (8002154 <rt_test_004_001_execute.lto_priv.755+0x114>)
 800212e:	4618      	mov	r0, r3
 8002130:	f013 f9a6 	bl	8015480 <_test_assert>
  }
}
 8002134:	b004      	add	sp, #16
 8002136:	bd10      	pop	{r4, pc}
 8002138:	20001988 	.word	0x20001988
 800213c:	08017360 	.word	0x08017360
 8002140:	08017f34 	.word	0x08017f34
 8002144:	08002001 	.word	0x08002001
 8002148:	20002018 	.word	0x20002018
 800214c:	2000202c 	.word	0x2000202c
 8002150:	08018034 	.word	0x08018034
 8002154:	08018040 	.word	0x08018040
 8002158:	08017f08 	.word	0x08017f08
 800215c:	00000000 	.word	0x00000000

08002160 <chTimeAddX.lto_priv.122>:
                                   sysinterval_t interval) {
 8002160:	b082      	sub	sp, #8
 8002162:	9001      	str	r0, [sp, #4]
 8002164:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
 8002166:	9a01      	ldr	r2, [sp, #4]
 8002168:	9b00      	ldr	r3, [sp, #0]
 800216a:	4413      	add	r3, r2
}
 800216c:	4618      	mov	r0, r3
 800216e:	b002      	add	sp, #8
 8002170:	4770      	bx	lr
 8002172:	bf00      	nop
	...

08002180 <port_lock.lto_priv.22>:
static inline void port_lock(void) {
 8002180:	b082      	sub	sp, #8
 8002182:	2320      	movs	r3, #32
 8002184:	9301      	str	r3, [sp, #4]
 8002186:	9b01      	ldr	r3, [sp, #4]
 8002188:	f383 8811 	msr	BASEPRI, r3
}
 800218c:	b002      	add	sp, #8
 800218e:	4770      	bx	lr

08002190 <port_unlock.lto_priv.12>:
static inline void port_unlock(void) {
 8002190:	b082      	sub	sp, #8
 8002192:	2300      	movs	r3, #0
 8002194:	9301      	str	r3, [sp, #4]
 8002196:	9b01      	ldr	r3, [sp, #4]
 8002198:	f383 8811 	msr	BASEPRI, r3
}
 800219c:	b002      	add	sp, #8
 800219e:	4770      	bx	lr

080021a0 <queue_isempty.lto_priv.128>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 80021a0:	b082      	sub	sp, #8
 80021a2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->next == (const thread_t *)tqp);
 80021a4:	9b01      	ldr	r3, [sp, #4]
 80021a6:	681b      	ldr	r3, [r3, #0]
 80021a8:	9a01      	ldr	r2, [sp, #4]
 80021aa:	429a      	cmp	r2, r3
 80021ac:	bf0c      	ite	eq
 80021ae:	2301      	moveq	r3, #1
 80021b0:	2300      	movne	r3, #0
 80021b2:	b2db      	uxtb	r3, r3
}
 80021b4:	4618      	mov	r0, r3
 80021b6:	b002      	add	sp, #8
 80021b8:	4770      	bx	lr
 80021ba:	bf00      	nop
 80021bc:	0000      	movs	r0, r0
	...

080021c0 <chSysLock.lto_priv.78>:
static inline void chSysLock(void) {
 80021c0:	b508      	push	{r3, lr}
  port_lock();
 80021c2:	f7ff ffdd 	bl	8002180 <port_lock.lto_priv.22>
  _dbg_check_lock();
 80021c6:	f00d f87b 	bl	800f2c0 <_dbg_check_lock>
}
 80021ca:	bd08      	pop	{r3, pc}
 80021cc:	0000      	movs	r0, r0
	...

080021d0 <chSysUnlock.lto_priv.42>:
static inline void chSysUnlock(void) {
 80021d0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80021d2:	f00d f88d 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80021d6:	4b09      	ldr	r3, [pc, #36]	; (80021fc <chSysUnlock.lto_priv.42+0x2c>)
 80021d8:	681b      	ldr	r3, [r3, #0]
 80021da:	4a08      	ldr	r2, [pc, #32]	; (80021fc <chSysUnlock.lto_priv.42+0x2c>)
 80021dc:	4293      	cmp	r3, r2
 80021de:	d00a      	beq.n	80021f6 <chSysUnlock.lto_priv.42+0x26>
 80021e0:	4b06      	ldr	r3, [pc, #24]	; (80021fc <chSysUnlock.lto_priv.42+0x2c>)
 80021e2:	699b      	ldr	r3, [r3, #24]
 80021e4:	689a      	ldr	r2, [r3, #8]
 80021e6:	4b05      	ldr	r3, [pc, #20]	; (80021fc <chSysUnlock.lto_priv.42+0x2c>)
 80021e8:	681b      	ldr	r3, [r3, #0]
 80021ea:	689b      	ldr	r3, [r3, #8]
 80021ec:	429a      	cmp	r2, r3
 80021ee:	d202      	bcs.n	80021f6 <chSysUnlock.lto_priv.42+0x26>
 80021f0:	4803      	ldr	r0, [pc, #12]	; (8002200 <chSysUnlock.lto_priv.42+0x30>)
 80021f2:	f00c fef5 	bl	800efe0 <chSysHalt>
  port_unlock();
 80021f6:	f7ff ffcb 	bl	8002190 <port_unlock.lto_priv.12>
}
 80021fa:	bd08      	pop	{r3, pc}
 80021fc:	20001090 	.word	0x20001090
 8002200:	080181a8 	.word	0x080181a8
	...

08002210 <chThdGetSelfX.lto_priv.99>:
  return ch.rlist.current;
 8002210:	4b01      	ldr	r3, [pc, #4]	; (8002218 <chThdGetSelfX.lto_priv.99+0x8>)
 8002212:	699b      	ldr	r3, [r3, #24]
}
 8002214:	4618      	mov	r0, r3
 8002216:	4770      	bx	lr
 8002218:	20001090 	.word	0x20001090
 800221c:	00000000 	.word	0x00000000

08002220 <chThdGetPriorityX.lto_priv.91>:
static inline tprio_t chThdGetPriorityX(void) {
 8002220:	b508      	push	{r3, lr}
  return chThdGetSelfX()->prio;
 8002222:	f7ff fff5 	bl	8002210 <chThdGetSelfX.lto_priv.99>
 8002226:	4603      	mov	r3, r0
 8002228:	689b      	ldr	r3, [r3, #8]
}
 800222a:	4618      	mov	r0, r3
 800222c:	bd08      	pop	{r3, pc}
 800222e:	bf00      	nop

08002230 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(const semaphore_t *sp) {
 8002230:	b500      	push	{lr}
 8002232:	b083      	sub	sp, #12
 8002234:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002236:	f00d f8e3 	bl	800f400 <chDbgCheckClassI>

  return sp->cnt;
 800223a:	9b01      	ldr	r3, [sp, #4]
 800223c:	689b      	ldr	r3, [r3, #8]
}
 800223e:	4618      	mov	r0, r3
 8002240:	b003      	add	sp, #12
 8002242:	f85d fb04 	ldr.w	pc, [sp], #4
 8002246:	bf00      	nop
	...

08002250 <chBSemObjectInit>:
 *                      - @a true, the initial state is taken.
 *                      .
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {
 8002250:	b500      	push	{lr}
 8002252:	b083      	sub	sp, #12
 8002254:	9001      	str	r0, [sp, #4]
 8002256:	460b      	mov	r3, r1
 8002258:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemObjectInit(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 800225c:	9a01      	ldr	r2, [sp, #4]
 800225e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002262:	f083 0301 	eor.w	r3, r3, #1
 8002266:	b2db      	uxtb	r3, r3
 8002268:	4619      	mov	r1, r3
 800226a:	4610      	mov	r0, r2
 800226c:	f00e fdd8 	bl	8010e20 <chSemObjectInit>
}
 8002270:	b003      	add	sp, #12
 8002272:	f85d fb04 	ldr.w	pc, [sp], #4
 8002276:	bf00      	nop
	...

08002280 <chBSemWait>:
 * @retval MSG_RESET    if the binary semaphore has been reset using
 *                      @p bsemReset().
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {
 8002280:	b500      	push	{lr}
 8002282:	b083      	sub	sp, #12
 8002284:	9001      	str	r0, [sp, #4]

  return chSemWait(&bsp->sem);
 8002286:	9b01      	ldr	r3, [sp, #4]
 8002288:	4618      	mov	r0, r3
 800228a:	f00e fe51 	bl	8010f30 <chSemWait>
 800228e:	4603      	mov	r3, r0
}
 8002290:	4618      	mov	r0, r3
 8002292:	b003      	add	sp, #12
 8002294:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080022a0 <chBSemReset>:
 *                      - @a true, the new state is taken.
 *                      .
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {
 80022a0:	b500      	push	{lr}
 80022a2:	b083      	sub	sp, #12
 80022a4:	9001      	str	r0, [sp, #4]
 80022a6:	460b      	mov	r3, r1
 80022a8:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 80022ac:	9a01      	ldr	r2, [sp, #4]
 80022ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80022b2:	f083 0301 	eor.w	r3, r3, #1
 80022b6:	b2db      	uxtb	r3, r3
 80022b8:	4619      	mov	r1, r3
 80022ba:	4610      	mov	r0, r2
 80022bc:	f00e fdd0 	bl	8010e60 <chSemReset>
}
 80022c0:	b003      	add	sp, #12
 80022c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80022c6:	bf00      	nop
	...

080022d0 <chBSemSignalI>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {
 80022d0:	b500      	push	{lr}
 80022d2:	b083      	sub	sp, #12
 80022d4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80022d6:	f00d f893 	bl	800f400 <chDbgCheckClassI>

  if (bsp->sem.cnt < (cnt_t)1) {
 80022da:	9b01      	ldr	r3, [sp, #4]
 80022dc:	689b      	ldr	r3, [r3, #8]
 80022de:	2b00      	cmp	r3, #0
 80022e0:	dc03      	bgt.n	80022ea <chBSemSignalI+0x1a>
    chSemSignalI(&bsp->sem);
 80022e2:	9b01      	ldr	r3, [sp, #4]
 80022e4:	4618      	mov	r0, r3
 80022e6:	f00e ff43 	bl	8011170 <chSemSignalI>
  }
}
 80022ea:	b003      	add	sp, #12
 80022ec:	f85d fb04 	ldr.w	pc, [sp], #4

080022f0 <chBSemSignal>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @api
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {
 80022f0:	b500      	push	{lr}
 80022f2:	b083      	sub	sp, #12
 80022f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80022f6:	f7ff ff63 	bl	80021c0 <chSysLock.lto_priv.78>
  chBSemSignalI(bsp);
 80022fa:	9801      	ldr	r0, [sp, #4]
 80022fc:	f7ff ffe8 	bl	80022d0 <chBSemSignalI>
  chSchRescheduleS();
 8002300:	f00d fdd6 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 8002304:	f7ff ff64 	bl	80021d0 <chSysUnlock.lto_priv.42>
}
 8002308:	b003      	add	sp, #12
 800230a:	f85d fb04 	ldr.w	pc, [sp], #4
 800230e:	bf00      	nop

08002310 <chBSemGetStateI>:
 * @retval false        if the binary semaphore is not taken.
 * @retval true         if the binary semaphore is taken.
 *
 * @iclass
 */
static inline bool chBSemGetStateI(const binary_semaphore_t *bsp) {
 8002310:	b500      	push	{lr}
 8002312:	b083      	sub	sp, #12
 8002314:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002316:	f00d f873 	bl	800f400 <chDbgCheckClassI>

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 800231a:	9b01      	ldr	r3, [sp, #4]
 800231c:	689b      	ldr	r3, [r3, #8]
 800231e:	2b00      	cmp	r3, #0
 8002320:	bfd4      	ite	le
 8002322:	2301      	movle	r3, #1
 8002324:	2300      	movgt	r3, #0
 8002326:	b2db      	uxtb	r3, r3
}
 8002328:	4618      	mov	r0, r3
 800232a:	b003      	add	sp, #12
 800232c:	f85d fb04 	ldr.w	pc, [sp], #4

08002330 <osalSysLock.lto_priv.35>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8002330:	b508      	push	{r3, lr}

  chSysLock();
 8002332:	f7ff ff45 	bl	80021c0 <chSysLock.lto_priv.78>
}
 8002336:	bd08      	pop	{r3, pc}
	...

08002340 <osalSysUnlock.lto_priv.32>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8002340:	b508      	push	{r3, lr}

  chSysUnlock();
 8002342:	f7ff ff45 	bl	80021d0 <chSysUnlock.lto_priv.42>
}
 8002346:	bd08      	pop	{r3, pc}
	...

08002350 <thread1.lto_priv.126>:

#include "ch.h"

static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {
 8002350:	b500      	push	{lr}
 8002352:	b083      	sub	sp, #12
 8002354:	9001      	str	r0, [sp, #4]

  chSemWait(&sem1);
 8002356:	4805      	ldr	r0, [pc, #20]	; (800236c <thread1.lto_priv.126+0x1c>)
 8002358:	f00e fdea 	bl	8010f30 <chSemWait>
  test_emit_token(*(char *)p);
 800235c:	9b01      	ldr	r3, [sp, #4]
 800235e:	781b      	ldrb	r3, [r3, #0]
 8002360:	4618      	mov	r0, r3
 8002362:	f013 f96d 	bl	8015640 <test_emit_token>
}
 8002366:	b003      	add	sp, #12
 8002368:	f85d fb04 	ldr.w	pc, [sp], #4
 800236c:	20002030 	.word	0x20002030

08002370 <thread2>:

static THD_FUNCTION(thread2, p) {
 8002370:	b500      	push	{lr}
 8002372:	b083      	sub	sp, #12
 8002374:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 8002376:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800237a:	f00e fa49 	bl	8010810 <chThdSleep>
  chSysLock();
 800237e:	f7ff ff1f 	bl	80021c0 <chSysLock.lto_priv.78>
  chSemSignalI(&sem1); /* For coverage reasons */
 8002382:	4805      	ldr	r0, [pc, #20]	; (8002398 <thread2+0x28>)
 8002384:	f00e fef4 	bl	8011170 <chSemSignalI>
  chSchRescheduleS();
 8002388:	f00d fd92 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 800238c:	f7ff ff20 	bl	80021d0 <chSysUnlock.lto_priv.42>
}
 8002390:	b003      	add	sp, #12
 8002392:	f85d fb04 	ldr.w	pc, [sp], #4
 8002396:	bf00      	nop
 8002398:	20002030 	.word	0x20002030
 800239c:	00000000 	.word	0x00000000

080023a0 <thread3>:

static THD_FUNCTION(thread3, p) {
 80023a0:	b500      	push	{lr}
 80023a2:	b083      	sub	sp, #12
 80023a4:	9001      	str	r0, [sp, #4]

  (void)p;
  chSemWait(&sem1);
 80023a6:	4804      	ldr	r0, [pc, #16]	; (80023b8 <thread3+0x18>)
 80023a8:	f00e fdc2 	bl	8010f30 <chSemWait>
  chSemSignal(&sem1);
 80023ac:	4802      	ldr	r0, [pc, #8]	; (80023b8 <thread3+0x18>)
 80023ae:	f00e fe97 	bl	80110e0 <chSemSignal>
}
 80023b2:	b003      	add	sp, #12
 80023b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80023b8:	20002030 	.word	0x20002030
 80023bc:	00000000 	.word	0x00000000

080023c0 <thread4>:

static THD_FUNCTION(thread4, p) {
 80023c0:	b500      	push	{lr}
 80023c2:	b083      	sub	sp, #12
 80023c4:	9001      	str	r0, [sp, #4]

  chBSemSignal((binary_semaphore_t *)p);
 80023c6:	9801      	ldr	r0, [sp, #4]
 80023c8:	f7ff ff92 	bl	80022f0 <chBSemSignal>
}
 80023cc:	b003      	add	sp, #12
 80023ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80023d2:	bf00      	nop
	...

080023e0 <rt_test_005_001_setup.lto_priv.756>:
 * - [5.1.3] The function chSemReset() is invoked, after return the
 *   counter is tested.
 * .
 */

static void rt_test_005_001_setup(void) {
 80023e0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 1);
 80023e2:	2101      	movs	r1, #1
 80023e4:	4801      	ldr	r0, [pc, #4]	; (80023ec <rt_test_005_001_setup.lto_priv.756+0xc>)
 80023e6:	f00e fd1b 	bl	8010e20 <chSemObjectInit>
}
 80023ea:	bd08      	pop	{r3, pc}
 80023ec:	20002030 	.word	0x20002030

080023f0 <rt_test_005_001_teardown.lto_priv.757>:

static void rt_test_005_001_teardown(void) {
 80023f0:	b508      	push	{r3, lr}
  chSemReset(&sem1, 0);
 80023f2:	2100      	movs	r1, #0
 80023f4:	4801      	ldr	r0, [pc, #4]	; (80023fc <rt_test_005_001_teardown.lto_priv.757+0xc>)
 80023f6:	f00e fd33 	bl	8010e60 <chSemReset>
}
 80023fa:	bd08      	pop	{r3, pc}
 80023fc:	20002030 	.word	0x20002030

08002400 <rt_test_005_001_execute.lto_priv.758>:

static void rt_test_005_001_execute(void) {
 8002400:	b500      	push	{lr}
 8002402:	b083      	sub	sp, #12

  /* [5.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 8002404:	4b34      	ldr	r3, [pc, #208]	; (80024d8 <rt_test_005_001_execute.lto_priv.758+0xd8>)
 8002406:	2201      	movs	r2, #1
 8002408:	601a      	str	r2, [r3, #0]
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 800240a:	4834      	ldr	r0, [pc, #208]	; (80024dc <rt_test_005_001_execute.lto_priv.758+0xdc>)
 800240c:	f00e fd90 	bl	8010f30 <chSemWait>
 8002410:	9001      	str	r0, [sp, #4]
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 8002412:	f7ff ff8d 	bl	8002330 <osalSysLock.lto_priv.35>
 8002416:	4831      	ldr	r0, [pc, #196]	; (80024dc <rt_test_005_001_execute.lto_priv.758+0xdc>)
 8002418:	f7ff ff0a 	bl	8002230 <chSemGetCounterI>
 800241c:	4603      	mov	r3, r0
 800241e:	2b00      	cmp	r3, #0
 8002420:	bf0c      	ite	eq
 8002422:	2301      	moveq	r3, #1
 8002424:	2300      	movne	r3, #0
 8002426:	b2db      	uxtb	r3, r3
 8002428:	492d      	ldr	r1, [pc, #180]	; (80024e0 <rt_test_005_001_execute.lto_priv.758+0xe0>)
 800242a:	4618      	mov	r0, r3
 800242c:	f013 f828 	bl	8015480 <_test_assert>
 8002430:	4603      	mov	r3, r0
 8002432:	2b00      	cmp	r3, #0
 8002434:	d002      	beq.n	800243c <rt_test_005_001_execute.lto_priv.758+0x3c>
 8002436:	f7ff ff83 	bl	8002340 <osalSysUnlock.lto_priv.32>
 800243a:	e049      	b.n	80024d0 <rt_test_005_001_execute.lto_priv.758+0xd0>
 800243c:	f7ff ff80 	bl	8002340 <osalSysUnlock.lto_priv.32>
    test_assert(MSG_OK == msg, "wrong returned message");
 8002440:	9b01      	ldr	r3, [sp, #4]
 8002442:	2b00      	cmp	r3, #0
 8002444:	bf0c      	ite	eq
 8002446:	2301      	moveq	r3, #1
 8002448:	2300      	movne	r3, #0
 800244a:	b2db      	uxtb	r3, r3
 800244c:	4925      	ldr	r1, [pc, #148]	; (80024e4 <rt_test_005_001_execute.lto_priv.758+0xe4>)
 800244e:	4618      	mov	r0, r3
 8002450:	f013 f816 	bl	8015480 <_test_assert>
 8002454:	4603      	mov	r3, r0
 8002456:	2b00      	cmp	r3, #0
 8002458:	d13a      	bne.n	80024d0 <rt_test_005_001_execute.lto_priv.758+0xd0>
  }

  /* [5.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 800245a:	4b1f      	ldr	r3, [pc, #124]	; (80024d8 <rt_test_005_001_execute.lto_priv.758+0xd8>)
 800245c:	2202      	movs	r2, #2
 800245e:	601a      	str	r2, [r3, #0]
  {
    chSemSignal(&sem1);
 8002460:	481e      	ldr	r0, [pc, #120]	; (80024dc <rt_test_005_001_execute.lto_priv.758+0xdc>)
 8002462:	f00e fe3d 	bl	80110e0 <chSemSignal>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 8002466:	f7ff ff63 	bl	8002330 <osalSysLock.lto_priv.35>
 800246a:	481c      	ldr	r0, [pc, #112]	; (80024dc <rt_test_005_001_execute.lto_priv.758+0xdc>)
 800246c:	f7ff fee0 	bl	8002230 <chSemGetCounterI>
 8002470:	4603      	mov	r3, r0
 8002472:	2b01      	cmp	r3, #1
 8002474:	bf0c      	ite	eq
 8002476:	2301      	moveq	r3, #1
 8002478:	2300      	movne	r3, #0
 800247a:	b2db      	uxtb	r3, r3
 800247c:	4918      	ldr	r1, [pc, #96]	; (80024e0 <rt_test_005_001_execute.lto_priv.758+0xe0>)
 800247e:	4618      	mov	r0, r3
 8002480:	f012 fffe 	bl	8015480 <_test_assert>
 8002484:	4603      	mov	r3, r0
 8002486:	2b00      	cmp	r3, #0
 8002488:	d002      	beq.n	8002490 <rt_test_005_001_execute.lto_priv.758+0x90>
 800248a:	f7ff ff59 	bl	8002340 <osalSysUnlock.lto_priv.32>
 800248e:	e01f      	b.n	80024d0 <rt_test_005_001_execute.lto_priv.758+0xd0>
 8002490:	f7ff ff56 	bl	8002340 <osalSysUnlock.lto_priv.32>
  }

  /* [5.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 8002494:	4b10      	ldr	r3, [pc, #64]	; (80024d8 <rt_test_005_001_execute.lto_priv.758+0xd8>)
 8002496:	2203      	movs	r2, #3
 8002498:	601a      	str	r2, [r3, #0]
  {
    chSemReset(&sem1, 2);
 800249a:	2102      	movs	r1, #2
 800249c:	480f      	ldr	r0, [pc, #60]	; (80024dc <rt_test_005_001_execute.lto_priv.758+0xdc>)
 800249e:	f00e fcdf 	bl	8010e60 <chSemReset>
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 80024a2:	f7ff ff45 	bl	8002330 <osalSysLock.lto_priv.35>
 80024a6:	480d      	ldr	r0, [pc, #52]	; (80024dc <rt_test_005_001_execute.lto_priv.758+0xdc>)
 80024a8:	f7ff fec2 	bl	8002230 <chSemGetCounterI>
 80024ac:	4603      	mov	r3, r0
 80024ae:	2b02      	cmp	r3, #2
 80024b0:	bf0c      	ite	eq
 80024b2:	2301      	moveq	r3, #1
 80024b4:	2300      	movne	r3, #0
 80024b6:	b2db      	uxtb	r3, r3
 80024b8:	4909      	ldr	r1, [pc, #36]	; (80024e0 <rt_test_005_001_execute.lto_priv.758+0xe0>)
 80024ba:	4618      	mov	r0, r3
 80024bc:	f012 ffe0 	bl	8015480 <_test_assert>
 80024c0:	4603      	mov	r3, r0
 80024c2:	2b00      	cmp	r3, #0
 80024c4:	d002      	beq.n	80024cc <rt_test_005_001_execute.lto_priv.758+0xcc>
 80024c6:	f7ff ff3b 	bl	8002340 <osalSysUnlock.lto_priv.32>
 80024ca:	e001      	b.n	80024d0 <rt_test_005_001_execute.lto_priv.758+0xd0>
 80024cc:	f7ff ff38 	bl	8002340 <osalSysUnlock.lto_priv.32>
  }
}
 80024d0:	b003      	add	sp, #12
 80024d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80024d6:	bf00      	nop
 80024d8:	20001988 	.word	0x20001988
 80024dc:	20002030 	.word	0x20002030
 80024e0:	08018084 	.word	0x08018084
 80024e4:	08018040 	.word	0x08018040
	...

080024f0 <rt_test_005_002_setup.lto_priv.759>:
 * - [5.2.2] The semaphore is signaled 5 times. The thread activation
 *   sequence is tested.
 * .
 */

static void rt_test_005_002_setup(void) {
 80024f0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 80024f2:	2100      	movs	r1, #0
 80024f4:	4801      	ldr	r0, [pc, #4]	; (80024fc <rt_test_005_002_setup.lto_priv.759+0xc>)
 80024f6:	f00e fc93 	bl	8010e20 <chSemObjectInit>
}
 80024fa:	bd08      	pop	{r3, pc}
 80024fc:	20002030 	.word	0x20002030

08002500 <rt_test_005_002_execute.lto_priv.760>:

static void rt_test_005_002_execute(void) {
 8002500:	b510      	push	{r4, lr}
 8002502:	b082      	sub	sp, #8

  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 8002504:	4b38      	ldr	r3, [pc, #224]	; (80025e8 <rt_test_005_002_execute.lto_priv.760+0xe8>)
 8002506:	2201      	movs	r2, #1
 8002508:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800250a:	4b38      	ldr	r3, [pc, #224]	; (80025ec <rt_test_005_002_execute.lto_priv.760+0xec>)
 800250c:	681c      	ldr	r4, [r3, #0]
 800250e:	f7ff fe87 	bl	8002220 <chThdGetPriorityX.lto_priv.91>
 8002512:	4603      	mov	r3, r0
 8002514:	1d5a      	adds	r2, r3, #5
 8002516:	4b36      	ldr	r3, [pc, #216]	; (80025f0 <rt_test_005_002_execute.lto_priv.760+0xf0>)
 8002518:	9300      	str	r3, [sp, #0]
 800251a:	4b36      	ldr	r3, [pc, #216]	; (80025f4 <rt_test_005_002_execute.lto_priv.760+0xf4>)
 800251c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002520:	4620      	mov	r0, r4
 8002522:	f00d ffdd 	bl	80104e0 <chThdCreateStatic>
 8002526:	4602      	mov	r2, r0
 8002528:	4b33      	ldr	r3, [pc, #204]	; (80025f8 <rt_test_005_002_execute.lto_priv.760+0xf8>)
 800252a:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800252c:	4b2f      	ldr	r3, [pc, #188]	; (80025ec <rt_test_005_002_execute.lto_priv.760+0xec>)
 800252e:	685c      	ldr	r4, [r3, #4]
 8002530:	f7ff fe76 	bl	8002220 <chThdGetPriorityX.lto_priv.91>
 8002534:	4603      	mov	r3, r0
 8002536:	1c5a      	adds	r2, r3, #1
 8002538:	4b30      	ldr	r3, [pc, #192]	; (80025fc <rt_test_005_002_execute.lto_priv.760+0xfc>)
 800253a:	9300      	str	r3, [sp, #0]
 800253c:	4b2d      	ldr	r3, [pc, #180]	; (80025f4 <rt_test_005_002_execute.lto_priv.760+0xf4>)
 800253e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002542:	4620      	mov	r0, r4
 8002544:	f00d ffcc 	bl	80104e0 <chThdCreateStatic>
 8002548:	4602      	mov	r2, r0
 800254a:	4b2b      	ldr	r3, [pc, #172]	; (80025f8 <rt_test_005_002_execute.lto_priv.760+0xf8>)
 800254c:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800254e:	4b27      	ldr	r3, [pc, #156]	; (80025ec <rt_test_005_002_execute.lto_priv.760+0xec>)
 8002550:	689c      	ldr	r4, [r3, #8]
 8002552:	f7ff fe65 	bl	8002220 <chThdGetPriorityX.lto_priv.91>
 8002556:	4603      	mov	r3, r0
 8002558:	1cda      	adds	r2, r3, #3
 800255a:	4b29      	ldr	r3, [pc, #164]	; (8002600 <rt_test_005_002_execute.lto_priv.760+0x100>)
 800255c:	9300      	str	r3, [sp, #0]
 800255e:	4b25      	ldr	r3, [pc, #148]	; (80025f4 <rt_test_005_002_execute.lto_priv.760+0xf4>)
 8002560:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002564:	4620      	mov	r0, r4
 8002566:	f00d ffbb 	bl	80104e0 <chThdCreateStatic>
 800256a:	4602      	mov	r2, r0
 800256c:	4b22      	ldr	r3, [pc, #136]	; (80025f8 <rt_test_005_002_execute.lto_priv.760+0xf8>)
 800256e:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8002570:	4b1e      	ldr	r3, [pc, #120]	; (80025ec <rt_test_005_002_execute.lto_priv.760+0xec>)
 8002572:	68dc      	ldr	r4, [r3, #12]
 8002574:	f7ff fe54 	bl	8002220 <chThdGetPriorityX.lto_priv.91>
 8002578:	4603      	mov	r3, r0
 800257a:	1d1a      	adds	r2, r3, #4
 800257c:	4b21      	ldr	r3, [pc, #132]	; (8002604 <rt_test_005_002_execute.lto_priv.760+0x104>)
 800257e:	9300      	str	r3, [sp, #0]
 8002580:	4b1c      	ldr	r3, [pc, #112]	; (80025f4 <rt_test_005_002_execute.lto_priv.760+0xf4>)
 8002582:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002586:	4620      	mov	r0, r4
 8002588:	f00d ffaa 	bl	80104e0 <chThdCreateStatic>
 800258c:	4602      	mov	r2, r0
 800258e:	4b1a      	ldr	r3, [pc, #104]	; (80025f8 <rt_test_005_002_execute.lto_priv.760+0xf8>)
 8002590:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8002592:	4b16      	ldr	r3, [pc, #88]	; (80025ec <rt_test_005_002_execute.lto_priv.760+0xec>)
 8002594:	691c      	ldr	r4, [r3, #16]
 8002596:	f7ff fe43 	bl	8002220 <chThdGetPriorityX.lto_priv.91>
 800259a:	4603      	mov	r3, r0
 800259c:	1c9a      	adds	r2, r3, #2
 800259e:	4b1a      	ldr	r3, [pc, #104]	; (8002608 <rt_test_005_002_execute.lto_priv.760+0x108>)
 80025a0:	9300      	str	r3, [sp, #0]
 80025a2:	4b14      	ldr	r3, [pc, #80]	; (80025f4 <rt_test_005_002_execute.lto_priv.760+0xf4>)
 80025a4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80025a8:	4620      	mov	r0, r4
 80025aa:	f00d ff99 	bl	80104e0 <chThdCreateStatic>
 80025ae:	4602      	mov	r2, r0
 80025b0:	4b11      	ldr	r3, [pc, #68]	; (80025f8 <rt_test_005_002_execute.lto_priv.760+0xf8>)
 80025b2:	611a      	str	r2, [r3, #16]
  }

  /* [5.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 80025b4:	4b0c      	ldr	r3, [pc, #48]	; (80025e8 <rt_test_005_002_execute.lto_priv.760+0xe8>)
 80025b6:	2202      	movs	r2, #2
 80025b8:	601a      	str	r2, [r3, #0]
  {
    chSemSignal(&sem1);
 80025ba:	4814      	ldr	r0, [pc, #80]	; (800260c <rt_test_005_002_execute.lto_priv.760+0x10c>)
 80025bc:	f00e fd90 	bl	80110e0 <chSemSignal>
    chSemSignal(&sem1);
 80025c0:	4812      	ldr	r0, [pc, #72]	; (800260c <rt_test_005_002_execute.lto_priv.760+0x10c>)
 80025c2:	f00e fd8d 	bl	80110e0 <chSemSignal>
    chSemSignal(&sem1);
 80025c6:	4811      	ldr	r0, [pc, #68]	; (800260c <rt_test_005_002_execute.lto_priv.760+0x10c>)
 80025c8:	f00e fd8a 	bl	80110e0 <chSemSignal>
    chSemSignal(&sem1);
 80025cc:	480f      	ldr	r0, [pc, #60]	; (800260c <rt_test_005_002_execute.lto_priv.760+0x10c>)
 80025ce:	f00e fd87 	bl	80110e0 <chSemSignal>
    chSemSignal(&sem1);
 80025d2:	480e      	ldr	r0, [pc, #56]	; (800260c <rt_test_005_002_execute.lto_priv.760+0x10c>)
 80025d4:	f00e fd84 	bl	80110e0 <chSemSignal>
    test_wait_threads();
 80025d8:	f7fe fbd2 	bl	8000d80 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
 80025dc:	490c      	ldr	r1, [pc, #48]	; (8002610 <rt_test_005_002_execute.lto_priv.760+0x110>)
 80025de:	480d      	ldr	r0, [pc, #52]	; (8002614 <rt_test_005_002_execute.lto_priv.760+0x114>)
 80025e0:	f012 ff66 	bl	80154b0 <_test_assert_sequence>
#endif
  }
}
 80025e4:	b002      	add	sp, #8
 80025e6:	bd10      	pop	{r4, pc}
 80025e8:	20001988 	.word	0x20001988
 80025ec:	08017360 	.word	0x08017360
 80025f0:	08017f34 	.word	0x08017f34
 80025f4:	08002351 	.word	0x08002351
 80025f8:	20002018 	.word	0x20002018
 80025fc:	08017f30 	.word	0x08017f30
 8002600:	08017f2c 	.word	0x08017f2c
 8002604:	0801622c 	.word	0x0801622c
 8002608:	08017f50 	.word	0x08017f50
 800260c:	20002030 	.word	0x20002030
 8002610:	08017f38 	.word	0x08017f38
 8002614:	08017f4c 	.word	0x08017f4c
	...

08002620 <rt_test_005_003_setup.lto_priv.761>:
 * - [5.3.2] Testing non-timeout condition.
 * - [5.3.3] Testing timeout condition.
 * .
 */

static void rt_test_005_003_setup(void) {
 8002620:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 8002622:	2100      	movs	r1, #0
 8002624:	4801      	ldr	r0, [pc, #4]	; (800262c <rt_test_005_003_setup.lto_priv.761+0xc>)
 8002626:	f00e fbfb 	bl	8010e20 <chSemObjectInit>
}
 800262a:	bd08      	pop	{r3, pc}
 800262c:	20002030 	.word	0x20002030

08002630 <rt_test_005_003_execute.lto_priv.762>:

static void rt_test_005_003_execute(void) {
 8002630:	b510      	push	{r4, lr}
 8002632:	b086      	sub	sp, #24
  unsigned i;
  systime_t target_time;
  msg_t msg;

  /* [5.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
 8002634:	4b67      	ldr	r3, [pc, #412]	; (80027d4 <rt_test_005_003_execute.lto_priv.762+0x1a4>)
 8002636:	2201      	movs	r2, #1
 8002638:	601a      	str	r2, [r3, #0]
  {
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 800263a:	2100      	movs	r1, #0
 800263c:	4866      	ldr	r0, [pc, #408]	; (80027d8 <rt_test_005_003_execute.lto_priv.762+0x1a8>)
 800263e:	f00e fcd7 	bl	8010ff0 <chSemWaitTimeout>
 8002642:	9004      	str	r0, [sp, #16]
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8002644:	9b04      	ldr	r3, [sp, #16]
 8002646:	f1b3 3fff 	cmp.w	r3, #4294967295
 800264a:	bf0c      	ite	eq
 800264c:	2301      	moveq	r3, #1
 800264e:	2300      	movne	r3, #0
 8002650:	b2db      	uxtb	r3, r3
 8002652:	4962      	ldr	r1, [pc, #392]	; (80027dc <rt_test_005_003_execute.lto_priv.762+0x1ac>)
 8002654:	4618      	mov	r0, r3
 8002656:	f012 ff13 	bl	8015480 <_test_assert>
 800265a:	4603      	mov	r3, r0
 800265c:	2b00      	cmp	r3, #0
 800265e:	f040 80b7 	bne.w	80027d0 <rt_test_005_003_execute.lto_priv.762+0x1a0>
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8002662:	485d      	ldr	r0, [pc, #372]	; (80027d8 <rt_test_005_003_execute.lto_priv.762+0x1a8>)
 8002664:	f7ff fd9c 	bl	80021a0 <queue_isempty.lto_priv.128>
 8002668:	4603      	mov	r3, r0
 800266a:	495d      	ldr	r1, [pc, #372]	; (80027e0 <rt_test_005_003_execute.lto_priv.762+0x1b0>)
 800266c:	4618      	mov	r0, r3
 800266e:	f012 ff07 	bl	8015480 <_test_assert>
 8002672:	4603      	mov	r3, r0
 8002674:	2b00      	cmp	r3, #0
 8002676:	f040 80ab 	bne.w	80027d0 <rt_test_005_003_execute.lto_priv.762+0x1a0>
    test_assert(sem1.cnt == 0, "counter not zero");
 800267a:	4b57      	ldr	r3, [pc, #348]	; (80027d8 <rt_test_005_003_execute.lto_priv.762+0x1a8>)
 800267c:	689b      	ldr	r3, [r3, #8]
 800267e:	2b00      	cmp	r3, #0
 8002680:	bf0c      	ite	eq
 8002682:	2301      	moveq	r3, #1
 8002684:	2300      	movne	r3, #0
 8002686:	b2db      	uxtb	r3, r3
 8002688:	4956      	ldr	r1, [pc, #344]	; (80027e4 <rt_test_005_003_execute.lto_priv.762+0x1b4>)
 800268a:	4618      	mov	r0, r3
 800268c:	f012 fef8 	bl	8015480 <_test_assert>
 8002690:	4603      	mov	r3, r0
 8002692:	2b00      	cmp	r3, #0
 8002694:	f040 809c 	bne.w	80027d0 <rt_test_005_003_execute.lto_priv.762+0x1a0>
  }

  /* [5.3.2] Testing non-timeout condition.*/
  test_set_step(2);
 8002698:	4b4e      	ldr	r3, [pc, #312]	; (80027d4 <rt_test_005_003_execute.lto_priv.762+0x1a4>)
 800269a:	2202      	movs	r2, #2
 800269c:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800269e:	4b52      	ldr	r3, [pc, #328]	; (80027e8 <rt_test_005_003_execute.lto_priv.762+0x1b8>)
 80026a0:	681c      	ldr	r4, [r3, #0]
 80026a2:	f7ff fdbd 	bl	8002220 <chThdGetPriorityX.lto_priv.91>
 80026a6:	4603      	mov	r3, r0
 80026a8:	1e5a      	subs	r2, r3, #1
 80026aa:	2300      	movs	r3, #0
 80026ac:	9300      	str	r3, [sp, #0]
 80026ae:	4b4f      	ldr	r3, [pc, #316]	; (80027ec <rt_test_005_003_execute.lto_priv.762+0x1bc>)
 80026b0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80026b4:	4620      	mov	r0, r4
 80026b6:	f00d ff13 	bl	80104e0 <chThdCreateStatic>
 80026ba:	4602      	mov	r2, r0
 80026bc:	4b4c      	ldr	r3, [pc, #304]	; (80027f0 <rt_test_005_003_execute.lto_priv.762+0x1c0>)
 80026be:	601a      	str	r2, [r3, #0]
                                   thread2, 0);
    msg = chSemWaitTimeout(&sem1, TIME_MS2I(500));
 80026c0:	f241 3188 	movw	r1, #5000	; 0x1388
 80026c4:	4844      	ldr	r0, [pc, #272]	; (80027d8 <rt_test_005_003_execute.lto_priv.762+0x1a8>)
 80026c6:	f00e fc93 	bl	8010ff0 <chSemWaitTimeout>
 80026ca:	9004      	str	r0, [sp, #16]
    test_wait_threads();
 80026cc:	f7fe fb58 	bl	8000d80 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 80026d0:	9b04      	ldr	r3, [sp, #16]
 80026d2:	2b00      	cmp	r3, #0
 80026d4:	bf0c      	ite	eq
 80026d6:	2301      	moveq	r3, #1
 80026d8:	2300      	movne	r3, #0
 80026da:	b2db      	uxtb	r3, r3
 80026dc:	493f      	ldr	r1, [pc, #252]	; (80027dc <rt_test_005_003_execute.lto_priv.762+0x1ac>)
 80026de:	4618      	mov	r0, r3
 80026e0:	f012 fece 	bl	8015480 <_test_assert>
 80026e4:	4603      	mov	r3, r0
 80026e6:	2b00      	cmp	r3, #0
 80026e8:	d172      	bne.n	80027d0 <rt_test_005_003_execute.lto_priv.762+0x1a0>
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80026ea:	483b      	ldr	r0, [pc, #236]	; (80027d8 <rt_test_005_003_execute.lto_priv.762+0x1a8>)
 80026ec:	f7ff fd58 	bl	80021a0 <queue_isempty.lto_priv.128>
 80026f0:	4603      	mov	r3, r0
 80026f2:	493b      	ldr	r1, [pc, #236]	; (80027e0 <rt_test_005_003_execute.lto_priv.762+0x1b0>)
 80026f4:	4618      	mov	r0, r3
 80026f6:	f012 fec3 	bl	8015480 <_test_assert>
 80026fa:	4603      	mov	r3, r0
 80026fc:	2b00      	cmp	r3, #0
 80026fe:	d167      	bne.n	80027d0 <rt_test_005_003_execute.lto_priv.762+0x1a0>
    test_assert(sem1.cnt == 0, "counter not zero");
 8002700:	4b35      	ldr	r3, [pc, #212]	; (80027d8 <rt_test_005_003_execute.lto_priv.762+0x1a8>)
 8002702:	689b      	ldr	r3, [r3, #8]
 8002704:	2b00      	cmp	r3, #0
 8002706:	bf0c      	ite	eq
 8002708:	2301      	moveq	r3, #1
 800270a:	2300      	movne	r3, #0
 800270c:	b2db      	uxtb	r3, r3
 800270e:	4935      	ldr	r1, [pc, #212]	; (80027e4 <rt_test_005_003_execute.lto_priv.762+0x1b4>)
 8002710:	4618      	mov	r0, r3
 8002712:	f012 feb5 	bl	8015480 <_test_assert>
 8002716:	4603      	mov	r3, r0
 8002718:	2b00      	cmp	r3, #0
 800271a:	d159      	bne.n	80027d0 <rt_test_005_003_execute.lto_priv.762+0x1a0>
  }

  /* [5.3.3] Testing timeout condition.*/
  test_set_step(3);
 800271c:	4b2d      	ldr	r3, [pc, #180]	; (80027d4 <rt_test_005_003_execute.lto_priv.762+0x1a4>)
 800271e:	2203      	movs	r2, #3
 8002720:	601a      	str	r2, [r3, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
 8002722:	f7fe fb55 	bl	8000dd0 <test_wait_tick>
 8002726:	4603      	mov	r3, r0
 8002728:	f640 11c4 	movw	r1, #2500	; 0x9c4
 800272c:	4618      	mov	r0, r3
 800272e:	f7ff fd17 	bl	8002160 <chTimeAddX.lto_priv.122>
 8002732:	9003      	str	r0, [sp, #12]
    for (i = 0; i < 5; i++) {
 8002734:	2300      	movs	r3, #0
 8002736:	9305      	str	r3, [sp, #20]
 8002738:	e036      	b.n	80027a8 <rt_test_005_003_execute.lto_priv.762+0x178>
      test_emit_token('A' + i);
 800273a:	9b05      	ldr	r3, [sp, #20]
 800273c:	b2db      	uxtb	r3, r3
 800273e:	3341      	adds	r3, #65	; 0x41
 8002740:	b2db      	uxtb	r3, r3
 8002742:	4618      	mov	r0, r3
 8002744:	f012 ff7c 	bl	8015640 <test_emit_token>
      msg = chSemWaitTimeout(&sem1, TIME_MS2I(50));
 8002748:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800274c:	4822      	ldr	r0, [pc, #136]	; (80027d8 <rt_test_005_003_execute.lto_priv.762+0x1a8>)
 800274e:	f00e fc4f 	bl	8010ff0 <chSemWaitTimeout>
 8002752:	9004      	str	r0, [sp, #16]
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8002754:	9b04      	ldr	r3, [sp, #16]
 8002756:	f1b3 3fff 	cmp.w	r3, #4294967295
 800275a:	bf0c      	ite	eq
 800275c:	2301      	moveq	r3, #1
 800275e:	2300      	movne	r3, #0
 8002760:	b2db      	uxtb	r3, r3
 8002762:	491e      	ldr	r1, [pc, #120]	; (80027dc <rt_test_005_003_execute.lto_priv.762+0x1ac>)
 8002764:	4618      	mov	r0, r3
 8002766:	f012 fe8b 	bl	8015480 <_test_assert>
 800276a:	4603      	mov	r3, r0
 800276c:	2b00      	cmp	r3, #0
 800276e:	d12f      	bne.n	80027d0 <rt_test_005_003_execute.lto_priv.762+0x1a0>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8002770:	4819      	ldr	r0, [pc, #100]	; (80027d8 <rt_test_005_003_execute.lto_priv.762+0x1a8>)
 8002772:	f7ff fd15 	bl	80021a0 <queue_isempty.lto_priv.128>
 8002776:	4603      	mov	r3, r0
 8002778:	4919      	ldr	r1, [pc, #100]	; (80027e0 <rt_test_005_003_execute.lto_priv.762+0x1b0>)
 800277a:	4618      	mov	r0, r3
 800277c:	f012 fe80 	bl	8015480 <_test_assert>
 8002780:	4603      	mov	r3, r0
 8002782:	2b00      	cmp	r3, #0
 8002784:	d124      	bne.n	80027d0 <rt_test_005_003_execute.lto_priv.762+0x1a0>
      test_assert(sem1.cnt == 0, "counter not zero");
 8002786:	4b14      	ldr	r3, [pc, #80]	; (80027d8 <rt_test_005_003_execute.lto_priv.762+0x1a8>)
 8002788:	689b      	ldr	r3, [r3, #8]
 800278a:	2b00      	cmp	r3, #0
 800278c:	bf0c      	ite	eq
 800278e:	2301      	moveq	r3, #1
 8002790:	2300      	movne	r3, #0
 8002792:	b2db      	uxtb	r3, r3
 8002794:	4913      	ldr	r1, [pc, #76]	; (80027e4 <rt_test_005_003_execute.lto_priv.762+0x1b4>)
 8002796:	4618      	mov	r0, r3
 8002798:	f012 fe72 	bl	8015480 <_test_assert>
 800279c:	4603      	mov	r3, r0
 800279e:	2b00      	cmp	r3, #0
 80027a0:	d116      	bne.n	80027d0 <rt_test_005_003_execute.lto_priv.762+0x1a0>
    for (i = 0; i < 5; i++) {
 80027a2:	9b05      	ldr	r3, [sp, #20]
 80027a4:	3301      	adds	r3, #1
 80027a6:	9305      	str	r3, [sp, #20]
 80027a8:	9b05      	ldr	r3, [sp, #20]
 80027aa:	2b04      	cmp	r3, #4
 80027ac:	d9c5      	bls.n	800273a <rt_test_005_003_execute.lto_priv.762+0x10a>
    }
    test_assert_sequence("ABCDE", "invalid sequence");
 80027ae:	4911      	ldr	r1, [pc, #68]	; (80027f4 <rt_test_005_003_execute.lto_priv.762+0x1c4>)
 80027b0:	4811      	ldr	r0, [pc, #68]	; (80027f8 <rt_test_005_003_execute.lto_priv.762+0x1c8>)
 80027b2:	f012 fe7d 	bl	80154b0 <_test_assert_sequence>
 80027b6:	4603      	mov	r3, r0
 80027b8:	2b00      	cmp	r3, #0
 80027ba:	d109      	bne.n	80027d0 <rt_test_005_003_execute.lto_priv.762+0x1a0>
    test_assert_time_window(target_time,
 80027bc:	2114      	movs	r1, #20
 80027be:	9803      	ldr	r0, [sp, #12]
 80027c0:	f7ff fcce 	bl	8002160 <chTimeAddX.lto_priv.122>
 80027c4:	4603      	mov	r3, r0
 80027c6:	4a0d      	ldr	r2, [pc, #52]	; (80027fc <rt_test_005_003_execute.lto_priv.762+0x1cc>)
 80027c8:	4619      	mov	r1, r3
 80027ca:	9803      	ldr	r0, [sp, #12]
 80027cc:	f012 fea0 	bl	8015510 <_test_assert_time_window>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
  }
}
 80027d0:	b006      	add	sp, #24
 80027d2:	bd10      	pop	{r4, pc}
 80027d4:	20001988 	.word	0x20001988
 80027d8:	20002030 	.word	0x20002030
 80027dc:	080180b8 	.word	0x080180b8
 80027e0:	080180d0 	.word	0x080180d0
 80027e4:	080180e0 	.word	0x080180e0
 80027e8:	08017360 	.word	0x08017360
 80027ec:	08002371 	.word	0x08002371
 80027f0:	20002018 	.word	0x20002018
 80027f4:	08017f38 	.word	0x08017f38
 80027f8:	08017f4c 	.word	0x08017f4c
 80027fc:	08017f08 	.word	0x08017f08

08002800 <rt_test_005_004_setup.lto_priv.763>:
 * - [5.4.2] The semaphore counter is increased by two, it is then
 *   tested to be one, the thread must have completed.
 * .
 */

static void rt_test_005_004_setup(void) {
 8002800:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 8002802:	2100      	movs	r1, #0
 8002804:	4801      	ldr	r0, [pc, #4]	; (800280c <rt_test_005_004_setup.lto_priv.763+0xc>)
 8002806:	f00e fb0b 	bl	8010e20 <chSemObjectInit>
}
 800280a:	bd08      	pop	{r3, pc}
 800280c:	20002030 	.word	0x20002030

08002810 <rt_test_005_004_execute.lto_priv.764>:

static void rt_test_005_004_execute(void) {
 8002810:	b510      	push	{r4, lr}
 8002812:	b082      	sub	sp, #8

  /* [5.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 8002814:	4b1f      	ldr	r3, [pc, #124]	; (8002894 <rt_test_005_004_execute.lto_priv.764+0x84>)
 8002816:	2201      	movs	r2, #1
 8002818:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 800281a:	4b1f      	ldr	r3, [pc, #124]	; (8002898 <rt_test_005_004_execute.lto_priv.764+0x88>)
 800281c:	681c      	ldr	r4, [r3, #0]
 800281e:	f7ff fcff 	bl	8002220 <chThdGetPriorityX.lto_priv.91>
 8002822:	4603      	mov	r3, r0
 8002824:	1c5a      	adds	r2, r3, #1
 8002826:	4b1d      	ldr	r3, [pc, #116]	; (800289c <rt_test_005_004_execute.lto_priv.764+0x8c>)
 8002828:	9300      	str	r3, [sp, #0]
 800282a:	4b1d      	ldr	r3, [pc, #116]	; (80028a0 <rt_test_005_004_execute.lto_priv.764+0x90>)
 800282c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002830:	4620      	mov	r0, r4
 8002832:	f00d fe55 	bl	80104e0 <chThdCreateStatic>
 8002836:	4602      	mov	r2, r0
 8002838:	4b1a      	ldr	r3, [pc, #104]	; (80028a4 <rt_test_005_004_execute.lto_priv.764+0x94>)
 800283a:	601a      	str	r2, [r3, #0]
  }

  /* [5.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
 800283c:	4b15      	ldr	r3, [pc, #84]	; (8002894 <rt_test_005_004_execute.lto_priv.764+0x84>)
 800283e:	2202      	movs	r2, #2
 8002840:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8002842:	f7ff fcbd 	bl	80021c0 <chSysLock.lto_priv.78>
    chSemAddCounterI(&sem1, 2);
 8002846:	2102      	movs	r1, #2
 8002848:	4817      	ldr	r0, [pc, #92]	; (80028a8 <rt_test_005_004_execute.lto_priv.764+0x98>)
 800284a:	f00e fcd9 	bl	8011200 <chSemAddCounterI>
    chSchRescheduleS();
 800284e:	f00d fb2f 	bl	800feb0 <chSchRescheduleS>
    chSysUnlock();
 8002852:	f7ff fcbd 	bl	80021d0 <chSysUnlock.lto_priv.42>
    test_wait_threads();
 8002856:	f7fe fa93 	bl	8000d80 <test_wait_threads>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 800285a:	f7ff fd69 	bl	8002330 <osalSysLock.lto_priv.35>
 800285e:	4812      	ldr	r0, [pc, #72]	; (80028a8 <rt_test_005_004_execute.lto_priv.764+0x98>)
 8002860:	f7ff fce6 	bl	8002230 <chSemGetCounterI>
 8002864:	4603      	mov	r3, r0
 8002866:	2b01      	cmp	r3, #1
 8002868:	bf0c      	ite	eq
 800286a:	2301      	moveq	r3, #1
 800286c:	2300      	movne	r3, #0
 800286e:	b2db      	uxtb	r3, r3
 8002870:	490e      	ldr	r1, [pc, #56]	; (80028ac <rt_test_005_004_execute.lto_priv.764+0x9c>)
 8002872:	4618      	mov	r0, r3
 8002874:	f012 fe04 	bl	8015480 <_test_assert>
 8002878:	4603      	mov	r3, r0
 800287a:	2b00      	cmp	r3, #0
 800287c:	d002      	beq.n	8002884 <rt_test_005_004_execute.lto_priv.764+0x74>
 800287e:	f7ff fd5f 	bl	8002340 <osalSysUnlock.lto_priv.32>
 8002882:	e005      	b.n	8002890 <rt_test_005_004_execute.lto_priv.764+0x80>
 8002884:	f7ff fd5c 	bl	8002340 <osalSysUnlock.lto_priv.32>
    test_assert_sequence("A", "invalid sequence");
 8002888:	4909      	ldr	r1, [pc, #36]	; (80028b0 <rt_test_005_004_execute.lto_priv.764+0xa0>)
 800288a:	4804      	ldr	r0, [pc, #16]	; (800289c <rt_test_005_004_execute.lto_priv.764+0x8c>)
 800288c:	f012 fe10 	bl	80154b0 <_test_assert_sequence>
  }
}
 8002890:	b002      	add	sp, #8
 8002892:	bd10      	pop	{r4, pc}
 8002894:	20001988 	.word	0x20001988
 8002898:	08017360 	.word	0x08017360
 800289c:	08017f34 	.word	0x08017f34
 80028a0:	08002351 	.word	0x08002351
 80028a4:	20002018 	.word	0x20002018
 80028a8:	20002030 	.word	0x20002030
 80028ac:	08018104 	.word	0x08018104
 80028b0:	08017f38 	.word	0x08017f38
	...

080028c0 <rt_test_005_005_setup.lto_priv.765>:
 *   specifying the same semaphore for the wait and signal phases. The
 *   counter value must be one on exit.
 * .
 */

static void rt_test_005_005_setup(void) {
 80028c0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 80028c2:	2100      	movs	r1, #0
 80028c4:	4801      	ldr	r0, [pc, #4]	; (80028cc <rt_test_005_005_setup.lto_priv.765+0xc>)
 80028c6:	f00e faab 	bl	8010e20 <chSemObjectInit>
}
 80028ca:	bd08      	pop	{r3, pc}
 80028cc:	20002030 	.word	0x20002030

080028d0 <rt_test_005_005_teardown.lto_priv.766>:

static void rt_test_005_005_teardown(void) {
 80028d0:	b508      	push	{r3, lr}
  test_wait_threads();
 80028d2:	f7fe fa55 	bl	8000d80 <test_wait_threads>
}
 80028d6:	bd08      	pop	{r3, pc}
	...

080028e0 <rt_test_005_005_execute.lto_priv.767>:

static void rt_test_005_005_execute(void) {
 80028e0:	b510      	push	{r4, lr}
 80028e2:	b082      	sub	sp, #8

  /* [5.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 80028e4:	4b29      	ldr	r3, [pc, #164]	; (800298c <rt_test_005_005_execute.lto_priv.767+0xac>)
 80028e6:	2201      	movs	r2, #1
 80028e8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80028ea:	4b29      	ldr	r3, [pc, #164]	; (8002990 <rt_test_005_005_execute.lto_priv.767+0xb0>)
 80028ec:	681c      	ldr	r4, [r3, #0]
 80028ee:	f7ff fc97 	bl	8002220 <chThdGetPriorityX.lto_priv.91>
 80028f2:	4603      	mov	r3, r0
 80028f4:	1c5a      	adds	r2, r3, #1
 80028f6:	2300      	movs	r3, #0
 80028f8:	9300      	str	r3, [sp, #0]
 80028fa:	4b26      	ldr	r3, [pc, #152]	; (8002994 <rt_test_005_005_execute.lto_priv.767+0xb4>)
 80028fc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002900:	4620      	mov	r0, r4
 8002902:	f00d fded 	bl	80104e0 <chThdCreateStatic>
 8002906:	4602      	mov	r2, r0
 8002908:	4b23      	ldr	r3, [pc, #140]	; (8002998 <rt_test_005_005_execute.lto_priv.767+0xb8>)
 800290a:	601a      	str	r2, [r3, #0]
  }

  /* [5.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 800290c:	4b1f      	ldr	r3, [pc, #124]	; (800298c <rt_test_005_005_execute.lto_priv.767+0xac>)
 800290e:	2202      	movs	r2, #2
 8002910:	601a      	str	r2, [r3, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 8002912:	4922      	ldr	r1, [pc, #136]	; (800299c <rt_test_005_005_execute.lto_priv.767+0xbc>)
 8002914:	4821      	ldr	r0, [pc, #132]	; (800299c <rt_test_005_005_execute.lto_priv.767+0xbc>)
 8002916:	f00e fcc3 	bl	80112a0 <chSemSignalWait>
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800291a:	4820      	ldr	r0, [pc, #128]	; (800299c <rt_test_005_005_execute.lto_priv.767+0xbc>)
 800291c:	f7ff fc40 	bl	80021a0 <queue_isempty.lto_priv.128>
 8002920:	4603      	mov	r3, r0
 8002922:	491f      	ldr	r1, [pc, #124]	; (80029a0 <rt_test_005_005_execute.lto_priv.767+0xc0>)
 8002924:	4618      	mov	r0, r3
 8002926:	f012 fdab 	bl	8015480 <_test_assert>
 800292a:	4603      	mov	r3, r0
 800292c:	2b00      	cmp	r3, #0
 800292e:	d12a      	bne.n	8002986 <rt_test_005_005_execute.lto_priv.767+0xa6>
    test_assert(sem1.cnt == 0, "counter not zero");
 8002930:	4b1a      	ldr	r3, [pc, #104]	; (800299c <rt_test_005_005_execute.lto_priv.767+0xbc>)
 8002932:	689b      	ldr	r3, [r3, #8]
 8002934:	2b00      	cmp	r3, #0
 8002936:	bf0c      	ite	eq
 8002938:	2301      	moveq	r3, #1
 800293a:	2300      	movne	r3, #0
 800293c:	b2db      	uxtb	r3, r3
 800293e:	4919      	ldr	r1, [pc, #100]	; (80029a4 <rt_test_005_005_execute.lto_priv.767+0xc4>)
 8002940:	4618      	mov	r0, r3
 8002942:	f012 fd9d 	bl	8015480 <_test_assert>
 8002946:	4603      	mov	r3, r0
 8002948:	2b00      	cmp	r3, #0
 800294a:	d11c      	bne.n	8002986 <rt_test_005_005_execute.lto_priv.767+0xa6>
  }

  /* [5.5.3] The function chSemSignalWait() is invoked again by
     specifying the same semaphore for the wait and signal phases. The
     counter value must be one on exit.*/
  test_set_step(3);
 800294c:	4b0f      	ldr	r3, [pc, #60]	; (800298c <rt_test_005_005_execute.lto_priv.767+0xac>)
 800294e:	2203      	movs	r2, #3
 8002950:	601a      	str	r2, [r3, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 8002952:	4912      	ldr	r1, [pc, #72]	; (800299c <rt_test_005_005_execute.lto_priv.767+0xbc>)
 8002954:	4811      	ldr	r0, [pc, #68]	; (800299c <rt_test_005_005_execute.lto_priv.767+0xbc>)
 8002956:	f00e fca3 	bl	80112a0 <chSemSignalWait>
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800295a:	4810      	ldr	r0, [pc, #64]	; (800299c <rt_test_005_005_execute.lto_priv.767+0xbc>)
 800295c:	f7ff fc20 	bl	80021a0 <queue_isempty.lto_priv.128>
 8002960:	4603      	mov	r3, r0
 8002962:	490f      	ldr	r1, [pc, #60]	; (80029a0 <rt_test_005_005_execute.lto_priv.767+0xc0>)
 8002964:	4618      	mov	r0, r3
 8002966:	f012 fd8b 	bl	8015480 <_test_assert>
 800296a:	4603      	mov	r3, r0
 800296c:	2b00      	cmp	r3, #0
 800296e:	d10a      	bne.n	8002986 <rt_test_005_005_execute.lto_priv.767+0xa6>
    test_assert(sem1.cnt == 0, "counter not zero");
 8002970:	4b0a      	ldr	r3, [pc, #40]	; (800299c <rt_test_005_005_execute.lto_priv.767+0xbc>)
 8002972:	689b      	ldr	r3, [r3, #8]
 8002974:	2b00      	cmp	r3, #0
 8002976:	bf0c      	ite	eq
 8002978:	2301      	moveq	r3, #1
 800297a:	2300      	movne	r3, #0
 800297c:	b2db      	uxtb	r3, r3
 800297e:	4909      	ldr	r1, [pc, #36]	; (80029a4 <rt_test_005_005_execute.lto_priv.767+0xc4>)
 8002980:	4618      	mov	r0, r3
 8002982:	f012 fd7d 	bl	8015480 <_test_assert>
  }
}
 8002986:	b002      	add	sp, #8
 8002988:	bd10      	pop	{r4, pc}
 800298a:	bf00      	nop
 800298c:	20001988 	.word	0x20001988
 8002990:	08017360 	.word	0x08017360
 8002994:	080023a1 	.word	0x080023a1
 8002998:	20002018 	.word	0x20002018
 800299c:	20002030 	.word	0x20002030
 80029a0:	080180d0 	.word	0x080180d0
 80029a4:	080180e0 	.word	0x080180e0
	...

080029b0 <rt_test_005_006_teardown.lto_priv.768>:
 * - [5.6.6] Signaling the binary semaphore again, the internal state
 *   must not change from "not taken".
 * .
 */

static void rt_test_005_006_teardown(void) {
 80029b0:	b508      	push	{r3, lr}
  test_wait_threads();
 80029b2:	f7fe f9e5 	bl	8000d80 <test_wait_threads>
}
 80029b6:	bd08      	pop	{r3, pc}
	...

080029c0 <rt_test_005_006_execute.lto_priv.769>:

static void rt_test_005_006_execute(void) {
 80029c0:	b510      	push	{r4, lr}
 80029c2:	b086      	sub	sp, #24
  binary_semaphore_t bsem;
  msg_t msg;

  /* [5.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 80029c4:	4b76      	ldr	r3, [pc, #472]	; (8002ba0 <rt_test_005_006_execute.lto_priv.769+0x1e0>)
 80029c6:	2201      	movs	r2, #1
 80029c8:	601a      	str	r2, [r3, #0]
  {
    chBSemObjectInit(&bsem, true);
 80029ca:	ab02      	add	r3, sp, #8
 80029cc:	2101      	movs	r1, #1
 80029ce:	4618      	mov	r0, r3
 80029d0:	f7ff fc3e 	bl	8002250 <chBSemObjectInit>
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80029d4:	f7ff fcac 	bl	8002330 <osalSysLock.lto_priv.35>
 80029d8:	ab02      	add	r3, sp, #8
 80029da:	4618      	mov	r0, r3
 80029dc:	f7ff fc98 	bl	8002310 <chBSemGetStateI>
 80029e0:	4603      	mov	r3, r0
 80029e2:	4970      	ldr	r1, [pc, #448]	; (8002ba4 <rt_test_005_006_execute.lto_priv.769+0x1e4>)
 80029e4:	4618      	mov	r0, r3
 80029e6:	f012 fd4b 	bl	8015480 <_test_assert>
 80029ea:	4603      	mov	r3, r0
 80029ec:	2b00      	cmp	r3, #0
 80029ee:	d002      	beq.n	80029f6 <rt_test_005_006_execute.lto_priv.769+0x36>
 80029f0:	f7ff fca6 	bl	8002340 <osalSysUnlock.lto_priv.32>
 80029f4:	e0d2      	b.n	8002b9c <rt_test_005_006_execute.lto_priv.769+0x1dc>
 80029f6:	f7ff fca3 	bl	8002340 <osalSysUnlock.lto_priv.32>
  }

  /* [5.6.2] Resetting the binary semaphore in "taken" state, the state
     must not change.*/
  test_set_step(2);
 80029fa:	4b69      	ldr	r3, [pc, #420]	; (8002ba0 <rt_test_005_006_execute.lto_priv.769+0x1e0>)
 80029fc:	2202      	movs	r2, #2
 80029fe:	601a      	str	r2, [r3, #0]
  {
    chBSemReset(&bsem, true);
 8002a00:	ab02      	add	r3, sp, #8
 8002a02:	2101      	movs	r1, #1
 8002a04:	4618      	mov	r0, r3
 8002a06:	f7ff fc4b 	bl	80022a0 <chBSemReset>
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8002a0a:	f7ff fc91 	bl	8002330 <osalSysLock.lto_priv.35>
 8002a0e:	ab02      	add	r3, sp, #8
 8002a10:	4618      	mov	r0, r3
 8002a12:	f7ff fc7d 	bl	8002310 <chBSemGetStateI>
 8002a16:	4603      	mov	r3, r0
 8002a18:	4962      	ldr	r1, [pc, #392]	; (8002ba4 <rt_test_005_006_execute.lto_priv.769+0x1e4>)
 8002a1a:	4618      	mov	r0, r3
 8002a1c:	f012 fd30 	bl	8015480 <_test_assert>
 8002a20:	4603      	mov	r3, r0
 8002a22:	2b00      	cmp	r3, #0
 8002a24:	d002      	beq.n	8002a2c <rt_test_005_006_execute.lto_priv.769+0x6c>
 8002a26:	f7ff fc8b 	bl	8002340 <osalSysUnlock.lto_priv.32>
 8002a2a:	e0b7      	b.n	8002b9c <rt_test_005_006_execute.lto_priv.769+0x1dc>
 8002a2c:	f7ff fc88 	bl	8002340 <osalSysUnlock.lto_priv.32>
  }

  /* [5.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 8002a30:	4b5b      	ldr	r3, [pc, #364]	; (8002ba0 <rt_test_005_006_execute.lto_priv.769+0x1e0>)
 8002a32:	2203      	movs	r2, #3
 8002a34:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8002a36:	4b5c      	ldr	r3, [pc, #368]	; (8002ba8 <rt_test_005_006_execute.lto_priv.769+0x1e8>)
 8002a38:	681c      	ldr	r4, [r3, #0]
                                   chThdGetPriorityX()-1, thread4, &bsem);
 8002a3a:	f7ff fbf1 	bl	8002220 <chThdGetPriorityX.lto_priv.91>
 8002a3e:	4603      	mov	r3, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8002a40:	1e5a      	subs	r2, r3, #1
 8002a42:	ab02      	add	r3, sp, #8
 8002a44:	9300      	str	r3, [sp, #0]
 8002a46:	4b59      	ldr	r3, [pc, #356]	; (8002bac <rt_test_005_006_execute.lto_priv.769+0x1ec>)
 8002a48:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002a4c:	4620      	mov	r0, r4
 8002a4e:	f00d fd47 	bl	80104e0 <chThdCreateStatic>
 8002a52:	4602      	mov	r2, r0
 8002a54:	4b56      	ldr	r3, [pc, #344]	; (8002bb0 <rt_test_005_006_execute.lto_priv.769+0x1f0>)
 8002a56:	601a      	str	r2, [r3, #0]
  }

  /* [5.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
 8002a58:	4b51      	ldr	r3, [pc, #324]	; (8002ba0 <rt_test_005_006_execute.lto_priv.769+0x1e0>)
 8002a5a:	2204      	movs	r2, #4
 8002a5c:	601a      	str	r2, [r3, #0]
  {
    msg = chBSemWait(&bsem);
 8002a5e:	ab02      	add	r3, sp, #8
 8002a60:	4618      	mov	r0, r3
 8002a62:	f7ff fc0d 	bl	8002280 <chBSemWait>
 8002a66:	9005      	str	r0, [sp, #20]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8002a68:	f7ff fc62 	bl	8002330 <osalSysLock.lto_priv.35>
 8002a6c:	ab02      	add	r3, sp, #8
 8002a6e:	4618      	mov	r0, r3
 8002a70:	f7ff fc4e 	bl	8002310 <chBSemGetStateI>
 8002a74:	4603      	mov	r3, r0
 8002a76:	494b      	ldr	r1, [pc, #300]	; (8002ba4 <rt_test_005_006_execute.lto_priv.769+0x1e4>)
 8002a78:	4618      	mov	r0, r3
 8002a7a:	f012 fd01 	bl	8015480 <_test_assert>
 8002a7e:	4603      	mov	r3, r0
 8002a80:	2b00      	cmp	r3, #0
 8002a82:	d002      	beq.n	8002a8a <rt_test_005_006_execute.lto_priv.769+0xca>
 8002a84:	f7ff fc5c 	bl	8002340 <osalSysUnlock.lto_priv.32>
 8002a88:	e088      	b.n	8002b9c <rt_test_005_006_execute.lto_priv.769+0x1dc>
 8002a8a:	f7ff fc59 	bl	8002340 <osalSysUnlock.lto_priv.32>
    test_assert(msg == MSG_OK, "unexpected message");
 8002a8e:	9b05      	ldr	r3, [sp, #20]
 8002a90:	2b00      	cmp	r3, #0
 8002a92:	bf0c      	ite	eq
 8002a94:	2301      	moveq	r3, #1
 8002a96:	2300      	movne	r3, #0
 8002a98:	b2db      	uxtb	r3, r3
 8002a9a:	4946      	ldr	r1, [pc, #280]	; (8002bb4 <rt_test_005_006_execute.lto_priv.769+0x1f4>)
 8002a9c:	4618      	mov	r0, r3
 8002a9e:	f012 fcef 	bl	8015480 <_test_assert>
 8002aa2:	4603      	mov	r3, r0
 8002aa4:	2b00      	cmp	r3, #0
 8002aa6:	d179      	bne.n	8002b9c <rt_test_005_006_execute.lto_priv.769+0x1dc>
  }

  /* [5.6.5] Signaling the binary semaphore, checking the binary
     semaphore state to be "not taken" and the underlying counter
     semaphore counter to be one.*/
  test_set_step(5);
 8002aa8:	4b3d      	ldr	r3, [pc, #244]	; (8002ba0 <rt_test_005_006_execute.lto_priv.769+0x1e0>)
 8002aaa:	2205      	movs	r2, #5
 8002aac:	601a      	str	r2, [r3, #0]
  {
    chBSemSignal(&bsem);
 8002aae:	ab02      	add	r3, sp, #8
 8002ab0:	4618      	mov	r0, r3
 8002ab2:	f7ff fc1d 	bl	80022f0 <chBSemSignal>
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 8002ab6:	f7ff fc3b 	bl	8002330 <osalSysLock.lto_priv.35>
 8002aba:	ab02      	add	r3, sp, #8
 8002abc:	4618      	mov	r0, r3
 8002abe:	f7ff fc27 	bl	8002310 <chBSemGetStateI>
 8002ac2:	4603      	mov	r3, r0
 8002ac4:	2b00      	cmp	r3, #0
 8002ac6:	bf14      	ite	ne
 8002ac8:	2301      	movne	r3, #1
 8002aca:	2300      	moveq	r3, #0
 8002acc:	b2db      	uxtb	r3, r3
 8002ace:	f083 0301 	eor.w	r3, r3, #1
 8002ad2:	b2db      	uxtb	r3, r3
 8002ad4:	f003 0301 	and.w	r3, r3, #1
 8002ad8:	b2db      	uxtb	r3, r3
 8002ada:	4937      	ldr	r1, [pc, #220]	; (8002bb8 <rt_test_005_006_execute.lto_priv.769+0x1f8>)
 8002adc:	4618      	mov	r0, r3
 8002ade:	f012 fccf 	bl	8015480 <_test_assert>
 8002ae2:	4603      	mov	r3, r0
 8002ae4:	2b00      	cmp	r3, #0
 8002ae6:	d002      	beq.n	8002aee <rt_test_005_006_execute.lto_priv.769+0x12e>
 8002ae8:	f7ff fc2a 	bl	8002340 <osalSysUnlock.lto_priv.32>
 8002aec:	e056      	b.n	8002b9c <rt_test_005_006_execute.lto_priv.769+0x1dc>
 8002aee:	f7ff fc27 	bl	8002340 <osalSysUnlock.lto_priv.32>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8002af2:	f7ff fc1d 	bl	8002330 <osalSysLock.lto_priv.35>
 8002af6:	ab02      	add	r3, sp, #8
 8002af8:	4618      	mov	r0, r3
 8002afa:	f7ff fb99 	bl	8002230 <chSemGetCounterI>
 8002afe:	4603      	mov	r3, r0
 8002b00:	2b01      	cmp	r3, #1
 8002b02:	bf0c      	ite	eq
 8002b04:	2301      	moveq	r3, #1
 8002b06:	2300      	movne	r3, #0
 8002b08:	b2db      	uxtb	r3, r3
 8002b0a:	492c      	ldr	r1, [pc, #176]	; (8002bbc <rt_test_005_006_execute.lto_priv.769+0x1fc>)
 8002b0c:	4618      	mov	r0, r3
 8002b0e:	f012 fcb7 	bl	8015480 <_test_assert>
 8002b12:	4603      	mov	r3, r0
 8002b14:	2b00      	cmp	r3, #0
 8002b16:	d002      	beq.n	8002b1e <rt_test_005_006_execute.lto_priv.769+0x15e>
 8002b18:	f7ff fc12 	bl	8002340 <osalSysUnlock.lto_priv.32>
 8002b1c:	e03e      	b.n	8002b9c <rt_test_005_006_execute.lto_priv.769+0x1dc>
 8002b1e:	f7ff fc0f 	bl	8002340 <osalSysUnlock.lto_priv.32>
  }

  /* [5.6.6] Signaling the binary semaphore again, the internal state
     must not change from "not taken".*/
  test_set_step(6);
 8002b22:	4b1f      	ldr	r3, [pc, #124]	; (8002ba0 <rt_test_005_006_execute.lto_priv.769+0x1e0>)
 8002b24:	2206      	movs	r2, #6
 8002b26:	601a      	str	r2, [r3, #0]
  {
    chBSemSignal(&bsem);
 8002b28:	ab02      	add	r3, sp, #8
 8002b2a:	4618      	mov	r0, r3
 8002b2c:	f7ff fbe0 	bl	80022f0 <chBSemSignal>
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 8002b30:	f7ff fbfe 	bl	8002330 <osalSysLock.lto_priv.35>
 8002b34:	ab02      	add	r3, sp, #8
 8002b36:	4618      	mov	r0, r3
 8002b38:	f7ff fbea 	bl	8002310 <chBSemGetStateI>
 8002b3c:	4603      	mov	r3, r0
 8002b3e:	2b00      	cmp	r3, #0
 8002b40:	bf14      	ite	ne
 8002b42:	2301      	movne	r3, #1
 8002b44:	2300      	moveq	r3, #0
 8002b46:	b2db      	uxtb	r3, r3
 8002b48:	f083 0301 	eor.w	r3, r3, #1
 8002b4c:	b2db      	uxtb	r3, r3
 8002b4e:	f003 0301 	and.w	r3, r3, #1
 8002b52:	b2db      	uxtb	r3, r3
 8002b54:	491a      	ldr	r1, [pc, #104]	; (8002bc0 <rt_test_005_006_execute.lto_priv.769+0x200>)
 8002b56:	4618      	mov	r0, r3
 8002b58:	f012 fc92 	bl	8015480 <_test_assert>
 8002b5c:	4603      	mov	r3, r0
 8002b5e:	2b00      	cmp	r3, #0
 8002b60:	d002      	beq.n	8002b68 <rt_test_005_006_execute.lto_priv.769+0x1a8>
 8002b62:	f7ff fbed 	bl	8002340 <osalSysUnlock.lto_priv.32>
 8002b66:	e019      	b.n	8002b9c <rt_test_005_006_execute.lto_priv.769+0x1dc>
 8002b68:	f7ff fbea 	bl	8002340 <osalSysUnlock.lto_priv.32>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8002b6c:	f7ff fbe0 	bl	8002330 <osalSysLock.lto_priv.35>
 8002b70:	ab02      	add	r3, sp, #8
 8002b72:	4618      	mov	r0, r3
 8002b74:	f7ff fb5c 	bl	8002230 <chSemGetCounterI>
 8002b78:	4603      	mov	r3, r0
 8002b7a:	2b01      	cmp	r3, #1
 8002b7c:	bf0c      	ite	eq
 8002b7e:	2301      	moveq	r3, #1
 8002b80:	2300      	movne	r3, #0
 8002b82:	b2db      	uxtb	r3, r3
 8002b84:	490d      	ldr	r1, [pc, #52]	; (8002bbc <rt_test_005_006_execute.lto_priv.769+0x1fc>)
 8002b86:	4618      	mov	r0, r3
 8002b88:	f012 fc7a 	bl	8015480 <_test_assert>
 8002b8c:	4603      	mov	r3, r0
 8002b8e:	2b00      	cmp	r3, #0
 8002b90:	d002      	beq.n	8002b98 <rt_test_005_006_execute.lto_priv.769+0x1d8>
 8002b92:	f7ff fbd5 	bl	8002340 <osalSysUnlock.lto_priv.32>
 8002b96:	e001      	b.n	8002b9c <rt_test_005_006_execute.lto_priv.769+0x1dc>
 8002b98:	f7ff fbd2 	bl	8002340 <osalSysUnlock.lto_priv.32>
  }
}
 8002b9c:	b006      	add	sp, #24
 8002b9e:	bd10      	pop	{r4, pc}
 8002ba0:	20001988 	.word	0x20001988
 8002ba4:	08018134 	.word	0x08018134
 8002ba8:	08017360 	.word	0x08017360
 8002bac:	080023c1 	.word	0x080023c1
 8002bb0:	20002018 	.word	0x20002018
 8002bb4:	08018140 	.word	0x08018140
 8002bb8:	08018154 	.word	0x08018154
 8002bbc:	08018160 	.word	0x08018160
 8002bc0:	08018138 	.word	0x08018138
	...

08002bd0 <port_lock.lto_priv.23>:
static inline void port_lock(void) {
 8002bd0:	b082      	sub	sp, #8
 8002bd2:	2320      	movs	r3, #32
 8002bd4:	9301      	str	r3, [sp, #4]
 8002bd6:	9b01      	ldr	r3, [sp, #4]
 8002bd8:	f383 8811 	msr	BASEPRI, r3
}
 8002bdc:	b002      	add	sp, #8
 8002bde:	4770      	bx	lr

08002be0 <port_unlock.lto_priv.13>:
static inline void port_unlock(void) {
 8002be0:	b082      	sub	sp, #8
 8002be2:	2300      	movs	r3, #0
 8002be4:	9301      	str	r3, [sp, #4]
 8002be6:	9b01      	ldr	r3, [sp, #4]
 8002be8:	f383 8811 	msr	BASEPRI, r3
}
 8002bec:	b002      	add	sp, #8
 8002bee:	4770      	bx	lr

08002bf0 <queue_isempty.lto_priv.129>:
static inline bool queue_isempty(const threads_queue_t *tqp) {
 8002bf0:	b082      	sub	sp, #8
 8002bf2:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next == (const thread_t *)tqp);
 8002bf4:	9b01      	ldr	r3, [sp, #4]
 8002bf6:	681b      	ldr	r3, [r3, #0]
 8002bf8:	9a01      	ldr	r2, [sp, #4]
 8002bfa:	429a      	cmp	r2, r3
 8002bfc:	bf0c      	ite	eq
 8002bfe:	2301      	moveq	r3, #1
 8002c00:	2300      	movne	r3, #0
 8002c02:	b2db      	uxtb	r3, r3
}
 8002c04:	4618      	mov	r0, r3
 8002c06:	b002      	add	sp, #8
 8002c08:	4770      	bx	lr
 8002c0a:	bf00      	nop
 8002c0c:	0000      	movs	r0, r0
	...

08002c10 <chSysLock.lto_priv.79>:
static inline void chSysLock(void) {
 8002c10:	b508      	push	{r3, lr}
  port_lock();
 8002c12:	f7ff ffdd 	bl	8002bd0 <port_lock.lto_priv.23>
  _dbg_check_lock();
 8002c16:	f00c fb53 	bl	800f2c0 <_dbg_check_lock>
}
 8002c1a:	bd08      	pop	{r3, pc}
 8002c1c:	0000      	movs	r0, r0
	...

08002c20 <chSysUnlock.lto_priv.43>:
static inline void chSysUnlock(void) {
 8002c20:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8002c22:	f00c fb65 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002c26:	4b09      	ldr	r3, [pc, #36]	; (8002c4c <chSysUnlock.lto_priv.43+0x2c>)
 8002c28:	681b      	ldr	r3, [r3, #0]
 8002c2a:	4a08      	ldr	r2, [pc, #32]	; (8002c4c <chSysUnlock.lto_priv.43+0x2c>)
 8002c2c:	4293      	cmp	r3, r2
 8002c2e:	d00a      	beq.n	8002c46 <chSysUnlock.lto_priv.43+0x26>
 8002c30:	4b06      	ldr	r3, [pc, #24]	; (8002c4c <chSysUnlock.lto_priv.43+0x2c>)
 8002c32:	699b      	ldr	r3, [r3, #24]
 8002c34:	689a      	ldr	r2, [r3, #8]
 8002c36:	4b05      	ldr	r3, [pc, #20]	; (8002c4c <chSysUnlock.lto_priv.43+0x2c>)
 8002c38:	681b      	ldr	r3, [r3, #0]
 8002c3a:	689b      	ldr	r3, [r3, #8]
 8002c3c:	429a      	cmp	r2, r3
 8002c3e:	d202      	bcs.n	8002c46 <chSysUnlock.lto_priv.43+0x26>
 8002c40:	4803      	ldr	r0, [pc, #12]	; (8002c50 <chSysUnlock.lto_priv.43+0x30>)
 8002c42:	f00c f9cd 	bl	800efe0 <chSysHalt>
  port_unlock();
 8002c46:	f7ff ffcb 	bl	8002be0 <port_unlock.lto_priv.13>
}
 8002c4a:	bd08      	pop	{r3, pc}
 8002c4c:	20001090 	.word	0x20001090
 8002c50:	0801827c 	.word	0x0801827c
	...

08002c60 <chThdGetSelfX.lto_priv.100>:
  return ch.rlist.current;
 8002c60:	4b01      	ldr	r3, [pc, #4]	; (8002c68 <chThdGetSelfX.lto_priv.100+0x8>)
 8002c62:	699b      	ldr	r3, [r3, #24]
}
 8002c64:	4618      	mov	r0, r3
 8002c66:	4770      	bx	lr
 8002c68:	20001090 	.word	0x20001090
 8002c6c:	00000000 	.word	0x00000000

08002c70 <chThdGetPriorityX.lto_priv.92>:
static inline tprio_t chThdGetPriorityX(void) {
 8002c70:	b508      	push	{r3, lr}
  return chThdGetSelfX()->prio;
 8002c72:	f7ff fff5 	bl	8002c60 <chThdGetSelfX.lto_priv.100>
 8002c76:	4603      	mov	r3, r0
 8002c78:	689b      	ldr	r3, [r3, #8]
}
 8002c7a:	4618      	mov	r0, r3
 8002c7c:	bd08      	pop	{r3, pc}
 8002c7e:	bf00      	nop

08002c80 <thread1.lto_priv.127>:
  }
  while (chTimeIsInRangeX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 8002c80:	b500      	push	{lr}
 8002c82:	b083      	sub	sp, #12
 8002c84:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 8002c86:	4807      	ldr	r0, [pc, #28]	; (8002ca4 <thread1.lto_priv.127+0x24>)
 8002c88:	f00e fc6a 	bl	8011560 <chMtxLock>
  test_emit_token(*(char *)p);
 8002c8c:	9b01      	ldr	r3, [sp, #4]
 8002c8e:	781b      	ldrb	r3, [r3, #0]
 8002c90:	4618      	mov	r0, r3
 8002c92:	f012 fcd5 	bl	8015640 <test_emit_token>
  chMtxUnlock(&m1);
 8002c96:	4803      	ldr	r0, [pc, #12]	; (8002ca4 <thread1.lto_priv.127+0x24>)
 8002c98:	f00e fd32 	bl	8011700 <chMtxUnlock>
}
 8002c9c:	b003      	add	sp, #12
 8002c9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ca2:	bf00      	nop
 8002ca4:	20000848 	.word	0x20000848
	...

08002cb0 <thread4A>:
  chMtxUnlock(&m2);
  test_emit_token('A');
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {
 8002cb0:	b500      	push	{lr}
 8002cb2:	b083      	sub	sp, #12
 8002cb4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 8002cb6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002cba:	f00d fda9 	bl	8010810 <chThdSleep>
  chMtxLock(&m1);
 8002cbe:	4804      	ldr	r0, [pc, #16]	; (8002cd0 <thread4A+0x20>)
 8002cc0:	f00e fc4e 	bl	8011560 <chMtxLock>
  chMtxUnlock(&m1);
 8002cc4:	4802      	ldr	r0, [pc, #8]	; (8002cd0 <thread4A+0x20>)
 8002cc6:	f00e fd1b 	bl	8011700 <chMtxUnlock>
}
 8002cca:	b003      	add	sp, #12
 8002ccc:	f85d fb04 	ldr.w	pc, [sp], #4
 8002cd0:	20000848 	.word	0x20000848
	...

08002ce0 <thread4B>:

static THD_FUNCTION(thread4B, p) {
 8002ce0:	b500      	push	{lr}
 8002ce2:	b083      	sub	sp, #12
 8002ce4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(150);
 8002ce6:	f240 50dc 	movw	r0, #1500	; 0x5dc
 8002cea:	f00d fd91 	bl	8010810 <chThdSleep>
  chSysLock();
 8002cee:	f7ff ff8f 	bl	8002c10 <chSysLock.lto_priv.79>
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 8002cf2:	4806      	ldr	r0, [pc, #24]	; (8002d0c <thread4B+0x2c>)
 8002cf4:	f00e fc44 	bl	8011580 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 8002cf8:	4804      	ldr	r0, [pc, #16]	; (8002d0c <thread4B+0x2c>)
 8002cfa:	f00e fd79 	bl	80117f0 <chMtxUnlockS>
  chSchRescheduleS();
 8002cfe:	f00d f8d7 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 8002d02:	f7ff ff8d 	bl	8002c20 <chSysUnlock.lto_priv.43>
}
 8002d06:	b003      	add	sp, #12
 8002d08:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d0c:	20000858 	.word	0x20000858

08002d10 <thread6>:

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
 8002d10:	b500      	push	{lr}
 8002d12:	b083      	sub	sp, #12
 8002d14:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 8002d16:	4808      	ldr	r0, [pc, #32]	; (8002d38 <thread6+0x28>)
 8002d18:	f00e fc22 	bl	8011560 <chMtxLock>
  chCondWait(&c1);
 8002d1c:	4807      	ldr	r0, [pc, #28]	; (8002d3c <thread6+0x2c>)
 8002d1e:	f00e ff5f 	bl	8011be0 <chCondWait>
  test_emit_token(*(char *)p);
 8002d22:	9b01      	ldr	r3, [sp, #4]
 8002d24:	781b      	ldrb	r3, [r3, #0]
 8002d26:	4618      	mov	r0, r3
 8002d28:	f012 fc8a 	bl	8015640 <test_emit_token>
  chMtxUnlock(&m1);
 8002d2c:	4802      	ldr	r0, [pc, #8]	; (8002d38 <thread6+0x28>)
 8002d2e:	f00e fce7 	bl	8011700 <chMtxUnlock>
}
 8002d32:	b003      	add	sp, #12
 8002d34:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d38:	20000848 	.word	0x20000848
 8002d3c:	20000868 	.word	0x20000868

08002d40 <thread8>:

static THD_FUNCTION(thread8, p) {
 8002d40:	b500      	push	{lr}
 8002d42:	b083      	sub	sp, #12
 8002d44:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 8002d46:	480c      	ldr	r0, [pc, #48]	; (8002d78 <thread8+0x38>)
 8002d48:	f00e fc0a 	bl	8011560 <chMtxLock>
  chMtxLock(&m1);
 8002d4c:	480b      	ldr	r0, [pc, #44]	; (8002d7c <thread8+0x3c>)
 8002d4e:	f00e fc07 	bl	8011560 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 8002d52:	f04f 31ff 	mov.w	r1, #4294967295
 8002d56:	480a      	ldr	r0, [pc, #40]	; (8002d80 <thread8+0x40>)
 8002d58:	f00e ff8a 	bl	8011c70 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 8002d5c:	9b01      	ldr	r3, [sp, #4]
 8002d5e:	781b      	ldrb	r3, [r3, #0]
 8002d60:	4618      	mov	r0, r3
 8002d62:	f012 fc6d 	bl	8015640 <test_emit_token>
  chMtxUnlock(&m1);
 8002d66:	4805      	ldr	r0, [pc, #20]	; (8002d7c <thread8+0x3c>)
 8002d68:	f00e fcca 	bl	8011700 <chMtxUnlock>
  chMtxUnlock(&m2);
 8002d6c:	4802      	ldr	r0, [pc, #8]	; (8002d78 <thread8+0x38>)
 8002d6e:	f00e fcc7 	bl	8011700 <chMtxUnlock>
}
 8002d72:	b003      	add	sp, #12
 8002d74:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d78:	20000858 	.word	0x20000858
 8002d7c:	20000848 	.word	0x20000848
 8002d80:	20000868 	.word	0x20000868
	...

08002d90 <thread9>:

static THD_FUNCTION(thread9, p) {
 8002d90:	b500      	push	{lr}
 8002d92:	b083      	sub	sp, #12
 8002d94:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 8002d96:	4807      	ldr	r0, [pc, #28]	; (8002db4 <thread9+0x24>)
 8002d98:	f00e fbe2 	bl	8011560 <chMtxLock>
  test_emit_token(*(char *)p);
 8002d9c:	9b01      	ldr	r3, [sp, #4]
 8002d9e:	781b      	ldrb	r3, [r3, #0]
 8002da0:	4618      	mov	r0, r3
 8002da2:	f012 fc4d 	bl	8015640 <test_emit_token>
  chMtxUnlock(&m2);
 8002da6:	4803      	ldr	r0, [pc, #12]	; (8002db4 <thread9+0x24>)
 8002da8:	f00e fcaa 	bl	8011700 <chMtxUnlock>
}
 8002dac:	b003      	add	sp, #12
 8002dae:	f85d fb04 	ldr.w	pc, [sp], #4
 8002db2:	bf00      	nop
 8002db4:	20000858 	.word	0x20000858
	...

08002dc0 <rt_test_006_001_setup.lto_priv.770>:
 * - [6.1.4] Unlocking the mutex, the threads will wakeup in priority
 *   order because the mutext queue is an ordered one.
 * .
 */

static void rt_test_006_001_setup(void) {
 8002dc0:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
 8002dc2:	4802      	ldr	r0, [pc, #8]	; (8002dcc <rt_test_006_001_setup.lto_priv.770+0xc>)
 8002dc4:	f00e fbb4 	bl	8011530 <chMtxObjectInit>
}
 8002dc8:	bd08      	pop	{r3, pc}
 8002dca:	bf00      	nop
 8002dcc:	20000848 	.word	0x20000848

08002dd0 <rt_test_006_001_execute.lto_priv.771>:

static void rt_test_006_001_execute(void) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b085      	sub	sp, #20
  tprio_t prio;

  /* [6.1.1] Getting the initial priority.*/
  test_set_step(1);
 8002dd4:	4b39      	ldr	r3, [pc, #228]	; (8002ebc <rt_test_006_001_execute.lto_priv.771+0xec>)
 8002dd6:	2201      	movs	r2, #1
 8002dd8:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 8002dda:	f7ff ff49 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 8002dde:	9003      	str	r0, [sp, #12]
  }

  /* [6.1.2] Locking the mutex.*/
  test_set_step(2);
 8002de0:	4b36      	ldr	r3, [pc, #216]	; (8002ebc <rt_test_006_001_execute.lto_priv.771+0xec>)
 8002de2:	2202      	movs	r2, #2
 8002de4:	601a      	str	r2, [r3, #0]
  {
    chMtxLock(&m1);
 8002de6:	4836      	ldr	r0, [pc, #216]	; (8002ec0 <rt_test_006_001_execute.lto_priv.771+0xf0>)
 8002de8:	f00e fbba 	bl	8011560 <chMtxLock>
  }

  /* [6.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 8002dec:	4b33      	ldr	r3, [pc, #204]	; (8002ebc <rt_test_006_001_execute.lto_priv.771+0xec>)
 8002dee:	2203      	movs	r2, #3
 8002df0:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8002df2:	4b34      	ldr	r3, [pc, #208]	; (8002ec4 <rt_test_006_001_execute.lto_priv.771+0xf4>)
 8002df4:	6818      	ldr	r0, [r3, #0]
 8002df6:	9b03      	ldr	r3, [sp, #12]
 8002df8:	1c5a      	adds	r2, r3, #1
 8002dfa:	4b33      	ldr	r3, [pc, #204]	; (8002ec8 <rt_test_006_001_execute.lto_priv.771+0xf8>)
 8002dfc:	9300      	str	r3, [sp, #0]
 8002dfe:	4b33      	ldr	r3, [pc, #204]	; (8002ecc <rt_test_006_001_execute.lto_priv.771+0xfc>)
 8002e00:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002e04:	f00d fb6c 	bl	80104e0 <chThdCreateStatic>
 8002e08:	4602      	mov	r2, r0
 8002e0a:	4b31      	ldr	r3, [pc, #196]	; (8002ed0 <rt_test_006_001_execute.lto_priv.771+0x100>)
 8002e0c:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8002e0e:	4b2d      	ldr	r3, [pc, #180]	; (8002ec4 <rt_test_006_001_execute.lto_priv.771+0xf4>)
 8002e10:	6858      	ldr	r0, [r3, #4]
 8002e12:	9b03      	ldr	r3, [sp, #12]
 8002e14:	1c9a      	adds	r2, r3, #2
 8002e16:	4b2f      	ldr	r3, [pc, #188]	; (8002ed4 <rt_test_006_001_execute.lto_priv.771+0x104>)
 8002e18:	9300      	str	r3, [sp, #0]
 8002e1a:	4b2c      	ldr	r3, [pc, #176]	; (8002ecc <rt_test_006_001_execute.lto_priv.771+0xfc>)
 8002e1c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002e20:	f00d fb5e 	bl	80104e0 <chThdCreateStatic>
 8002e24:	4602      	mov	r2, r0
 8002e26:	4b2a      	ldr	r3, [pc, #168]	; (8002ed0 <rt_test_006_001_execute.lto_priv.771+0x100>)
 8002e28:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8002e2a:	4b26      	ldr	r3, [pc, #152]	; (8002ec4 <rt_test_006_001_execute.lto_priv.771+0xf4>)
 8002e2c:	6898      	ldr	r0, [r3, #8]
 8002e2e:	9b03      	ldr	r3, [sp, #12]
 8002e30:	1cda      	adds	r2, r3, #3
 8002e32:	4b29      	ldr	r3, [pc, #164]	; (8002ed8 <rt_test_006_001_execute.lto_priv.771+0x108>)
 8002e34:	9300      	str	r3, [sp, #0]
 8002e36:	4b25      	ldr	r3, [pc, #148]	; (8002ecc <rt_test_006_001_execute.lto_priv.771+0xfc>)
 8002e38:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002e3c:	f00d fb50 	bl	80104e0 <chThdCreateStatic>
 8002e40:	4602      	mov	r2, r0
 8002e42:	4b23      	ldr	r3, [pc, #140]	; (8002ed0 <rt_test_006_001_execute.lto_priv.771+0x100>)
 8002e44:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8002e46:	4b1f      	ldr	r3, [pc, #124]	; (8002ec4 <rt_test_006_001_execute.lto_priv.771+0xf4>)
 8002e48:	68d8      	ldr	r0, [r3, #12]
 8002e4a:	9b03      	ldr	r3, [sp, #12]
 8002e4c:	1d1a      	adds	r2, r3, #4
 8002e4e:	4b23      	ldr	r3, [pc, #140]	; (8002edc <rt_test_006_001_execute.lto_priv.771+0x10c>)
 8002e50:	9300      	str	r3, [sp, #0]
 8002e52:	4b1e      	ldr	r3, [pc, #120]	; (8002ecc <rt_test_006_001_execute.lto_priv.771+0xfc>)
 8002e54:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002e58:	f00d fb42 	bl	80104e0 <chThdCreateStatic>
 8002e5c:	4602      	mov	r2, r0
 8002e5e:	4b1c      	ldr	r3, [pc, #112]	; (8002ed0 <rt_test_006_001_execute.lto_priv.771+0x100>)
 8002e60:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8002e62:	4b18      	ldr	r3, [pc, #96]	; (8002ec4 <rt_test_006_001_execute.lto_priv.771+0xf4>)
 8002e64:	6918      	ldr	r0, [r3, #16]
 8002e66:	9b03      	ldr	r3, [sp, #12]
 8002e68:	1d5a      	adds	r2, r3, #5
 8002e6a:	4b1d      	ldr	r3, [pc, #116]	; (8002ee0 <rt_test_006_001_execute.lto_priv.771+0x110>)
 8002e6c:	9300      	str	r3, [sp, #0]
 8002e6e:	4b17      	ldr	r3, [pc, #92]	; (8002ecc <rt_test_006_001_execute.lto_priv.771+0xfc>)
 8002e70:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002e74:	f00d fb34 	bl	80104e0 <chThdCreateStatic>
 8002e78:	4602      	mov	r2, r0
 8002e7a:	4b15      	ldr	r3, [pc, #84]	; (8002ed0 <rt_test_006_001_execute.lto_priv.771+0x100>)
 8002e7c:	611a      	str	r2, [r3, #16]
  }

  /* [6.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 8002e7e:	4b0f      	ldr	r3, [pc, #60]	; (8002ebc <rt_test_006_001_execute.lto_priv.771+0xec>)
 8002e80:	2204      	movs	r2, #4
 8002e82:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m1);
 8002e84:	480e      	ldr	r0, [pc, #56]	; (8002ec0 <rt_test_006_001_execute.lto_priv.771+0xf0>)
 8002e86:	f00e fc3b 	bl	8011700 <chMtxUnlock>
    test_wait_threads();
 8002e8a:	f7fd ff79 	bl	8000d80 <test_wait_threads>
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 8002e8e:	f7ff feef 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 8002e92:	4602      	mov	r2, r0
 8002e94:	9b03      	ldr	r3, [sp, #12]
 8002e96:	4293      	cmp	r3, r2
 8002e98:	bf0c      	ite	eq
 8002e9a:	2301      	moveq	r3, #1
 8002e9c:	2300      	movne	r3, #0
 8002e9e:	b2db      	uxtb	r3, r3
 8002ea0:	4910      	ldr	r1, [pc, #64]	; (8002ee4 <rt_test_006_001_execute.lto_priv.771+0x114>)
 8002ea2:	4618      	mov	r0, r3
 8002ea4:	f012 faec 	bl	8015480 <_test_assert>
 8002ea8:	4603      	mov	r3, r0
 8002eaa:	2b00      	cmp	r3, #0
 8002eac:	d103      	bne.n	8002eb6 <rt_test_006_001_execute.lto_priv.771+0xe6>
    test_assert_sequence("ABCDE", "invalid sequence");
 8002eae:	490e      	ldr	r1, [pc, #56]	; (8002ee8 <rt_test_006_001_execute.lto_priv.771+0x118>)
 8002eb0:	480e      	ldr	r0, [pc, #56]	; (8002eec <rt_test_006_001_execute.lto_priv.771+0x11c>)
 8002eb2:	f012 fafd 	bl	80154b0 <_test_assert_sequence>
  }
}
 8002eb6:	b005      	add	sp, #20
 8002eb8:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ebc:	20001988 	.word	0x20001988
 8002ec0:	20000848 	.word	0x20000848
 8002ec4:	08017360 	.word	0x08017360
 8002ec8:	08017f50 	.word	0x08017f50
 8002ecc:	08002c81 	.word	0x08002c81
 8002ed0:	20002018 	.word	0x20002018
 8002ed4:	0801622c 	.word	0x0801622c
 8002ed8:	08017f2c 	.word	0x08017f2c
 8002edc:	08017f30 	.word	0x08017f30
 8002ee0:	08017f34 	.word	0x08017f34
 8002ee4:	080181b4 	.word	0x080181b4
 8002ee8:	08017f38 	.word	0x08017f38
 8002eec:	08017f4c 	.word	0x08017f4c

08002ef0 <rt_test_006_004_setup.lto_priv.772>:
 * - [6.4.7] Unlocking M2, the priority should fall back to P(A).
 * - [6.4.8] Unlocking M1, the priority should fall back to P(0).
 * .
 */

static void rt_test_006_004_setup(void) {
 8002ef0:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
 8002ef2:	4803      	ldr	r0, [pc, #12]	; (8002f00 <rt_test_006_004_setup.lto_priv.772+0x10>)
 8002ef4:	f00e fb1c 	bl	8011530 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 8002ef8:	4802      	ldr	r0, [pc, #8]	; (8002f04 <rt_test_006_004_setup.lto_priv.772+0x14>)
 8002efa:	f00e fb19 	bl	8011530 <chMtxObjectInit>
}
 8002efe:	bd08      	pop	{r3, pc}
 8002f00:	20000848 	.word	0x20000848
 8002f04:	20000858 	.word	0x20000858
	...

08002f10 <rt_test_006_004_teardown.lto_priv.773>:

static void rt_test_006_004_teardown(void) {
 8002f10:	b508      	push	{r3, lr}
  test_wait_threads();
 8002f12:	f7fd ff35 	bl	8000d80 <test_wait_threads>
}
 8002f16:	bd08      	pop	{r3, pc}
	...

08002f20 <rt_test_006_004_execute.lto_priv.774>:

static void rt_test_006_004_execute(void) {
 8002f20:	b500      	push	{lr}
 8002f22:	b087      	sub	sp, #28
  tprio_t p, pa, pb;

  /* [6.4.1] Getting current thread priority P(0) and assigning to the
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
 8002f24:	4b57      	ldr	r3, [pc, #348]	; (8003084 <rt_test_006_004_execute.lto_priv.774+0x164>)
 8002f26:	2201      	movs	r2, #1
 8002f28:	601a      	str	r2, [r3, #0]
  {
    p = chThdGetPriorityX();
 8002f2a:	f7ff fea1 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 8002f2e:	9005      	str	r0, [sp, #20]
    pa = p + 1;
 8002f30:	9b05      	ldr	r3, [sp, #20]
 8002f32:	3301      	adds	r3, #1
 8002f34:	9304      	str	r3, [sp, #16]
    pb = p + 2;
 8002f36:	9b05      	ldr	r3, [sp, #20]
 8002f38:	3302      	adds	r3, #2
 8002f3a:	9303      	str	r3, [sp, #12]
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8002f3c:	4b51      	ldr	r3, [pc, #324]	; (8003084 <rt_test_006_004_execute.lto_priv.774+0x164>)
 8002f3e:	2202      	movs	r2, #2
 8002f40:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8002f42:	4b51      	ldr	r3, [pc, #324]	; (8003088 <rt_test_006_004_execute.lto_priv.774+0x168>)
 8002f44:	6818      	ldr	r0, [r3, #0]
 8002f46:	4b51      	ldr	r3, [pc, #324]	; (800308c <rt_test_006_004_execute.lto_priv.774+0x16c>)
 8002f48:	9300      	str	r3, [sp, #0]
 8002f4a:	4b51      	ldr	r3, [pc, #324]	; (8003090 <rt_test_006_004_execute.lto_priv.774+0x170>)
 8002f4c:	9a04      	ldr	r2, [sp, #16]
 8002f4e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002f52:	f00d fac5 	bl	80104e0 <chThdCreateStatic>
 8002f56:	4602      	mov	r2, r0
 8002f58:	4b4e      	ldr	r3, [pc, #312]	; (8003094 <rt_test_006_004_execute.lto_priv.774+0x174>)
 8002f5a:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 8002f5c:	4b4a      	ldr	r3, [pc, #296]	; (8003088 <rt_test_006_004_execute.lto_priv.774+0x168>)
 8002f5e:	6858      	ldr	r0, [r3, #4]
 8002f60:	4b4d      	ldr	r3, [pc, #308]	; (8003098 <rt_test_006_004_execute.lto_priv.774+0x178>)
 8002f62:	9300      	str	r3, [sp, #0]
 8002f64:	4b4d      	ldr	r3, [pc, #308]	; (800309c <rt_test_006_004_execute.lto_priv.774+0x17c>)
 8002f66:	9a03      	ldr	r2, [sp, #12]
 8002f68:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002f6c:	f00d fab8 	bl	80104e0 <chThdCreateStatic>
 8002f70:	4602      	mov	r2, r0
 8002f72:	4b48      	ldr	r3, [pc, #288]	; (8003094 <rt_test_006_004_execute.lto_priv.774+0x174>)
 8002f74:	605a      	str	r2, [r3, #4]
  }

  /* [6.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
 8002f76:	4b43      	ldr	r3, [pc, #268]	; (8003084 <rt_test_006_004_execute.lto_priv.774+0x164>)
 8002f78:	2203      	movs	r2, #3
 8002f7a:	601a      	str	r2, [r3, #0]
  {
    chMtxLock(&m1);
 8002f7c:	4848      	ldr	r0, [pc, #288]	; (80030a0 <rt_test_006_004_execute.lto_priv.774+0x180>)
 8002f7e:	f00e faef 	bl	8011560 <chMtxLock>
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8002f82:	f7ff fe75 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 8002f86:	4602      	mov	r2, r0
 8002f88:	9b05      	ldr	r3, [sp, #20]
 8002f8a:	4293      	cmp	r3, r2
 8002f8c:	bf0c      	ite	eq
 8002f8e:	2301      	moveq	r3, #1
 8002f90:	2300      	movne	r3, #0
 8002f92:	b2db      	uxtb	r3, r3
 8002f94:	4943      	ldr	r1, [pc, #268]	; (80030a4 <rt_test_006_004_execute.lto_priv.774+0x184>)
 8002f96:	4618      	mov	r0, r3
 8002f98:	f012 fa72 	bl	8015480 <_test_assert>
 8002f9c:	4603      	mov	r3, r0
 8002f9e:	2b00      	cmp	r3, #0
 8002fa0:	d16c      	bne.n	800307c <rt_test_006_004_execute.lto_priv.774+0x15c>
  }

  /* [6.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 8002fa2:	4b38      	ldr	r3, [pc, #224]	; (8003084 <rt_test_006_004_execute.lto_priv.774+0x164>)
 8002fa4:	2204      	movs	r2, #4
 8002fa6:	601a      	str	r2, [r3, #0]
  {
    chThdSleepMilliseconds(100);
 8002fa8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002fac:	f00d fc30 	bl	8010810 <chThdSleep>
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8002fb0:	f7ff fe5e 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 8002fb4:	4602      	mov	r2, r0
 8002fb6:	9b04      	ldr	r3, [sp, #16]
 8002fb8:	4293      	cmp	r3, r2
 8002fba:	bf0c      	ite	eq
 8002fbc:	2301      	moveq	r3, #1
 8002fbe:	2300      	movne	r3, #0
 8002fc0:	b2db      	uxtb	r3, r3
 8002fc2:	4938      	ldr	r1, [pc, #224]	; (80030a4 <rt_test_006_004_execute.lto_priv.774+0x184>)
 8002fc4:	4618      	mov	r0, r3
 8002fc6:	f012 fa5b 	bl	8015480 <_test_assert>
 8002fca:	4603      	mov	r3, r0
 8002fcc:	2b00      	cmp	r3, #0
 8002fce:	d155      	bne.n	800307c <rt_test_006_004_execute.lto_priv.774+0x15c>
  }

  /* [6.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
 8002fd0:	4b2c      	ldr	r3, [pc, #176]	; (8003084 <rt_test_006_004_execute.lto_priv.774+0x164>)
 8002fd2:	2205      	movs	r2, #5
 8002fd4:	601a      	str	r2, [r3, #0]
  {
    chMtxLock(&m2);
 8002fd6:	4834      	ldr	r0, [pc, #208]	; (80030a8 <rt_test_006_004_execute.lto_priv.774+0x188>)
 8002fd8:	f00e fac2 	bl	8011560 <chMtxLock>
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8002fdc:	f7ff fe48 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 8002fe0:	4602      	mov	r2, r0
 8002fe2:	9b04      	ldr	r3, [sp, #16]
 8002fe4:	4293      	cmp	r3, r2
 8002fe6:	bf0c      	ite	eq
 8002fe8:	2301      	moveq	r3, #1
 8002fea:	2300      	movne	r3, #0
 8002fec:	b2db      	uxtb	r3, r3
 8002fee:	492d      	ldr	r1, [pc, #180]	; (80030a4 <rt_test_006_004_execute.lto_priv.774+0x184>)
 8002ff0:	4618      	mov	r0, r3
 8002ff2:	f012 fa45 	bl	8015480 <_test_assert>
 8002ff6:	4603      	mov	r3, r0
 8002ff8:	2b00      	cmp	r3, #0
 8002ffa:	d13f      	bne.n	800307c <rt_test_006_004_execute.lto_priv.774+0x15c>
  }

  /* [6.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 8002ffc:	4b21      	ldr	r3, [pc, #132]	; (8003084 <rt_test_006_004_execute.lto_priv.774+0x164>)
 8002ffe:	2206      	movs	r2, #6
 8003000:	601a      	str	r2, [r3, #0]
  {
    chThdSleepMilliseconds(100);
 8003002:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003006:	f00d fc03 	bl	8010810 <chThdSleep>
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 800300a:	f7ff fe31 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 800300e:	4602      	mov	r2, r0
 8003010:	9b03      	ldr	r3, [sp, #12]
 8003012:	4293      	cmp	r3, r2
 8003014:	bf0c      	ite	eq
 8003016:	2301      	moveq	r3, #1
 8003018:	2300      	movne	r3, #0
 800301a:	b2db      	uxtb	r3, r3
 800301c:	4921      	ldr	r1, [pc, #132]	; (80030a4 <rt_test_006_004_execute.lto_priv.774+0x184>)
 800301e:	4618      	mov	r0, r3
 8003020:	f012 fa2e 	bl	8015480 <_test_assert>
 8003024:	4603      	mov	r3, r0
 8003026:	2b00      	cmp	r3, #0
 8003028:	d128      	bne.n	800307c <rt_test_006_004_execute.lto_priv.774+0x15c>
  }

  /* [6.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 800302a:	4b16      	ldr	r3, [pc, #88]	; (8003084 <rt_test_006_004_execute.lto_priv.774+0x164>)
 800302c:	2207      	movs	r2, #7
 800302e:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m2);
 8003030:	481d      	ldr	r0, [pc, #116]	; (80030a8 <rt_test_006_004_execute.lto_priv.774+0x188>)
 8003032:	f00e fb65 	bl	8011700 <chMtxUnlock>
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8003036:	f7ff fe1b 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 800303a:	4602      	mov	r2, r0
 800303c:	9b04      	ldr	r3, [sp, #16]
 800303e:	4293      	cmp	r3, r2
 8003040:	bf0c      	ite	eq
 8003042:	2301      	moveq	r3, #1
 8003044:	2300      	movne	r3, #0
 8003046:	b2db      	uxtb	r3, r3
 8003048:	4916      	ldr	r1, [pc, #88]	; (80030a4 <rt_test_006_004_execute.lto_priv.774+0x184>)
 800304a:	4618      	mov	r0, r3
 800304c:	f012 fa18 	bl	8015480 <_test_assert>
 8003050:	4603      	mov	r3, r0
 8003052:	2b00      	cmp	r3, #0
 8003054:	d112      	bne.n	800307c <rt_test_006_004_execute.lto_priv.774+0x15c>
  }

  /* [6.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 8003056:	4b0b      	ldr	r3, [pc, #44]	; (8003084 <rt_test_006_004_execute.lto_priv.774+0x164>)
 8003058:	2208      	movs	r2, #8
 800305a:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m1);
 800305c:	4810      	ldr	r0, [pc, #64]	; (80030a0 <rt_test_006_004_execute.lto_priv.774+0x180>)
 800305e:	f00e fb4f 	bl	8011700 <chMtxUnlock>
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8003062:	f7ff fe05 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 8003066:	4602      	mov	r2, r0
 8003068:	9b05      	ldr	r3, [sp, #20]
 800306a:	4293      	cmp	r3, r2
 800306c:	bf0c      	ite	eq
 800306e:	2301      	moveq	r3, #1
 8003070:	2300      	movne	r3, #0
 8003072:	b2db      	uxtb	r3, r3
 8003074:	490b      	ldr	r1, [pc, #44]	; (80030a4 <rt_test_006_004_execute.lto_priv.774+0x184>)
 8003076:	4618      	mov	r0, r3
 8003078:	f012 fa02 	bl	8015480 <_test_assert>
  }
}
 800307c:	b007      	add	sp, #28
 800307e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003082:	bf00      	nop
 8003084:	20001988 	.word	0x20001988
 8003088:	08017360 	.word	0x08017360
 800308c:	08017f34 	.word	0x08017f34
 8003090:	08002cb1 	.word	0x08002cb1
 8003094:	20002018 	.word	0x20002018
 8003098:	08017f30 	.word	0x08017f30
 800309c:	08002ce1 	.word	0x08002ce1
 80030a0:	20000848 	.word	0x20000848
 80030a4:	080181b4 	.word	0x080181b4
 80030a8:	20000858 	.word	0x20000858
 80030ac:	00000000 	.word	0x00000000

080030b0 <rt_test_006_005_setup.lto_priv.775>:
 * - [6.5.6] Testing chMtxUnlockAll() behavior.
 * - [6.5.7] Testing that priority has not changed after operations.
 * .
 */

static void rt_test_006_005_setup(void) {
 80030b0:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
 80030b2:	4802      	ldr	r0, [pc, #8]	; (80030bc <rt_test_006_005_setup.lto_priv.775+0xc>)
 80030b4:	f00e fa3c 	bl	8011530 <chMtxObjectInit>
}
 80030b8:	bd08      	pop	{r3, pc}
 80030ba:	bf00      	nop
 80030bc:	20000848 	.word	0x20000848

080030c0 <rt_test_006_005_execute.lto_priv.776>:

static void rt_test_006_005_execute(void) {
 80030c0:	b500      	push	{lr}
 80030c2:	b083      	sub	sp, #12
  bool b;
  tprio_t prio;

  /* [6.5.1] Getting current thread priority for later checks.*/
  test_set_step(1);
 80030c4:	4b61      	ldr	r3, [pc, #388]	; (800324c <rt_test_006_005_execute.lto_priv.776+0x18c>)
 80030c6:	2201      	movs	r2, #1
 80030c8:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 80030ca:	f7ff fdd1 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 80030ce:	9001      	str	r0, [sp, #4]
  }

  /* [6.5.2] Locking the mutex first time, it must be possible because
     it is not owned.*/
  test_set_step(2);
 80030d0:	4b5e      	ldr	r3, [pc, #376]	; (800324c <rt_test_006_005_execute.lto_priv.776+0x18c>)
 80030d2:	2202      	movs	r2, #2
 80030d4:	601a      	str	r2, [r3, #0]
  {
    b = chMtxTryLock(&m1);
 80030d6:	485e      	ldr	r0, [pc, #376]	; (8003250 <rt_test_006_005_execute.lto_priv.776+0x190>)
 80030d8:	f00e fad2 	bl	8011680 <chMtxTryLock>
 80030dc:	4603      	mov	r3, r0
 80030de:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(b, "already locked");
 80030e2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80030e6:	495b      	ldr	r1, [pc, #364]	; (8003254 <rt_test_006_005_execute.lto_priv.776+0x194>)
 80030e8:	4618      	mov	r0, r3
 80030ea:	f012 f9c9 	bl	8015480 <_test_assert>
 80030ee:	4603      	mov	r3, r0
 80030f0:	2b00      	cmp	r3, #0
 80030f2:	f040 80a7 	bne.w	8003244 <rt_test_006_005_execute.lto_priv.776+0x184>
  }

  /* [6.5.3] Locking the mutex second time, it must fail because it is
     already owned.*/
  test_set_step(3);
 80030f6:	4b55      	ldr	r3, [pc, #340]	; (800324c <rt_test_006_005_execute.lto_priv.776+0x18c>)
 80030f8:	2203      	movs	r2, #3
 80030fa:	601a      	str	r2, [r3, #0]
  {
    b = chMtxTryLock(&m1);
 80030fc:	4854      	ldr	r0, [pc, #336]	; (8003250 <rt_test_006_005_execute.lto_priv.776+0x190>)
 80030fe:	f00e fabf 	bl	8011680 <chMtxTryLock>
 8003102:	4603      	mov	r3, r0
 8003104:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(!b, "not locked");
 8003108:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800310c:	2b00      	cmp	r3, #0
 800310e:	bf14      	ite	ne
 8003110:	2301      	movne	r3, #1
 8003112:	2300      	moveq	r3, #0
 8003114:	b2db      	uxtb	r3, r3
 8003116:	f083 0301 	eor.w	r3, r3, #1
 800311a:	b2db      	uxtb	r3, r3
 800311c:	f003 0301 	and.w	r3, r3, #1
 8003120:	b2db      	uxtb	r3, r3
 8003122:	494d      	ldr	r1, [pc, #308]	; (8003258 <rt_test_006_005_execute.lto_priv.776+0x198>)
 8003124:	4618      	mov	r0, r3
 8003126:	f012 f9ab 	bl	8015480 <_test_assert>
 800312a:	4603      	mov	r3, r0
 800312c:	2b00      	cmp	r3, #0
 800312e:	f040 8089 	bne.w	8003244 <rt_test_006_005_execute.lto_priv.776+0x184>
  }

  /* [6.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
 8003132:	4b46      	ldr	r3, [pc, #280]	; (800324c <rt_test_006_005_execute.lto_priv.776+0x18c>)
 8003134:	2204      	movs	r2, #4
 8003136:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m1);
 8003138:	4845      	ldr	r0, [pc, #276]	; (8003250 <rt_test_006_005_execute.lto_priv.776+0x190>)
 800313a:	f00e fae1 	bl	8011700 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 800313e:	4b44      	ldr	r3, [pc, #272]	; (8003250 <rt_test_006_005_execute.lto_priv.776+0x190>)
 8003140:	689b      	ldr	r3, [r3, #8]
 8003142:	2b00      	cmp	r3, #0
 8003144:	bf0c      	ite	eq
 8003146:	2301      	moveq	r3, #1
 8003148:	2300      	movne	r3, #0
 800314a:	b2db      	uxtb	r3, r3
 800314c:	4943      	ldr	r1, [pc, #268]	; (800325c <rt_test_006_005_execute.lto_priv.776+0x19c>)
 800314e:	4618      	mov	r0, r3
 8003150:	f012 f996 	bl	8015480 <_test_assert>
 8003154:	4603      	mov	r3, r0
 8003156:	2b00      	cmp	r3, #0
 8003158:	d174      	bne.n	8003244 <rt_test_006_005_execute.lto_priv.776+0x184>
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 800315a:	483d      	ldr	r0, [pc, #244]	; (8003250 <rt_test_006_005_execute.lto_priv.776+0x190>)
 800315c:	f7ff fd48 	bl	8002bf0 <queue_isempty.lto_priv.129>
 8003160:	4603      	mov	r3, r0
 8003162:	493f      	ldr	r1, [pc, #252]	; (8003260 <rt_test_006_005_execute.lto_priv.776+0x1a0>)
 8003164:	4618      	mov	r0, r3
 8003166:	f012 f98b 	bl	8015480 <_test_assert>
 800316a:	4603      	mov	r3, r0
 800316c:	2b00      	cmp	r3, #0
 800316e:	d169      	bne.n	8003244 <rt_test_006_005_execute.lto_priv.776+0x184>
  }

  /* [6.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
 8003170:	4b36      	ldr	r3, [pc, #216]	; (800324c <rt_test_006_005_execute.lto_priv.776+0x18c>)
 8003172:	2205      	movs	r2, #5
 8003174:	601a      	str	r2, [r3, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8003176:	f7ff fd7b 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 800317a:	4602      	mov	r2, r0
 800317c:	9b01      	ldr	r3, [sp, #4]
 800317e:	4293      	cmp	r3, r2
 8003180:	bf0c      	ite	eq
 8003182:	2301      	moveq	r3, #1
 8003184:	2300      	movne	r3, #0
 8003186:	b2db      	uxtb	r3, r3
 8003188:	4936      	ldr	r1, [pc, #216]	; (8003264 <rt_test_006_005_execute.lto_priv.776+0x1a4>)
 800318a:	4618      	mov	r0, r3
 800318c:	f012 f978 	bl	8015480 <_test_assert>
 8003190:	4603      	mov	r3, r0
 8003192:	2b00      	cmp	r3, #0
 8003194:	d156      	bne.n	8003244 <rt_test_006_005_execute.lto_priv.776+0x184>
  }

  /* [6.5.6] Testing chMtxUnlockAll() behavior.*/
  test_set_step(6);
 8003196:	4b2d      	ldr	r3, [pc, #180]	; (800324c <rt_test_006_005_execute.lto_priv.776+0x18c>)
 8003198:	2206      	movs	r2, #6
 800319a:	601a      	str	r2, [r3, #0]
  {
    b = chMtxTryLock(&m1);
 800319c:	482c      	ldr	r0, [pc, #176]	; (8003250 <rt_test_006_005_execute.lto_priv.776+0x190>)
 800319e:	f00e fa6f 	bl	8011680 <chMtxTryLock>
 80031a2:	4603      	mov	r3, r0
 80031a4:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(b, "already locked");
 80031a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80031ac:	4929      	ldr	r1, [pc, #164]	; (8003254 <rt_test_006_005_execute.lto_priv.776+0x194>)
 80031ae:	4618      	mov	r0, r3
 80031b0:	f012 f966 	bl	8015480 <_test_assert>
 80031b4:	4603      	mov	r3, r0
 80031b6:	2b00      	cmp	r3, #0
 80031b8:	d144      	bne.n	8003244 <rt_test_006_005_execute.lto_priv.776+0x184>
    b = chMtxTryLock(&m1);
 80031ba:	4825      	ldr	r0, [pc, #148]	; (8003250 <rt_test_006_005_execute.lto_priv.776+0x190>)
 80031bc:	f00e fa60 	bl	8011680 <chMtxTryLock>
 80031c0:	4603      	mov	r3, r0
 80031c2:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(!b, "not locked");
 80031c6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80031ca:	2b00      	cmp	r3, #0
 80031cc:	bf14      	ite	ne
 80031ce:	2301      	movne	r3, #1
 80031d0:	2300      	moveq	r3, #0
 80031d2:	b2db      	uxtb	r3, r3
 80031d4:	f083 0301 	eor.w	r3, r3, #1
 80031d8:	b2db      	uxtb	r3, r3
 80031da:	f003 0301 	and.w	r3, r3, #1
 80031de:	b2db      	uxtb	r3, r3
 80031e0:	491d      	ldr	r1, [pc, #116]	; (8003258 <rt_test_006_005_execute.lto_priv.776+0x198>)
 80031e2:	4618      	mov	r0, r3
 80031e4:	f012 f94c 	bl	8015480 <_test_assert>
 80031e8:	4603      	mov	r3, r0
 80031ea:	2b00      	cmp	r3, #0
 80031ec:	d12a      	bne.n	8003244 <rt_test_006_005_execute.lto_priv.776+0x184>

    chMtxUnlockAll();
 80031ee:	f00e fb6f 	bl	80118d0 <chMtxUnlockAll>
    test_assert(m1.owner == NULL, "still owned");
 80031f2:	4b17      	ldr	r3, [pc, #92]	; (8003250 <rt_test_006_005_execute.lto_priv.776+0x190>)
 80031f4:	689b      	ldr	r3, [r3, #8]
 80031f6:	2b00      	cmp	r3, #0
 80031f8:	bf0c      	ite	eq
 80031fa:	2301      	moveq	r3, #1
 80031fc:	2300      	movne	r3, #0
 80031fe:	b2db      	uxtb	r3, r3
 8003200:	4916      	ldr	r1, [pc, #88]	; (800325c <rt_test_006_005_execute.lto_priv.776+0x19c>)
 8003202:	4618      	mov	r0, r3
 8003204:	f012 f93c 	bl	8015480 <_test_assert>
 8003208:	4603      	mov	r3, r0
 800320a:	2b00      	cmp	r3, #0
 800320c:	d11a      	bne.n	8003244 <rt_test_006_005_execute.lto_priv.776+0x184>
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 800320e:	4810      	ldr	r0, [pc, #64]	; (8003250 <rt_test_006_005_execute.lto_priv.776+0x190>)
 8003210:	f7ff fcee 	bl	8002bf0 <queue_isempty.lto_priv.129>
 8003214:	4603      	mov	r3, r0
 8003216:	4912      	ldr	r1, [pc, #72]	; (8003260 <rt_test_006_005_execute.lto_priv.776+0x1a0>)
 8003218:	4618      	mov	r0, r3
 800321a:	f012 f931 	bl	8015480 <_test_assert>
 800321e:	4603      	mov	r3, r0
 8003220:	2b00      	cmp	r3, #0
 8003222:	d10f      	bne.n	8003244 <rt_test_006_005_execute.lto_priv.776+0x184>
  }

  /* [6.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
 8003224:	4b09      	ldr	r3, [pc, #36]	; (800324c <rt_test_006_005_execute.lto_priv.776+0x18c>)
 8003226:	2207      	movs	r2, #7
 8003228:	601a      	str	r2, [r3, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 800322a:	f7ff fd21 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 800322e:	4602      	mov	r2, r0
 8003230:	9b01      	ldr	r3, [sp, #4]
 8003232:	4293      	cmp	r3, r2
 8003234:	bf0c      	ite	eq
 8003236:	2301      	moveq	r3, #1
 8003238:	2300      	movne	r3, #0
 800323a:	b2db      	uxtb	r3, r3
 800323c:	4909      	ldr	r1, [pc, #36]	; (8003264 <rt_test_006_005_execute.lto_priv.776+0x1a4>)
 800323e:	4618      	mov	r0, r3
 8003240:	f012 f91e 	bl	8015480 <_test_assert>
  }
}
 8003244:	b003      	add	sp, #12
 8003246:	f85d fb04 	ldr.w	pc, [sp], #4
 800324a:	bf00      	nop
 800324c:	20001988 	.word	0x20001988
 8003250:	20000848 	.word	0x20000848
 8003254:	080181ec 	.word	0x080181ec
 8003258:	080181fc 	.word	0x080181fc
 800325c:	08018208 	.word	0x08018208
 8003260:	080180d0 	.word	0x080180d0
 8003264:	080181b4 	.word	0x080181b4
	...

08003270 <rt_test_006_007_setup.lto_priv.777>:
 *   then waiting for the threads to terminate in priority order, the
 *   order is tested.
 * .
 */

static void rt_test_006_007_setup(void) {
 8003270:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 8003272:	4803      	ldr	r0, [pc, #12]	; (8003280 <rt_test_006_007_setup.lto_priv.777+0x10>)
 8003274:	f00e fc14 	bl	8011aa0 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8003278:	4802      	ldr	r0, [pc, #8]	; (8003284 <rt_test_006_007_setup.lto_priv.777+0x14>)
 800327a:	f00e f959 	bl	8011530 <chMtxObjectInit>
}
 800327e:	bd08      	pop	{r3, pc}
 8003280:	20000868 	.word	0x20000868
 8003284:	20000848 	.word	0x20000848
	...

08003290 <rt_test_006_007_execute.lto_priv.778>:

static void rt_test_006_007_execute(void) {
 8003290:	b500      	push	{lr}
 8003292:	b085      	sub	sp, #20

  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8003294:	4b36      	ldr	r3, [pc, #216]	; (8003370 <rt_test_006_007_execute.lto_priv.778+0xe0>)
 8003296:	2201      	movs	r2, #1
 8003298:	601a      	str	r2, [r3, #0]
  {
    tprio_t prio = chThdGetPriorityX();
 800329a:	f7ff fce9 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 800329e:	9003      	str	r0, [sp, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80032a0:	4b34      	ldr	r3, [pc, #208]	; (8003374 <rt_test_006_007_execute.lto_priv.778+0xe4>)
 80032a2:	6818      	ldr	r0, [r3, #0]
 80032a4:	9b03      	ldr	r3, [sp, #12]
 80032a6:	1c5a      	adds	r2, r3, #1
 80032a8:	4b33      	ldr	r3, [pc, #204]	; (8003378 <rt_test_006_007_execute.lto_priv.778+0xe8>)
 80032aa:	9300      	str	r3, [sp, #0]
 80032ac:	4b33      	ldr	r3, [pc, #204]	; (800337c <rt_test_006_007_execute.lto_priv.778+0xec>)
 80032ae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80032b2:	f00d f915 	bl	80104e0 <chThdCreateStatic>
 80032b6:	4602      	mov	r2, r0
 80032b8:	4b31      	ldr	r3, [pc, #196]	; (8003380 <rt_test_006_007_execute.lto_priv.778+0xf0>)
 80032ba:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80032bc:	4b2d      	ldr	r3, [pc, #180]	; (8003374 <rt_test_006_007_execute.lto_priv.778+0xe4>)
 80032be:	6858      	ldr	r0, [r3, #4]
 80032c0:	9b03      	ldr	r3, [sp, #12]
 80032c2:	1c9a      	adds	r2, r3, #2
 80032c4:	4b2f      	ldr	r3, [pc, #188]	; (8003384 <rt_test_006_007_execute.lto_priv.778+0xf4>)
 80032c6:	9300      	str	r3, [sp, #0]
 80032c8:	4b2c      	ldr	r3, [pc, #176]	; (800337c <rt_test_006_007_execute.lto_priv.778+0xec>)
 80032ca:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80032ce:	f00d f907 	bl	80104e0 <chThdCreateStatic>
 80032d2:	4602      	mov	r2, r0
 80032d4:	4b2a      	ldr	r3, [pc, #168]	; (8003380 <rt_test_006_007_execute.lto_priv.778+0xf0>)
 80032d6:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 80032d8:	4b26      	ldr	r3, [pc, #152]	; (8003374 <rt_test_006_007_execute.lto_priv.778+0xe4>)
 80032da:	6898      	ldr	r0, [r3, #8]
 80032dc:	9b03      	ldr	r3, [sp, #12]
 80032de:	1cda      	adds	r2, r3, #3
 80032e0:	4b29      	ldr	r3, [pc, #164]	; (8003388 <rt_test_006_007_execute.lto_priv.778+0xf8>)
 80032e2:	9300      	str	r3, [sp, #0]
 80032e4:	4b25      	ldr	r3, [pc, #148]	; (800337c <rt_test_006_007_execute.lto_priv.778+0xec>)
 80032e6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80032ea:	f00d f8f9 	bl	80104e0 <chThdCreateStatic>
 80032ee:	4602      	mov	r2, r0
 80032f0:	4b23      	ldr	r3, [pc, #140]	; (8003380 <rt_test_006_007_execute.lto_priv.778+0xf0>)
 80032f2:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 80032f4:	4b1f      	ldr	r3, [pc, #124]	; (8003374 <rt_test_006_007_execute.lto_priv.778+0xe4>)
 80032f6:	68d8      	ldr	r0, [r3, #12]
 80032f8:	9b03      	ldr	r3, [sp, #12]
 80032fa:	1d1a      	adds	r2, r3, #4
 80032fc:	4b23      	ldr	r3, [pc, #140]	; (800338c <rt_test_006_007_execute.lto_priv.778+0xfc>)
 80032fe:	9300      	str	r3, [sp, #0]
 8003300:	4b1e      	ldr	r3, [pc, #120]	; (800337c <rt_test_006_007_execute.lto_priv.778+0xec>)
 8003302:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003306:	f00d f8eb 	bl	80104e0 <chThdCreateStatic>
 800330a:	4602      	mov	r2, r0
 800330c:	4b1c      	ldr	r3, [pc, #112]	; (8003380 <rt_test_006_007_execute.lto_priv.778+0xf0>)
 800330e:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8003310:	4b18      	ldr	r3, [pc, #96]	; (8003374 <rt_test_006_007_execute.lto_priv.778+0xe4>)
 8003312:	6918      	ldr	r0, [r3, #16]
 8003314:	9b03      	ldr	r3, [sp, #12]
 8003316:	1d5a      	adds	r2, r3, #5
 8003318:	4b1d      	ldr	r3, [pc, #116]	; (8003390 <rt_test_006_007_execute.lto_priv.778+0x100>)
 800331a:	9300      	str	r3, [sp, #0]
 800331c:	4b17      	ldr	r3, [pc, #92]	; (800337c <rt_test_006_007_execute.lto_priv.778+0xec>)
 800331e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003322:	f00d f8dd 	bl	80104e0 <chThdCreateStatic>
 8003326:	4602      	mov	r2, r0
 8003328:	4b15      	ldr	r3, [pc, #84]	; (8003380 <rt_test_006_007_execute.lto_priv.778+0xf0>)
 800332a:	611a      	str	r2, [r3, #16]
  }

  /* [6.7.2] Atomically signaling the condition variable five times
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
 800332c:	4b10      	ldr	r3, [pc, #64]	; (8003370 <rt_test_006_007_execute.lto_priv.778+0xe0>)
 800332e:	2202      	movs	r2, #2
 8003330:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8003332:	f7ff fc6d 	bl	8002c10 <chSysLock.lto_priv.79>
    chCondSignalI(&c1);
 8003336:	4817      	ldr	r0, [pc, #92]	; (8003394 <rt_test_006_007_execute.lto_priv.778+0x104>)
 8003338:	f00e fbf2 	bl	8011b20 <chCondSignalI>
    chCondSignalI(&c1);
 800333c:	4815      	ldr	r0, [pc, #84]	; (8003394 <rt_test_006_007_execute.lto_priv.778+0x104>)
 800333e:	f00e fbef 	bl	8011b20 <chCondSignalI>
    chCondSignalI(&c1);
 8003342:	4814      	ldr	r0, [pc, #80]	; (8003394 <rt_test_006_007_execute.lto_priv.778+0x104>)
 8003344:	f00e fbec 	bl	8011b20 <chCondSignalI>
    chCondSignalI(&c1);
 8003348:	4812      	ldr	r0, [pc, #72]	; (8003394 <rt_test_006_007_execute.lto_priv.778+0x104>)
 800334a:	f00e fbe9 	bl	8011b20 <chCondSignalI>
    chCondSignalI(&c1);
 800334e:	4811      	ldr	r0, [pc, #68]	; (8003394 <rt_test_006_007_execute.lto_priv.778+0x104>)
 8003350:	f00e fbe6 	bl	8011b20 <chCondSignalI>
    chSchRescheduleS();
 8003354:	f00c fdac 	bl	800feb0 <chSchRescheduleS>
    chSysUnlock();
 8003358:	f7ff fc62 	bl	8002c20 <chSysUnlock.lto_priv.43>
    test_wait_threads();
 800335c:	f7fd fd10 	bl	8000d80 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8003360:	490d      	ldr	r1, [pc, #52]	; (8003398 <rt_test_006_007_execute.lto_priv.778+0x108>)
 8003362:	480e      	ldr	r0, [pc, #56]	; (800339c <rt_test_006_007_execute.lto_priv.778+0x10c>)
 8003364:	f012 f8a4 	bl	80154b0 <_test_assert_sequence>
  }
}
 8003368:	b005      	add	sp, #20
 800336a:	f85d fb04 	ldr.w	pc, [sp], #4
 800336e:	bf00      	nop
 8003370:	20001988 	.word	0x20001988
 8003374:	08017360 	.word	0x08017360
 8003378:	08017f50 	.word	0x08017f50
 800337c:	08002d11 	.word	0x08002d11
 8003380:	20002018 	.word	0x20002018
 8003384:	0801622c 	.word	0x0801622c
 8003388:	08017f2c 	.word	0x08017f2c
 800338c:	08017f30 	.word	0x08017f30
 8003390:	08017f34 	.word	0x08017f34
 8003394:	20000868 	.word	0x20000868
 8003398:	08017f38 	.word	0x08017f38
 800339c:	08017f4c 	.word	0x08017f4c

080033a0 <rt_test_006_008_setup.lto_priv.779>:
 * - [6.8.2] Broarcasting on the condition variable then waiting for
 *   the threads to terminate in priority order, the order is tested.
 * .
 */

static void rt_test_006_008_setup(void) {
 80033a0:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 80033a2:	4803      	ldr	r0, [pc, #12]	; (80033b0 <rt_test_006_008_setup.lto_priv.779+0x10>)
 80033a4:	f00e fb7c 	bl	8011aa0 <chCondObjectInit>
  chMtxObjectInit(&m1);
 80033a8:	4802      	ldr	r0, [pc, #8]	; (80033b4 <rt_test_006_008_setup.lto_priv.779+0x14>)
 80033aa:	f00e f8c1 	bl	8011530 <chMtxObjectInit>
}
 80033ae:	bd08      	pop	{r3, pc}
 80033b0:	20000868 	.word	0x20000868
 80033b4:	20000848 	.word	0x20000848
	...

080033c0 <rt_test_006_008_execute.lto_priv.780>:

static void rt_test_006_008_execute(void) {
 80033c0:	b500      	push	{lr}
 80033c2:	b085      	sub	sp, #20

  /* [6.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 80033c4:	4b2d      	ldr	r3, [pc, #180]	; (800347c <rt_test_006_008_execute.lto_priv.780+0xbc>)
 80033c6:	2201      	movs	r2, #1
 80033c8:	601a      	str	r2, [r3, #0]
  {
    tprio_t prio = chThdGetPriorityX();
 80033ca:	f7ff fc51 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 80033ce:	9003      	str	r0, [sp, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80033d0:	4b2b      	ldr	r3, [pc, #172]	; (8003480 <rt_test_006_008_execute.lto_priv.780+0xc0>)
 80033d2:	6818      	ldr	r0, [r3, #0]
 80033d4:	9b03      	ldr	r3, [sp, #12]
 80033d6:	1c5a      	adds	r2, r3, #1
 80033d8:	4b2a      	ldr	r3, [pc, #168]	; (8003484 <rt_test_006_008_execute.lto_priv.780+0xc4>)
 80033da:	9300      	str	r3, [sp, #0]
 80033dc:	4b2a      	ldr	r3, [pc, #168]	; (8003488 <rt_test_006_008_execute.lto_priv.780+0xc8>)
 80033de:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80033e2:	f00d f87d 	bl	80104e0 <chThdCreateStatic>
 80033e6:	4602      	mov	r2, r0
 80033e8:	4b28      	ldr	r3, [pc, #160]	; (800348c <rt_test_006_008_execute.lto_priv.780+0xcc>)
 80033ea:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80033ec:	4b24      	ldr	r3, [pc, #144]	; (8003480 <rt_test_006_008_execute.lto_priv.780+0xc0>)
 80033ee:	6858      	ldr	r0, [r3, #4]
 80033f0:	9b03      	ldr	r3, [sp, #12]
 80033f2:	1c9a      	adds	r2, r3, #2
 80033f4:	4b26      	ldr	r3, [pc, #152]	; (8003490 <rt_test_006_008_execute.lto_priv.780+0xd0>)
 80033f6:	9300      	str	r3, [sp, #0]
 80033f8:	4b23      	ldr	r3, [pc, #140]	; (8003488 <rt_test_006_008_execute.lto_priv.780+0xc8>)
 80033fa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80033fe:	f00d f86f 	bl	80104e0 <chThdCreateStatic>
 8003402:	4602      	mov	r2, r0
 8003404:	4b21      	ldr	r3, [pc, #132]	; (800348c <rt_test_006_008_execute.lto_priv.780+0xcc>)
 8003406:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8003408:	4b1d      	ldr	r3, [pc, #116]	; (8003480 <rt_test_006_008_execute.lto_priv.780+0xc0>)
 800340a:	6898      	ldr	r0, [r3, #8]
 800340c:	9b03      	ldr	r3, [sp, #12]
 800340e:	1cda      	adds	r2, r3, #3
 8003410:	4b20      	ldr	r3, [pc, #128]	; (8003494 <rt_test_006_008_execute.lto_priv.780+0xd4>)
 8003412:	9300      	str	r3, [sp, #0]
 8003414:	4b1c      	ldr	r3, [pc, #112]	; (8003488 <rt_test_006_008_execute.lto_priv.780+0xc8>)
 8003416:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800341a:	f00d f861 	bl	80104e0 <chThdCreateStatic>
 800341e:	4602      	mov	r2, r0
 8003420:	4b1a      	ldr	r3, [pc, #104]	; (800348c <rt_test_006_008_execute.lto_priv.780+0xcc>)
 8003422:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8003424:	4b16      	ldr	r3, [pc, #88]	; (8003480 <rt_test_006_008_execute.lto_priv.780+0xc0>)
 8003426:	68d8      	ldr	r0, [r3, #12]
 8003428:	9b03      	ldr	r3, [sp, #12]
 800342a:	1d1a      	adds	r2, r3, #4
 800342c:	4b1a      	ldr	r3, [pc, #104]	; (8003498 <rt_test_006_008_execute.lto_priv.780+0xd8>)
 800342e:	9300      	str	r3, [sp, #0]
 8003430:	4b15      	ldr	r3, [pc, #84]	; (8003488 <rt_test_006_008_execute.lto_priv.780+0xc8>)
 8003432:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003436:	f00d f853 	bl	80104e0 <chThdCreateStatic>
 800343a:	4602      	mov	r2, r0
 800343c:	4b13      	ldr	r3, [pc, #76]	; (800348c <rt_test_006_008_execute.lto_priv.780+0xcc>)
 800343e:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8003440:	4b0f      	ldr	r3, [pc, #60]	; (8003480 <rt_test_006_008_execute.lto_priv.780+0xc0>)
 8003442:	6918      	ldr	r0, [r3, #16]
 8003444:	9b03      	ldr	r3, [sp, #12]
 8003446:	1d5a      	adds	r2, r3, #5
 8003448:	4b14      	ldr	r3, [pc, #80]	; (800349c <rt_test_006_008_execute.lto_priv.780+0xdc>)
 800344a:	9300      	str	r3, [sp, #0]
 800344c:	4b0e      	ldr	r3, [pc, #56]	; (8003488 <rt_test_006_008_execute.lto_priv.780+0xc8>)
 800344e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003452:	f00d f845 	bl	80104e0 <chThdCreateStatic>
 8003456:	4602      	mov	r2, r0
 8003458:	4b0c      	ldr	r3, [pc, #48]	; (800348c <rt_test_006_008_execute.lto_priv.780+0xcc>)
 800345a:	611a      	str	r2, [r3, #16]
  }

  /* [6.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
 800345c:	4b07      	ldr	r3, [pc, #28]	; (800347c <rt_test_006_008_execute.lto_priv.780+0xbc>)
 800345e:	2202      	movs	r2, #2
 8003460:	601a      	str	r2, [r3, #0]
  {
    chCondBroadcast(&c1);
 8003462:	480f      	ldr	r0, [pc, #60]	; (80034a0 <rt_test_006_008_execute.lto_priv.780+0xe0>)
 8003464:	f00e fb84 	bl	8011b70 <chCondBroadcast>
    test_wait_threads();
 8003468:	f7fd fc8a 	bl	8000d80 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800346c:	490d      	ldr	r1, [pc, #52]	; (80034a4 <rt_test_006_008_execute.lto_priv.780+0xe4>)
 800346e:	480e      	ldr	r0, [pc, #56]	; (80034a8 <rt_test_006_008_execute.lto_priv.780+0xe8>)
 8003470:	f012 f81e 	bl	80154b0 <_test_assert_sequence>
  }
}
 8003474:	b005      	add	sp, #20
 8003476:	f85d fb04 	ldr.w	pc, [sp], #4
 800347a:	bf00      	nop
 800347c:	20001988 	.word	0x20001988
 8003480:	08017360 	.word	0x08017360
 8003484:	08017f50 	.word	0x08017f50
 8003488:	08002d11 	.word	0x08002d11
 800348c:	20002018 	.word	0x20002018
 8003490:	0801622c 	.word	0x0801622c
 8003494:	08017f2c 	.word	0x08017f2c
 8003498:	08017f30 	.word	0x08017f30
 800349c:	08017f34 	.word	0x08017f34
 80034a0:	20000868 	.word	0x20000868
 80034a4:	08017f38 	.word	0x08017f38
 80034a8:	08017f4c 	.word	0x08017f4c
 80034ac:	00000000 	.word	0x00000000

080034b0 <rt_test_006_009_setup.lto_priv.781>:
 * - [6.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.
 * - [6.9.7] Checking the order of operations.
 * .
 */

static void rt_test_006_009_setup(void) {
 80034b0:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 80034b2:	4805      	ldr	r0, [pc, #20]	; (80034c8 <rt_test_006_009_setup.lto_priv.781+0x18>)
 80034b4:	f00e faf4 	bl	8011aa0 <chCondObjectInit>
  chMtxObjectInit(&m1);
 80034b8:	4804      	ldr	r0, [pc, #16]	; (80034cc <rt_test_006_009_setup.lto_priv.781+0x1c>)
 80034ba:	f00e f839 	bl	8011530 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 80034be:	4804      	ldr	r0, [pc, #16]	; (80034d0 <rt_test_006_009_setup.lto_priv.781+0x20>)
 80034c0:	f00e f836 	bl	8011530 <chMtxObjectInit>
}
 80034c4:	bd08      	pop	{r3, pc}
 80034c6:	bf00      	nop
 80034c8:	20000868 	.word	0x20000868
 80034cc:	20000848 	.word	0x20000848
 80034d0:	20000858 	.word	0x20000858
	...

080034e0 <rt_test_006_009_execute.lto_priv.782>:

static void rt_test_006_009_execute(void) {
 80034e0:	b500      	push	{lr}
 80034e2:	b085      	sub	sp, #20
  tprio_t prio;

  /* [6.9.1] Reading current base priority.*/
  test_set_step(1);
 80034e4:	4b28      	ldr	r3, [pc, #160]	; (8003588 <rt_test_006_009_execute.lto_priv.782+0xa8>)
 80034e6:	2201      	movs	r2, #1
 80034e8:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 80034ea:	f7ff fbc1 	bl	8002c70 <chThdGetPriorityX.lto_priv.92>
 80034ee:	9003      	str	r0, [sp, #12]
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 80034f0:	4b25      	ldr	r3, [pc, #148]	; (8003588 <rt_test_006_009_execute.lto_priv.782+0xa8>)
 80034f2:	2202      	movs	r2, #2
 80034f4:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 80034f6:	4b25      	ldr	r3, [pc, #148]	; (800358c <rt_test_006_009_execute.lto_priv.782+0xac>)
 80034f8:	6818      	ldr	r0, [r3, #0]
 80034fa:	9b03      	ldr	r3, [sp, #12]
 80034fc:	1c5a      	adds	r2, r3, #1
 80034fe:	4b24      	ldr	r3, [pc, #144]	; (8003590 <rt_test_006_009_execute.lto_priv.782+0xb0>)
 8003500:	9300      	str	r3, [sp, #0]
 8003502:	4b24      	ldr	r3, [pc, #144]	; (8003594 <rt_test_006_009_execute.lto_priv.782+0xb4>)
 8003504:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003508:	f00c ffea 	bl	80104e0 <chThdCreateStatic>
 800350c:	4602      	mov	r2, r0
 800350e:	4b22      	ldr	r3, [pc, #136]	; (8003598 <rt_test_006_009_execute.lto_priv.782+0xb8>)
 8003510:	601a      	str	r2, [r3, #0]
  }

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8003512:	4b1d      	ldr	r3, [pc, #116]	; (8003588 <rt_test_006_009_execute.lto_priv.782+0xa8>)
 8003514:	2203      	movs	r2, #3
 8003516:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8003518:	4b1c      	ldr	r3, [pc, #112]	; (800358c <rt_test_006_009_execute.lto_priv.782+0xac>)
 800351a:	6858      	ldr	r0, [r3, #4]
 800351c:	9b03      	ldr	r3, [sp, #12]
 800351e:	1c9a      	adds	r2, r3, #2
 8003520:	4b1e      	ldr	r3, [pc, #120]	; (800359c <rt_test_006_009_execute.lto_priv.782+0xbc>)
 8003522:	9300      	str	r3, [sp, #0]
 8003524:	4b1e      	ldr	r3, [pc, #120]	; (80035a0 <rt_test_006_009_execute.lto_priv.782+0xc0>)
 8003526:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800352a:	f00c ffd9 	bl	80104e0 <chThdCreateStatic>
 800352e:	4602      	mov	r2, r0
 8003530:	4b19      	ldr	r3, [pc, #100]	; (8003598 <rt_test_006_009_execute.lto_priv.782+0xb8>)
 8003532:	605a      	str	r2, [r3, #4]
  }

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 8003534:	4b14      	ldr	r3, [pc, #80]	; (8003588 <rt_test_006_009_execute.lto_priv.782+0xa8>)
 8003536:	2204      	movs	r2, #4
 8003538:	601a      	str	r2, [r3, #0]
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 800353a:	4b14      	ldr	r3, [pc, #80]	; (800358c <rt_test_006_009_execute.lto_priv.782+0xac>)
 800353c:	6898      	ldr	r0, [r3, #8]
 800353e:	9b03      	ldr	r3, [sp, #12]
 8003540:	1cda      	adds	r2, r3, #3
 8003542:	4b18      	ldr	r3, [pc, #96]	; (80035a4 <rt_test_006_009_execute.lto_priv.782+0xc4>)
 8003544:	9300      	str	r3, [sp, #0]
 8003546:	4b18      	ldr	r3, [pc, #96]	; (80035a8 <rt_test_006_009_execute.lto_priv.782+0xc8>)
 8003548:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800354c:	f00c ffc8 	bl	80104e0 <chThdCreateStatic>
 8003550:	4602      	mov	r2, r0
 8003552:	4b11      	ldr	r3, [pc, #68]	; (8003598 <rt_test_006_009_execute.lto_priv.782+0xb8>)
 8003554:	609a      	str	r2, [r3, #8]
  }

  /* [6.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 8003556:	4b0c      	ldr	r3, [pc, #48]	; (8003588 <rt_test_006_009_execute.lto_priv.782+0xa8>)
 8003558:	2205      	movs	r2, #5
 800355a:	601a      	str	r2, [r3, #0]
  {
    chCondSignal(&c1);
 800355c:	4813      	ldr	r0, [pc, #76]	; (80035ac <rt_test_006_009_execute.lto_priv.782+0xcc>)
 800355e:	f00e fab7 	bl	8011ad0 <chCondSignal>
  }

  /* [6.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 8003562:	4b09      	ldr	r3, [pc, #36]	; (8003588 <rt_test_006_009_execute.lto_priv.782+0xa8>)
 8003564:	2206      	movs	r2, #6
 8003566:	601a      	str	r2, [r3, #0]
  {
    chCondSignal(&c1);
 8003568:	4810      	ldr	r0, [pc, #64]	; (80035ac <rt_test_006_009_execute.lto_priv.782+0xcc>)
 800356a:	f00e fab1 	bl	8011ad0 <chCondSignal>
  }

  /* [6.9.7] Checking the order of operations.*/
  test_set_step(7);
 800356e:	4b06      	ldr	r3, [pc, #24]	; (8003588 <rt_test_006_009_execute.lto_priv.782+0xa8>)
 8003570:	2207      	movs	r2, #7
 8003572:	601a      	str	r2, [r3, #0]
  {
    test_wait_threads();
 8003574:	f7fd fc04 	bl	8000d80 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
 8003578:	490d      	ldr	r1, [pc, #52]	; (80035b0 <rt_test_006_009_execute.lto_priv.782+0xd0>)
 800357a:	480e      	ldr	r0, [pc, #56]	; (80035b4 <rt_test_006_009_execute.lto_priv.782+0xd4>)
 800357c:	f011 ff98 	bl	80154b0 <_test_assert_sequence>
  }
}
 8003580:	b005      	add	sp, #20
 8003582:	f85d fb04 	ldr.w	pc, [sp], #4
 8003586:	bf00      	nop
 8003588:	20001988 	.word	0x20001988
 800358c:	08017360 	.word	0x08017360
 8003590:	08017f34 	.word	0x08017f34
 8003594:	08002d41 	.word	0x08002d41
 8003598:	20002018 	.word	0x20002018
 800359c:	08017f2c 	.word	0x08017f2c
 80035a0:	08002d11 	.word	0x08002d11
 80035a4:	08017f30 	.word	0x08017f30
 80035a8:	08002d91 	.word	0x08002d91
 80035ac:	20000868 	.word	0x20000868
 80035b0:	08017f38 	.word	0x08017f38
 80035b4:	08018244 	.word	0x08018244
	...

080035c0 <chThdGetSelfX.lto_priv.101>:
  return ch.rlist.current;
 80035c0:	4b01      	ldr	r3, [pc, #4]	; (80035c8 <chThdGetSelfX.lto_priv.101+0x8>)
 80035c2:	699b      	ldr	r3, [r3, #24]
}
 80035c4:	4618      	mov	r0, r3
 80035c6:	4770      	bx	lr
 80035c8:	20001090 	.word	0x20001090
 80035cc:	00000000 	.word	0x00000000

080035d0 <chThdGetPriorityX.lto_priv.93>:
static inline tprio_t chThdGetPriorityX(void) {
 80035d0:	b508      	push	{r3, lr}
  return chThdGetSelfX()->prio;
 80035d2:	f7ff fff5 	bl	80035c0 <chThdGetSelfX.lto_priv.101>
 80035d6:	4603      	mov	r3, r0
 80035d8:	689b      	ldr	r3, [r3, #8]
}
 80035da:	4618      	mov	r0, r3
 80035dc:	bd08      	pop	{r3, pc}
 80035de:	bf00      	nop

080035e0 <chMsgGet.lto_priv.85>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 80035e0:	b500      	push	{lr}
 80035e2:	b083      	sub	sp, #12
 80035e4:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
 80035e6:	9b01      	ldr	r3, [sp, #4]
 80035e8:	f893 3020 	ldrb.w	r3, [r3, #32]
 80035ec:	2b0d      	cmp	r3, #13
 80035ee:	d002      	beq.n	80035f6 <chMsgGet.lto_priv.85+0x16>
 80035f0:	4804      	ldr	r0, [pc, #16]	; (8003604 <chMsgGet.lto_priv.85+0x24>)
 80035f2:	f00b fcf5 	bl	800efe0 <chSysHalt>

  return tp->u.sentmsg;
 80035f6:	9b01      	ldr	r3, [sp, #4]
 80035f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80035fa:	4618      	mov	r0, r3
 80035fc:	b003      	add	sp, #12
 80035fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8003602:	bf00      	nop
 8003604:	080182b0 	.word	0x080182b0
	...

08003610 <msg_thread1>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8003610:	b500      	push	{lr}
 8003612:	b083      	sub	sp, #12
 8003614:	9001      	str	r0, [sp, #4]

  chMsgSend(p, 'A');
 8003616:	2141      	movs	r1, #65	; 0x41
 8003618:	9801      	ldr	r0, [sp, #4]
 800361a:	f00e ff19 	bl	8012450 <chMsgSend>
  chMsgSend(p, 'B');
 800361e:	2142      	movs	r1, #66	; 0x42
 8003620:	9801      	ldr	r0, [sp, #4]
 8003622:	f00e ff15 	bl	8012450 <chMsgSend>
  chMsgSend(p, 'C');
 8003626:	2143      	movs	r1, #67	; 0x43
 8003628:	9801      	ldr	r0, [sp, #4]
 800362a:	f00e ff11 	bl	8012450 <chMsgSend>
  chMsgSend(p, 'D');
 800362e:	2144      	movs	r1, #68	; 0x44
 8003630:	9801      	ldr	r0, [sp, #4]
 8003632:	f00e ff0d 	bl	8012450 <chMsgSend>
}
 8003636:	b003      	add	sp, #12
 8003638:	f85d fb04 	ldr.w	pc, [sp], #4
 800363c:	0000      	movs	r0, r0
	...

08003640 <rt_test_007_001_execute.lto_priv.783>:
 * - [7.1.1] Starting the messenger thread.
 * - [7.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void rt_test_007_001_execute(void) {
 8003640:	b530      	push	{r4, r5, lr}
 8003642:	b087      	sub	sp, #28
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8003644:	4b1d      	ldr	r3, [pc, #116]	; (80036bc <rt_test_007_001_execute.lto_priv.783+0x7c>)
 8003646:	2201      	movs	r2, #1
 8003648:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800364a:	4b1d      	ldr	r3, [pc, #116]	; (80036c0 <rt_test_007_001_execute.lto_priv.783+0x80>)
 800364c:	681c      	ldr	r4, [r3, #0]
 800364e:	f7ff ffbf 	bl	80035d0 <chThdGetPriorityX.lto_priv.93>
 8003652:	4603      	mov	r3, r0
 8003654:	1c5d      	adds	r5, r3, #1
                                   msg_thread1, chThdGetSelfX());
 8003656:	f7ff ffb3 	bl	80035c0 <chThdGetSelfX.lto_priv.101>
 800365a:	4603      	mov	r3, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800365c:	9300      	str	r3, [sp, #0]
 800365e:	4b19      	ldr	r3, [pc, #100]	; (80036c4 <rt_test_007_001_execute.lto_priv.783+0x84>)
 8003660:	462a      	mov	r2, r5
 8003662:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003666:	4620      	mov	r0, r4
 8003668:	f00c ff3a 	bl	80104e0 <chThdCreateStatic>
 800366c:	4602      	mov	r2, r0
 800366e:	4b16      	ldr	r3, [pc, #88]	; (80036c8 <rt_test_007_001_execute.lto_priv.783+0x88>)
 8003670:	601a      	str	r2, [r3, #0]
  }

  /* [7.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8003672:	4b12      	ldr	r3, [pc, #72]	; (80036bc <rt_test_007_001_execute.lto_priv.783+0x7c>)
 8003674:	2202      	movs	r2, #2
 8003676:	601a      	str	r2, [r3, #0]
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
 8003678:	2300      	movs	r3, #0
 800367a:	9305      	str	r3, [sp, #20]
 800367c:	e012      	b.n	80036a4 <rt_test_007_001_execute.lto_priv.783+0x64>
      tp = chMsgWait();
 800367e:	f00e ff1f 	bl	80124c0 <chMsgWait>
 8003682:	9004      	str	r0, [sp, #16]
      msg = chMsgGet(tp);
 8003684:	9804      	ldr	r0, [sp, #16]
 8003686:	f7ff ffab 	bl	80035e0 <chMsgGet.lto_priv.85>
 800368a:	9003      	str	r0, [sp, #12]
      chMsgRelease(tp, msg);
 800368c:	9903      	ldr	r1, [sp, #12]
 800368e:	9804      	ldr	r0, [sp, #16]
 8003690:	f00e ff3e 	bl	8012510 <chMsgRelease>
      test_emit_token(msg);
 8003694:	9b03      	ldr	r3, [sp, #12]
 8003696:	b2db      	uxtb	r3, r3
 8003698:	4618      	mov	r0, r3
 800369a:	f011 ffd1 	bl	8015640 <test_emit_token>
    for (i = 0; i < 4; i++) {
 800369e:	9b05      	ldr	r3, [sp, #20]
 80036a0:	3301      	adds	r3, #1
 80036a2:	9305      	str	r3, [sp, #20]
 80036a4:	9b05      	ldr	r3, [sp, #20]
 80036a6:	2b03      	cmp	r3, #3
 80036a8:	d9e9      	bls.n	800367e <rt_test_007_001_execute.lto_priv.783+0x3e>
    }
    test_wait_threads();
 80036aa:	f7fd fb69 	bl	8000d80 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 80036ae:	4907      	ldr	r1, [pc, #28]	; (80036cc <rt_test_007_001_execute.lto_priv.783+0x8c>)
 80036b0:	4807      	ldr	r0, [pc, #28]	; (80036d0 <rt_test_007_001_execute.lto_priv.783+0x90>)
 80036b2:	f011 fefd 	bl	80154b0 <_test_assert_sequence>
  }
}
 80036b6:	b007      	add	sp, #28
 80036b8:	bd30      	pop	{r4, r5, pc}
 80036ba:	bf00      	nop
 80036bc:	20001988 	.word	0x20001988
 80036c0:	08017360 	.word	0x08017360
 80036c4:	08003611 	.word	0x08003611
 80036c8:	20002018 	.word	0x20002018
 80036cc:	08017f38 	.word	0x08017f38
 80036d0:	08018288 	.word	0x08018288
	...

080036e0 <chTimeAddX.lto_priv.123>:
                                   sysinterval_t interval) {
 80036e0:	b082      	sub	sp, #8
 80036e2:	9001      	str	r0, [sp, #4]
 80036e4:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
 80036e6:	9a01      	ldr	r2, [sp, #4]
 80036e8:	9b00      	ldr	r3, [sp, #0]
 80036ea:	4413      	add	r3, r2
}
 80036ec:	4618      	mov	r0, r3
 80036ee:	b002      	add	sp, #8
 80036f0:	4770      	bx	lr
 80036f2:	bf00      	nop
	...

08003700 <port_lock.lto_priv.24>:
static inline void port_lock(void) {
 8003700:	b082      	sub	sp, #8
 8003702:	2320      	movs	r3, #32
 8003704:	9301      	str	r3, [sp, #4]
 8003706:	9b01      	ldr	r3, [sp, #4]
 8003708:	f383 8811 	msr	BASEPRI, r3
}
 800370c:	b002      	add	sp, #8
 800370e:	4770      	bx	lr

08003710 <port_unlock.lto_priv.14>:
static inline void port_unlock(void) {
 8003710:	b082      	sub	sp, #8
 8003712:	2300      	movs	r3, #0
 8003714:	9301      	str	r3, [sp, #4]
 8003716:	9b01      	ldr	r3, [sp, #4]
 8003718:	f383 8811 	msr	BASEPRI, r3
}
 800371c:	b002      	add	sp, #8
 800371e:	4770      	bx	lr

08003720 <chSysLock.lto_priv.80>:
static inline void chSysLock(void) {
 8003720:	b508      	push	{r3, lr}
  port_lock();
 8003722:	f7ff ffed 	bl	8003700 <port_lock.lto_priv.24>
  _dbg_check_lock();
 8003726:	f00b fdcb 	bl	800f2c0 <_dbg_check_lock>
}
 800372a:	bd08      	pop	{r3, pc}
 800372c:	0000      	movs	r0, r0
	...

08003730 <chSysUnlock.lto_priv.44>:
static inline void chSysUnlock(void) {
 8003730:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8003732:	f00b fddd 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003736:	4b09      	ldr	r3, [pc, #36]	; (800375c <chSysUnlock.lto_priv.44+0x2c>)
 8003738:	681b      	ldr	r3, [r3, #0]
 800373a:	4a08      	ldr	r2, [pc, #32]	; (800375c <chSysUnlock.lto_priv.44+0x2c>)
 800373c:	4293      	cmp	r3, r2
 800373e:	d00a      	beq.n	8003756 <chSysUnlock.lto_priv.44+0x26>
 8003740:	4b06      	ldr	r3, [pc, #24]	; (800375c <chSysUnlock.lto_priv.44+0x2c>)
 8003742:	699b      	ldr	r3, [r3, #24]
 8003744:	689a      	ldr	r2, [r3, #8]
 8003746:	4b05      	ldr	r3, [pc, #20]	; (800375c <chSysUnlock.lto_priv.44+0x2c>)
 8003748:	681b      	ldr	r3, [r3, #0]
 800374a:	689b      	ldr	r3, [r3, #8]
 800374c:	429a      	cmp	r2, r3
 800374e:	d202      	bcs.n	8003756 <chSysUnlock.lto_priv.44+0x26>
 8003750:	4803      	ldr	r0, [pc, #12]	; (8003760 <chSysUnlock.lto_priv.44+0x30>)
 8003752:	f00b fc45 	bl	800efe0 <chSysHalt>
  port_unlock();
 8003756:	f7ff ffdb 	bl	8003710 <port_unlock.lto_priv.14>
}
 800375a:	bd08      	pop	{r3, pc}
 800375c:	20001090 	.word	0x20001090
 8003760:	080183ec 	.word	0x080183ec
	...

08003770 <chThdGetSelfX.lto_priv.102>:
  return ch.rlist.current;
 8003770:	4b01      	ldr	r3, [pc, #4]	; (8003778 <chThdGetSelfX.lto_priv.102+0x8>)
 8003772:	699b      	ldr	r3, [r3, #24]
}
 8003774:	4618      	mov	r0, r3
 8003776:	4770      	bx	lr
 8003778:	20001090 	.word	0x20001090
 800377c:	00000000 	.word	0x00000000

08003780 <chThdGetPriorityX.lto_priv.94>:
static inline tprio_t chThdGetPriorityX(void) {
 8003780:	b508      	push	{r3, lr}
  return chThdGetSelfX()->prio;
 8003782:	f7ff fff5 	bl	8003770 <chThdGetSelfX.lto_priv.102>
 8003786:	4603      	mov	r3, r0
 8003788:	689b      	ldr	r3, [r3, #8]
}
 800378a:	4618      	mov	r0, r3
 800378c:	bd08      	pop	{r3, pc}
 800378e:	bf00      	nop

08003790 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8003790:	b082      	sub	sp, #8
 8003792:	9001      	str	r0, [sp, #4]

  esp->next = (event_listener_t *)esp;
 8003794:	9b01      	ldr	r3, [sp, #4]
 8003796:	9a01      	ldr	r2, [sp, #4]
 8003798:	601a      	str	r2, [r3, #0]
}
 800379a:	b002      	add	sp, #8
 800379c:	4770      	bx	lr
 800379e:	bf00      	nop

080037a0 <chEvtRegisterMask>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 80037a0:	b500      	push	{lr}
 80037a2:	b085      	sub	sp, #20
 80037a4:	9003      	str	r0, [sp, #12]
 80037a6:	9102      	str	r1, [sp, #8]
 80037a8:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 80037aa:	f04f 33ff 	mov.w	r3, #4294967295
 80037ae:	9a01      	ldr	r2, [sp, #4]
 80037b0:	9902      	ldr	r1, [sp, #8]
 80037b2:	9803      	ldr	r0, [sp, #12]
 80037b4:	f00e fafc 	bl	8011db0 <chEvtRegisterMaskWithFlags>
}
 80037b8:	b005      	add	sp, #20
 80037ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80037be:	bf00      	nop

080037c0 <chEvtIsListeningI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @return              The event source status.
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {
 80037c0:	b082      	sub	sp, #8
 80037c2:	9001      	str	r0, [sp, #4]

  return (bool)(esp != (event_source_t *)esp->next);
 80037c4:	9b01      	ldr	r3, [sp, #4]
 80037c6:	681b      	ldr	r3, [r3, #0]
 80037c8:	9a01      	ldr	r2, [sp, #4]
 80037ca:	429a      	cmp	r2, r3
 80037cc:	bf14      	ite	ne
 80037ce:	2301      	movne	r3, #1
 80037d0:	2300      	moveq	r3, #0
 80037d2:	b2db      	uxtb	r3, r3
}
 80037d4:	4618      	mov	r0, r3
 80037d6:	b002      	add	sp, #8
 80037d8:	4770      	bx	lr
 80037da:	bf00      	nop
 80037dc:	0000      	movs	r0, r0
	...

080037e0 <chEvtBroadcast>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {
 80037e0:	b500      	push	{lr}
 80037e2:	b083      	sub	sp, #12
 80037e4:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 80037e6:	2100      	movs	r1, #0
 80037e8:	9801      	ldr	r0, [sp, #4]
 80037ea:	f00e fc09 	bl	8012000 <chEvtBroadcastFlags>
}
 80037ee:	b003      	add	sp, #12
 80037f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003800 <osalSysLock.lto_priv.36>:
static inline void osalSysLock(void) {
 8003800:	b508      	push	{r3, lr}
  chSysLock();
 8003802:	f7ff ff8d 	bl	8003720 <chSysLock.lto_priv.80>
}
 8003806:	bd08      	pop	{r3, pc}
	...

08003810 <osalSysUnlock.lto_priv.33>:
static inline void osalSysUnlock(void) {
 8003810:	b508      	push	{r3, lr}
  chSysUnlock();
 8003812:	f7ff ff8d 	bl	8003730 <chSysUnlock.lto_priv.44>
}
 8003816:	bd08      	pop	{r3, pc}
	...

08003820 <h1>:
 ****************************************************************************/

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8003820:	b500      	push	{lr}
 8003822:	b083      	sub	sp, #12
 8003824:	9001      	str	r0, [sp, #4]
 8003826:	2041      	movs	r0, #65	; 0x41
 8003828:	f011 ff0a 	bl	8015640 <test_emit_token>
 800382c:	b003      	add	sp, #12
 800382e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003832:	bf00      	nop
	...

08003840 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8003840:	b500      	push	{lr}
 8003842:	b083      	sub	sp, #12
 8003844:	9001      	str	r0, [sp, #4]
 8003846:	2042      	movs	r0, #66	; 0x42
 8003848:	f011 fefa 	bl	8015640 <test_emit_token>
 800384c:	b003      	add	sp, #12
 800384e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003852:	bf00      	nop
	...

08003860 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8003860:	b500      	push	{lr}
 8003862:	b083      	sub	sp, #12
 8003864:	9001      	str	r0, [sp, #4]
 8003866:	2043      	movs	r0, #67	; 0x43
 8003868:	f011 feea 	bl	8015640 <test_emit_token>
 800386c:	b003      	add	sp, #12
 800386e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003872:	bf00      	nop
	...

08003880 <evt_thread3>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static THD_FUNCTION(evt_thread3, p) {
 8003880:	b500      	push	{lr}
 8003882:	b083      	sub	sp, #12
 8003884:	9001      	str	r0, [sp, #4]

  chThdSleepMilliseconds(50);
 8003886:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800388a:	f00c ffc1 	bl	8010810 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 800388e:	2101      	movs	r1, #1
 8003890:	9801      	ldr	r0, [sp, #4]
 8003892:	f00e fb5d 	bl	8011f50 <chEvtSignal>
}
 8003896:	b003      	add	sp, #12
 8003898:	f85d fb04 	ldr.w	pc, [sp], #4
 800389c:	0000      	movs	r0, r0
	...

080038a0 <evt_thread7>:

static THD_FUNCTION(evt_thread7, p) {
 80038a0:	b500      	push	{lr}
 80038a2:	b083      	sub	sp, #12
 80038a4:	9001      	str	r0, [sp, #4]

  (void)p;
  chEvtBroadcast(&es1);
 80038a6:	4806      	ldr	r0, [pc, #24]	; (80038c0 <evt_thread7+0x20>)
 80038a8:	f7ff ff9a 	bl	80037e0 <chEvtBroadcast>
  chThdSleepMilliseconds(50);
 80038ac:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80038b0:	f00c ffae 	bl	8010810 <chThdSleep>
  chEvtBroadcast(&es2);
 80038b4:	4803      	ldr	r0, [pc, #12]	; (80038c4 <evt_thread7+0x24>)
 80038b6:	f7ff ff93 	bl	80037e0 <chEvtBroadcast>
}
 80038ba:	b003      	add	sp, #12
 80038bc:	f85d fb04 	ldr.w	pc, [sp], #4
 80038c0:	20000870 	.word	0x20000870
 80038c4:	20000874 	.word	0x20000874
	...

080038d0 <rt_test_008_001_execute.lto_priv.784>:
 * - [8.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void rt_test_008_001_execute(void) {
 80038d0:	b500      	push	{lr}
 80038d2:	b08b      	sub	sp, #44	; 0x2c
  event_listener_t el1, el2;

  /* [8.1.1] An Event Source is initialized.*/
  test_set_step(1);
 80038d4:	4b34      	ldr	r3, [pc, #208]	; (80039a8 <rt_test_008_001_execute.lto_priv.784+0xd8>)
 80038d6:	2201      	movs	r2, #1
 80038d8:	601a      	str	r2, [r3, #0]
  {
    chEvtObjectInit(&es1);
 80038da:	4834      	ldr	r0, [pc, #208]	; (80039ac <rt_test_008_001_execute.lto_priv.784+0xdc>)
 80038dc:	f7ff ff58 	bl	8003790 <chEvtObjectInit>
  }

  /* [8.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 80038e0:	4b31      	ldr	r3, [pc, #196]	; (80039a8 <rt_test_008_001_execute.lto_priv.784+0xd8>)
 80038e2:	2202      	movs	r2, #2
 80038e4:	601a      	str	r2, [r3, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
 80038e6:	ab05      	add	r3, sp, #20
 80038e8:	2201      	movs	r2, #1
 80038ea:	4619      	mov	r1, r3
 80038ec:	482f      	ldr	r0, [pc, #188]	; (80039ac <rt_test_008_001_execute.lto_priv.784+0xdc>)
 80038ee:	f7ff ff57 	bl	80037a0 <chEvtRegisterMask>
    chEvtRegisterMask(&es1, &el2, 2);
 80038f2:	466b      	mov	r3, sp
 80038f4:	2202      	movs	r2, #2
 80038f6:	4619      	mov	r1, r3
 80038f8:	482c      	ldr	r0, [pc, #176]	; (80039ac <rt_test_008_001_execute.lto_priv.784+0xdc>)
 80038fa:	f7ff ff51 	bl	80037a0 <chEvtRegisterMask>
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 80038fe:	f7ff ff7f 	bl	8003800 <osalSysLock.lto_priv.36>
 8003902:	482a      	ldr	r0, [pc, #168]	; (80039ac <rt_test_008_001_execute.lto_priv.784+0xdc>)
 8003904:	f7ff ff5c 	bl	80037c0 <chEvtIsListeningI>
 8003908:	4603      	mov	r3, r0
 800390a:	4929      	ldr	r1, [pc, #164]	; (80039b0 <rt_test_008_001_execute.lto_priv.784+0xe0>)
 800390c:	4618      	mov	r0, r3
 800390e:	f011 fdb7 	bl	8015480 <_test_assert>
 8003912:	4603      	mov	r3, r0
 8003914:	2b00      	cmp	r3, #0
 8003916:	d002      	beq.n	800391e <rt_test_008_001_execute.lto_priv.784+0x4e>
 8003918:	f7ff ff7a 	bl	8003810 <osalSysUnlock.lto_priv.33>
 800391c:	e040      	b.n	80039a0 <rt_test_008_001_execute.lto_priv.784+0xd0>
 800391e:	f7ff ff77 	bl	8003810 <osalSysUnlock.lto_priv.33>
  }

  /* [8.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8003922:	4b21      	ldr	r3, [pc, #132]	; (80039a8 <rt_test_008_001_execute.lto_priv.784+0xd8>)
 8003924:	2203      	movs	r2, #3
 8003926:	601a      	str	r2, [r3, #0]
  {
    chEvtUnregister(&es1, &el1);
 8003928:	ab05      	add	r3, sp, #20
 800392a:	4619      	mov	r1, r3
 800392c:	481f      	ldr	r0, [pc, #124]	; (80039ac <rt_test_008_001_execute.lto_priv.784+0xdc>)
 800392e:	f00e fa6f 	bl	8011e10 <chEvtUnregister>
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8003932:	f7ff ff65 	bl	8003800 <osalSysLock.lto_priv.36>
 8003936:	481d      	ldr	r0, [pc, #116]	; (80039ac <rt_test_008_001_execute.lto_priv.784+0xdc>)
 8003938:	f7ff ff42 	bl	80037c0 <chEvtIsListeningI>
 800393c:	4603      	mov	r3, r0
 800393e:	491c      	ldr	r1, [pc, #112]	; (80039b0 <rt_test_008_001_execute.lto_priv.784+0xe0>)
 8003940:	4618      	mov	r0, r3
 8003942:	f011 fd9d 	bl	8015480 <_test_assert>
 8003946:	4603      	mov	r3, r0
 8003948:	2b00      	cmp	r3, #0
 800394a:	d002      	beq.n	8003952 <rt_test_008_001_execute.lto_priv.784+0x82>
 800394c:	f7ff ff60 	bl	8003810 <osalSysUnlock.lto_priv.33>
 8003950:	e026      	b.n	80039a0 <rt_test_008_001_execute.lto_priv.784+0xd0>
 8003952:	f7ff ff5d 	bl	8003810 <osalSysUnlock.lto_priv.33>
  }

  /* [8.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 8003956:	4b14      	ldr	r3, [pc, #80]	; (80039a8 <rt_test_008_001_execute.lto_priv.784+0xd8>)
 8003958:	2204      	movs	r2, #4
 800395a:	601a      	str	r2, [r3, #0]
  {
    chEvtUnregister(&es1, &el2);
 800395c:	466b      	mov	r3, sp
 800395e:	4619      	mov	r1, r3
 8003960:	4812      	ldr	r0, [pc, #72]	; (80039ac <rt_test_008_001_execute.lto_priv.784+0xdc>)
 8003962:	f00e fa55 	bl	8011e10 <chEvtUnregister>
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 8003966:	f7ff ff4b 	bl	8003800 <osalSysLock.lto_priv.36>
 800396a:	4810      	ldr	r0, [pc, #64]	; (80039ac <rt_test_008_001_execute.lto_priv.784+0xdc>)
 800396c:	f7ff ff28 	bl	80037c0 <chEvtIsListeningI>
 8003970:	4603      	mov	r3, r0
 8003972:	2b00      	cmp	r3, #0
 8003974:	bf14      	ite	ne
 8003976:	2301      	movne	r3, #1
 8003978:	2300      	moveq	r3, #0
 800397a:	b2db      	uxtb	r3, r3
 800397c:	f083 0301 	eor.w	r3, r3, #1
 8003980:	b2db      	uxtb	r3, r3
 8003982:	f003 0301 	and.w	r3, r3, #1
 8003986:	b2db      	uxtb	r3, r3
 8003988:	490a      	ldr	r1, [pc, #40]	; (80039b4 <rt_test_008_001_execute.lto_priv.784+0xe4>)
 800398a:	4618      	mov	r0, r3
 800398c:	f011 fd78 	bl	8015480 <_test_assert>
 8003990:	4603      	mov	r3, r0
 8003992:	2b00      	cmp	r3, #0
 8003994:	d002      	beq.n	800399c <rt_test_008_001_execute.lto_priv.784+0xcc>
 8003996:	f7ff ff3b 	bl	8003810 <osalSysUnlock.lto_priv.33>
 800399a:	e001      	b.n	80039a0 <rt_test_008_001_execute.lto_priv.784+0xd0>
 800399c:	f7ff ff38 	bl	8003810 <osalSysUnlock.lto_priv.33>
  }
}
 80039a0:	b00b      	add	sp, #44	; 0x2c
 80039a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80039a6:	bf00      	nop
 80039a8:	20001988 	.word	0x20001988
 80039ac:	20000870 	.word	0x20000870
 80039b0:	080182c8 	.word	0x080182c8
 80039b4:	080182d4 	.word	0x080182d4
	...

080039c0 <rt_test_008_002_setup.lto_priv.785>:
 * - [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
 *   invoked, the sequence of handlers calls is tested.
 * .
 */

static void rt_test_008_002_setup(void) {
 80039c0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80039c2:	f04f 30ff 	mov.w	r0, #4294967295
 80039c6:	f00e fa6b 	bl	8011ea0 <chEvtGetAndClearEvents>
}
 80039ca:	bd08      	pop	{r3, pc}
 80039cc:	0000      	movs	r0, r0
	...

080039d0 <rt_test_008_002_execute.lto_priv.786>:

static void rt_test_008_002_execute(void) {
 80039d0:	b508      	push	{r3, lr}

  /* [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
 80039d2:	4b06      	ldr	r3, [pc, #24]	; (80039ec <rt_test_008_002_execute.lto_priv.786+0x1c>)
 80039d4:	2201      	movs	r2, #1
 80039d6:	601a      	str	r2, [r3, #0]
  {
    chEvtDispatch(evhndl, 7);
 80039d8:	2107      	movs	r1, #7
 80039da:	4805      	ldr	r0, [pc, #20]	; (80039f0 <rt_test_008_002_execute.lto_priv.786+0x20>)
 80039dc:	f00e fb28 	bl	8012030 <chEvtDispatch>
    test_assert_sequence("ABC", "invalid sequence");
 80039e0:	4904      	ldr	r1, [pc, #16]	; (80039f4 <rt_test_008_002_execute.lto_priv.786+0x24>)
 80039e2:	4805      	ldr	r0, [pc, #20]	; (80039f8 <rt_test_008_002_execute.lto_priv.786+0x28>)
 80039e4:	f011 fd64 	bl	80154b0 <_test_assert_sequence>
  }
}
 80039e8:	bd08      	pop	{r3, pc}
 80039ea:	bf00      	nop
 80039ec:	20001988 	.word	0x20001988
 80039f0:	080182bc 	.word	0x080182bc
 80039f4:	08017f38 	.word	0x08017f38
 80039f8:	08018244 	.word	0x08018244
 80039fc:	00000000 	.word	0x00000000

08003a00 <rt_test_008_003_setup.lto_priv.787>:
 *   been received after 50mS and that the event flags mask has been
 *   emptied.
 * .
 */

static void rt_test_008_003_setup(void) {
 8003a00:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8003a02:	f04f 30ff 	mov.w	r0, #4294967295
 8003a06:	f00e fa4b 	bl	8011ea0 <chEvtGetAndClearEvents>
}
 8003a0a:	bd08      	pop	{r3, pc}
 8003a0c:	0000      	movs	r0, r0
	...

08003a10 <rt_test_008_003_execute.lto_priv.788>:

static void rt_test_008_003_execute(void) {
 8003a10:	b530      	push	{r4, r5, lr}
 8003a12:	b085      	sub	sp, #20
  eventmask_t m;
  systime_t target_time;

  /* [8.3.1] Setting three event flags.*/
  test_set_step(1);
 8003a14:	4b54      	ldr	r3, [pc, #336]	; (8003b68 <rt_test_008_003_execute.lto_priv.788+0x158>)
 8003a16:	2201      	movs	r2, #1
 8003a18:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(7);
 8003a1a:	2007      	movs	r0, #7
 8003a1c:	f00e fa50 	bl	8011ec0 <chEvtAddEvents>
  }

  /* [8.3.2] Calling chEvtWaitOne() three times, each time a single
     flag must be returned in order of priority.*/
  test_set_step(2);
 8003a20:	4b51      	ldr	r3, [pc, #324]	; (8003b68 <rt_test_008_003_execute.lto_priv.788+0x158>)
 8003a22:	2202      	movs	r2, #2
 8003a24:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8003a26:	f04f 30ff 	mov.w	r0, #4294967295
 8003a2a:	f00e fb41 	bl	80120b0 <chEvtWaitOne>
 8003a2e:	9003      	str	r0, [sp, #12]
    test_assert(m == 1, "single event error");
 8003a30:	9b03      	ldr	r3, [sp, #12]
 8003a32:	2b01      	cmp	r3, #1
 8003a34:	bf0c      	ite	eq
 8003a36:	2301      	moveq	r3, #1
 8003a38:	2300      	movne	r3, #0
 8003a3a:	b2db      	uxtb	r3, r3
 8003a3c:	494b      	ldr	r1, [pc, #300]	; (8003b6c <rt_test_008_003_execute.lto_priv.788+0x15c>)
 8003a3e:	4618      	mov	r0, r3
 8003a40:	f011 fd1e 	bl	8015480 <_test_assert>
 8003a44:	4603      	mov	r3, r0
 8003a46:	2b00      	cmp	r3, #0
 8003a48:	f040 808c 	bne.w	8003b64 <rt_test_008_003_execute.lto_priv.788+0x154>
    m = chEvtWaitOne(ALL_EVENTS);
 8003a4c:	f04f 30ff 	mov.w	r0, #4294967295
 8003a50:	f00e fb2e 	bl	80120b0 <chEvtWaitOne>
 8003a54:	9003      	str	r0, [sp, #12]
    test_assert(m == 2, "single event error");
 8003a56:	9b03      	ldr	r3, [sp, #12]
 8003a58:	2b02      	cmp	r3, #2
 8003a5a:	bf0c      	ite	eq
 8003a5c:	2301      	moveq	r3, #1
 8003a5e:	2300      	movne	r3, #0
 8003a60:	b2db      	uxtb	r3, r3
 8003a62:	4942      	ldr	r1, [pc, #264]	; (8003b6c <rt_test_008_003_execute.lto_priv.788+0x15c>)
 8003a64:	4618      	mov	r0, r3
 8003a66:	f011 fd0b 	bl	8015480 <_test_assert>
 8003a6a:	4603      	mov	r3, r0
 8003a6c:	2b00      	cmp	r3, #0
 8003a6e:	d179      	bne.n	8003b64 <rt_test_008_003_execute.lto_priv.788+0x154>
    m = chEvtWaitOne(ALL_EVENTS);
 8003a70:	f04f 30ff 	mov.w	r0, #4294967295
 8003a74:	f00e fb1c 	bl	80120b0 <chEvtWaitOne>
 8003a78:	9003      	str	r0, [sp, #12]
    test_assert(m == 4, "single event error");
 8003a7a:	9b03      	ldr	r3, [sp, #12]
 8003a7c:	2b04      	cmp	r3, #4
 8003a7e:	bf0c      	ite	eq
 8003a80:	2301      	moveq	r3, #1
 8003a82:	2300      	movne	r3, #0
 8003a84:	b2db      	uxtb	r3, r3
 8003a86:	4939      	ldr	r1, [pc, #228]	; (8003b6c <rt_test_008_003_execute.lto_priv.788+0x15c>)
 8003a88:	4618      	mov	r0, r3
 8003a8a:	f011 fcf9 	bl	8015480 <_test_assert>
 8003a8e:	4603      	mov	r3, r0
 8003a90:	2b00      	cmp	r3, #0
 8003a92:	d167      	bne.n	8003b64 <rt_test_008_003_execute.lto_priv.788+0x154>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003a94:	f04f 30ff 	mov.w	r0, #4294967295
 8003a98:	f00e fa02 	bl	8011ea0 <chEvtGetAndClearEvents>
 8003a9c:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 8003a9e:	9b03      	ldr	r3, [sp, #12]
 8003aa0:	2b00      	cmp	r3, #0
 8003aa2:	bf0c      	ite	eq
 8003aa4:	2301      	moveq	r3, #1
 8003aa6:	2300      	movne	r3, #0
 8003aa8:	b2db      	uxtb	r3, r3
 8003aaa:	4931      	ldr	r1, [pc, #196]	; (8003b70 <rt_test_008_003_execute.lto_priv.788+0x160>)
 8003aac:	4618      	mov	r0, r3
 8003aae:	f011 fce7 	bl	8015480 <_test_assert>
 8003ab2:	4603      	mov	r3, r0
 8003ab4:	2b00      	cmp	r3, #0
 8003ab6:	d155      	bne.n	8003b64 <rt_test_008_003_execute.lto_priv.788+0x154>
  }

  /* [8.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 8003ab8:	4b2b      	ldr	r3, [pc, #172]	; (8003b68 <rt_test_008_003_execute.lto_priv.788+0x158>)
 8003aba:	2203      	movs	r2, #3
 8003abc:	601a      	str	r2, [r3, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8003abe:	f7fd f987 	bl	8000dd0 <test_wait_tick>
 8003ac2:	4603      	mov	r3, r0
 8003ac4:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8003ac8:	4618      	mov	r0, r3
 8003aca:	f7ff fe09 	bl	80036e0 <chTimeAddX.lto_priv.123>
 8003ace:	9002      	str	r0, [sp, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003ad0:	4b28      	ldr	r3, [pc, #160]	; (8003b74 <rt_test_008_003_execute.lto_priv.788+0x164>)
 8003ad2:	681c      	ldr	r4, [r3, #0]
 8003ad4:	f7ff fe54 	bl	8003780 <chThdGetPriorityX.lto_priv.94>
 8003ad8:	4603      	mov	r3, r0
 8003ada:	1e5d      	subs	r5, r3, #1
                                   evt_thread3, chThdGetSelfX());
 8003adc:	f7ff fe48 	bl	8003770 <chThdGetSelfX.lto_priv.102>
 8003ae0:	4603      	mov	r3, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003ae2:	9300      	str	r3, [sp, #0]
 8003ae4:	4b24      	ldr	r3, [pc, #144]	; (8003b78 <rt_test_008_003_execute.lto_priv.788+0x168>)
 8003ae6:	462a      	mov	r2, r5
 8003ae8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003aec:	4620      	mov	r0, r4
 8003aee:	f00c fcf7 	bl	80104e0 <chThdCreateStatic>
 8003af2:	4602      	mov	r2, r0
 8003af4:	4b21      	ldr	r3, [pc, #132]	; (8003b7c <rt_test_008_003_execute.lto_priv.788+0x16c>)
 8003af6:	601a      	str	r2, [r3, #0]
  }

  /* [8.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 8003af8:	4b1b      	ldr	r3, [pc, #108]	; (8003b68 <rt_test_008_003_execute.lto_priv.788+0x158>)
 8003afa:	2204      	movs	r2, #4
 8003afc:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8003afe:	f04f 30ff 	mov.w	r0, #4294967295
 8003b02:	f00e fad5 	bl	80120b0 <chEvtWaitOne>
 8003b06:	9003      	str	r0, [sp, #12]
    test_assert_time_window(target_time,
 8003b08:	2114      	movs	r1, #20
 8003b0a:	9802      	ldr	r0, [sp, #8]
 8003b0c:	f7ff fde8 	bl	80036e0 <chTimeAddX.lto_priv.123>
 8003b10:	4603      	mov	r3, r0
 8003b12:	4a1b      	ldr	r2, [pc, #108]	; (8003b80 <rt_test_008_003_execute.lto_priv.788+0x170>)
 8003b14:	4619      	mov	r1, r3
 8003b16:	9802      	ldr	r0, [sp, #8]
 8003b18:	f011 fcfa 	bl	8015510 <_test_assert_time_window>
 8003b1c:	4603      	mov	r3, r0
 8003b1e:	2b00      	cmp	r3, #0
 8003b20:	d120      	bne.n	8003b64 <rt_test_008_003_execute.lto_priv.788+0x154>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    test_assert(m == 1, "event flag error");
 8003b22:	9b03      	ldr	r3, [sp, #12]
 8003b24:	2b01      	cmp	r3, #1
 8003b26:	bf0c      	ite	eq
 8003b28:	2301      	moveq	r3, #1
 8003b2a:	2300      	movne	r3, #0
 8003b2c:	b2db      	uxtb	r3, r3
 8003b2e:	4915      	ldr	r1, [pc, #84]	; (8003b84 <rt_test_008_003_execute.lto_priv.788+0x174>)
 8003b30:	4618      	mov	r0, r3
 8003b32:	f011 fca5 	bl	8015480 <_test_assert>
 8003b36:	4603      	mov	r3, r0
 8003b38:	2b00      	cmp	r3, #0
 8003b3a:	d113      	bne.n	8003b64 <rt_test_008_003_execute.lto_priv.788+0x154>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003b3c:	f04f 30ff 	mov.w	r0, #4294967295
 8003b40:	f00e f9ae 	bl	8011ea0 <chEvtGetAndClearEvents>
 8003b44:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 8003b46:	9b03      	ldr	r3, [sp, #12]
 8003b48:	2b00      	cmp	r3, #0
 8003b4a:	bf0c      	ite	eq
 8003b4c:	2301      	moveq	r3, #1
 8003b4e:	2300      	movne	r3, #0
 8003b50:	b2db      	uxtb	r3, r3
 8003b52:	4907      	ldr	r1, [pc, #28]	; (8003b70 <rt_test_008_003_execute.lto_priv.788+0x160>)
 8003b54:	4618      	mov	r0, r3
 8003b56:	f011 fc93 	bl	8015480 <_test_assert>
 8003b5a:	4603      	mov	r3, r0
 8003b5c:	2b00      	cmp	r3, #0
 8003b5e:	d101      	bne.n	8003b64 <rt_test_008_003_execute.lto_priv.788+0x154>
    test_wait_threads();
 8003b60:	f7fd f90e 	bl	8000d80 <test_wait_threads>
  }
}
 8003b64:	b005      	add	sp, #20
 8003b66:	bd30      	pop	{r4, r5, pc}
 8003b68:	20001988 	.word	0x20001988
 8003b6c:	08018304 	.word	0x08018304
 8003b70:	08018318 	.word	0x08018318
 8003b74:	08017360 	.word	0x08017360
 8003b78:	08003881 	.word	0x08003881
 8003b7c:	20002018 	.word	0x20002018
 8003b80:	08017f08 	.word	0x08017f08
 8003b84:	08018324 	.word	0x08018324
	...

08003b90 <rt_test_008_004_setup.lto_priv.789>:
 *   been received after 50mS and that the event flags mask has been
 *   emptied.
 * .
 */

static void rt_test_008_004_setup(void) {
 8003b90:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8003b92:	f04f 30ff 	mov.w	r0, #4294967295
 8003b96:	f00e f983 	bl	8011ea0 <chEvtGetAndClearEvents>
}
 8003b9a:	bd08      	pop	{r3, pc}
 8003b9c:	0000      	movs	r0, r0
	...

08003ba0 <rt_test_008_004_execute.lto_priv.790>:

static void rt_test_008_004_execute(void) {
 8003ba0:	b530      	push	{r4, r5, lr}
 8003ba2:	b085      	sub	sp, #20
  eventmask_t m;
  systime_t target_time;

  /* [8.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8003ba4:	4b42      	ldr	r3, [pc, #264]	; (8003cb0 <rt_test_008_004_execute.lto_priv.790+0x110>)
 8003ba6:	2201      	movs	r2, #1
 8003ba8:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(5);
 8003baa:	2005      	movs	r0, #5
 8003bac:	f00e f988 	bl	8011ec0 <chEvtAddEvents>
  }

  /* [8.4.2] Calling chEvtWaitAny() one time, the two flags must be
     returned.*/
  test_set_step(2);
 8003bb0:	4b3f      	ldr	r3, [pc, #252]	; (8003cb0 <rt_test_008_004_execute.lto_priv.790+0x110>)
 8003bb2:	2202      	movs	r2, #2
 8003bb4:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8003bb6:	f04f 30ff 	mov.w	r0, #4294967295
 8003bba:	f00e faa9 	bl	8012110 <chEvtWaitAny>
 8003bbe:	9003      	str	r0, [sp, #12]
    test_assert(m == 5, "unexpected pending bit");
 8003bc0:	9b03      	ldr	r3, [sp, #12]
 8003bc2:	2b05      	cmp	r3, #5
 8003bc4:	bf0c      	ite	eq
 8003bc6:	2301      	moveq	r3, #1
 8003bc8:	2300      	movne	r3, #0
 8003bca:	b2db      	uxtb	r3, r3
 8003bcc:	4939      	ldr	r1, [pc, #228]	; (8003cb4 <rt_test_008_004_execute.lto_priv.790+0x114>)
 8003bce:	4618      	mov	r0, r3
 8003bd0:	f011 fc56 	bl	8015480 <_test_assert>
 8003bd4:	4603      	mov	r3, r0
 8003bd6:	2b00      	cmp	r3, #0
 8003bd8:	d167      	bne.n	8003caa <rt_test_008_004_execute.lto_priv.790+0x10a>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003bda:	f04f 30ff 	mov.w	r0, #4294967295
 8003bde:	f00e f95f 	bl	8011ea0 <chEvtGetAndClearEvents>
 8003be2:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 8003be4:	9b03      	ldr	r3, [sp, #12]
 8003be6:	2b00      	cmp	r3, #0
 8003be8:	bf0c      	ite	eq
 8003bea:	2301      	moveq	r3, #1
 8003bec:	2300      	movne	r3, #0
 8003bee:	b2db      	uxtb	r3, r3
 8003bf0:	4931      	ldr	r1, [pc, #196]	; (8003cb8 <rt_test_008_004_execute.lto_priv.790+0x118>)
 8003bf2:	4618      	mov	r0, r3
 8003bf4:	f011 fc44 	bl	8015480 <_test_assert>
 8003bf8:	4603      	mov	r3, r0
 8003bfa:	2b00      	cmp	r3, #0
 8003bfc:	d155      	bne.n	8003caa <rt_test_008_004_execute.lto_priv.790+0x10a>
  }

  /* [8.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 8003bfe:	4b2c      	ldr	r3, [pc, #176]	; (8003cb0 <rt_test_008_004_execute.lto_priv.790+0x110>)
 8003c00:	2203      	movs	r2, #3
 8003c02:	601a      	str	r2, [r3, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8003c04:	f7fd f8e4 	bl	8000dd0 <test_wait_tick>
 8003c08:	4603      	mov	r3, r0
 8003c0a:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8003c0e:	4618      	mov	r0, r3
 8003c10:	f7ff fd66 	bl	80036e0 <chTimeAddX.lto_priv.123>
 8003c14:	9002      	str	r0, [sp, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003c16:	4b29      	ldr	r3, [pc, #164]	; (8003cbc <rt_test_008_004_execute.lto_priv.790+0x11c>)
 8003c18:	681c      	ldr	r4, [r3, #0]
 8003c1a:	f7ff fdb1 	bl	8003780 <chThdGetPriorityX.lto_priv.94>
 8003c1e:	4603      	mov	r3, r0
 8003c20:	1e5d      	subs	r5, r3, #1
                                   evt_thread3, chThdGetSelfX());
 8003c22:	f7ff fda5 	bl	8003770 <chThdGetSelfX.lto_priv.102>
 8003c26:	4603      	mov	r3, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003c28:	9300      	str	r3, [sp, #0]
 8003c2a:	4b25      	ldr	r3, [pc, #148]	; (8003cc0 <rt_test_008_004_execute.lto_priv.790+0x120>)
 8003c2c:	462a      	mov	r2, r5
 8003c2e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003c32:	4620      	mov	r0, r4
 8003c34:	f00c fc54 	bl	80104e0 <chThdCreateStatic>
 8003c38:	4602      	mov	r2, r0
 8003c3a:	4b22      	ldr	r3, [pc, #136]	; (8003cc4 <rt_test_008_004_execute.lto_priv.790+0x124>)
 8003c3c:	601a      	str	r2, [r3, #0]
  }

  /* [8.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 8003c3e:	4b1c      	ldr	r3, [pc, #112]	; (8003cb0 <rt_test_008_004_execute.lto_priv.790+0x110>)
 8003c40:	2204      	movs	r2, #4
 8003c42:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8003c44:	f04f 30ff 	mov.w	r0, #4294967295
 8003c48:	f00e fa62 	bl	8012110 <chEvtWaitAny>
 8003c4c:	9003      	str	r0, [sp, #12]
    test_assert_time_window(target_time,
 8003c4e:	2114      	movs	r1, #20
 8003c50:	9802      	ldr	r0, [sp, #8]
 8003c52:	f7ff fd45 	bl	80036e0 <chTimeAddX.lto_priv.123>
 8003c56:	4603      	mov	r3, r0
 8003c58:	4a1b      	ldr	r2, [pc, #108]	; (8003cc8 <rt_test_008_004_execute.lto_priv.790+0x128>)
 8003c5a:	4619      	mov	r1, r3
 8003c5c:	9802      	ldr	r0, [sp, #8]
 8003c5e:	f011 fc57 	bl	8015510 <_test_assert_time_window>
 8003c62:	4603      	mov	r3, r0
 8003c64:	2b00      	cmp	r3, #0
 8003c66:	d120      	bne.n	8003caa <rt_test_008_004_execute.lto_priv.790+0x10a>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    test_assert(m == 1, "event flag error");
 8003c68:	9b03      	ldr	r3, [sp, #12]
 8003c6a:	2b01      	cmp	r3, #1
 8003c6c:	bf0c      	ite	eq
 8003c6e:	2301      	moveq	r3, #1
 8003c70:	2300      	movne	r3, #0
 8003c72:	b2db      	uxtb	r3, r3
 8003c74:	4915      	ldr	r1, [pc, #84]	; (8003ccc <rt_test_008_004_execute.lto_priv.790+0x12c>)
 8003c76:	4618      	mov	r0, r3
 8003c78:	f011 fc02 	bl	8015480 <_test_assert>
 8003c7c:	4603      	mov	r3, r0
 8003c7e:	2b00      	cmp	r3, #0
 8003c80:	d113      	bne.n	8003caa <rt_test_008_004_execute.lto_priv.790+0x10a>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003c82:	f04f 30ff 	mov.w	r0, #4294967295
 8003c86:	f00e f90b 	bl	8011ea0 <chEvtGetAndClearEvents>
 8003c8a:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 8003c8c:	9b03      	ldr	r3, [sp, #12]
 8003c8e:	2b00      	cmp	r3, #0
 8003c90:	bf0c      	ite	eq
 8003c92:	2301      	moveq	r3, #1
 8003c94:	2300      	movne	r3, #0
 8003c96:	b2db      	uxtb	r3, r3
 8003c98:	4907      	ldr	r1, [pc, #28]	; (8003cb8 <rt_test_008_004_execute.lto_priv.790+0x118>)
 8003c9a:	4618      	mov	r0, r3
 8003c9c:	f011 fbf0 	bl	8015480 <_test_assert>
 8003ca0:	4603      	mov	r3, r0
 8003ca2:	2b00      	cmp	r3, #0
 8003ca4:	d101      	bne.n	8003caa <rt_test_008_004_execute.lto_priv.790+0x10a>
    test_wait_threads();
 8003ca6:	f7fd f86b 	bl	8000d80 <test_wait_threads>
  }
}
 8003caa:	b005      	add	sp, #20
 8003cac:	bd30      	pop	{r4, r5, pc}
 8003cae:	bf00      	nop
 8003cb0:	20001988 	.word	0x20001988
 8003cb4:	08018348 	.word	0x08018348
 8003cb8:	08018318 	.word	0x08018318
 8003cbc:	08017360 	.word	0x08017360
 8003cc0:	08003881 	.word	0x08003881
 8003cc4:	20002018 	.word	0x20002018
 8003cc8:	08017f08 	.word	0x08017f08
 8003ccc:	08018324 	.word	0x08018324

08003cd0 <rt_test_008_005_setup.lto_priv.791>:
 *   flags have been received after 50mS and that the event flags mask
 *   has been emptied.
 * .
 */

static void rt_test_008_005_setup(void) {
 8003cd0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8003cd2:	f04f 30ff 	mov.w	r0, #4294967295
 8003cd6:	f00e f8e3 	bl	8011ea0 <chEvtGetAndClearEvents>
}
 8003cda:	bd08      	pop	{r3, pc}
 8003cdc:	0000      	movs	r0, r0
	...

08003ce0 <rt_test_008_005_execute.lto_priv.792>:

static void rt_test_008_005_execute(void) {
 8003ce0:	b530      	push	{r4, r5, lr}
 8003ce2:	b085      	sub	sp, #20
  eventmask_t m;
  systime_t target_time;

  /* [8.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8003ce4:	4b44      	ldr	r3, [pc, #272]	; (8003df8 <rt_test_008_005_execute.lto_priv.792+0x118>)
 8003ce6:	2201      	movs	r2, #1
 8003ce8:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(5);
 8003cea:	2005      	movs	r0, #5
 8003cec:	f00e f8e8 	bl	8011ec0 <chEvtAddEvents>
  }

  /* [8.5.2] Calling chEvtWaitAll() one time, the two flags must be
     returned.*/
  test_set_step(2);
 8003cf0:	4b41      	ldr	r3, [pc, #260]	; (8003df8 <rt_test_008_005_execute.lto_priv.792+0x118>)
 8003cf2:	2202      	movs	r2, #2
 8003cf4:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAll(5);
 8003cf6:	2005      	movs	r0, #5
 8003cf8:	f00e fa3a 	bl	8012170 <chEvtWaitAll>
 8003cfc:	9003      	str	r0, [sp, #12]
    test_assert(m == 5, "unexpected pending bit");
 8003cfe:	9b03      	ldr	r3, [sp, #12]
 8003d00:	2b05      	cmp	r3, #5
 8003d02:	bf0c      	ite	eq
 8003d04:	2301      	moveq	r3, #1
 8003d06:	2300      	movne	r3, #0
 8003d08:	b2db      	uxtb	r3, r3
 8003d0a:	493c      	ldr	r1, [pc, #240]	; (8003dfc <rt_test_008_005_execute.lto_priv.792+0x11c>)
 8003d0c:	4618      	mov	r0, r3
 8003d0e:	f011 fbb7 	bl	8015480 <_test_assert>
 8003d12:	4603      	mov	r3, r0
 8003d14:	2b00      	cmp	r3, #0
 8003d16:	d16c      	bne.n	8003df2 <rt_test_008_005_execute.lto_priv.792+0x112>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003d18:	f04f 30ff 	mov.w	r0, #4294967295
 8003d1c:	f00e f8c0 	bl	8011ea0 <chEvtGetAndClearEvents>
 8003d20:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 8003d22:	9b03      	ldr	r3, [sp, #12]
 8003d24:	2b00      	cmp	r3, #0
 8003d26:	bf0c      	ite	eq
 8003d28:	2301      	moveq	r3, #1
 8003d2a:	2300      	movne	r3, #0
 8003d2c:	b2db      	uxtb	r3, r3
 8003d2e:	4934      	ldr	r1, [pc, #208]	; (8003e00 <rt_test_008_005_execute.lto_priv.792+0x120>)
 8003d30:	4618      	mov	r0, r3
 8003d32:	f011 fba5 	bl	8015480 <_test_assert>
 8003d36:	4603      	mov	r3, r0
 8003d38:	2b00      	cmp	r3, #0
 8003d3a:	d15a      	bne.n	8003df2 <rt_test_008_005_execute.lto_priv.792+0x112>
  }

  /* [8.5.3] Setting one event flag.*/
  test_set_step(3);
 8003d3c:	4b2e      	ldr	r3, [pc, #184]	; (8003df8 <rt_test_008_005_execute.lto_priv.792+0x118>)
 8003d3e:	2203      	movs	r2, #3
 8003d40:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(4);
 8003d42:	2004      	movs	r0, #4
 8003d44:	f00e f8bc 	bl	8011ec0 <chEvtAddEvents>
  }

  /* [8.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
 8003d48:	4b2b      	ldr	r3, [pc, #172]	; (8003df8 <rt_test_008_005_execute.lto_priv.792+0x118>)
 8003d4a:	2204      	movs	r2, #4
 8003d4c:	601a      	str	r2, [r3, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8003d4e:	f7fd f83f 	bl	8000dd0 <test_wait_tick>
 8003d52:	4603      	mov	r3, r0
 8003d54:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8003d58:	4618      	mov	r0, r3
 8003d5a:	f7ff fcc1 	bl	80036e0 <chTimeAddX.lto_priv.123>
 8003d5e:	9002      	str	r0, [sp, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003d60:	4b28      	ldr	r3, [pc, #160]	; (8003e04 <rt_test_008_005_execute.lto_priv.792+0x124>)
 8003d62:	681c      	ldr	r4, [r3, #0]
 8003d64:	f7ff fd0c 	bl	8003780 <chThdGetPriorityX.lto_priv.94>
 8003d68:	4603      	mov	r3, r0
 8003d6a:	1e5d      	subs	r5, r3, #1
                                   evt_thread3, chThdGetSelfX());
 8003d6c:	f7ff fd00 	bl	8003770 <chThdGetSelfX.lto_priv.102>
 8003d70:	4603      	mov	r3, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003d72:	9300      	str	r3, [sp, #0]
 8003d74:	4b24      	ldr	r3, [pc, #144]	; (8003e08 <rt_test_008_005_execute.lto_priv.792+0x128>)
 8003d76:	462a      	mov	r2, r5
 8003d78:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003d7c:	4620      	mov	r0, r4
 8003d7e:	f00c fbaf 	bl	80104e0 <chThdCreateStatic>
 8003d82:	4602      	mov	r2, r0
 8003d84:	4b21      	ldr	r3, [pc, #132]	; (8003e0c <rt_test_008_005_execute.lto_priv.792+0x12c>)
 8003d86:	601a      	str	r2, [r3, #0]
  }

  /* [8.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
 8003d88:	4b1b      	ldr	r3, [pc, #108]	; (8003df8 <rt_test_008_005_execute.lto_priv.792+0x118>)
 8003d8a:	2205      	movs	r2, #5
 8003d8c:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAll(5);
 8003d8e:	2005      	movs	r0, #5
 8003d90:	f00e f9ee 	bl	8012170 <chEvtWaitAll>
 8003d94:	9003      	str	r0, [sp, #12]
    test_assert_time_window(target_time,
 8003d96:	2114      	movs	r1, #20
 8003d98:	9802      	ldr	r0, [sp, #8]
 8003d9a:	f7ff fca1 	bl	80036e0 <chTimeAddX.lto_priv.123>
 8003d9e:	4603      	mov	r3, r0
 8003da0:	4a1b      	ldr	r2, [pc, #108]	; (8003e10 <rt_test_008_005_execute.lto_priv.792+0x130>)
 8003da2:	4619      	mov	r1, r3
 8003da4:	9802      	ldr	r0, [sp, #8]
 8003da6:	f011 fbb3 	bl	8015510 <_test_assert_time_window>
 8003daa:	4603      	mov	r3, r0
 8003dac:	2b00      	cmp	r3, #0
 8003dae:	d120      	bne.n	8003df2 <rt_test_008_005_execute.lto_priv.792+0x112>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    test_assert(m == 5, "event flags error");
 8003db0:	9b03      	ldr	r3, [sp, #12]
 8003db2:	2b05      	cmp	r3, #5
 8003db4:	bf0c      	ite	eq
 8003db6:	2301      	moveq	r3, #1
 8003db8:	2300      	movne	r3, #0
 8003dba:	b2db      	uxtb	r3, r3
 8003dbc:	4915      	ldr	r1, [pc, #84]	; (8003e14 <rt_test_008_005_execute.lto_priv.792+0x134>)
 8003dbe:	4618      	mov	r0, r3
 8003dc0:	f011 fb5e 	bl	8015480 <_test_assert>
 8003dc4:	4603      	mov	r3, r0
 8003dc6:	2b00      	cmp	r3, #0
 8003dc8:	d113      	bne.n	8003df2 <rt_test_008_005_execute.lto_priv.792+0x112>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003dca:	f04f 30ff 	mov.w	r0, #4294967295
 8003dce:	f00e f867 	bl	8011ea0 <chEvtGetAndClearEvents>
 8003dd2:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 8003dd4:	9b03      	ldr	r3, [sp, #12]
 8003dd6:	2b00      	cmp	r3, #0
 8003dd8:	bf0c      	ite	eq
 8003dda:	2301      	moveq	r3, #1
 8003ddc:	2300      	movne	r3, #0
 8003dde:	b2db      	uxtb	r3, r3
 8003de0:	4907      	ldr	r1, [pc, #28]	; (8003e00 <rt_test_008_005_execute.lto_priv.792+0x120>)
 8003de2:	4618      	mov	r0, r3
 8003de4:	f011 fb4c 	bl	8015480 <_test_assert>
 8003de8:	4603      	mov	r3, r0
 8003dea:	2b00      	cmp	r3, #0
 8003dec:	d101      	bne.n	8003df2 <rt_test_008_005_execute.lto_priv.792+0x112>
    test_wait_threads();
 8003dee:	f7fc ffc7 	bl	8000d80 <test_wait_threads>
  }
}
 8003df2:	b005      	add	sp, #20
 8003df4:	bd30      	pop	{r4, r5, pc}
 8003df6:	bf00      	nop
 8003df8:	20001988 	.word	0x20001988
 8003dfc:	08018348 	.word	0x08018348
 8003e00:	08018318 	.word	0x08018318
 8003e04:	08017360 	.word	0x08017360
 8003e08:	08003881 	.word	0x08003881
 8003e0c:	20002018 	.word	0x20002018
 8003e10:	08017f08 	.word	0x08017f08
 8003e14:	08018370 	.word	0x08018370
	...

08003e20 <rt_test_008_006_setup.lto_priv.793>:
 * - [8.6.2] The functions are invoked first with a 50mS timeout, the
 *   timeout condition is tested.
 * .
 */

static void rt_test_008_006_setup(void) {
 8003e20:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8003e22:	f04f 30ff 	mov.w	r0, #4294967295
 8003e26:	f00e f83b 	bl	8011ea0 <chEvtGetAndClearEvents>
}
 8003e2a:	bd08      	pop	{r3, pc}
 8003e2c:	0000      	movs	r0, r0
	...

08003e30 <rt_test_008_006_execute.lto_priv.794>:

static void rt_test_008_006_execute(void) {
 8003e30:	b500      	push	{lr}
 8003e32:	b083      	sub	sp, #12
  eventmask_t m;

  /* [8.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
 8003e34:	4b3d      	ldr	r3, [pc, #244]	; (8003f2c <rt_test_008_006_execute.lto_priv.794+0xfc>)
 8003e36:	2201      	movs	r2, #1
 8003e38:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8003e3a:	2100      	movs	r1, #0
 8003e3c:	f04f 30ff 	mov.w	r0, #4294967295
 8003e40:	f00e f9be 	bl	80121c0 <chEvtWaitOneTimeout>
 8003e44:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 8003e46:	9b01      	ldr	r3, [sp, #4]
 8003e48:	2b00      	cmp	r3, #0
 8003e4a:	bf0c      	ite	eq
 8003e4c:	2301      	moveq	r3, #1
 8003e4e:	2300      	movne	r3, #0
 8003e50:	b2db      	uxtb	r3, r3
 8003e52:	4937      	ldr	r1, [pc, #220]	; (8003f30 <rt_test_008_006_execute.lto_priv.794+0x100>)
 8003e54:	4618      	mov	r0, r3
 8003e56:	f011 fb13 	bl	8015480 <_test_assert>
 8003e5a:	4603      	mov	r3, r0
 8003e5c:	2b00      	cmp	r3, #0
 8003e5e:	d161      	bne.n	8003f24 <rt_test_008_006_execute.lto_priv.794+0xf4>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8003e60:	2100      	movs	r1, #0
 8003e62:	f04f 30ff 	mov.w	r0, #4294967295
 8003e66:	f00e f9eb 	bl	8012240 <chEvtWaitAnyTimeout>
 8003e6a:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 8003e6c:	9b01      	ldr	r3, [sp, #4]
 8003e6e:	2b00      	cmp	r3, #0
 8003e70:	bf0c      	ite	eq
 8003e72:	2301      	moveq	r3, #1
 8003e74:	2300      	movne	r3, #0
 8003e76:	b2db      	uxtb	r3, r3
 8003e78:	492d      	ldr	r1, [pc, #180]	; (8003f30 <rt_test_008_006_execute.lto_priv.794+0x100>)
 8003e7a:	4618      	mov	r0, r3
 8003e7c:	f011 fb00 	bl	8015480 <_test_assert>
 8003e80:	4603      	mov	r3, r0
 8003e82:	2b00      	cmp	r3, #0
 8003e84:	d14e      	bne.n	8003f24 <rt_test_008_006_execute.lto_priv.794+0xf4>
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8003e86:	2100      	movs	r1, #0
 8003e88:	f04f 30ff 	mov.w	r0, #4294967295
 8003e8c:	f00e fa18 	bl	80122c0 <chEvtWaitAllTimeout>
 8003e90:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 8003e92:	9b01      	ldr	r3, [sp, #4]
 8003e94:	2b00      	cmp	r3, #0
 8003e96:	bf0c      	ite	eq
 8003e98:	2301      	moveq	r3, #1
 8003e9a:	2300      	movne	r3, #0
 8003e9c:	b2db      	uxtb	r3, r3
 8003e9e:	4924      	ldr	r1, [pc, #144]	; (8003f30 <rt_test_008_006_execute.lto_priv.794+0x100>)
 8003ea0:	4618      	mov	r0, r3
 8003ea2:	f011 faed 	bl	8015480 <_test_assert>
 8003ea6:	4603      	mov	r3, r0
 8003ea8:	2b00      	cmp	r3, #0
 8003eaa:	d13b      	bne.n	8003f24 <rt_test_008_006_execute.lto_priv.794+0xf4>
  }

  /* [8.6.2] The functions are invoked first with a 50mS timeout, the
     timeout condition is tested.*/
  test_set_step(2);
 8003eac:	4b1f      	ldr	r3, [pc, #124]	; (8003f2c <rt_test_008_006_execute.lto_priv.794+0xfc>)
 8003eae:	2202      	movs	r2, #2
 8003eb0:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
 8003eb2:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8003eb6:	f04f 30ff 	mov.w	r0, #4294967295
 8003eba:	f00e f981 	bl	80121c0 <chEvtWaitOneTimeout>
 8003ebe:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 8003ec0:	9b01      	ldr	r3, [sp, #4]
 8003ec2:	2b00      	cmp	r3, #0
 8003ec4:	bf0c      	ite	eq
 8003ec6:	2301      	moveq	r3, #1
 8003ec8:	2300      	movne	r3, #0
 8003eca:	b2db      	uxtb	r3, r3
 8003ecc:	4918      	ldr	r1, [pc, #96]	; (8003f30 <rt_test_008_006_execute.lto_priv.794+0x100>)
 8003ece:	4618      	mov	r0, r3
 8003ed0:	f011 fad6 	bl	8015480 <_test_assert>
 8003ed4:	4603      	mov	r3, r0
 8003ed6:	2b00      	cmp	r3, #0
 8003ed8:	d124      	bne.n	8003f24 <rt_test_008_006_execute.lto_priv.794+0xf4>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_MS2I(50));
 8003eda:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8003ede:	f04f 30ff 	mov.w	r0, #4294967295
 8003ee2:	f00e f9ad 	bl	8012240 <chEvtWaitAnyTimeout>
 8003ee6:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 8003ee8:	9b01      	ldr	r3, [sp, #4]
 8003eea:	2b00      	cmp	r3, #0
 8003eec:	bf0c      	ite	eq
 8003eee:	2301      	moveq	r3, #1
 8003ef0:	2300      	movne	r3, #0
 8003ef2:	b2db      	uxtb	r3, r3
 8003ef4:	490e      	ldr	r1, [pc, #56]	; (8003f30 <rt_test_008_006_execute.lto_priv.794+0x100>)
 8003ef6:	4618      	mov	r0, r3
 8003ef8:	f011 fac2 	bl	8015480 <_test_assert>
 8003efc:	4603      	mov	r3, r0
 8003efe:	2b00      	cmp	r3, #0
 8003f00:	d110      	bne.n	8003f24 <rt_test_008_006_execute.lto_priv.794+0xf4>
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_MS2I(50));
 8003f02:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8003f06:	f04f 30ff 	mov.w	r0, #4294967295
 8003f0a:	f00e f9d9 	bl	80122c0 <chEvtWaitAllTimeout>
 8003f0e:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 8003f10:	9b01      	ldr	r3, [sp, #4]
 8003f12:	2b00      	cmp	r3, #0
 8003f14:	bf0c      	ite	eq
 8003f16:	2301      	moveq	r3, #1
 8003f18:	2300      	movne	r3, #0
 8003f1a:	b2db      	uxtb	r3, r3
 8003f1c:	4904      	ldr	r1, [pc, #16]	; (8003f30 <rt_test_008_006_execute.lto_priv.794+0x100>)
 8003f1e:	4618      	mov	r0, r3
 8003f20:	f011 faae 	bl	8015480 <_test_assert>
  }
}
 8003f24:	b003      	add	sp, #12
 8003f26:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f2a:	bf00      	nop
 8003f2c:	20001988 	.word	0x20001988
 8003f30:	08018394 	.word	0x08018394
	...

08003f40 <rt_test_008_007_setup.lto_priv.795>:
 *   has been emptied.
 * - [8.7.4] Unregistering from the Event Sources.
 * .
 */

static void rt_test_008_007_setup(void) {
 8003f40:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8003f42:	f04f 30ff 	mov.w	r0, #4294967295
 8003f46:	f00d ffab 	bl	8011ea0 <chEvtGetAndClearEvents>
  chEvtObjectInit(&es1);
 8003f4a:	4803      	ldr	r0, [pc, #12]	; (8003f58 <rt_test_008_007_setup.lto_priv.795+0x18>)
 8003f4c:	f7ff fc20 	bl	8003790 <chEvtObjectInit>
  chEvtObjectInit(&es2);
 8003f50:	4802      	ldr	r0, [pc, #8]	; (8003f5c <rt_test_008_007_setup.lto_priv.795+0x1c>)
 8003f52:	f7ff fc1d 	bl	8003790 <chEvtObjectInit>
}
 8003f56:	bd08      	pop	{r3, pc}
 8003f58:	20000870 	.word	0x20000870
 8003f5c:	20000874 	.word	0x20000874

08003f60 <rt_test_008_007_execute.lto_priv.796>:

static void rt_test_008_007_execute(void) {
 8003f60:	b510      	push	{r4, lr}
 8003f62:	b08e      	sub	sp, #56	; 0x38
  event_listener_t el1, el2;
  systime_t target_time;

  /* [8.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 8003f64:	4b46      	ldr	r3, [pc, #280]	; (8004080 <rt_test_008_007_execute.lto_priv.796+0x120>)
 8003f66:	2201      	movs	r2, #1
 8003f68:	601a      	str	r2, [r3, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
 8003f6a:	ab07      	add	r3, sp, #28
 8003f6c:	2201      	movs	r2, #1
 8003f6e:	4619      	mov	r1, r3
 8003f70:	4844      	ldr	r0, [pc, #272]	; (8004084 <rt_test_008_007_execute.lto_priv.796+0x124>)
 8003f72:	f7ff fc15 	bl	80037a0 <chEvtRegisterMask>
    chEvtRegisterMask(&es2, &el2, 4);
 8003f76:	ab02      	add	r3, sp, #8
 8003f78:	2204      	movs	r2, #4
 8003f7a:	4619      	mov	r1, r3
 8003f7c:	4842      	ldr	r0, [pc, #264]	; (8004088 <rt_test_008_007_execute.lto_priv.796+0x128>)
 8003f7e:	f7ff fc0f 	bl	80037a0 <chEvtRegisterMask>
  }

  /* [8.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 8003f82:	4b3f      	ldr	r3, [pc, #252]	; (8004080 <rt_test_008_007_execute.lto_priv.796+0x120>)
 8003f84:	2202      	movs	r2, #2
 8003f86:	601a      	str	r2, [r3, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8003f88:	f7fc ff22 	bl	8000dd0 <test_wait_tick>
 8003f8c:	4603      	mov	r3, r0
 8003f8e:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8003f92:	4618      	mov	r0, r3
 8003f94:	f7ff fba4 	bl	80036e0 <chTimeAddX.lto_priv.123>
 8003f98:	900d      	str	r0, [sp, #52]	; 0x34
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003f9a:	4b3c      	ldr	r3, [pc, #240]	; (800408c <rt_test_008_007_execute.lto_priv.796+0x12c>)
 8003f9c:	681c      	ldr	r4, [r3, #0]
 8003f9e:	f7ff fbef 	bl	8003780 <chThdGetPriorityX.lto_priv.94>
 8003fa2:	4603      	mov	r3, r0
 8003fa4:	1e5a      	subs	r2, r3, #1
 8003fa6:	4b3a      	ldr	r3, [pc, #232]	; (8004090 <rt_test_008_007_execute.lto_priv.796+0x130>)
 8003fa8:	9300      	str	r3, [sp, #0]
 8003faa:	4b3a      	ldr	r3, [pc, #232]	; (8004094 <rt_test_008_007_execute.lto_priv.796+0x134>)
 8003fac:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003fb0:	4620      	mov	r0, r4
 8003fb2:	f00c fa95 	bl	80104e0 <chThdCreateStatic>
 8003fb6:	4602      	mov	r2, r0
 8003fb8:	4b37      	ldr	r3, [pc, #220]	; (8004098 <rt_test_008_007_execute.lto_priv.796+0x138>)
 8003fba:	601a      	str	r2, [r3, #0]
  }

  /* [8.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8003fbc:	4b30      	ldr	r3, [pc, #192]	; (8004080 <rt_test_008_007_execute.lto_priv.796+0x120>)
 8003fbe:	2203      	movs	r2, #3
 8003fc0:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAll(5);
 8003fc2:	2005      	movs	r0, #5
 8003fc4:	f00e f8d4 	bl	8012170 <chEvtWaitAll>
 8003fc8:	900c      	str	r0, [sp, #48]	; 0x30
    test_assert_time_window(target_time,
 8003fca:	2114      	movs	r1, #20
 8003fcc:	980d      	ldr	r0, [sp, #52]	; 0x34
 8003fce:	f7ff fb87 	bl	80036e0 <chTimeAddX.lto_priv.123>
 8003fd2:	4603      	mov	r3, r0
 8003fd4:	4a31      	ldr	r2, [pc, #196]	; (800409c <rt_test_008_007_execute.lto_priv.796+0x13c>)
 8003fd6:	4619      	mov	r1, r3
 8003fd8:	980d      	ldr	r0, [sp, #52]	; 0x34
 8003fda:	f011 fa99 	bl	8015510 <_test_assert_time_window>
 8003fde:	4603      	mov	r3, r0
 8003fe0:	2b00      	cmp	r3, #0
 8003fe2:	d14b      	bne.n	800407c <rt_test_008_007_execute.lto_priv.796+0x11c>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003fe4:	f04f 30ff 	mov.w	r0, #4294967295
 8003fe8:	f00d ff5a 	bl	8011ea0 <chEvtGetAndClearEvents>
 8003fec:	900c      	str	r0, [sp, #48]	; 0x30
    test_assert(m == 0, "stuck event");
 8003fee:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003ff0:	2b00      	cmp	r3, #0
 8003ff2:	bf0c      	ite	eq
 8003ff4:	2301      	moveq	r3, #1
 8003ff6:	2300      	movne	r3, #0
 8003ff8:	b2db      	uxtb	r3, r3
 8003ffa:	4929      	ldr	r1, [pc, #164]	; (80040a0 <rt_test_008_007_execute.lto_priv.796+0x140>)
 8003ffc:	4618      	mov	r0, r3
 8003ffe:	f011 fa3f 	bl	8015480 <_test_assert>
 8004002:	4603      	mov	r3, r0
 8004004:	2b00      	cmp	r3, #0
 8004006:	d139      	bne.n	800407c <rt_test_008_007_execute.lto_priv.796+0x11c>
    test_wait_threads();
 8004008:	f7fc feba 	bl	8000d80 <test_wait_threads>
  }

  /* [8.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 800400c:	4b1c      	ldr	r3, [pc, #112]	; (8004080 <rt_test_008_007_execute.lto_priv.796+0x120>)
 800400e:	2204      	movs	r2, #4
 8004010:	601a      	str	r2, [r3, #0]
  {
    chEvtUnregister(&es1, &el1);
 8004012:	ab07      	add	r3, sp, #28
 8004014:	4619      	mov	r1, r3
 8004016:	481b      	ldr	r0, [pc, #108]	; (8004084 <rt_test_008_007_execute.lto_priv.796+0x124>)
 8004018:	f00d fefa 	bl	8011e10 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 800401c:	ab02      	add	r3, sp, #8
 800401e:	4619      	mov	r1, r3
 8004020:	4819      	ldr	r0, [pc, #100]	; (8004088 <rt_test_008_007_execute.lto_priv.796+0x128>)
 8004022:	f00d fef5 	bl	8011e10 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 8004026:	4817      	ldr	r0, [pc, #92]	; (8004084 <rt_test_008_007_execute.lto_priv.796+0x124>)
 8004028:	f7ff fbca 	bl	80037c0 <chEvtIsListeningI>
 800402c:	4603      	mov	r3, r0
 800402e:	2b00      	cmp	r3, #0
 8004030:	bf14      	ite	ne
 8004032:	2301      	movne	r3, #1
 8004034:	2300      	moveq	r3, #0
 8004036:	b2db      	uxtb	r3, r3
 8004038:	f083 0301 	eor.w	r3, r3, #1
 800403c:	b2db      	uxtb	r3, r3
 800403e:	f003 0301 	and.w	r3, r3, #1
 8004042:	b2db      	uxtb	r3, r3
 8004044:	4917      	ldr	r1, [pc, #92]	; (80040a4 <rt_test_008_007_execute.lto_priv.796+0x144>)
 8004046:	4618      	mov	r0, r3
 8004048:	f011 fa1a 	bl	8015480 <_test_assert>
 800404c:	4603      	mov	r3, r0
 800404e:	2b00      	cmp	r3, #0
 8004050:	d114      	bne.n	800407c <rt_test_008_007_execute.lto_priv.796+0x11c>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 8004052:	480d      	ldr	r0, [pc, #52]	; (8004088 <rt_test_008_007_execute.lto_priv.796+0x128>)
 8004054:	f7ff fbb4 	bl	80037c0 <chEvtIsListeningI>
 8004058:	4603      	mov	r3, r0
 800405a:	2b00      	cmp	r3, #0
 800405c:	bf14      	ite	ne
 800405e:	2301      	movne	r3, #1
 8004060:	2300      	moveq	r3, #0
 8004062:	b2db      	uxtb	r3, r3
 8004064:	f083 0301 	eor.w	r3, r3, #1
 8004068:	b2db      	uxtb	r3, r3
 800406a:	f003 0301 	and.w	r3, r3, #1
 800406e:	b2db      	uxtb	r3, r3
 8004070:	490c      	ldr	r1, [pc, #48]	; (80040a4 <rt_test_008_007_execute.lto_priv.796+0x144>)
 8004072:	4618      	mov	r0, r3
 8004074:	f011 fa04 	bl	8015480 <_test_assert>
 8004078:	4603      	mov	r3, r0
 800407a:	2b00      	cmp	r3, #0
  }
}
 800407c:	b00e      	add	sp, #56	; 0x38
 800407e:	bd10      	pop	{r4, pc}
 8004080:	20001988 	.word	0x20001988
 8004084:	20000870 	.word	0x20000870
 8004088:	20000874 	.word	0x20000874
 800408c:	08017360 	.word	0x08017360
 8004090:	08017f34 	.word	0x08017f34
 8004094:	080038a1 	.word	0x080038a1
 8004098:	20002018 	.word	0x20002018
 800409c:	08017f08 	.word	0x08017f08
 80040a0:	08018318 	.word	0x08018318
 80040a4:	080182d4 	.word	0x080182d4
	...

080040b0 <chThdGetSelfX.lto_priv.103>:
  return ch.rlist.current;
 80040b0:	4b01      	ldr	r3, [pc, #4]	; (80040b8 <chThdGetSelfX.lto_priv.103+0x8>)
 80040b2:	699b      	ldr	r3, [r3, #24]
}
 80040b4:	4618      	mov	r0, r3
 80040b6:	4770      	bx	lr
 80040b8:	20001090 	.word	0x20001090
 80040bc:	00000000 	.word	0x00000000

080040c0 <chThdGetPriorityX.lto_priv.95>:
static inline tprio_t chThdGetPriorityX(void) {
 80040c0:	b508      	push	{r3, lr}
  return chThdGetSelfX()->prio;
 80040c2:	f7ff fff5 	bl	80040b0 <chThdGetSelfX.lto_priv.103>
 80040c6:	4603      	mov	r3, r0
 80040c8:	689b      	ldr	r3, [r3, #8]
}
 80040ca:	4618      	mov	r0, r3
 80040cc:	bd08      	pop	{r3, pc}
 80040ce:	bf00      	nop

080040d0 <chPoolObjectInit.lto_priv.30>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 80040d0:	b500      	push	{lr}
 80040d2:	b085      	sub	sp, #20
 80040d4:	9003      	str	r0, [sp, #12]
 80040d6:	9102      	str	r1, [sp, #8]
 80040d8:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 80040da:	9b01      	ldr	r3, [sp, #4]
 80040dc:	2204      	movs	r2, #4
 80040de:	9902      	ldr	r1, [sp, #8]
 80040e0:	9803      	ldr	r0, [sp, #12]
 80040e2:	f00f f93d 	bl	8013360 <chPoolObjectInitAligned>
}
 80040e6:	b005      	add	sp, #20
 80040e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80040ec:	0000      	movs	r0, r0
	...

080040f0 <dyn_thread1>:
#endif
#if CH_CFG_USE_MEMPOOLS
static memory_pool_t mp1;
#endif

static THD_FUNCTION(dyn_thread1, p) {
 80040f0:	b500      	push	{lr}
 80040f2:	b083      	sub	sp, #12
 80040f4:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 80040f6:	9b01      	ldr	r3, [sp, #4]
 80040f8:	781b      	ldrb	r3, [r3, #0]
 80040fa:	4618      	mov	r0, r3
 80040fc:	f011 faa0 	bl	8015640 <test_emit_token>
}
 8004100:	b003      	add	sp, #12
 8004102:	f85d fb04 	ldr.w	pc, [sp], #4
 8004106:	bf00      	nop
	...

08004110 <rt_test_009_001_setup.lto_priv.797>:
 *   freeing memory.
 * - [9.1.7] Getting heap info again for verification.
 * .
 */

static void rt_test_009_001_setup(void) {
 8004110:	b508      	push	{r3, lr}
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
 8004112:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 8004116:	4902      	ldr	r1, [pc, #8]	; (8004120 <rt_test_009_001_setup.lto_priv.797+0x10>)
 8004118:	4802      	ldr	r0, [pc, #8]	; (8004124 <rt_test_009_001_setup.lto_priv.797+0x14>)
 800411a:	f00e feb9 	bl	8012e90 <chHeapObjectInit>
}
 800411e:	bd08      	pop	{r3, pc}
 8004120:	200019b0 	.word	0x200019b0
 8004124:	2000203c 	.word	0x2000203c
	...

08004130 <rt_test_009_001_execute.lto_priv.798>:

static void rt_test_009_001_execute(void) {
 8004130:	b500      	push	{lr}
 8004132:	b08b      	sub	sp, #44	; 0x2c
  size_t n1, total1, largest1;
  size_t n2, total2, largest2;
  tprio_t prio;

  /* [9.1.1] Getting base priority for threads.*/
  test_set_step(1);
 8004134:	4b61      	ldr	r3, [pc, #388]	; (80042bc <rt_test_009_001_execute.lto_priv.798+0x18c>)
 8004136:	2201      	movs	r2, #1
 8004138:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 800413a:	f7ff ffc1 	bl	80040c0 <chThdGetPriorityX.lto_priv.95>
 800413e:	9009      	str	r0, [sp, #36]	; 0x24
  }

  /* [9.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8004140:	4b5e      	ldr	r3, [pc, #376]	; (80042bc <rt_test_009_001_execute.lto_priv.798+0x18c>)
 8004142:	2202      	movs	r2, #2
 8004144:	601a      	str	r2, [r3, #0]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8004146:	aa05      	add	r2, sp, #20
 8004148:	ab06      	add	r3, sp, #24
 800414a:	4619      	mov	r1, r3
 800414c:	485c      	ldr	r0, [pc, #368]	; (80042c0 <rt_test_009_001_execute.lto_priv.798+0x190>)
 800414e:	f00f f847 	bl	80131e0 <chHeapStatus>
 8004152:	9008      	str	r0, [sp, #32]
    test_assert(n1 == 1, "heap fragmented");
 8004154:	9b08      	ldr	r3, [sp, #32]
 8004156:	2b01      	cmp	r3, #1
 8004158:	bf0c      	ite	eq
 800415a:	2301      	moveq	r3, #1
 800415c:	2300      	movne	r3, #0
 800415e:	b2db      	uxtb	r3, r3
 8004160:	4958      	ldr	r1, [pc, #352]	; (80042c4 <rt_test_009_001_execute.lto_priv.798+0x194>)
 8004162:	4618      	mov	r0, r3
 8004164:	f011 f98c 	bl	8015480 <_test_assert>
 8004168:	4603      	mov	r3, r0
 800416a:	2b00      	cmp	r3, #0
 800416c:	f040 80a3 	bne.w	80042b6 <rt_test_009_001_execute.lto_priv.798+0x186>
  }

  /* [9.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
 8004170:	4b52      	ldr	r3, [pc, #328]	; (80042bc <rt_test_009_001_execute.lto_priv.798+0x18c>)
 8004172:	2203      	movs	r2, #3
 8004174:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8004176:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004178:	1e5a      	subs	r2, r3, #1
 800417a:	4b53      	ldr	r3, [pc, #332]	; (80042c8 <rt_test_009_001_execute.lto_priv.798+0x198>)
 800417c:	9301      	str	r3, [sp, #4]
 800417e:	4b53      	ldr	r3, [pc, #332]	; (80042cc <rt_test_009_001_execute.lto_priv.798+0x19c>)
 8004180:	9300      	str	r3, [sp, #0]
 8004182:	4613      	mov	r3, r2
 8004184:	4a52      	ldr	r2, [pc, #328]	; (80042d0 <rt_test_009_001_execute.lto_priv.798+0x1a0>)
 8004186:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800418a:	484d      	ldr	r0, [pc, #308]	; (80042c0 <rt_test_009_001_execute.lto_priv.798+0x190>)
 800418c:	f00e fa18 	bl	80125c0 <chThdCreateFromHeap>
 8004190:	4602      	mov	r2, r0
 8004192:	4b50      	ldr	r3, [pc, #320]	; (80042d4 <rt_test_009_001_execute.lto_priv.798+0x1a4>)
 8004194:	601a      	str	r2, [r3, #0]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn1",
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
 8004196:	4b4f      	ldr	r3, [pc, #316]	; (80042d4 <rt_test_009_001_execute.lto_priv.798+0x1a4>)
 8004198:	681b      	ldr	r3, [r3, #0]
 800419a:	2b00      	cmp	r3, #0
 800419c:	bf14      	ite	ne
 800419e:	2301      	movne	r3, #1
 80041a0:	2300      	moveq	r3, #0
 80041a2:	b2db      	uxtb	r3, r3
 80041a4:	494c      	ldr	r1, [pc, #304]	; (80042d8 <rt_test_009_001_execute.lto_priv.798+0x1a8>)
 80041a6:	4618      	mov	r0, r3
 80041a8:	f011 f96a 	bl	8015480 <_test_assert>
 80041ac:	4603      	mov	r3, r0
 80041ae:	2b00      	cmp	r3, #0
 80041b0:	f040 8081 	bne.w	80042b6 <rt_test_009_001_execute.lto_priv.798+0x186>
  }

  /* [9.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
 80041b4:	4b41      	ldr	r3, [pc, #260]	; (80042bc <rt_test_009_001_execute.lto_priv.798+0x18c>)
 80041b6:	2204      	movs	r2, #4
 80041b8:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 80041ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80041bc:	1e9a      	subs	r2, r3, #2
 80041be:	4b47      	ldr	r3, [pc, #284]	; (80042dc <rt_test_009_001_execute.lto_priv.798+0x1ac>)
 80041c0:	9301      	str	r3, [sp, #4]
 80041c2:	4b42      	ldr	r3, [pc, #264]	; (80042cc <rt_test_009_001_execute.lto_priv.798+0x19c>)
 80041c4:	9300      	str	r3, [sp, #0]
 80041c6:	4613      	mov	r3, r2
 80041c8:	4a45      	ldr	r2, [pc, #276]	; (80042e0 <rt_test_009_001_execute.lto_priv.798+0x1b0>)
 80041ca:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80041ce:	483c      	ldr	r0, [pc, #240]	; (80042c0 <rt_test_009_001_execute.lto_priv.798+0x190>)
 80041d0:	f00e f9f6 	bl	80125c0 <chThdCreateFromHeap>
 80041d4:	4602      	mov	r2, r0
 80041d6:	4b3f      	ldr	r3, [pc, #252]	; (80042d4 <rt_test_009_001_execute.lto_priv.798+0x1a4>)
 80041d8:	605a      	str	r2, [r3, #4]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 80041da:	4b3e      	ldr	r3, [pc, #248]	; (80042d4 <rt_test_009_001_execute.lto_priv.798+0x1a4>)
 80041dc:	685b      	ldr	r3, [r3, #4]
 80041de:	2b00      	cmp	r3, #0
 80041e0:	bf14      	ite	ne
 80041e2:	2301      	movne	r3, #1
 80041e4:	2300      	moveq	r3, #0
 80041e6:	b2db      	uxtb	r3, r3
 80041e8:	493b      	ldr	r1, [pc, #236]	; (80042d8 <rt_test_009_001_execute.lto_priv.798+0x1a8>)
 80041ea:	4618      	mov	r0, r3
 80041ec:	f011 f948 	bl	8015480 <_test_assert>
 80041f0:	4603      	mov	r3, r0
 80041f2:	2b00      	cmp	r3, #0
 80041f4:	d15f      	bne.n	80042b6 <rt_test_009_001_execute.lto_priv.798+0x186>
  }

  /* [9.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
 80041f6:	4b31      	ldr	r3, [pc, #196]	; (80042bc <rt_test_009_001_execute.lto_priv.798+0x18c>)
 80041f8:	2205      	movs	r2, #5
 80041fa:	601a      	str	r2, [r3, #0]
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80041fc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80041fe:	1eda      	subs	r2, r3, #3
 8004200:	4b38      	ldr	r3, [pc, #224]	; (80042e4 <rt_test_009_001_execute.lto_priv.798+0x1b4>)
 8004202:	9301      	str	r3, [sp, #4]
 8004204:	4b31      	ldr	r3, [pc, #196]	; (80042cc <rt_test_009_001_execute.lto_priv.798+0x19c>)
 8004206:	9300      	str	r3, [sp, #0]
 8004208:	4613      	mov	r3, r2
 800420a:	4a37      	ldr	r2, [pc, #220]	; (80042e8 <rt_test_009_001_execute.lto_priv.798+0x1b8>)
 800420c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8004210:	482b      	ldr	r0, [pc, #172]	; (80042c0 <rt_test_009_001_execute.lto_priv.798+0x190>)
 8004212:	f00e f9d5 	bl	80125c0 <chThdCreateFromHeap>
 8004216:	4602      	mov	r2, r0
 8004218:	4b2e      	ldr	r3, [pc, #184]	; (80042d4 <rt_test_009_001_execute.lto_priv.798+0x1a4>)
 800421a:	609a      	str	r2, [r3, #8]
                                     (((size_t)-1) >> 1U) + 1U,
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 800421c:	4b2d      	ldr	r3, [pc, #180]	; (80042d4 <rt_test_009_001_execute.lto_priv.798+0x1a4>)
 800421e:	689b      	ldr	r3, [r3, #8]
 8004220:	2b00      	cmp	r3, #0
 8004222:	bf0c      	ite	eq
 8004224:	2301      	moveq	r3, #1
 8004226:	2300      	movne	r3, #0
 8004228:	b2db      	uxtb	r3, r3
 800422a:	4930      	ldr	r1, [pc, #192]	; (80042ec <rt_test_009_001_execute.lto_priv.798+0x1bc>)
 800422c:	4618      	mov	r0, r3
 800422e:	f011 f927 	bl	8015480 <_test_assert>
 8004232:	4603      	mov	r3, r0
 8004234:	2b00      	cmp	r3, #0
 8004236:	d13e      	bne.n	80042b6 <rt_test_009_001_execute.lto_priv.798+0x186>
  }

  /* [9.1.6] Letting threads execute then checking the start order and
     freeing memory.*/
  test_set_step(6);
 8004238:	4b20      	ldr	r3, [pc, #128]	; (80042bc <rt_test_009_001_execute.lto_priv.798+0x18c>)
 800423a:	2206      	movs	r2, #6
 800423c:	601a      	str	r2, [r3, #0]
  {
    test_wait_threads();
 800423e:	f7fc fd9f 	bl	8000d80 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 8004242:	492b      	ldr	r1, [pc, #172]	; (80042f0 <rt_test_009_001_execute.lto_priv.798+0x1c0>)
 8004244:	482b      	ldr	r0, [pc, #172]	; (80042f4 <rt_test_009_001_execute.lto_priv.798+0x1c4>)
 8004246:	f011 f933 	bl	80154b0 <_test_assert_sequence>
 800424a:	4603      	mov	r3, r0
 800424c:	2b00      	cmp	r3, #0
 800424e:	d132      	bne.n	80042b6 <rt_test_009_001_execute.lto_priv.798+0x186>
  }

  /* [9.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 8004250:	4b1a      	ldr	r3, [pc, #104]	; (80042bc <rt_test_009_001_execute.lto_priv.798+0x18c>)
 8004252:	2207      	movs	r2, #7
 8004254:	601a      	str	r2, [r3, #0]
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8004256:	aa03      	add	r2, sp, #12
 8004258:	ab04      	add	r3, sp, #16
 800425a:	4619      	mov	r1, r3
 800425c:	4818      	ldr	r0, [pc, #96]	; (80042c0 <rt_test_009_001_execute.lto_priv.798+0x190>)
 800425e:	f00e ffbf 	bl	80131e0 <chHeapStatus>
 8004262:	9007      	str	r0, [sp, #28]
    test_assert(n1 == n2, "fragmentation changed");
 8004264:	9a08      	ldr	r2, [sp, #32]
 8004266:	9b07      	ldr	r3, [sp, #28]
 8004268:	429a      	cmp	r2, r3
 800426a:	bf0c      	ite	eq
 800426c:	2301      	moveq	r3, #1
 800426e:	2300      	movne	r3, #0
 8004270:	b2db      	uxtb	r3, r3
 8004272:	4921      	ldr	r1, [pc, #132]	; (80042f8 <rt_test_009_001_execute.lto_priv.798+0x1c8>)
 8004274:	4618      	mov	r0, r3
 8004276:	f011 f903 	bl	8015480 <_test_assert>
 800427a:	4603      	mov	r3, r0
 800427c:	2b00      	cmp	r3, #0
 800427e:	d11a      	bne.n	80042b6 <rt_test_009_001_execute.lto_priv.798+0x186>
    test_assert(total1 == total2, "total free space changed");
 8004280:	9a06      	ldr	r2, [sp, #24]
 8004282:	9b04      	ldr	r3, [sp, #16]
 8004284:	429a      	cmp	r2, r3
 8004286:	bf0c      	ite	eq
 8004288:	2301      	moveq	r3, #1
 800428a:	2300      	movne	r3, #0
 800428c:	b2db      	uxtb	r3, r3
 800428e:	491b      	ldr	r1, [pc, #108]	; (80042fc <rt_test_009_001_execute.lto_priv.798+0x1cc>)
 8004290:	4618      	mov	r0, r3
 8004292:	f011 f8f5 	bl	8015480 <_test_assert>
 8004296:	4603      	mov	r3, r0
 8004298:	2b00      	cmp	r3, #0
 800429a:	d10c      	bne.n	80042b6 <rt_test_009_001_execute.lto_priv.798+0x186>
    test_assert(largest1 == largest2, "largest fragment size changed");
 800429c:	9a05      	ldr	r2, [sp, #20]
 800429e:	9b03      	ldr	r3, [sp, #12]
 80042a0:	429a      	cmp	r2, r3
 80042a2:	bf0c      	ite	eq
 80042a4:	2301      	moveq	r3, #1
 80042a6:	2300      	movne	r3, #0
 80042a8:	b2db      	uxtb	r3, r3
 80042aa:	4915      	ldr	r1, [pc, #84]	; (8004300 <rt_test_009_001_execute.lto_priv.798+0x1d0>)
 80042ac:	4618      	mov	r0, r3
 80042ae:	f011 f8e7 	bl	8015480 <_test_assert>
 80042b2:	4603      	mov	r3, r0
 80042b4:	2b00      	cmp	r3, #0
  }
}
 80042b6:	b00b      	add	sp, #44	; 0x2c
 80042b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80042bc:	20001988 	.word	0x20001988
 80042c0:	2000203c 	.word	0x2000203c
 80042c4:	080183f8 	.word	0x080183f8
 80042c8:	08017f34 	.word	0x08017f34
 80042cc:	080040f1 	.word	0x080040f1
 80042d0:	08018408 	.word	0x08018408
 80042d4:	20002018 	.word	0x20002018
 80042d8:	08018410 	.word	0x08018410
 80042dc:	08017f30 	.word	0x08017f30
 80042e0:	08018428 	.word	0x08018428
 80042e4:	08017f2c 	.word	0x08017f2c
 80042e8:	08018430 	.word	0x08018430
 80042ec:	08018438 	.word	0x08018438
 80042f0:	08017f38 	.word	0x08017f38
 80042f4:	08018454 	.word	0x08018454
 80042f8:	08018458 	.word	0x08018458
 80042fc:	08018470 	.word	0x08018470
 8004300:	0801848c 	.word	0x0801848c
	...

08004310 <rt_test_009_002_setup.lto_priv.799>:
 *   execution sequence.
 * - [9.2.6] Testing that the pool contains four elements again.
 * .
 */

static void rt_test_009_002_setup(void) {
 8004310:	b508      	push	{r3, lr}
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 8004312:	2200      	movs	r2, #0
 8004314:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004318:	4801      	ldr	r0, [pc, #4]	; (8004320 <rt_test_009_002_setup.lto_priv.799+0x10>)
 800431a:	f7ff fed9 	bl	80040d0 <chPoolObjectInit.lto_priv.30>
}
 800431e:	bd08      	pop	{r3, pc}
 8004320:	20002058 	.word	0x20002058
	...

08004330 <rt_test_009_002_execute.lto_priv.800>:

static void rt_test_009_002_execute(void) {
 8004330:	b500      	push	{lr}
 8004332:	b085      	sub	sp, #20
  unsigned i;
  tprio_t prio;

  /* [9.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 8004334:	4b5f      	ldr	r3, [pc, #380]	; (80044b4 <rt_test_009_002_execute.lto_priv.800+0x184>)
 8004336:	2201      	movs	r2, #1
 8004338:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < 4; i++)
 800433a:	2300      	movs	r3, #0
 800433c:	9303      	str	r3, [sp, #12]
 800433e:	e00a      	b.n	8004356 <rt_test_009_002_execute.lto_priv.800+0x26>
      chPoolFree(&mp1, wa[i]);
 8004340:	4a5d      	ldr	r2, [pc, #372]	; (80044b8 <rt_test_009_002_execute.lto_priv.800+0x188>)
 8004342:	9b03      	ldr	r3, [sp, #12]
 8004344:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004348:	4619      	mov	r1, r3
 800434a:	485c      	ldr	r0, [pc, #368]	; (80044bc <rt_test_009_002_execute.lto_priv.800+0x18c>)
 800434c:	f00f f8d0 	bl	80134f0 <chPoolFree>
    for (i = 0; i < 4; i++)
 8004350:	9b03      	ldr	r3, [sp, #12]
 8004352:	3301      	adds	r3, #1
 8004354:	9303      	str	r3, [sp, #12]
 8004356:	9b03      	ldr	r3, [sp, #12]
 8004358:	2b03      	cmp	r3, #3
 800435a:	d9f1      	bls.n	8004340 <rt_test_009_002_execute.lto_priv.800+0x10>
  }

  /* [9.2.2] Getting base priority for threads.*/
  test_set_step(2);
 800435c:	4b55      	ldr	r3, [pc, #340]	; (80044b4 <rt_test_009_002_execute.lto_priv.800+0x184>)
 800435e:	2202      	movs	r2, #2
 8004360:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 8004362:	f7ff fead 	bl	80040c0 <chThdGetPriorityX.lto_priv.95>
 8004366:	9002      	str	r0, [sp, #8]
  }

  /* [9.2.3] Creating the five threads.*/
  test_set_step(3);
 8004368:	4b52      	ldr	r3, [pc, #328]	; (80044b4 <rt_test_009_002_execute.lto_priv.800+0x184>)
 800436a:	2203      	movs	r2, #3
 800436c:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 800436e:	9b02      	ldr	r3, [sp, #8]
 8004370:	1e5a      	subs	r2, r3, #1
 8004372:	4b53      	ldr	r3, [pc, #332]	; (80044c0 <rt_test_009_002_execute.lto_priv.800+0x190>)
 8004374:	9300      	str	r3, [sp, #0]
 8004376:	4b53      	ldr	r3, [pc, #332]	; (80044c4 <rt_test_009_002_execute.lto_priv.800+0x194>)
 8004378:	4953      	ldr	r1, [pc, #332]	; (80044c8 <rt_test_009_002_execute.lto_priv.800+0x198>)
 800437a:	4850      	ldr	r0, [pc, #320]	; (80044bc <rt_test_009_002_execute.lto_priv.800+0x18c>)
 800437c:	f00e f960 	bl	8012640 <chThdCreateFromMemoryPool>
 8004380:	4602      	mov	r2, r0
 8004382:	4b52      	ldr	r3, [pc, #328]	; (80044cc <rt_test_009_002_execute.lto_priv.800+0x19c>)
 8004384:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8004386:	9b02      	ldr	r3, [sp, #8]
 8004388:	1e9a      	subs	r2, r3, #2
 800438a:	4b51      	ldr	r3, [pc, #324]	; (80044d0 <rt_test_009_002_execute.lto_priv.800+0x1a0>)
 800438c:	9300      	str	r3, [sp, #0]
 800438e:	4b4d      	ldr	r3, [pc, #308]	; (80044c4 <rt_test_009_002_execute.lto_priv.800+0x194>)
 8004390:	4950      	ldr	r1, [pc, #320]	; (80044d4 <rt_test_009_002_execute.lto_priv.800+0x1a4>)
 8004392:	484a      	ldr	r0, [pc, #296]	; (80044bc <rt_test_009_002_execute.lto_priv.800+0x18c>)
 8004394:	f00e f954 	bl	8012640 <chThdCreateFromMemoryPool>
 8004398:	4602      	mov	r2, r0
 800439a:	4b4c      	ldr	r3, [pc, #304]	; (80044cc <rt_test_009_002_execute.lto_priv.800+0x19c>)
 800439c:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 800439e:	9b02      	ldr	r3, [sp, #8]
 80043a0:	1eda      	subs	r2, r3, #3
 80043a2:	4b4d      	ldr	r3, [pc, #308]	; (80044d8 <rt_test_009_002_execute.lto_priv.800+0x1a8>)
 80043a4:	9300      	str	r3, [sp, #0]
 80043a6:	4b47      	ldr	r3, [pc, #284]	; (80044c4 <rt_test_009_002_execute.lto_priv.800+0x194>)
 80043a8:	494c      	ldr	r1, [pc, #304]	; (80044dc <rt_test_009_002_execute.lto_priv.800+0x1ac>)
 80043aa:	4844      	ldr	r0, [pc, #272]	; (80044bc <rt_test_009_002_execute.lto_priv.800+0x18c>)
 80043ac:	f00e f948 	bl	8012640 <chThdCreateFromMemoryPool>
 80043b0:	4602      	mov	r2, r0
 80043b2:	4b46      	ldr	r3, [pc, #280]	; (80044cc <rt_test_009_002_execute.lto_priv.800+0x19c>)
 80043b4:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 80043b6:	9b02      	ldr	r3, [sp, #8]
 80043b8:	1f1a      	subs	r2, r3, #4
 80043ba:	4b49      	ldr	r3, [pc, #292]	; (80044e0 <rt_test_009_002_execute.lto_priv.800+0x1b0>)
 80043bc:	9300      	str	r3, [sp, #0]
 80043be:	4b41      	ldr	r3, [pc, #260]	; (80044c4 <rt_test_009_002_execute.lto_priv.800+0x194>)
 80043c0:	4948      	ldr	r1, [pc, #288]	; (80044e4 <rt_test_009_002_execute.lto_priv.800+0x1b4>)
 80043c2:	483e      	ldr	r0, [pc, #248]	; (80044bc <rt_test_009_002_execute.lto_priv.800+0x18c>)
 80043c4:	f00e f93c 	bl	8012640 <chThdCreateFromMemoryPool>
 80043c8:	4602      	mov	r2, r0
 80043ca:	4b40      	ldr	r3, [pc, #256]	; (80044cc <rt_test_009_002_execute.lto_priv.800+0x19c>)
 80043cc:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 80043ce:	9b02      	ldr	r3, [sp, #8]
 80043d0:	1f5a      	subs	r2, r3, #5
 80043d2:	4b45      	ldr	r3, [pc, #276]	; (80044e8 <rt_test_009_002_execute.lto_priv.800+0x1b8>)
 80043d4:	9300      	str	r3, [sp, #0]
 80043d6:	4b3b      	ldr	r3, [pc, #236]	; (80044c4 <rt_test_009_002_execute.lto_priv.800+0x194>)
 80043d8:	4944      	ldr	r1, [pc, #272]	; (80044ec <rt_test_009_002_execute.lto_priv.800+0x1bc>)
 80043da:	4838      	ldr	r0, [pc, #224]	; (80044bc <rt_test_009_002_execute.lto_priv.800+0x18c>)
 80043dc:	f00e f930 	bl	8012640 <chThdCreateFromMemoryPool>
 80043e0:	4602      	mov	r2, r0
 80043e2:	4b3a      	ldr	r3, [pc, #232]	; (80044cc <rt_test_009_002_execute.lto_priv.800+0x19c>)
 80043e4:	611a      	str	r2, [r3, #16]
  }

  /* [9.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
 80043e6:	4b33      	ldr	r3, [pc, #204]	; (80044b4 <rt_test_009_002_execute.lto_priv.800+0x184>)
 80043e8:	2204      	movs	r2, #4
 80043ea:	601a      	str	r2, [r3, #0]
  {
    test_assert((threads[0] != NULL) &&
 80043ec:	4b37      	ldr	r3, [pc, #220]	; (80044cc <rt_test_009_002_execute.lto_priv.800+0x19c>)
 80043ee:	681b      	ldr	r3, [r3, #0]
 80043f0:	2b00      	cmp	r3, #0
 80043f2:	d00d      	beq.n	8004410 <rt_test_009_002_execute.lto_priv.800+0xe0>
 80043f4:	4b35      	ldr	r3, [pc, #212]	; (80044cc <rt_test_009_002_execute.lto_priv.800+0x19c>)
 80043f6:	685b      	ldr	r3, [r3, #4]
 80043f8:	2b00      	cmp	r3, #0
 80043fa:	d009      	beq.n	8004410 <rt_test_009_002_execute.lto_priv.800+0xe0>
 80043fc:	4b33      	ldr	r3, [pc, #204]	; (80044cc <rt_test_009_002_execute.lto_priv.800+0x19c>)
 80043fe:	689b      	ldr	r3, [r3, #8]
 8004400:	2b00      	cmp	r3, #0
 8004402:	d005      	beq.n	8004410 <rt_test_009_002_execute.lto_priv.800+0xe0>
 8004404:	4b31      	ldr	r3, [pc, #196]	; (80044cc <rt_test_009_002_execute.lto_priv.800+0x19c>)
 8004406:	68db      	ldr	r3, [r3, #12]
 8004408:	2b00      	cmp	r3, #0
 800440a:	d001      	beq.n	8004410 <rt_test_009_002_execute.lto_priv.800+0xe0>
 800440c:	2301      	movs	r3, #1
 800440e:	e000      	b.n	8004412 <rt_test_009_002_execute.lto_priv.800+0xe2>
 8004410:	2300      	movs	r3, #0
 8004412:	f003 0301 	and.w	r3, r3, #1
 8004416:	b2db      	uxtb	r3, r3
 8004418:	4935      	ldr	r1, [pc, #212]	; (80044f0 <rt_test_009_002_execute.lto_priv.800+0x1c0>)
 800441a:	4618      	mov	r0, r3
 800441c:	f011 f830 	bl	8015480 <_test_assert>
 8004420:	4603      	mov	r3, r0
 8004422:	2b00      	cmp	r3, #0
 8004424:	d142      	bne.n	80044ac <rt_test_009_002_execute.lto_priv.800+0x17c>
                (threads[1] != NULL) &&
                (threads[2] != NULL) &&
                (threads[3] != NULL),
                "thread creation failed");
    test_assert(threads[4] == NULL,
 8004426:	4b29      	ldr	r3, [pc, #164]	; (80044cc <rt_test_009_002_execute.lto_priv.800+0x19c>)
 8004428:	691b      	ldr	r3, [r3, #16]
 800442a:	2b00      	cmp	r3, #0
 800442c:	bf0c      	ite	eq
 800442e:	2301      	moveq	r3, #1
 8004430:	2300      	movne	r3, #0
 8004432:	b2db      	uxtb	r3, r3
 8004434:	492f      	ldr	r1, [pc, #188]	; (80044f4 <rt_test_009_002_execute.lto_priv.800+0x1c4>)
 8004436:	4618      	mov	r0, r3
 8004438:	f011 f822 	bl	8015480 <_test_assert>
 800443c:	4603      	mov	r3, r0
 800443e:	2b00      	cmp	r3, #0
 8004440:	d134      	bne.n	80044ac <rt_test_009_002_execute.lto_priv.800+0x17c>
                "thread creation not failed");
  }

  /* [9.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 8004442:	4b1c      	ldr	r3, [pc, #112]	; (80044b4 <rt_test_009_002_execute.lto_priv.800+0x184>)
 8004444:	2205      	movs	r2, #5
 8004446:	601a      	str	r2, [r3, #0]
  {
    test_wait_threads();
 8004448:	f7fc fc9a 	bl	8000d80 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 800444c:	492a      	ldr	r1, [pc, #168]	; (80044f8 <rt_test_009_002_execute.lto_priv.800+0x1c8>)
 800444e:	482b      	ldr	r0, [pc, #172]	; (80044fc <rt_test_009_002_execute.lto_priv.800+0x1cc>)
 8004450:	f011 f82e 	bl	80154b0 <_test_assert_sequence>
 8004454:	4603      	mov	r3, r0
 8004456:	2b00      	cmp	r3, #0
 8004458:	d128      	bne.n	80044ac <rt_test_009_002_execute.lto_priv.800+0x17c>
  }

  /* [9.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
 800445a:	4b16      	ldr	r3, [pc, #88]	; (80044b4 <rt_test_009_002_execute.lto_priv.800+0x184>)
 800445c:	2206      	movs	r2, #6
 800445e:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < 4; i++)
 8004460:	2300      	movs	r3, #0
 8004462:	9303      	str	r3, [sp, #12]
 8004464:	e012      	b.n	800448c <rt_test_009_002_execute.lto_priv.800+0x15c>
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 8004466:	4815      	ldr	r0, [pc, #84]	; (80044bc <rt_test_009_002_execute.lto_priv.800+0x18c>)
 8004468:	f00f f80a 	bl	8013480 <chPoolAlloc>
 800446c:	4603      	mov	r3, r0
 800446e:	2b00      	cmp	r3, #0
 8004470:	bf14      	ite	ne
 8004472:	2301      	movne	r3, #1
 8004474:	2300      	moveq	r3, #0
 8004476:	b2db      	uxtb	r3, r3
 8004478:	4921      	ldr	r1, [pc, #132]	; (8004500 <rt_test_009_002_execute.lto_priv.800+0x1d0>)
 800447a:	4618      	mov	r0, r3
 800447c:	f011 f800 	bl	8015480 <_test_assert>
 8004480:	4603      	mov	r3, r0
 8004482:	2b00      	cmp	r3, #0
 8004484:	d112      	bne.n	80044ac <rt_test_009_002_execute.lto_priv.800+0x17c>
    for (i = 0; i < 4; i++)
 8004486:	9b03      	ldr	r3, [sp, #12]
 8004488:	3301      	adds	r3, #1
 800448a:	9303      	str	r3, [sp, #12]
 800448c:	9b03      	ldr	r3, [sp, #12]
 800448e:	2b03      	cmp	r3, #3
 8004490:	d9e9      	bls.n	8004466 <rt_test_009_002_execute.lto_priv.800+0x136>
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8004492:	480a      	ldr	r0, [pc, #40]	; (80044bc <rt_test_009_002_execute.lto_priv.800+0x18c>)
 8004494:	f00e fff4 	bl	8013480 <chPoolAlloc>
 8004498:	4603      	mov	r3, r0
 800449a:	2b00      	cmp	r3, #0
 800449c:	bf0c      	ite	eq
 800449e:	2301      	moveq	r3, #1
 80044a0:	2300      	movne	r3, #0
 80044a2:	b2db      	uxtb	r3, r3
 80044a4:	4917      	ldr	r1, [pc, #92]	; (8004504 <rt_test_009_002_execute.lto_priv.800+0x1d4>)
 80044a6:	4618      	mov	r0, r3
 80044a8:	f010 ffea 	bl	8015480 <_test_assert>
  }
}
 80044ac:	b005      	add	sp, #20
 80044ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80044b2:	bf00      	nop
 80044b4:	20001988 	.word	0x20001988
 80044b8:	08017360 	.word	0x08017360
 80044bc:	20002058 	.word	0x20002058
 80044c0:	08017f34 	.word	0x08017f34
 80044c4:	080040f1 	.word	0x080040f1
 80044c8:	08018408 	.word	0x08018408
 80044cc:	20002018 	.word	0x20002018
 80044d0:	08017f30 	.word	0x08017f30
 80044d4:	08018428 	.word	0x08018428
 80044d8:	08017f2c 	.word	0x08017f2c
 80044dc:	08018430 	.word	0x08018430
 80044e0:	0801622c 	.word	0x0801622c
 80044e4:	080184bc 	.word	0x080184bc
 80044e8:	08017f50 	.word	0x08017f50
 80044ec:	080184c4 	.word	0x080184c4
 80044f0:	08018410 	.word	0x08018410
 80044f4:	08018438 	.word	0x08018438
 80044f8:	08017f38 	.word	0x08017f38
 80044fc:	08018288 	.word	0x08018288
 8004500:	080184cc 	.word	0x080184cc
 8004504:	080184dc 	.word	0x080184dc
	...

08004510 <chTimeAddX.lto_priv.124>:
                                   sysinterval_t interval) {
 8004510:	b082      	sub	sp, #8
 8004512:	9001      	str	r0, [sp, #4]
 8004514:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
 8004516:	9a01      	ldr	r2, [sp, #4]
 8004518:	9b00      	ldr	r3, [sp, #0]
 800451a:	4413      	add	r3, r2
}
 800451c:	4618      	mov	r0, r3
 800451e:	b002      	add	sp, #8
 8004520:	4770      	bx	lr
 8004522:	bf00      	nop
	...

08004530 <chTimeIsInRangeX>:
 *
 * @xclass
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {
 8004530:	b084      	sub	sp, #16
 8004532:	9003      	str	r0, [sp, #12]
 8004534:	9102      	str	r1, [sp, #8]
 8004536:	9201      	str	r2, [sp, #4]

  return (bool)((time - start) < (end - start));
 8004538:	9a03      	ldr	r2, [sp, #12]
 800453a:	9b02      	ldr	r3, [sp, #8]
 800453c:	1ad2      	subs	r2, r2, r3
 800453e:	9901      	ldr	r1, [sp, #4]
 8004540:	9b02      	ldr	r3, [sp, #8]
 8004542:	1acb      	subs	r3, r1, r3
 8004544:	429a      	cmp	r2, r3
 8004546:	bf34      	ite	cc
 8004548:	2301      	movcc	r3, #1
 800454a:	2300      	movcs	r3, #0
 800454c:	b2db      	uxtb	r3, r3
}
 800454e:	4618      	mov	r0, r3
 8004550:	b004      	add	sp, #16
 8004552:	4770      	bx	lr
	...

08004560 <port_lock.lto_priv.25>:
static inline void port_lock(void) {
 8004560:	b082      	sub	sp, #8
 8004562:	2320      	movs	r3, #32
 8004564:	9301      	str	r3, [sp, #4]
 8004566:	9b01      	ldr	r3, [sp, #4]
 8004568:	f383 8811 	msr	BASEPRI, r3
}
 800456c:	b002      	add	sp, #8
 800456e:	4770      	bx	lr

08004570 <port_unlock.lto_priv.15>:
static inline void port_unlock(void) {
 8004570:	b082      	sub	sp, #8
 8004572:	2300      	movs	r3, #0
 8004574:	9301      	str	r3, [sp, #4]
 8004576:	9b01      	ldr	r3, [sp, #4]
 8004578:	f383 8811 	msr	BASEPRI, r3
}
 800457c:	b002      	add	sp, #8
 800457e:	4770      	bx	lr

08004580 <st_lld_get_counter.lto_priv.119>:
  return (systime_t)STM32_ST_TIM->CNT;
 8004580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004584:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8004586:	4618      	mov	r0, r3
 8004588:	4770      	bx	lr
 800458a:	bf00      	nop
 800458c:	0000      	movs	r0, r0
	...

08004590 <port_timer_get_time.lto_priv.114>:
static inline systime_t port_timer_get_time(void) {
 8004590:	b508      	push	{r3, lr}
  return stGetCounter();
 8004592:	f7ff fff5 	bl	8004580 <st_lld_get_counter.lto_priv.119>
 8004596:	4603      	mov	r3, r0
}
 8004598:	4618      	mov	r0, r3
 800459a:	bd08      	pop	{r3, pc}
 800459c:	0000      	movs	r0, r0
	...

080045a0 <chSysLock.lto_priv.81>:
static inline void chSysLock(void) {
 80045a0:	b508      	push	{r3, lr}
  port_lock();
 80045a2:	f7ff ffdd 	bl	8004560 <port_lock.lto_priv.25>
  _dbg_check_lock();
 80045a6:	f00a fe8b 	bl	800f2c0 <_dbg_check_lock>
}
 80045aa:	bd08      	pop	{r3, pc}
 80045ac:	0000      	movs	r0, r0
	...

080045b0 <chSysUnlock.lto_priv.45>:
static inline void chSysUnlock(void) {
 80045b0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80045b2:	f00a fe9d 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80045b6:	4b09      	ldr	r3, [pc, #36]	; (80045dc <chSysUnlock.lto_priv.45+0x2c>)
 80045b8:	681b      	ldr	r3, [r3, #0]
 80045ba:	4a08      	ldr	r2, [pc, #32]	; (80045dc <chSysUnlock.lto_priv.45+0x2c>)
 80045bc:	4293      	cmp	r3, r2
 80045be:	d00a      	beq.n	80045d6 <chSysUnlock.lto_priv.45+0x26>
 80045c0:	4b06      	ldr	r3, [pc, #24]	; (80045dc <chSysUnlock.lto_priv.45+0x2c>)
 80045c2:	699b      	ldr	r3, [r3, #24]
 80045c4:	689a      	ldr	r2, [r3, #8]
 80045c6:	4b05      	ldr	r3, [pc, #20]	; (80045dc <chSysUnlock.lto_priv.45+0x2c>)
 80045c8:	681b      	ldr	r3, [r3, #0]
 80045ca:	689b      	ldr	r3, [r3, #8]
 80045cc:	429a      	cmp	r2, r3
 80045ce:	d202      	bcs.n	80045d6 <chSysUnlock.lto_priv.45+0x26>
 80045d0:	4803      	ldr	r0, [pc, #12]	; (80045e0 <chSysUnlock.lto_priv.45+0x30>)
 80045d2:	f00a fd05 	bl	800efe0 <chSysHalt>
  port_unlock();
 80045d6:	f7ff ffcb 	bl	8004570 <port_unlock.lto_priv.15>
}
 80045da:	bd08      	pop	{r3, pc}
 80045dc:	20001090 	.word	0x20001090
 80045e0:	08018728 	.word	0x08018728
	...

080045f0 <chVTGetSystemTimeX.lto_priv.109>:
static inline systime_t chVTGetSystemTimeX(void) {
 80045f0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 80045f2:	f7ff ffcd 	bl	8004590 <port_timer_get_time.lto_priv.114>
 80045f6:	4603      	mov	r3, r0
}
 80045f8:	4618      	mov	r0, r3
 80045fa:	bd08      	pop	{r3, pc}
 80045fc:	0000      	movs	r0, r0
	...

08004600 <chVTIsSystemTimeWithinX>:
static inline bool chVTIsSystemTimeWithinX(systime_t start, systime_t end) {
 8004600:	b500      	push	{lr}
 8004602:	b083      	sub	sp, #12
 8004604:	9001      	str	r0, [sp, #4]
 8004606:	9100      	str	r1, [sp, #0]
  return chTimeIsInRangeX(chVTGetSystemTimeX(), start, end);
 8004608:	f7ff fff2 	bl	80045f0 <chVTGetSystemTimeX.lto_priv.109>
 800460c:	4603      	mov	r3, r0
 800460e:	9a00      	ldr	r2, [sp, #0]
 8004610:	9901      	ldr	r1, [sp, #4]
 8004612:	4618      	mov	r0, r3
 8004614:	f7ff ff8c 	bl	8004530 <chTimeIsInRangeX>
 8004618:	4603      	mov	r3, r0
}
 800461a:	4618      	mov	r0, r3
 800461c:	b003      	add	sp, #12
 800461e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004622:	bf00      	nop
	...

08004630 <chThdGetSelfX.lto_priv.104>:
  return ch.rlist.current;
 8004630:	4b01      	ldr	r3, [pc, #4]	; (8004638 <chThdGetSelfX.lto_priv.104+0x8>)
 8004632:	699b      	ldr	r3, [r3, #24]
}
 8004634:	4618      	mov	r0, r3
 8004636:	4770      	bx	lr
 8004638:	20001090 	.word	0x20001090
 800463c:	00000000 	.word	0x00000000

08004640 <chThdGetPriorityX.lto_priv.96>:
static inline tprio_t chThdGetPriorityX(void) {
 8004640:	b508      	push	{r3, lr}
  return chThdGetSelfX()->prio;
 8004642:	f7ff fff5 	bl	8004630 <chThdGetSelfX.lto_priv.104>
 8004646:	4603      	mov	r3, r0
 8004648:	689b      	ldr	r3, [r3, #8]
}
 800464a:	4618      	mov	r0, r3
 800464c:	bd08      	pop	{r3, pc}
 800464e:	bf00      	nop

08004650 <chThdShouldTerminateX>:
 * @retval true         termination request pending.
 * @retval false        termination request not pending.
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {
 8004650:	b508      	push	{r3, lr}

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8004652:	f7ff ffed 	bl	8004630 <chThdGetSelfX.lto_priv.104>
 8004656:	4603      	mov	r3, r0
 8004658:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800465c:	f003 0304 	and.w	r3, r3, #4
 8004660:	2b00      	cmp	r3, #0
 8004662:	bf14      	ite	ne
 8004664:	2301      	movne	r3, #1
 8004666:	2300      	moveq	r3, #0
 8004668:	b2db      	uxtb	r3, r3
}
 800466a:	4618      	mov	r0, r3
 800466c:	bd08      	pop	{r3, pc}
 800466e:	bf00      	nop

08004670 <chMsgGet.lto_priv.86>:
static inline msg_t chMsgGet(thread_t *tp) {
 8004670:	b500      	push	{lr}
 8004672:	b083      	sub	sp, #12
 8004674:	9001      	str	r0, [sp, #4]
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
 8004676:	9b01      	ldr	r3, [sp, #4]
 8004678:	f893 3020 	ldrb.w	r3, [r3, #32]
 800467c:	2b0d      	cmp	r3, #13
 800467e:	d002      	beq.n	8004686 <chMsgGet.lto_priv.86+0x16>
 8004680:	4804      	ldr	r0, [pc, #16]	; (8004694 <chMsgGet.lto_priv.86+0x24>)
 8004682:	f00a fcad 	bl	800efe0 <chSysHalt>
  return tp->u.sentmsg;
 8004686:	9b01      	ldr	r3, [sp, #4]
 8004688:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800468a:	4618      	mov	r0, r3
 800468c:	b003      	add	sp, #12
 800468e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004692:	bf00      	nop
 8004694:	0801871c 	.word	0x0801871c
	...

080046a0 <tmo>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(void *param) {(void)param;}
 80046a0:	b082      	sub	sp, #8
 80046a2:	9001      	str	r0, [sp, #4]
 80046a4:	b002      	add	sp, #8
 80046a6:	4770      	bx	lr
	...

080046b0 <bmk_thread1>:

#if CH_CFG_USE_MESSAGES
static THD_FUNCTION(bmk_thread1, p) {
 80046b0:	b500      	push	{lr}
 80046b2:	b085      	sub	sp, #20
 80046b4:	9001      	str	r0, [sp, #4]
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 80046b6:	f00d ff03 	bl	80124c0 <chMsgWait>
 80046ba:	9003      	str	r0, [sp, #12]
    msg = chMsgGet(tp);
 80046bc:	9803      	ldr	r0, [sp, #12]
 80046be:	f7ff ffd7 	bl	8004670 <chMsgGet.lto_priv.86>
 80046c2:	9002      	str	r0, [sp, #8]
    chMsgRelease(tp, msg);
 80046c4:	9902      	ldr	r1, [sp, #8]
 80046c6:	9803      	ldr	r0, [sp, #12]
 80046c8:	f00d ff22 	bl	8012510 <chMsgRelease>
  } while (msg);
 80046cc:	9b02      	ldr	r3, [sp, #8]
 80046ce:	2b00      	cmp	r3, #0
 80046d0:	d1f1      	bne.n	80046b6 <bmk_thread1+0x6>
}
 80046d2:	b005      	add	sp, #20
 80046d4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080046e0 <msg_loop_test>:

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 80046e0:	b500      	push	{lr}
 80046e2:	b087      	sub	sp, #28
 80046e4:	9001      	str	r0, [sp, #4]
  systime_t start, end;

  uint32_t n = 0;
 80046e6:	2300      	movs	r3, #0
 80046e8:	9305      	str	r3, [sp, #20]
  start = test_wait_tick();
 80046ea:	f7fc fb71 	bl	8000dd0 <test_wait_tick>
 80046ee:	9004      	str	r0, [sp, #16]
  end = chTimeAddX(start, TIME_MS2I(1000));
 80046f0:	f242 7110 	movw	r1, #10000	; 0x2710
 80046f4:	9804      	ldr	r0, [sp, #16]
 80046f6:	f7ff ff0b 	bl	8004510 <chTimeAddX.lto_priv.124>
 80046fa:	9003      	str	r0, [sp, #12]
  do {
    (void)chMsgSend(tp, 1);
 80046fc:	2101      	movs	r1, #1
 80046fe:	9801      	ldr	r0, [sp, #4]
 8004700:	f00d fea6 	bl	8012450 <chMsgSend>
    n++;
 8004704:	9b05      	ldr	r3, [sp, #20]
 8004706:	3301      	adds	r3, #1
 8004708:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 800470a:	9903      	ldr	r1, [sp, #12]
 800470c:	9804      	ldr	r0, [sp, #16]
 800470e:	f7ff ff77 	bl	8004600 <chVTIsSystemTimeWithinX>
 8004712:	4603      	mov	r3, r0
 8004714:	2b00      	cmp	r3, #0
 8004716:	d1f1      	bne.n	80046fc <msg_loop_test+0x1c>
  (void)chMsgSend(tp, 0);
 8004718:	2100      	movs	r1, #0
 800471a:	9801      	ldr	r0, [sp, #4]
 800471c:	f00d fe98 	bl	8012450 <chMsgSend>
  return n;
 8004720:	9b05      	ldr	r3, [sp, #20]
}
 8004722:	4618      	mov	r0, r3
 8004724:	b007      	add	sp, #28
 8004726:	f85d fb04 	ldr.w	pc, [sp], #4
 800472a:	bf00      	nop
 800472c:	0000      	movs	r0, r0
	...

08004730 <bmk_thread3>:
#endif

static THD_FUNCTION(bmk_thread3, p) {
 8004730:	b500      	push	{lr}
 8004732:	b083      	sub	sp, #12
 8004734:	9001      	str	r0, [sp, #4]

  chThdExit((msg_t)p);
 8004736:	9b01      	ldr	r3, [sp, #4]
 8004738:	4618      	mov	r0, r3
 800473a:	f00b ff89 	bl	8010650 <chThdExit>
}
 800473e:	b003      	add	sp, #12
 8004740:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004750 <bmk_thread4>:

static THD_FUNCTION(bmk_thread4, p) {
 8004750:	b500      	push	{lr}
 8004752:	b085      	sub	sp, #20
 8004754:	9001      	str	r0, [sp, #4]
  msg_t msg;
  thread_t *self = chThdGetSelfX();
 8004756:	f7ff ff6b 	bl	8004630 <chThdGetSelfX.lto_priv.104>
 800475a:	9003      	str	r0, [sp, #12]

  (void)p;
  chSysLock();
 800475c:	f7ff ff20 	bl	80045a0 <chSysLock.lto_priv.81>
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8004760:	2003      	movs	r0, #3
 8004762:	f00b fa95 	bl	800fc90 <chSchGoSleepS>
    msg = self->u.rdymsg;
 8004766:	9b03      	ldr	r3, [sp, #12]
 8004768:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800476a:	9302      	str	r3, [sp, #8]
  } while (msg == MSG_OK);
 800476c:	9b02      	ldr	r3, [sp, #8]
 800476e:	2b00      	cmp	r3, #0
 8004770:	d0f6      	beq.n	8004760 <bmk_thread4+0x10>
  chSysUnlock();
 8004772:	f7ff ff1d 	bl	80045b0 <chSysUnlock.lto_priv.45>
}
 8004776:	b005      	add	sp, #20
 8004778:	f85d fb04 	ldr.w	pc, [sp], #4
 800477c:	0000      	movs	r0, r0
	...

08004780 <bmk_thread7>:

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {
 8004780:	b500      	push	{lr}
 8004782:	b083      	sub	sp, #12
 8004784:	9001      	str	r0, [sp, #4]
 8004786:	e002      	b.n	800478e <bmk_thread7+0xe>

  (void)p;
  while (!chThdShouldTerminateX())
    chSemWait(&sem1);
 8004788:	4806      	ldr	r0, [pc, #24]	; (80047a4 <bmk_thread7+0x24>)
 800478a:	f00c fbd1 	bl	8010f30 <chSemWait>
  while (!chThdShouldTerminateX())
 800478e:	f7ff ff5f 	bl	8004650 <chThdShouldTerminateX>
 8004792:	4603      	mov	r3, r0
 8004794:	f083 0301 	eor.w	r3, r3, #1
 8004798:	b2db      	uxtb	r3, r3
 800479a:	2b00      	cmp	r3, #0
 800479c:	d1f4      	bne.n	8004788 <bmk_thread7+0x8>
}
 800479e:	b003      	add	sp, #12
 80047a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80047a4:	20002068 	.word	0x20002068
	...

080047b0 <bmk_thread8>:
#endif

static THD_FUNCTION(bmk_thread8, p) {
 80047b0:	b500      	push	{lr}
 80047b2:	b083      	sub	sp, #12
 80047b4:	9001      	str	r0, [sp, #4]

  do {
    chThdYield();
 80047b6:	f00c f853 	bl	8010860 <chThdYield>
    chThdYield();
 80047ba:	f00c f851 	bl	8010860 <chThdYield>
    chThdYield();
 80047be:	f00c f84f 	bl	8010860 <chThdYield>
    chThdYield();
 80047c2:	f00c f84d 	bl	8010860 <chThdYield>
    (*(uint32_t *)p) += 4;
 80047c6:	9b01      	ldr	r3, [sp, #4]
 80047c8:	681b      	ldr	r3, [r3, #0]
 80047ca:	1d1a      	adds	r2, r3, #4
 80047cc:	9b01      	ldr	r3, [sp, #4]
 80047ce:	601a      	str	r2, [r3, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 80047d0:	f7ff ff3e 	bl	8004650 <chThdShouldTerminateX>
 80047d4:	4603      	mov	r3, r0
 80047d6:	f083 0301 	eor.w	r3, r3, #1
 80047da:	b2db      	uxtb	r3, r3
 80047dc:	2b00      	cmp	r3, #0
 80047de:	d1ea      	bne.n	80047b6 <bmk_thread8+0x6>
}
 80047e0:	b003      	add	sp, #12
 80047e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80047e6:	bf00      	nop
	...

080047f0 <rt_test_010_001_execute.lto_priv.801>:
 *   second time window.
 * - [10.1.3] Score is printed.
 * .
 */

static void rt_test_010_001_execute(void) {
 80047f0:	b510      	push	{r4, lr}
 80047f2:	b084      	sub	sp, #16
  uint32_t n;

  /* [10.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 80047f4:	4b1a      	ldr	r3, [pc, #104]	; (8004860 <rt_test_010_001_execute.lto_priv.801+0x70>)
 80047f6:	2201      	movs	r2, #1
 80047f8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80047fa:	4b1a      	ldr	r3, [pc, #104]	; (8004864 <rt_test_010_001_execute.lto_priv.801+0x74>)
 80047fc:	681c      	ldr	r4, [r3, #0]
 80047fe:	f7ff ff1f 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004802:	4603      	mov	r3, r0
 8004804:	1e5a      	subs	r2, r3, #1
 8004806:	2300      	movs	r3, #0
 8004808:	9300      	str	r3, [sp, #0]
 800480a:	4b17      	ldr	r3, [pc, #92]	; (8004868 <rt_test_010_001_execute.lto_priv.801+0x78>)
 800480c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004810:	4620      	mov	r0, r4
 8004812:	f00b fe65 	bl	80104e0 <chThdCreateStatic>
 8004816:	4602      	mov	r2, r0
 8004818:	4b14      	ldr	r3, [pc, #80]	; (800486c <rt_test_010_001_execute.lto_priv.801+0x7c>)
 800481a:	601a      	str	r2, [r3, #0]
  }

  /* [10.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 800481c:	4b10      	ldr	r3, [pc, #64]	; (8004860 <rt_test_010_001_execute.lto_priv.801+0x70>)
 800481e:	2202      	movs	r2, #2
 8004820:	601a      	str	r2, [r3, #0]
  {
    n = msg_loop_test(threads[0]);
 8004822:	4b12      	ldr	r3, [pc, #72]	; (800486c <rt_test_010_001_execute.lto_priv.801+0x7c>)
 8004824:	681b      	ldr	r3, [r3, #0]
 8004826:	4618      	mov	r0, r3
 8004828:	f7ff ff5a 	bl	80046e0 <msg_loop_test>
 800482c:	9003      	str	r0, [sp, #12]
    test_wait_threads();
 800482e:	f7fc faa7 	bl	8000d80 <test_wait_threads>
  }

  /* [10.1.3] Score is printed.*/
  test_set_step(3);
 8004832:	4b0b      	ldr	r3, [pc, #44]	; (8004860 <rt_test_010_001_execute.lto_priv.801+0x70>)
 8004834:	2203      	movs	r2, #3
 8004836:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 8004838:	480d      	ldr	r0, [pc, #52]	; (8004870 <rt_test_010_001_execute.lto_priv.801+0x80>)
 800483a:	f010 fec9 	bl	80155d0 <test_print>
    test_printn(n);
 800483e:	9803      	ldr	r0, [sp, #12]
 8004840:	f010 fe7e 	bl	8015540 <test_printn>
    test_print(" msgs/S, ");
 8004844:	480b      	ldr	r0, [pc, #44]	; (8004874 <rt_test_010_001_execute.lto_priv.801+0x84>)
 8004846:	f010 fec3 	bl	80155d0 <test_print>
    test_printn(n << 1);
 800484a:	9b03      	ldr	r3, [sp, #12]
 800484c:	005b      	lsls	r3, r3, #1
 800484e:	4618      	mov	r0, r3
 8004850:	f010 fe76 	bl	8015540 <test_printn>
    test_println(" ctxswc/S");
 8004854:	4808      	ldr	r0, [pc, #32]	; (8004878 <rt_test_010_001_execute.lto_priv.801+0x88>)
 8004856:	f010 fedb 	bl	8015610 <test_println>
  }
}
 800485a:	b004      	add	sp, #16
 800485c:	bd10      	pop	{r4, pc}
 800485e:	bf00      	nop
 8004860:	20001988 	.word	0x20001988
 8004864:	08017360 	.word	0x08017360
 8004868:	080046b1 	.word	0x080046b1
 800486c:	20002018 	.word	0x20002018
 8004870:	08018514 	.word	0x08018514
 8004874:	08018524 	.word	0x08018524
 8004878:	08018530 	.word	0x08018530
 800487c:	00000000 	.word	0x00000000

08004880 <rt_test_010_002_execute.lto_priv.802>:
 *   second time window.
 * - [10.2.3] Score is printed.
 * .
 */

static void rt_test_010_002_execute(void) {
 8004880:	b510      	push	{r4, lr}
 8004882:	b084      	sub	sp, #16
  uint32_t n;

  /* [10.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8004884:	4b1a      	ldr	r3, [pc, #104]	; (80048f0 <rt_test_010_002_execute.lto_priv.802+0x70>)
 8004886:	2201      	movs	r2, #1
 8004888:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800488a:	4b1a      	ldr	r3, [pc, #104]	; (80048f4 <rt_test_010_002_execute.lto_priv.802+0x74>)
 800488c:	681c      	ldr	r4, [r3, #0]
 800488e:	f7ff fed7 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004892:	4603      	mov	r3, r0
 8004894:	1c5a      	adds	r2, r3, #1
 8004896:	2300      	movs	r3, #0
 8004898:	9300      	str	r3, [sp, #0]
 800489a:	4b17      	ldr	r3, [pc, #92]	; (80048f8 <rt_test_010_002_execute.lto_priv.802+0x78>)
 800489c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80048a0:	4620      	mov	r0, r4
 80048a2:	f00b fe1d 	bl	80104e0 <chThdCreateStatic>
 80048a6:	4602      	mov	r2, r0
 80048a8:	4b14      	ldr	r3, [pc, #80]	; (80048fc <rt_test_010_002_execute.lto_priv.802+0x7c>)
 80048aa:	601a      	str	r2, [r3, #0]
  }

  /* [10.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 80048ac:	4b10      	ldr	r3, [pc, #64]	; (80048f0 <rt_test_010_002_execute.lto_priv.802+0x70>)
 80048ae:	2202      	movs	r2, #2
 80048b0:	601a      	str	r2, [r3, #0]
  {
    n = msg_loop_test(threads[0]);
 80048b2:	4b12      	ldr	r3, [pc, #72]	; (80048fc <rt_test_010_002_execute.lto_priv.802+0x7c>)
 80048b4:	681b      	ldr	r3, [r3, #0]
 80048b6:	4618      	mov	r0, r3
 80048b8:	f7ff ff12 	bl	80046e0 <msg_loop_test>
 80048bc:	9003      	str	r0, [sp, #12]
    test_wait_threads();
 80048be:	f7fc fa5f 	bl	8000d80 <test_wait_threads>
  }

  /* [10.2.3] Score is printed.*/
  test_set_step(3);
 80048c2:	4b0b      	ldr	r3, [pc, #44]	; (80048f0 <rt_test_010_002_execute.lto_priv.802+0x70>)
 80048c4:	2203      	movs	r2, #3
 80048c6:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 80048c8:	480d      	ldr	r0, [pc, #52]	; (8004900 <rt_test_010_002_execute.lto_priv.802+0x80>)
 80048ca:	f010 fe81 	bl	80155d0 <test_print>
    test_printn(n);
 80048ce:	9803      	ldr	r0, [sp, #12]
 80048d0:	f010 fe36 	bl	8015540 <test_printn>
    test_print(" msgs/S, ");
 80048d4:	480b      	ldr	r0, [pc, #44]	; (8004904 <rt_test_010_002_execute.lto_priv.802+0x84>)
 80048d6:	f010 fe7b 	bl	80155d0 <test_print>
    test_printn(n << 1);
 80048da:	9b03      	ldr	r3, [sp, #12]
 80048dc:	005b      	lsls	r3, r3, #1
 80048de:	4618      	mov	r0, r3
 80048e0:	f010 fe2e 	bl	8015540 <test_printn>
    test_println(" ctxswc/S");
 80048e4:	4808      	ldr	r0, [pc, #32]	; (8004908 <rt_test_010_002_execute.lto_priv.802+0x88>)
 80048e6:	f010 fe93 	bl	8015610 <test_println>
  }
}
 80048ea:	b004      	add	sp, #16
 80048ec:	bd10      	pop	{r4, pc}
 80048ee:	bf00      	nop
 80048f0:	20001988 	.word	0x20001988
 80048f4:	08017360 	.word	0x08017360
 80048f8:	080046b1 	.word	0x080046b1
 80048fc:	20002018 	.word	0x20002018
 8004900:	08018514 	.word	0x08018514
 8004904:	08018524 	.word	0x08018524
 8004908:	08018530 	.word	0x08018530
 800490c:	00000000 	.word	0x00000000

08004910 <rt_test_010_003_execute.lto_priv.803>:
 *   second time window.
 * - [10.3.4] Score is printed.
 * .
 */

static void rt_test_010_003_execute(void) {
 8004910:	b510      	push	{r4, lr}
 8004912:	b084      	sub	sp, #16
  uint32_t n;

  /* [10.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8004914:	4b3d      	ldr	r3, [pc, #244]	; (8004a0c <rt_test_010_003_execute.lto_priv.803+0xfc>)
 8004916:	2201      	movs	r2, #1
 8004918:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800491a:	4b3d      	ldr	r3, [pc, #244]	; (8004a10 <rt_test_010_003_execute.lto_priv.803+0x100>)
 800491c:	681c      	ldr	r4, [r3, #0]
 800491e:	f7ff fe8f 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004922:	4603      	mov	r3, r0
 8004924:	1c5a      	adds	r2, r3, #1
 8004926:	2300      	movs	r3, #0
 8004928:	9300      	str	r3, [sp, #0]
 800492a:	4b3a      	ldr	r3, [pc, #232]	; (8004a14 <rt_test_010_003_execute.lto_priv.803+0x104>)
 800492c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004930:	4620      	mov	r0, r4
 8004932:	f00b fdd5 	bl	80104e0 <chThdCreateStatic>
 8004936:	4602      	mov	r2, r0
 8004938:	4b37      	ldr	r3, [pc, #220]	; (8004a18 <rt_test_010_003_execute.lto_priv.803+0x108>)
 800493a:	601a      	str	r2, [r3, #0]
  }

  /* [10.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 800493c:	4b33      	ldr	r3, [pc, #204]	; (8004a0c <rt_test_010_003_execute.lto_priv.803+0xfc>)
 800493e:	2202      	movs	r2, #2
 8004940:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8004942:	4b33      	ldr	r3, [pc, #204]	; (8004a10 <rt_test_010_003_execute.lto_priv.803+0x100>)
 8004944:	685c      	ldr	r4, [r3, #4]
 8004946:	f7ff fe7b 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 800494a:	4603      	mov	r3, r0
 800494c:	1e9a      	subs	r2, r3, #2
 800494e:	2300      	movs	r3, #0
 8004950:	9300      	str	r3, [sp, #0]
 8004952:	4b32      	ldr	r3, [pc, #200]	; (8004a1c <rt_test_010_003_execute.lto_priv.803+0x10c>)
 8004954:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004958:	4620      	mov	r0, r4
 800495a:	f00b fdc1 	bl	80104e0 <chThdCreateStatic>
 800495e:	4602      	mov	r2, r0
 8004960:	4b2d      	ldr	r3, [pc, #180]	; (8004a18 <rt_test_010_003_execute.lto_priv.803+0x108>)
 8004962:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8004964:	4b2a      	ldr	r3, [pc, #168]	; (8004a10 <rt_test_010_003_execute.lto_priv.803+0x100>)
 8004966:	689c      	ldr	r4, [r3, #8]
 8004968:	f7ff fe6a 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 800496c:	4603      	mov	r3, r0
 800496e:	1eda      	subs	r2, r3, #3
 8004970:	2300      	movs	r3, #0
 8004972:	9300      	str	r3, [sp, #0]
 8004974:	4b29      	ldr	r3, [pc, #164]	; (8004a1c <rt_test_010_003_execute.lto_priv.803+0x10c>)
 8004976:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800497a:	4620      	mov	r0, r4
 800497c:	f00b fdb0 	bl	80104e0 <chThdCreateStatic>
 8004980:	4602      	mov	r2, r0
 8004982:	4b25      	ldr	r3, [pc, #148]	; (8004a18 <rt_test_010_003_execute.lto_priv.803+0x108>)
 8004984:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 8004986:	4b22      	ldr	r3, [pc, #136]	; (8004a10 <rt_test_010_003_execute.lto_priv.803+0x100>)
 8004988:	68dc      	ldr	r4, [r3, #12]
 800498a:	f7ff fe59 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 800498e:	4603      	mov	r3, r0
 8004990:	1f1a      	subs	r2, r3, #4
 8004992:	2300      	movs	r3, #0
 8004994:	9300      	str	r3, [sp, #0]
 8004996:	4b21      	ldr	r3, [pc, #132]	; (8004a1c <rt_test_010_003_execute.lto_priv.803+0x10c>)
 8004998:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800499c:	4620      	mov	r0, r4
 800499e:	f00b fd9f 	bl	80104e0 <chThdCreateStatic>
 80049a2:	4602      	mov	r2, r0
 80049a4:	4b1c      	ldr	r3, [pc, #112]	; (8004a18 <rt_test_010_003_execute.lto_priv.803+0x108>)
 80049a6:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 80049a8:	4b19      	ldr	r3, [pc, #100]	; (8004a10 <rt_test_010_003_execute.lto_priv.803+0x100>)
 80049aa:	691c      	ldr	r4, [r3, #16]
 80049ac:	f7ff fe48 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 80049b0:	4603      	mov	r3, r0
 80049b2:	1f5a      	subs	r2, r3, #5
 80049b4:	2300      	movs	r3, #0
 80049b6:	9300      	str	r3, [sp, #0]
 80049b8:	4b18      	ldr	r3, [pc, #96]	; (8004a1c <rt_test_010_003_execute.lto_priv.803+0x10c>)
 80049ba:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80049be:	4620      	mov	r0, r4
 80049c0:	f00b fd8e 	bl	80104e0 <chThdCreateStatic>
 80049c4:	4602      	mov	r2, r0
 80049c6:	4b14      	ldr	r3, [pc, #80]	; (8004a18 <rt_test_010_003_execute.lto_priv.803+0x108>)
 80049c8:	611a      	str	r2, [r3, #16]
  }

  /* [10.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 80049ca:	4b10      	ldr	r3, [pc, #64]	; (8004a0c <rt_test_010_003_execute.lto_priv.803+0xfc>)
 80049cc:	2203      	movs	r2, #3
 80049ce:	601a      	str	r2, [r3, #0]
  {
    n = msg_loop_test(threads[0]);
 80049d0:	4b11      	ldr	r3, [pc, #68]	; (8004a18 <rt_test_010_003_execute.lto_priv.803+0x108>)
 80049d2:	681b      	ldr	r3, [r3, #0]
 80049d4:	4618      	mov	r0, r3
 80049d6:	f7ff fe83 	bl	80046e0 <msg_loop_test>
 80049da:	9003      	str	r0, [sp, #12]
    test_wait_threads();
 80049dc:	f7fc f9d0 	bl	8000d80 <test_wait_threads>
  }

  /* [10.3.4] Score is printed.*/
  test_set_step(4);
 80049e0:	4b0a      	ldr	r3, [pc, #40]	; (8004a0c <rt_test_010_003_execute.lto_priv.803+0xfc>)
 80049e2:	2204      	movs	r2, #4
 80049e4:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 80049e6:	480e      	ldr	r0, [pc, #56]	; (8004a20 <rt_test_010_003_execute.lto_priv.803+0x110>)
 80049e8:	f010 fdf2 	bl	80155d0 <test_print>
    test_printn(n);
 80049ec:	9803      	ldr	r0, [sp, #12]
 80049ee:	f010 fda7 	bl	8015540 <test_printn>
    test_print(" msgs/S, ");
 80049f2:	480c      	ldr	r0, [pc, #48]	; (8004a24 <rt_test_010_003_execute.lto_priv.803+0x114>)
 80049f4:	f010 fdec 	bl	80155d0 <test_print>
    test_printn(n << 1);
 80049f8:	9b03      	ldr	r3, [sp, #12]
 80049fa:	005b      	lsls	r3, r3, #1
 80049fc:	4618      	mov	r0, r3
 80049fe:	f010 fd9f 	bl	8015540 <test_printn>
    test_println(" ctxswc/S");
 8004a02:	4809      	ldr	r0, [pc, #36]	; (8004a28 <rt_test_010_003_execute.lto_priv.803+0x118>)
 8004a04:	f010 fe04 	bl	8015610 <test_println>
  }
}
 8004a08:	b004      	add	sp, #16
 8004a0a:	bd10      	pop	{r4, pc}
 8004a0c:	20001988 	.word	0x20001988
 8004a10:	08017360 	.word	0x08017360
 8004a14:	080046b1 	.word	0x080046b1
 8004a18:	20002018 	.word	0x20002018
 8004a1c:	08004731 	.word	0x08004731
 8004a20:	08018514 	.word	0x08018514
 8004a24:	08018524 	.word	0x08018524
 8004a28:	08018530 	.word	0x08018530
 8004a2c:	00000000 	.word	0x00000000

08004a30 <rt_test_010_004_execute.lto_priv.804>:
 * - [10.4.3] Stopping the target thread.
 * - [10.4.4] Score is printed.
 * .
 */

static void rt_test_010_004_execute(void) {
 8004a30:	b510      	push	{r4, lr}
 8004a32:	b086      	sub	sp, #24
  thread_t *tp;
  uint32_t n;

  /* [10.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 8004a34:	4b30      	ldr	r3, [pc, #192]	; (8004af8 <rt_test_010_004_execute.lto_priv.804+0xc8>)
 8004a36:	2201      	movs	r2, #1
 8004a38:	601a      	str	r2, [r3, #0]
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8004a3a:	4b30      	ldr	r3, [pc, #192]	; (8004afc <rt_test_010_004_execute.lto_priv.804+0xcc>)
 8004a3c:	681c      	ldr	r4, [r3, #0]
 8004a3e:	f7ff fdff 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004a42:	4603      	mov	r3, r0
 8004a44:	1c5a      	adds	r2, r3, #1
 8004a46:	2300      	movs	r3, #0
 8004a48:	9300      	str	r3, [sp, #0]
 8004a4a:	4b2d      	ldr	r3, [pc, #180]	; (8004b00 <rt_test_010_004_execute.lto_priv.804+0xd0>)
 8004a4c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004a50:	4620      	mov	r0, r4
 8004a52:	f00b fd45 	bl	80104e0 <chThdCreateStatic>
 8004a56:	4602      	mov	r2, r0
 8004a58:	4b2a      	ldr	r3, [pc, #168]	; (8004b04 <rt_test_010_004_execute.lto_priv.804+0xd4>)
 8004a5a:	601a      	str	r2, [r3, #0]
 8004a5c:	4b29      	ldr	r3, [pc, #164]	; (8004b04 <rt_test_010_004_execute.lto_priv.804+0xd4>)
 8004a5e:	681b      	ldr	r3, [r3, #0]
 8004a60:	9304      	str	r3, [sp, #16]
                                        bmk_thread4, NULL);
  }

  /* [10.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 8004a62:	4b25      	ldr	r3, [pc, #148]	; (8004af8 <rt_test_010_004_execute.lto_priv.804+0xc8>)
 8004a64:	2202      	movs	r2, #2
 8004a66:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
 8004a68:	2300      	movs	r3, #0
 8004a6a:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
 8004a6c:	f7fc f9b0 	bl	8000dd0 <test_wait_tick>
 8004a70:	9003      	str	r0, [sp, #12]
    end = chTimeAddX(start, TIME_MS2I(1000));
 8004a72:	f242 7110 	movw	r1, #10000	; 0x2710
 8004a76:	9803      	ldr	r0, [sp, #12]
 8004a78:	f7ff fd4a 	bl	8004510 <chTimeAddX.lto_priv.124>
 8004a7c:	9002      	str	r0, [sp, #8]
    do {
      chSysLock();
 8004a7e:	f7ff fd8f 	bl	80045a0 <chSysLock.lto_priv.81>
      chSchWakeupS(tp, MSG_OK);
 8004a82:	2100      	movs	r1, #0
 8004a84:	9804      	ldr	r0, [sp, #16]
 8004a86:	f00b f9bb 	bl	800fe00 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8004a8a:	2100      	movs	r1, #0
 8004a8c:	9804      	ldr	r0, [sp, #16]
 8004a8e:	f00b f9b7 	bl	800fe00 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8004a92:	2100      	movs	r1, #0
 8004a94:	9804      	ldr	r0, [sp, #16]
 8004a96:	f00b f9b3 	bl	800fe00 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8004a9a:	2100      	movs	r1, #0
 8004a9c:	9804      	ldr	r0, [sp, #16]
 8004a9e:	f00b f9af 	bl	800fe00 <chSchWakeupS>
      chSysUnlock();
 8004aa2:	f7ff fd85 	bl	80045b0 <chSysUnlock.lto_priv.45>
      n += 4;
 8004aa6:	9b05      	ldr	r3, [sp, #20]
 8004aa8:	3304      	adds	r3, #4
 8004aaa:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004aac:	9902      	ldr	r1, [sp, #8]
 8004aae:	9803      	ldr	r0, [sp, #12]
 8004ab0:	f7ff fda6 	bl	8004600 <chVTIsSystemTimeWithinX>
 8004ab4:	4603      	mov	r3, r0
 8004ab6:	2b00      	cmp	r3, #0
 8004ab8:	d1e1      	bne.n	8004a7e <rt_test_010_004_execute.lto_priv.804+0x4e>
  }

  /* [10.4.3] Stopping the target thread.*/
  test_set_step(3);
 8004aba:	4b0f      	ldr	r3, [pc, #60]	; (8004af8 <rt_test_010_004_execute.lto_priv.804+0xc8>)
 8004abc:	2203      	movs	r2, #3
 8004abe:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8004ac0:	f7ff fd6e 	bl	80045a0 <chSysLock.lto_priv.81>
    chSchWakeupS(tp, MSG_TIMEOUT);
 8004ac4:	f04f 31ff 	mov.w	r1, #4294967295
 8004ac8:	9804      	ldr	r0, [sp, #16]
 8004aca:	f00b f999 	bl	800fe00 <chSchWakeupS>
    chSysUnlock();
 8004ace:	f7ff fd6f 	bl	80045b0 <chSysUnlock.lto_priv.45>
    test_wait_threads();
 8004ad2:	f7fc f955 	bl	8000d80 <test_wait_threads>
  }

  /* [10.4.4] Score is printed.*/
  test_set_step(4);
 8004ad6:	4b08      	ldr	r3, [pc, #32]	; (8004af8 <rt_test_010_004_execute.lto_priv.804+0xc8>)
 8004ad8:	2204      	movs	r2, #4
 8004ada:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 8004adc:	480a      	ldr	r0, [pc, #40]	; (8004b08 <rt_test_010_004_execute.lto_priv.804+0xd8>)
 8004ade:	f010 fd77 	bl	80155d0 <test_print>
    test_printn(n * 2);
 8004ae2:	9b05      	ldr	r3, [sp, #20]
 8004ae4:	005b      	lsls	r3, r3, #1
 8004ae6:	4618      	mov	r0, r3
 8004ae8:	f010 fd2a 	bl	8015540 <test_printn>
    test_println(" ctxswc/S");
 8004aec:	4807      	ldr	r0, [pc, #28]	; (8004b0c <rt_test_010_004_execute.lto_priv.804+0xdc>)
 8004aee:	f010 fd8f 	bl	8015610 <test_println>
  }
}
 8004af2:	b006      	add	sp, #24
 8004af4:	bd10      	pop	{r4, pc}
 8004af6:	bf00      	nop
 8004af8:	20001988 	.word	0x20001988
 8004afc:	08017360 	.word	0x08017360
 8004b00:	08004751 	.word	0x08004751
 8004b04:	20002018 	.word	0x20002018
 8004b08:	08018514 	.word	0x08018514
 8004b0c:	08018530 	.word	0x08018530

08004b10 <rt_test_010_005_execute.lto_priv.805>:
 *   repeated continuously in a one-second time window.
 * - [10.5.2] Score is printed.
 * .
 */

static void rt_test_010_005_execute(void) {
 8004b10:	b500      	push	{lr}
 8004b12:	b087      	sub	sp, #28
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 8004b14:	f7ff fd94 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004b18:	4603      	mov	r3, r0
 8004b1a:	3b01      	subs	r3, #1
 8004b1c:	9304      	str	r3, [sp, #16]
  systime_t start, end;

  /* [10.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8004b1e:	4b1a      	ldr	r3, [pc, #104]	; (8004b88 <rt_test_010_005_execute.lto_priv.805+0x78>)
 8004b20:	2201      	movs	r2, #1
 8004b22:	601a      	str	r2, [r3, #0]
  {
    n = 0;
 8004b24:	2300      	movs	r3, #0
 8004b26:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
 8004b28:	f7fc f952 	bl	8000dd0 <test_wait_tick>
 8004b2c:	9003      	str	r0, [sp, #12]
    end = chTimeAddX(start, TIME_MS2I(1000));
 8004b2e:	f242 7110 	movw	r1, #10000	; 0x2710
 8004b32:	9803      	ldr	r0, [sp, #12]
 8004b34:	f7ff fcec 	bl	8004510 <chTimeAddX.lto_priv.124>
 8004b38:	9002      	str	r0, [sp, #8]
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8004b3a:	4b14      	ldr	r3, [pc, #80]	; (8004b8c <rt_test_010_005_execute.lto_priv.805+0x7c>)
 8004b3c:	6818      	ldr	r0, [r3, #0]
 8004b3e:	2300      	movs	r3, #0
 8004b40:	9300      	str	r3, [sp, #0]
 8004b42:	4b13      	ldr	r3, [pc, #76]	; (8004b90 <rt_test_010_005_execute.lto_priv.805+0x80>)
 8004b44:	9a04      	ldr	r2, [sp, #16]
 8004b46:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004b4a:	f00b fcc9 	bl	80104e0 <chThdCreateStatic>
 8004b4e:	4603      	mov	r3, r0
 8004b50:	4618      	mov	r0, r3
 8004b52:	f00b fdcd 	bl	80106f0 <chThdWait>
      n++;
 8004b56:	9b05      	ldr	r3, [sp, #20]
 8004b58:	3301      	adds	r3, #1
 8004b5a:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004b5c:	9902      	ldr	r1, [sp, #8]
 8004b5e:	9803      	ldr	r0, [sp, #12]
 8004b60:	f7ff fd4e 	bl	8004600 <chVTIsSystemTimeWithinX>
 8004b64:	4603      	mov	r3, r0
 8004b66:	2b00      	cmp	r3, #0
 8004b68:	d1e7      	bne.n	8004b3a <rt_test_010_005_execute.lto_priv.805+0x2a>
  }

  /* [10.5.2] Score is printed.*/
  test_set_step(2);
 8004b6a:	4b07      	ldr	r3, [pc, #28]	; (8004b88 <rt_test_010_005_execute.lto_priv.805+0x78>)
 8004b6c:	2202      	movs	r2, #2
 8004b6e:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 8004b70:	4808      	ldr	r0, [pc, #32]	; (8004b94 <rt_test_010_005_execute.lto_priv.805+0x84>)
 8004b72:	f010 fd2d 	bl	80155d0 <test_print>
    test_printn(n);
 8004b76:	9805      	ldr	r0, [sp, #20]
 8004b78:	f010 fce2 	bl	8015540 <test_printn>
    test_println(" threads/S");
 8004b7c:	4806      	ldr	r0, [pc, #24]	; (8004b98 <rt_test_010_005_execute.lto_priv.805+0x88>)
 8004b7e:	f010 fd47 	bl	8015610 <test_println>
  }
}
 8004b82:	b007      	add	sp, #28
 8004b84:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b88:	20001988 	.word	0x20001988
 8004b8c:	08017360 	.word	0x08017360
 8004b90:	08004731 	.word	0x08004731
 8004b94:	08018514 	.word	0x08018514
 8004b98:	0801857c 	.word	0x0801857c
 8004b9c:	00000000 	.word	0x00000000

08004ba0 <rt_test_010_006_execute.lto_priv.806>:
 *   one-second time window.
 * - [10.6.2] Score is printed.
 * .
 */

static void rt_test_010_006_execute(void) {
 8004ba0:	b500      	push	{lr}
 8004ba2:	b087      	sub	sp, #28
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 8004ba4:	f7ff fd4c 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004ba8:	4603      	mov	r3, r0
 8004baa:	3301      	adds	r3, #1
 8004bac:	9304      	str	r3, [sp, #16]
  systime_t start, end;

  /* [10.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8004bae:	4b1a      	ldr	r3, [pc, #104]	; (8004c18 <rt_test_010_006_execute.lto_priv.806+0x78>)
 8004bb0:	2201      	movs	r2, #1
 8004bb2:	601a      	str	r2, [r3, #0]
  {
    n = 0;
 8004bb4:	2300      	movs	r3, #0
 8004bb6:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
 8004bb8:	f7fc f90a 	bl	8000dd0 <test_wait_tick>
 8004bbc:	9003      	str	r0, [sp, #12]
    end = chTimeAddX(start, TIME_MS2I(1000));
 8004bbe:	f242 7110 	movw	r1, #10000	; 0x2710
 8004bc2:	9803      	ldr	r0, [sp, #12]
 8004bc4:	f7ff fca4 	bl	8004510 <chTimeAddX.lto_priv.124>
 8004bc8:	9002      	str	r0, [sp, #8]
    do {
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8004bca:	4b14      	ldr	r3, [pc, #80]	; (8004c1c <rt_test_010_006_execute.lto_priv.806+0x7c>)
 8004bcc:	6818      	ldr	r0, [r3, #0]
 8004bce:	2300      	movs	r3, #0
 8004bd0:	9300      	str	r3, [sp, #0]
 8004bd2:	4b13      	ldr	r3, [pc, #76]	; (8004c20 <rt_test_010_006_execute.lto_priv.806+0x80>)
 8004bd4:	9a04      	ldr	r2, [sp, #16]
 8004bd6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004bda:	f00b fc81 	bl	80104e0 <chThdCreateStatic>
 8004bde:	4603      	mov	r3, r0
 8004be0:	4618      	mov	r0, r3
 8004be2:	f00b fce5 	bl	80105b0 <chThdRelease>
#else
      chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL);
#endif
      n++;
 8004be6:	9b05      	ldr	r3, [sp, #20]
 8004be8:	3301      	adds	r3, #1
 8004bea:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004bec:	9902      	ldr	r1, [sp, #8]
 8004bee:	9803      	ldr	r0, [sp, #12]
 8004bf0:	f7ff fd06 	bl	8004600 <chVTIsSystemTimeWithinX>
 8004bf4:	4603      	mov	r3, r0
 8004bf6:	2b00      	cmp	r3, #0
 8004bf8:	d1e7      	bne.n	8004bca <rt_test_010_006_execute.lto_priv.806+0x2a>
  }

  /* [10.6.2] Score is printed.*/
  test_set_step(2);
 8004bfa:	4b07      	ldr	r3, [pc, #28]	; (8004c18 <rt_test_010_006_execute.lto_priv.806+0x78>)
 8004bfc:	2202      	movs	r2, #2
 8004bfe:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 8004c00:	4808      	ldr	r0, [pc, #32]	; (8004c24 <rt_test_010_006_execute.lto_priv.806+0x84>)
 8004c02:	f010 fce5 	bl	80155d0 <test_print>
    test_printn(n);
 8004c06:	9805      	ldr	r0, [sp, #20]
 8004c08:	f010 fc9a 	bl	8015540 <test_printn>
    test_println(" threads/S");
 8004c0c:	4806      	ldr	r0, [pc, #24]	; (8004c28 <rt_test_010_006_execute.lto_priv.806+0x88>)
 8004c0e:	f010 fcff 	bl	8015610 <test_println>
  }
}
 8004c12:	b007      	add	sp, #28
 8004c14:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c18:	20001988 	.word	0x20001988
 8004c1c:	08017360 	.word	0x08017360
 8004c20:	08004731 	.word	0x08004731
 8004c24:	08018514 	.word	0x08018514
 8004c28:	0801857c 	.word	0x0801857c
 8004c2c:	00000000 	.word	0x00000000

08004c30 <rt_test_010_007_setup.lto_priv.807>:
 * - [10.7.3] The five threads are terminated.
 * - [10.7.4] The score is printed.
 * .
 */

static void rt_test_010_007_setup(void) {
 8004c30:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 8004c32:	2100      	movs	r1, #0
 8004c34:	4801      	ldr	r0, [pc, #4]	; (8004c3c <rt_test_010_007_setup.lto_priv.807+0xc>)
 8004c36:	f00c f8f3 	bl	8010e20 <chSemObjectInit>
}
 8004c3a:	bd08      	pop	{r3, pc}
 8004c3c:	20002068 	.word	0x20002068

08004c40 <rt_test_010_007_execute.lto_priv.808>:

static void rt_test_010_007_execute(void) {
 8004c40:	b510      	push	{r4, lr}
 8004c42:	b086      	sub	sp, #24
  uint32_t n;

  /* [10.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 8004c44:	4b4b      	ldr	r3, [pc, #300]	; (8004d74 <rt_test_010_007_execute.lto_priv.808+0x134>)
 8004c46:	2201      	movs	r2, #1
 8004c48:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8004c4a:	4b4b      	ldr	r3, [pc, #300]	; (8004d78 <rt_test_010_007_execute.lto_priv.808+0x138>)
 8004c4c:	681c      	ldr	r4, [r3, #0]
 8004c4e:	f7ff fcf7 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004c52:	4603      	mov	r3, r0
 8004c54:	1d5a      	adds	r2, r3, #5
 8004c56:	2300      	movs	r3, #0
 8004c58:	9300      	str	r3, [sp, #0]
 8004c5a:	4b48      	ldr	r3, [pc, #288]	; (8004d7c <rt_test_010_007_execute.lto_priv.808+0x13c>)
 8004c5c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004c60:	4620      	mov	r0, r4
 8004c62:	f00b fc3d 	bl	80104e0 <chThdCreateStatic>
 8004c66:	4602      	mov	r2, r0
 8004c68:	4b45      	ldr	r3, [pc, #276]	; (8004d80 <rt_test_010_007_execute.lto_priv.808+0x140>)
 8004c6a:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 8004c6c:	4b42      	ldr	r3, [pc, #264]	; (8004d78 <rt_test_010_007_execute.lto_priv.808+0x138>)
 8004c6e:	685c      	ldr	r4, [r3, #4]
 8004c70:	f7ff fce6 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004c74:	4603      	mov	r3, r0
 8004c76:	1d1a      	adds	r2, r3, #4
 8004c78:	2300      	movs	r3, #0
 8004c7a:	9300      	str	r3, [sp, #0]
 8004c7c:	4b3f      	ldr	r3, [pc, #252]	; (8004d7c <rt_test_010_007_execute.lto_priv.808+0x13c>)
 8004c7e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004c82:	4620      	mov	r0, r4
 8004c84:	f00b fc2c 	bl	80104e0 <chThdCreateStatic>
 8004c88:	4602      	mov	r2, r0
 8004c8a:	4b3d      	ldr	r3, [pc, #244]	; (8004d80 <rt_test_010_007_execute.lto_priv.808+0x140>)
 8004c8c:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 8004c8e:	4b3a      	ldr	r3, [pc, #232]	; (8004d78 <rt_test_010_007_execute.lto_priv.808+0x138>)
 8004c90:	689c      	ldr	r4, [r3, #8]
 8004c92:	f7ff fcd5 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004c96:	4603      	mov	r3, r0
 8004c98:	1cda      	adds	r2, r3, #3
 8004c9a:	2300      	movs	r3, #0
 8004c9c:	9300      	str	r3, [sp, #0]
 8004c9e:	4b37      	ldr	r3, [pc, #220]	; (8004d7c <rt_test_010_007_execute.lto_priv.808+0x13c>)
 8004ca0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004ca4:	4620      	mov	r0, r4
 8004ca6:	f00b fc1b 	bl	80104e0 <chThdCreateStatic>
 8004caa:	4602      	mov	r2, r0
 8004cac:	4b34      	ldr	r3, [pc, #208]	; (8004d80 <rt_test_010_007_execute.lto_priv.808+0x140>)
 8004cae:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 8004cb0:	4b31      	ldr	r3, [pc, #196]	; (8004d78 <rt_test_010_007_execute.lto_priv.808+0x138>)
 8004cb2:	68dc      	ldr	r4, [r3, #12]
 8004cb4:	f7ff fcc4 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004cb8:	4603      	mov	r3, r0
 8004cba:	1c9a      	adds	r2, r3, #2
 8004cbc:	2300      	movs	r3, #0
 8004cbe:	9300      	str	r3, [sp, #0]
 8004cc0:	4b2e      	ldr	r3, [pc, #184]	; (8004d7c <rt_test_010_007_execute.lto_priv.808+0x13c>)
 8004cc2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004cc6:	4620      	mov	r0, r4
 8004cc8:	f00b fc0a 	bl	80104e0 <chThdCreateStatic>
 8004ccc:	4602      	mov	r2, r0
 8004cce:	4b2c      	ldr	r3, [pc, #176]	; (8004d80 <rt_test_010_007_execute.lto_priv.808+0x140>)
 8004cd0:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 8004cd2:	4b29      	ldr	r3, [pc, #164]	; (8004d78 <rt_test_010_007_execute.lto_priv.808+0x138>)
 8004cd4:	691c      	ldr	r4, [r3, #16]
 8004cd6:	f7ff fcb3 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004cda:	4603      	mov	r3, r0
 8004cdc:	1c5a      	adds	r2, r3, #1
 8004cde:	2300      	movs	r3, #0
 8004ce0:	9300      	str	r3, [sp, #0]
 8004ce2:	4b26      	ldr	r3, [pc, #152]	; (8004d7c <rt_test_010_007_execute.lto_priv.808+0x13c>)
 8004ce4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004ce8:	4620      	mov	r0, r4
 8004cea:	f00b fbf9 	bl	80104e0 <chThdCreateStatic>
 8004cee:	4602      	mov	r2, r0
 8004cf0:	4b23      	ldr	r3, [pc, #140]	; (8004d80 <rt_test_010_007_execute.lto_priv.808+0x140>)
 8004cf2:	611a      	str	r2, [r3, #16]
  }

  /* [10.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 8004cf4:	4b1f      	ldr	r3, [pc, #124]	; (8004d74 <rt_test_010_007_execute.lto_priv.808+0x134>)
 8004cf6:	2202      	movs	r2, #2
 8004cf8:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
 8004cfa:	2300      	movs	r3, #0
 8004cfc:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
 8004cfe:	f7fc f867 	bl	8000dd0 <test_wait_tick>
 8004d02:	9004      	str	r0, [sp, #16]
    end = chTimeAddX(start, TIME_MS2I(1000));
 8004d04:	f242 7110 	movw	r1, #10000	; 0x2710
 8004d08:	9804      	ldr	r0, [sp, #16]
 8004d0a:	f7ff fc01 	bl	8004510 <chTimeAddX.lto_priv.124>
 8004d0e:	9003      	str	r0, [sp, #12]
    do {
      chSemReset(&sem1, 0);
 8004d10:	2100      	movs	r1, #0
 8004d12:	481c      	ldr	r0, [pc, #112]	; (8004d84 <rt_test_010_007_execute.lto_priv.808+0x144>)
 8004d14:	f00c f8a4 	bl	8010e60 <chSemReset>
      n++;
 8004d18:	9b05      	ldr	r3, [sp, #20]
 8004d1a:	3301      	adds	r3, #1
 8004d1c:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004d1e:	9903      	ldr	r1, [sp, #12]
 8004d20:	9804      	ldr	r0, [sp, #16]
 8004d22:	f7ff fc6d 	bl	8004600 <chVTIsSystemTimeWithinX>
 8004d26:	4603      	mov	r3, r0
 8004d28:	2b00      	cmp	r3, #0
 8004d2a:	d1f1      	bne.n	8004d10 <rt_test_010_007_execute.lto_priv.808+0xd0>
  }

  /* [10.7.3] The five threads are terminated.*/
  test_set_step(3);
 8004d2c:	4b11      	ldr	r3, [pc, #68]	; (8004d74 <rt_test_010_007_execute.lto_priv.808+0x134>)
 8004d2e:	2203      	movs	r2, #3
 8004d30:	601a      	str	r2, [r3, #0]
  {
    test_terminate_threads();
 8004d32:	f7fc f805 	bl	8000d40 <test_terminate_threads>
    chSemReset(&sem1, 0);
 8004d36:	2100      	movs	r1, #0
 8004d38:	4812      	ldr	r0, [pc, #72]	; (8004d84 <rt_test_010_007_execute.lto_priv.808+0x144>)
 8004d3a:	f00c f891 	bl	8010e60 <chSemReset>
    test_wait_threads();
 8004d3e:	f7fc f81f 	bl	8000d80 <test_wait_threads>
  }

  /* [10.7.4] The score is printed.*/
  test_set_step(4);
 8004d42:	4b0c      	ldr	r3, [pc, #48]	; (8004d74 <rt_test_010_007_execute.lto_priv.808+0x134>)
 8004d44:	2204      	movs	r2, #4
 8004d46:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 8004d48:	480f      	ldr	r0, [pc, #60]	; (8004d88 <rt_test_010_007_execute.lto_priv.808+0x148>)
 8004d4a:	f010 fc41 	bl	80155d0 <test_print>
    test_printn(n);
 8004d4e:	9805      	ldr	r0, [sp, #20]
 8004d50:	f010 fbf6 	bl	8015540 <test_printn>
    test_print(" reschedules/S, ");
 8004d54:	480d      	ldr	r0, [pc, #52]	; (8004d8c <rt_test_010_007_execute.lto_priv.808+0x14c>)
 8004d56:	f010 fc3b 	bl	80155d0 <test_print>
    test_printn(n * 6);
 8004d5a:	9a05      	ldr	r2, [sp, #20]
 8004d5c:	4613      	mov	r3, r2
 8004d5e:	005b      	lsls	r3, r3, #1
 8004d60:	4413      	add	r3, r2
 8004d62:	005b      	lsls	r3, r3, #1
 8004d64:	4618      	mov	r0, r3
 8004d66:	f010 fbeb 	bl	8015540 <test_printn>
    test_println(" ctxswc/S");
 8004d6a:	4809      	ldr	r0, [pc, #36]	; (8004d90 <rt_test_010_007_execute.lto_priv.808+0x150>)
 8004d6c:	f010 fc50 	bl	8015610 <test_println>
  }
}
 8004d70:	b006      	add	sp, #24
 8004d72:	bd10      	pop	{r4, pc}
 8004d74:	20001988 	.word	0x20001988
 8004d78:	08017360 	.word	0x08017360
 8004d7c:	08004781 	.word	0x08004781
 8004d80:	20002018 	.word	0x20002018
 8004d84:	20002068 	.word	0x20002068
 8004d88:	08018514 	.word	0x08018514
 8004d8c:	080185a8 	.word	0x080185a8
 8004d90:	08018530 	.word	0x08018530
	...

08004da0 <rt_test_010_008_execute.lto_priv.809>:
 * - [10.8.2] Waiting one second then terminating the 5 threads.
 * - [10.8.3] The score is printed.
 * .
 */

static void rt_test_010_008_execute(void) {
 8004da0:	b510      	push	{r4, lr}
 8004da2:	b084      	sub	sp, #16
  uint32_t n;

  /* [10.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 8004da4:	4b3a      	ldr	r3, [pc, #232]	; (8004e90 <rt_test_010_008_execute.lto_priv.809+0xf0>)
 8004da6:	2201      	movs	r2, #1
 8004da8:	601a      	str	r2, [r3, #0]
  {
    n = 0;
 8004daa:	2300      	movs	r3, #0
 8004dac:	9303      	str	r3, [sp, #12]
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004dae:	f7fc f80f 	bl	8000dd0 <test_wait_tick>
 8004db2:	4b38      	ldr	r3, [pc, #224]	; (8004e94 <rt_test_010_008_execute.lto_priv.809+0xf4>)
 8004db4:	681c      	ldr	r4, [r3, #0]
 8004db6:	f7ff fc43 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004dba:	4603      	mov	r3, r0
 8004dbc:	1e5a      	subs	r2, r3, #1
 8004dbe:	ab03      	add	r3, sp, #12
 8004dc0:	9300      	str	r3, [sp, #0]
 8004dc2:	4b35      	ldr	r3, [pc, #212]	; (8004e98 <rt_test_010_008_execute.lto_priv.809+0xf8>)
 8004dc4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004dc8:	4620      	mov	r0, r4
 8004dca:	f00b fb89 	bl	80104e0 <chThdCreateStatic>
 8004dce:	4602      	mov	r2, r0
 8004dd0:	4b32      	ldr	r3, [pc, #200]	; (8004e9c <rt_test_010_008_execute.lto_priv.809+0xfc>)
 8004dd2:	601a      	str	r2, [r3, #0]

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004dd4:	4b2f      	ldr	r3, [pc, #188]	; (8004e94 <rt_test_010_008_execute.lto_priv.809+0xf4>)
 8004dd6:	685c      	ldr	r4, [r3, #4]
 8004dd8:	f7ff fc32 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004ddc:	4603      	mov	r3, r0
 8004dde:	1e5a      	subs	r2, r3, #1
 8004de0:	ab03      	add	r3, sp, #12
 8004de2:	9300      	str	r3, [sp, #0]
 8004de4:	4b2c      	ldr	r3, [pc, #176]	; (8004e98 <rt_test_010_008_execute.lto_priv.809+0xf8>)
 8004de6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004dea:	4620      	mov	r0, r4
 8004dec:	f00b fb78 	bl	80104e0 <chThdCreateStatic>
 8004df0:	4602      	mov	r2, r0
 8004df2:	4b2a      	ldr	r3, [pc, #168]	; (8004e9c <rt_test_010_008_execute.lto_priv.809+0xfc>)
 8004df4:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004df6:	4b27      	ldr	r3, [pc, #156]	; (8004e94 <rt_test_010_008_execute.lto_priv.809+0xf4>)
 8004df8:	689c      	ldr	r4, [r3, #8]
 8004dfa:	f7ff fc21 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004dfe:	4603      	mov	r3, r0
 8004e00:	1e5a      	subs	r2, r3, #1
 8004e02:	ab03      	add	r3, sp, #12
 8004e04:	9300      	str	r3, [sp, #0]
 8004e06:	4b24      	ldr	r3, [pc, #144]	; (8004e98 <rt_test_010_008_execute.lto_priv.809+0xf8>)
 8004e08:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004e0c:	4620      	mov	r0, r4
 8004e0e:	f00b fb67 	bl	80104e0 <chThdCreateStatic>
 8004e12:	4602      	mov	r2, r0
 8004e14:	4b21      	ldr	r3, [pc, #132]	; (8004e9c <rt_test_010_008_execute.lto_priv.809+0xfc>)
 8004e16:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004e18:	4b1e      	ldr	r3, [pc, #120]	; (8004e94 <rt_test_010_008_execute.lto_priv.809+0xf4>)
 8004e1a:	68dc      	ldr	r4, [r3, #12]
 8004e1c:	f7ff fc10 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004e20:	4603      	mov	r3, r0
 8004e22:	1e5a      	subs	r2, r3, #1
 8004e24:	ab03      	add	r3, sp, #12
 8004e26:	9300      	str	r3, [sp, #0]
 8004e28:	4b1b      	ldr	r3, [pc, #108]	; (8004e98 <rt_test_010_008_execute.lto_priv.809+0xf8>)
 8004e2a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004e2e:	4620      	mov	r0, r4
 8004e30:	f00b fb56 	bl	80104e0 <chThdCreateStatic>
 8004e34:	4602      	mov	r2, r0
 8004e36:	4b19      	ldr	r3, [pc, #100]	; (8004e9c <rt_test_010_008_execute.lto_priv.809+0xfc>)
 8004e38:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004e3a:	4b16      	ldr	r3, [pc, #88]	; (8004e94 <rt_test_010_008_execute.lto_priv.809+0xf4>)
 8004e3c:	691c      	ldr	r4, [r3, #16]
 8004e3e:	f7ff fbff 	bl	8004640 <chThdGetPriorityX.lto_priv.96>
 8004e42:	4603      	mov	r3, r0
 8004e44:	1e5a      	subs	r2, r3, #1
 8004e46:	ab03      	add	r3, sp, #12
 8004e48:	9300      	str	r3, [sp, #0]
 8004e4a:	4b13      	ldr	r3, [pc, #76]	; (8004e98 <rt_test_010_008_execute.lto_priv.809+0xf8>)
 8004e4c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004e50:	4620      	mov	r0, r4
 8004e52:	f00b fb45 	bl	80104e0 <chThdCreateStatic>
 8004e56:	4602      	mov	r2, r0
 8004e58:	4b10      	ldr	r3, [pc, #64]	; (8004e9c <rt_test_010_008_execute.lto_priv.809+0xfc>)
 8004e5a:	611a      	str	r2, [r3, #16]
  }

  /* [10.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 8004e5c:	4b0c      	ldr	r3, [pc, #48]	; (8004e90 <rt_test_010_008_execute.lto_priv.809+0xf0>)
 8004e5e:	2202      	movs	r2, #2
 8004e60:	601a      	str	r2, [r3, #0]
  {
    chThdSleepSeconds(1);
 8004e62:	f242 7010 	movw	r0, #10000	; 0x2710
 8004e66:	f00b fcd3 	bl	8010810 <chThdSleep>
    test_terminate_threads();
 8004e6a:	f7fb ff69 	bl	8000d40 <test_terminate_threads>
    test_wait_threads();
 8004e6e:	f7fb ff87 	bl	8000d80 <test_wait_threads>
  }

  /* [10.8.3] The score is printed.*/
  test_set_step(3);
 8004e72:	4b07      	ldr	r3, [pc, #28]	; (8004e90 <rt_test_010_008_execute.lto_priv.809+0xf0>)
 8004e74:	2203      	movs	r2, #3
 8004e76:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 8004e78:	4809      	ldr	r0, [pc, #36]	; (8004ea0 <rt_test_010_008_execute.lto_priv.809+0x100>)
 8004e7a:	f010 fba9 	bl	80155d0 <test_print>
    test_printn(n);
 8004e7e:	9b03      	ldr	r3, [sp, #12]
 8004e80:	4618      	mov	r0, r3
 8004e82:	f010 fb5d 	bl	8015540 <test_printn>
    test_println(" ctxswc/S");
 8004e86:	4807      	ldr	r0, [pc, #28]	; (8004ea4 <rt_test_010_008_execute.lto_priv.809+0x104>)
 8004e88:	f010 fbc2 	bl	8015610 <test_println>
  }
}
 8004e8c:	b004      	add	sp, #16
 8004e8e:	bd10      	pop	{r4, pc}
 8004e90:	20001988 	.word	0x20001988
 8004e94:	08017360 	.word	0x08017360
 8004e98:	080047b1 	.word	0x080047b1
 8004e9c:	20002018 	.word	0x20002018
 8004ea0:	08018514 	.word	0x08018514
 8004ea4:	08018530 	.word	0x08018530
	...

08004eb0 <rt_test_010_009_execute.lto_priv.810>:
 *   one-second time window.
 * - [10.9.2] The score is printed.
 * .
 */

static void rt_test_010_009_execute(void) {
 8004eb0:	b500      	push	{lr}
 8004eb2:	b085      	sub	sp, #20
  uint32_t n;

  /* [10.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8004eb4:	4b1f      	ldr	r3, [pc, #124]	; (8004f34 <rt_test_010_009_execute.lto_priv.810+0x84>)
 8004eb6:	2201      	movs	r2, #1
 8004eb8:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
 8004eba:	2300      	movs	r3, #0
 8004ebc:	9303      	str	r3, [sp, #12]
    start = test_wait_tick();
 8004ebe:	f7fb ff87 	bl	8000dd0 <test_wait_tick>
 8004ec2:	9002      	str	r0, [sp, #8]
    end = chTimeAddX(start, TIME_MS2I(1000));
 8004ec4:	f242 7110 	movw	r1, #10000	; 0x2710
 8004ec8:	9802      	ldr	r0, [sp, #8]
 8004eca:	f7ff fb21 	bl	8004510 <chTimeAddX.lto_priv.124>
 8004ece:	9001      	str	r0, [sp, #4]
    do {
      chSysLock();
 8004ed0:	f7ff fb66 	bl	80045a0 <chSysLock.lto_priv.81>
      chVTDoSetI(&vt1, 1, tmo, NULL);
 8004ed4:	2300      	movs	r3, #0
 8004ed6:	4a18      	ldr	r2, [pc, #96]	; (8004f38 <rt_test_010_009_execute.lto_priv.810+0x88>)
 8004ed8:	2101      	movs	r1, #1
 8004eda:	4818      	ldr	r0, [pc, #96]	; (8004f3c <rt_test_010_009_execute.lto_priv.810+0x8c>)
 8004edc:	f00a fc70 	bl	800f7c0 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 8004ee0:	2300      	movs	r3, #0
 8004ee2:	4a15      	ldr	r2, [pc, #84]	; (8004f38 <rt_test_010_009_execute.lto_priv.810+0x88>)
 8004ee4:	f242 7110 	movw	r1, #10000	; 0x2710
 8004ee8:	4815      	ldr	r0, [pc, #84]	; (8004f40 <rt_test_010_009_execute.lto_priv.810+0x90>)
 8004eea:	f00a fc69 	bl	800f7c0 <chVTDoSetI>
      chVTDoResetI(&vt1);
 8004eee:	4813      	ldr	r0, [pc, #76]	; (8004f3c <rt_test_010_009_execute.lto_priv.810+0x8c>)
 8004ef0:	f00a fd16 	bl	800f920 <chVTDoResetI>
      chVTDoResetI(&vt2);
 8004ef4:	4812      	ldr	r0, [pc, #72]	; (8004f40 <rt_test_010_009_execute.lto_priv.810+0x90>)
 8004ef6:	f00a fd13 	bl	800f920 <chVTDoResetI>
      chSysUnlock();
 8004efa:	f7ff fb59 	bl	80045b0 <chSysUnlock.lto_priv.45>
      n++;
 8004efe:	9b03      	ldr	r3, [sp, #12]
 8004f00:	3301      	adds	r3, #1
 8004f02:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004f04:	9901      	ldr	r1, [sp, #4]
 8004f06:	9802      	ldr	r0, [sp, #8]
 8004f08:	f7ff fb7a 	bl	8004600 <chVTIsSystemTimeWithinX>
 8004f0c:	4603      	mov	r3, r0
 8004f0e:	2b00      	cmp	r3, #0
 8004f10:	d1de      	bne.n	8004ed0 <rt_test_010_009_execute.lto_priv.810+0x20>
  }

  /* [10.9.2] The score is printed.*/
  test_set_step(2);
 8004f12:	4b08      	ldr	r3, [pc, #32]	; (8004f34 <rt_test_010_009_execute.lto_priv.810+0x84>)
 8004f14:	2202      	movs	r2, #2
 8004f16:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 8004f18:	480a      	ldr	r0, [pc, #40]	; (8004f44 <rt_test_010_009_execute.lto_priv.810+0x94>)
 8004f1a:	f010 fb59 	bl	80155d0 <test_print>
    test_printn(n * 2);
 8004f1e:	9b03      	ldr	r3, [sp, #12]
 8004f20:	005b      	lsls	r3, r3, #1
 8004f22:	4618      	mov	r0, r3
 8004f24:	f010 fb0c 	bl	8015540 <test_printn>
    test_println(" timers/S");
 8004f28:	4807      	ldr	r0, [pc, #28]	; (8004f48 <rt_test_010_009_execute.lto_priv.810+0x98>)
 8004f2a:	f010 fb71 	bl	8015610 <test_println>
  }
}
 8004f2e:	b005      	add	sp, #20
 8004f30:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f34:	20001988 	.word	0x20001988
 8004f38:	080046a1 	.word	0x080046a1
 8004f3c:	20002084 	.word	0x20002084
 8004f40:	20002098 	.word	0x20002098
 8004f44:	08018514 	.word	0x08018514
 8004f48:	080185dc 	.word	0x080185dc
 8004f4c:	00000000 	.word	0x00000000

08004f50 <rt_test_010_010_setup.lto_priv.811>:
 *   repeated continuously in a one-second time window.
 * - [10.10.2] The score is printed.
 * .
 */

static void rt_test_010_010_setup(void) {
 8004f50:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 1);
 8004f52:	2101      	movs	r1, #1
 8004f54:	4801      	ldr	r0, [pc, #4]	; (8004f5c <rt_test_010_010_setup.lto_priv.811+0xc>)
 8004f56:	f00b ff63 	bl	8010e20 <chSemObjectInit>
}
 8004f5a:	bd08      	pop	{r3, pc}
 8004f5c:	20002068 	.word	0x20002068

08004f60 <rt_test_010_010_execute.lto_priv.812>:

static void rt_test_010_010_execute(void) {
 8004f60:	b500      	push	{lr}
 8004f62:	b085      	sub	sp, #20
  uint32_t n;

  /* [10.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8004f64:	4b20      	ldr	r3, [pc, #128]	; (8004fe8 <rt_test_010_010_execute.lto_priv.812+0x88>)
 8004f66:	2201      	movs	r2, #1
 8004f68:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
 8004f6a:	2300      	movs	r3, #0
 8004f6c:	9303      	str	r3, [sp, #12]
    start = test_wait_tick();
 8004f6e:	f7fb ff2f 	bl	8000dd0 <test_wait_tick>
 8004f72:	9002      	str	r0, [sp, #8]
    end = chTimeAddX(start, TIME_MS2I(1000));
 8004f74:	f242 7110 	movw	r1, #10000	; 0x2710
 8004f78:	9802      	ldr	r0, [sp, #8]
 8004f7a:	f7ff fac9 	bl	8004510 <chTimeAddX.lto_priv.124>
 8004f7e:	9001      	str	r0, [sp, #4]
    do {
      chSemWait(&sem1);
 8004f80:	481a      	ldr	r0, [pc, #104]	; (8004fec <rt_test_010_010_execute.lto_priv.812+0x8c>)
 8004f82:	f00b ffd5 	bl	8010f30 <chSemWait>
      chSemSignal(&sem1);
 8004f86:	4819      	ldr	r0, [pc, #100]	; (8004fec <rt_test_010_010_execute.lto_priv.812+0x8c>)
 8004f88:	f00c f8aa 	bl	80110e0 <chSemSignal>
      chSemWait(&sem1);
 8004f8c:	4817      	ldr	r0, [pc, #92]	; (8004fec <rt_test_010_010_execute.lto_priv.812+0x8c>)
 8004f8e:	f00b ffcf 	bl	8010f30 <chSemWait>
      chSemSignal(&sem1);
 8004f92:	4816      	ldr	r0, [pc, #88]	; (8004fec <rt_test_010_010_execute.lto_priv.812+0x8c>)
 8004f94:	f00c f8a4 	bl	80110e0 <chSemSignal>
      chSemWait(&sem1);
 8004f98:	4814      	ldr	r0, [pc, #80]	; (8004fec <rt_test_010_010_execute.lto_priv.812+0x8c>)
 8004f9a:	f00b ffc9 	bl	8010f30 <chSemWait>
      chSemSignal(&sem1);
 8004f9e:	4813      	ldr	r0, [pc, #76]	; (8004fec <rt_test_010_010_execute.lto_priv.812+0x8c>)
 8004fa0:	f00c f89e 	bl	80110e0 <chSemSignal>
      chSemWait(&sem1);
 8004fa4:	4811      	ldr	r0, [pc, #68]	; (8004fec <rt_test_010_010_execute.lto_priv.812+0x8c>)
 8004fa6:	f00b ffc3 	bl	8010f30 <chSemWait>
      chSemSignal(&sem1);
 8004faa:	4810      	ldr	r0, [pc, #64]	; (8004fec <rt_test_010_010_execute.lto_priv.812+0x8c>)
 8004fac:	f00c f898 	bl	80110e0 <chSemSignal>
      n++;
 8004fb0:	9b03      	ldr	r3, [sp, #12]
 8004fb2:	3301      	adds	r3, #1
 8004fb4:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004fb6:	9901      	ldr	r1, [sp, #4]
 8004fb8:	9802      	ldr	r0, [sp, #8]
 8004fba:	f7ff fb21 	bl	8004600 <chVTIsSystemTimeWithinX>
 8004fbe:	4603      	mov	r3, r0
 8004fc0:	2b00      	cmp	r3, #0
 8004fc2:	d1dd      	bne.n	8004f80 <rt_test_010_010_execute.lto_priv.812+0x20>
  }

  /* [10.10.2] The score is printed.*/
  test_set_step(2);
 8004fc4:	4b08      	ldr	r3, [pc, #32]	; (8004fe8 <rt_test_010_010_execute.lto_priv.812+0x88>)
 8004fc6:	2202      	movs	r2, #2
 8004fc8:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 8004fca:	4809      	ldr	r0, [pc, #36]	; (8004ff0 <rt_test_010_010_execute.lto_priv.812+0x90>)
 8004fcc:	f010 fb00 	bl	80155d0 <test_print>
    test_printn(n * 4);
 8004fd0:	9b03      	ldr	r3, [sp, #12]
 8004fd2:	009b      	lsls	r3, r3, #2
 8004fd4:	4618      	mov	r0, r3
 8004fd6:	f010 fab3 	bl	8015540 <test_printn>
    test_println(" wait+signal/S");
 8004fda:	4806      	ldr	r0, [pc, #24]	; (8004ff4 <rt_test_010_010_execute.lto_priv.812+0x94>)
 8004fdc:	f010 fb18 	bl	8015610 <test_println>
  }
}
 8004fe0:	b005      	add	sp, #20
 8004fe2:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fe6:	bf00      	nop
 8004fe8:	20001988 	.word	0x20001988
 8004fec:	20002068 	.word	0x20002068
 8004ff0:	08018514 	.word	0x08018514
 8004ff4:	080185f8 	.word	0x080185f8
	...

08005000 <rt_test_010_011_setup.lto_priv.813>:
 *   repeated continuously in a one-second time window.
 * - [10.11.2] The score is printed.
 * .
 */

static void rt_test_010_011_setup(void) {
 8005000:	b508      	push	{r3, lr}
  chMtxObjectInit(&mtx1);
 8005002:	4802      	ldr	r0, [pc, #8]	; (800500c <rt_test_010_011_setup.lto_priv.813+0xc>)
 8005004:	f00c fa94 	bl	8011530 <chMtxObjectInit>
}
 8005008:	bd08      	pop	{r3, pc}
 800500a:	bf00      	nop
 800500c:	20002074 	.word	0x20002074

08005010 <rt_test_010_011_execute.lto_priv.814>:

static void rt_test_010_011_execute(void) {
 8005010:	b500      	push	{lr}
 8005012:	b085      	sub	sp, #20
  uint32_t n;

  /* [10.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8005014:	4b20      	ldr	r3, [pc, #128]	; (8005098 <rt_test_010_011_execute.lto_priv.814+0x88>)
 8005016:	2201      	movs	r2, #1
 8005018:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
 800501a:	2300      	movs	r3, #0
 800501c:	9303      	str	r3, [sp, #12]
    start = test_wait_tick();
 800501e:	f7fb fed7 	bl	8000dd0 <test_wait_tick>
 8005022:	9002      	str	r0, [sp, #8]
    end = chTimeAddX(start, TIME_MS2I(1000));
 8005024:	f242 7110 	movw	r1, #10000	; 0x2710
 8005028:	9802      	ldr	r0, [sp, #8]
 800502a:	f7ff fa71 	bl	8004510 <chTimeAddX.lto_priv.124>
 800502e:	9001      	str	r0, [sp, #4]
    do {
      chMtxLock(&mtx1);
 8005030:	481a      	ldr	r0, [pc, #104]	; (800509c <rt_test_010_011_execute.lto_priv.814+0x8c>)
 8005032:	f00c fa95 	bl	8011560 <chMtxLock>
      chMtxUnlock(&mtx1);
 8005036:	4819      	ldr	r0, [pc, #100]	; (800509c <rt_test_010_011_execute.lto_priv.814+0x8c>)
 8005038:	f00c fb62 	bl	8011700 <chMtxUnlock>
      chMtxLock(&mtx1);
 800503c:	4817      	ldr	r0, [pc, #92]	; (800509c <rt_test_010_011_execute.lto_priv.814+0x8c>)
 800503e:	f00c fa8f 	bl	8011560 <chMtxLock>
      chMtxUnlock(&mtx1);
 8005042:	4816      	ldr	r0, [pc, #88]	; (800509c <rt_test_010_011_execute.lto_priv.814+0x8c>)
 8005044:	f00c fb5c 	bl	8011700 <chMtxUnlock>
      chMtxLock(&mtx1);
 8005048:	4814      	ldr	r0, [pc, #80]	; (800509c <rt_test_010_011_execute.lto_priv.814+0x8c>)
 800504a:	f00c fa89 	bl	8011560 <chMtxLock>
      chMtxUnlock(&mtx1);
 800504e:	4813      	ldr	r0, [pc, #76]	; (800509c <rt_test_010_011_execute.lto_priv.814+0x8c>)
 8005050:	f00c fb56 	bl	8011700 <chMtxUnlock>
      chMtxLock(&mtx1);
 8005054:	4811      	ldr	r0, [pc, #68]	; (800509c <rt_test_010_011_execute.lto_priv.814+0x8c>)
 8005056:	f00c fa83 	bl	8011560 <chMtxLock>
      chMtxUnlock(&mtx1);
 800505a:	4810      	ldr	r0, [pc, #64]	; (800509c <rt_test_010_011_execute.lto_priv.814+0x8c>)
 800505c:	f00c fb50 	bl	8011700 <chMtxUnlock>
      n++;
 8005060:	9b03      	ldr	r3, [sp, #12]
 8005062:	3301      	adds	r3, #1
 8005064:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8005066:	9901      	ldr	r1, [sp, #4]
 8005068:	9802      	ldr	r0, [sp, #8]
 800506a:	f7ff fac9 	bl	8004600 <chVTIsSystemTimeWithinX>
 800506e:	4603      	mov	r3, r0
 8005070:	2b00      	cmp	r3, #0
 8005072:	d1dd      	bne.n	8005030 <rt_test_010_011_execute.lto_priv.814+0x20>
  }

  /* [10.11.2] The score is printed.*/
  test_set_step(2);
 8005074:	4b08      	ldr	r3, [pc, #32]	; (8005098 <rt_test_010_011_execute.lto_priv.814+0x88>)
 8005076:	2202      	movs	r2, #2
 8005078:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800507a:	4809      	ldr	r0, [pc, #36]	; (80050a0 <rt_test_010_011_execute.lto_priv.814+0x90>)
 800507c:	f010 faa8 	bl	80155d0 <test_print>
    test_printn(n * 4);
 8005080:	9b03      	ldr	r3, [sp, #12]
 8005082:	009b      	lsls	r3, r3, #2
 8005084:	4618      	mov	r0, r3
 8005086:	f010 fa5b 	bl	8015540 <test_printn>
    test_println(" lock+unlock/S");
 800508a:	4806      	ldr	r0, [pc, #24]	; (80050a4 <rt_test_010_011_execute.lto_priv.814+0x94>)
 800508c:	f010 fac0 	bl	8015610 <test_println>
  }
}
 8005090:	b005      	add	sp, #20
 8005092:	f85d fb04 	ldr.w	pc, [sp], #4
 8005096:	bf00      	nop
 8005098:	20001988 	.word	0x20001988
 800509c:	20002074 	.word	0x20002074
 80050a0:	08018514 	.word	0x08018514
 80050a4:	08018618 	.word	0x08018618
	...

080050b0 <rt_test_010_012_execute.lto_priv.815>:
 * - [10.12.8] The size of an event listener is printed.
 * - [10.12.9] The size of a mailbox is printed.
 * .
 */

static void rt_test_010_012_execute(void) {
 80050b0:	b508      	push	{r3, lr}

  /* [10.12.1] The size of the system area is printed.*/
  test_set_step(1);
 80050b2:	4b37      	ldr	r3, [pc, #220]	; (8005190 <rt_test_010_012_execute.lto_priv.815+0xe0>)
 80050b4:	2201      	movs	r2, #1
 80050b6:	601a      	str	r2, [r3, #0]
  {
    test_print("--- System: ");
 80050b8:	4836      	ldr	r0, [pc, #216]	; (8005194 <rt_test_010_012_execute.lto_priv.815+0xe4>)
 80050ba:	f010 fa89 	bl	80155d0 <test_print>
    test_printn(sizeof(ch_system_t));
 80050be:	f640 0088 	movw	r0, #2184	; 0x888
 80050c2:	f010 fa3d 	bl	8015540 <test_printn>
    test_println(" bytes");
 80050c6:	4834      	ldr	r0, [pc, #208]	; (8005198 <rt_test_010_012_execute.lto_priv.815+0xe8>)
 80050c8:	f010 faa2 	bl	8015610 <test_println>
  }

  /* [10.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 80050cc:	4b30      	ldr	r3, [pc, #192]	; (8005190 <rt_test_010_012_execute.lto_priv.815+0xe0>)
 80050ce:	2202      	movs	r2, #2
 80050d0:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Thread: ");
 80050d2:	4832      	ldr	r0, [pc, #200]	; (800519c <rt_test_010_012_execute.lto_priv.815+0xec>)
 80050d4:	f010 fa7c 	bl	80155d0 <test_print>
    test_printn(sizeof(thread_t));
 80050d8:	2044      	movs	r0, #68	; 0x44
 80050da:	f010 fa31 	bl	8015540 <test_printn>
    test_println(" bytes");
 80050de:	482e      	ldr	r0, [pc, #184]	; (8005198 <rt_test_010_012_execute.lto_priv.815+0xe8>)
 80050e0:	f010 fa96 	bl	8015610 <test_println>
  }

  /* [10.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 80050e4:	4b2a      	ldr	r3, [pc, #168]	; (8005190 <rt_test_010_012_execute.lto_priv.815+0xe0>)
 80050e6:	2203      	movs	r2, #3
 80050e8:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Timer : ");
 80050ea:	482d      	ldr	r0, [pc, #180]	; (80051a0 <rt_test_010_012_execute.lto_priv.815+0xf0>)
 80050ec:	f010 fa70 	bl	80155d0 <test_print>
    test_printn(sizeof(virtual_timer_t));
 80050f0:	2014      	movs	r0, #20
 80050f2:	f010 fa25 	bl	8015540 <test_printn>
    test_println(" bytes");
 80050f6:	4828      	ldr	r0, [pc, #160]	; (8005198 <rt_test_010_012_execute.lto_priv.815+0xe8>)
 80050f8:	f010 fa8a 	bl	8015610 <test_println>
  }

  /* [10.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 80050fc:	4b24      	ldr	r3, [pc, #144]	; (8005190 <rt_test_010_012_execute.lto_priv.815+0xe0>)
 80050fe:	2204      	movs	r2, #4
 8005100:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 8005102:	4828      	ldr	r0, [pc, #160]	; (80051a4 <rt_test_010_012_execute.lto_priv.815+0xf4>)
 8005104:	f010 fa64 	bl	80155d0 <test_print>
    test_printn(sizeof(semaphore_t));
 8005108:	200c      	movs	r0, #12
 800510a:	f010 fa19 	bl	8015540 <test_printn>
    test_println(" bytes");
 800510e:	4822      	ldr	r0, [pc, #136]	; (8005198 <rt_test_010_012_execute.lto_priv.815+0xe8>)
 8005110:	f010 fa7e 	bl	8015610 <test_println>
#endif
  }

  /* [10.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 8005114:	4b1e      	ldr	r3, [pc, #120]	; (8005190 <rt_test_010_012_execute.lto_priv.815+0xe0>)
 8005116:	2205      	movs	r2, #5
 8005118:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 800511a:	4823      	ldr	r0, [pc, #140]	; (80051a8 <rt_test_010_012_execute.lto_priv.815+0xf8>)
 800511c:	f010 fa58 	bl	80155d0 <test_print>
    test_printn(sizeof(mutex_t));
 8005120:	2010      	movs	r0, #16
 8005122:	f010 fa0d 	bl	8015540 <test_printn>
    test_println(" bytes");
 8005126:	481c      	ldr	r0, [pc, #112]	; (8005198 <rt_test_010_012_execute.lto_priv.815+0xe8>)
 8005128:	f010 fa72 	bl	8015610 <test_println>
#endif
  }

  /* [10.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 800512c:	4b18      	ldr	r3, [pc, #96]	; (8005190 <rt_test_010_012_execute.lto_priv.815+0xe0>)
 800512e:	2206      	movs	r2, #6
 8005130:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 8005132:	481e      	ldr	r0, [pc, #120]	; (80051ac <rt_test_010_012_execute.lto_priv.815+0xfc>)
 8005134:	f010 fa4c 	bl	80155d0 <test_print>
    test_printn(sizeof(condition_variable_t));
 8005138:	2008      	movs	r0, #8
 800513a:	f010 fa01 	bl	8015540 <test_printn>
    test_println(" bytes");
 800513e:	4816      	ldr	r0, [pc, #88]	; (8005198 <rt_test_010_012_execute.lto_priv.815+0xe8>)
 8005140:	f010 fa66 	bl	8015610 <test_println>
#endif
  }

  /* [10.12.7] The size of an event source is printed.*/
  test_set_step(7);
 8005144:	4b12      	ldr	r3, [pc, #72]	; (8005190 <rt_test_010_012_execute.lto_priv.815+0xe0>)
 8005146:	2207      	movs	r2, #7
 8005148:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 800514a:	4819      	ldr	r0, [pc, #100]	; (80051b0 <rt_test_010_012_execute.lto_priv.815+0x100>)
 800514c:	f010 fa40 	bl	80155d0 <test_print>
    test_printn(sizeof(event_source_t));
 8005150:	2004      	movs	r0, #4
 8005152:	f010 f9f5 	bl	8015540 <test_printn>
    test_println(" bytes");
 8005156:	4810      	ldr	r0, [pc, #64]	; (8005198 <rt_test_010_012_execute.lto_priv.815+0xe8>)
 8005158:	f010 fa5a 	bl	8015610 <test_println>
#endif
  }

  /* [10.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 800515c:	4b0c      	ldr	r3, [pc, #48]	; (8005190 <rt_test_010_012_execute.lto_priv.815+0xe0>)
 800515e:	2208      	movs	r2, #8
 8005160:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 8005162:	4814      	ldr	r0, [pc, #80]	; (80051b4 <rt_test_010_012_execute.lto_priv.815+0x104>)
 8005164:	f010 fa34 	bl	80155d0 <test_print>
    test_printn(sizeof(event_listener_t));
 8005168:	2014      	movs	r0, #20
 800516a:	f010 f9e9 	bl	8015540 <test_printn>
    test_println(" bytes");
 800516e:	480a      	ldr	r0, [pc, #40]	; (8005198 <rt_test_010_012_execute.lto_priv.815+0xe8>)
 8005170:	f010 fa4e 	bl	8015610 <test_println>
#endif
  }

  /* [10.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 8005174:	4b06      	ldr	r3, [pc, #24]	; (8005190 <rt_test_010_012_execute.lto_priv.815+0xe0>)
 8005176:	2209      	movs	r2, #9
 8005178:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 800517a:	480f      	ldr	r0, [pc, #60]	; (80051b8 <rt_test_010_012_execute.lto_priv.815+0x108>)
 800517c:	f010 fa28 	bl	80155d0 <test_print>
    test_printn(sizeof(mailbox_t));
 8005180:	2028      	movs	r0, #40	; 0x28
 8005182:	f010 f9dd 	bl	8015540 <test_printn>
    test_println(" bytes");
 8005186:	4804      	ldr	r0, [pc, #16]	; (8005198 <rt_test_010_012_execute.lto_priv.815+0xe8>)
 8005188:	f010 fa42 	bl	8015610 <test_println>
#endif
  }
}
 800518c:	bd08      	pop	{r3, pc}
 800518e:	bf00      	nop
 8005190:	20001988 	.word	0x20001988
 8005194:	08018638 	.word	0x08018638
 8005198:	08018648 	.word	0x08018648
 800519c:	08018650 	.word	0x08018650
 80051a0:	08018660 	.word	0x08018660
 80051a4:	08018670 	.word	0x08018670
 80051a8:	08018680 	.word	0x08018680
 80051ac:	08018690 	.word	0x08018690
 80051b0:	080186a0 	.word	0x080186a0
 80051b4:	080186b0 	.word	0x080186b0
 80051b8:	080186c0 	.word	0x080186c0
 80051bc:	00000000 	.word	0x00000000

080051c0 <port_lock.lto_priv.26>:
static inline void port_lock(void) {
 80051c0:	b082      	sub	sp, #8
 80051c2:	2320      	movs	r3, #32
 80051c4:	9301      	str	r3, [sp, #4]
 80051c6:	9b01      	ldr	r3, [sp, #4]
 80051c8:	f383 8811 	msr	BASEPRI, r3
}
 80051cc:	b002      	add	sp, #8
 80051ce:	4770      	bx	lr

080051d0 <port_unlock.lto_priv.16>:
static inline void port_unlock(void) {
 80051d0:	b082      	sub	sp, #8
 80051d2:	2300      	movs	r3, #0
 80051d4:	9301      	str	r3, [sp, #4]
 80051d6:	9b01      	ldr	r3, [sp, #4]
 80051d8:	f383 8811 	msr	BASEPRI, r3
}
 80051dc:	b002      	add	sp, #8
 80051de:	4770      	bx	lr

080051e0 <chSysLock.lto_priv.82>:
static inline void chSysLock(void) {
 80051e0:	b508      	push	{r3, lr}
  port_lock();
 80051e2:	f7ff ffed 	bl	80051c0 <port_lock.lto_priv.26>
  _dbg_check_lock();
 80051e6:	f00a f86b 	bl	800f2c0 <_dbg_check_lock>
}
 80051ea:	bd08      	pop	{r3, pc}
 80051ec:	0000      	movs	r0, r0
	...

080051f0 <chSysUnlock.lto_priv.46>:
static inline void chSysUnlock(void) {
 80051f0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80051f2:	f00a f87d 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80051f6:	4b09      	ldr	r3, [pc, #36]	; (800521c <chSysUnlock.lto_priv.46+0x2c>)
 80051f8:	681b      	ldr	r3, [r3, #0]
 80051fa:	4a08      	ldr	r2, [pc, #32]	; (800521c <chSysUnlock.lto_priv.46+0x2c>)
 80051fc:	4293      	cmp	r3, r2
 80051fe:	d00a      	beq.n	8005216 <chSysUnlock.lto_priv.46+0x26>
 8005200:	4b06      	ldr	r3, [pc, #24]	; (800521c <chSysUnlock.lto_priv.46+0x2c>)
 8005202:	699b      	ldr	r3, [r3, #24]
 8005204:	689a      	ldr	r2, [r3, #8]
 8005206:	4b05      	ldr	r3, [pc, #20]	; (800521c <chSysUnlock.lto_priv.46+0x2c>)
 8005208:	681b      	ldr	r3, [r3, #0]
 800520a:	689b      	ldr	r3, [r3, #8]
 800520c:	429a      	cmp	r2, r3
 800520e:	d202      	bcs.n	8005216 <chSysUnlock.lto_priv.46+0x26>
 8005210:	4803      	ldr	r0, [pc, #12]	; (8005220 <chSysUnlock.lto_priv.46+0x30>)
 8005212:	f009 fee5 	bl	800efe0 <chSysHalt>
  port_unlock();
 8005216:	f7ff ffdb 	bl	80051d0 <port_unlock.lto_priv.16>
}
 800521a:	bd08      	pop	{r3, pc}
 800521c:	20001090 	.word	0x20001090
 8005220:	08018860 	.word	0x08018860
	...

08005230 <chMBGetSizeI>:
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 * @return              The size of the mailbox.
 *
 * @iclass
 */
static inline size_t chMBGetSizeI(const mailbox_t *mbp) {
 8005230:	b082      	sub	sp, #8
 8005232:	9001      	str	r0, [sp, #4]

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (size_t)(mbp->top - mbp->buffer);
 8005234:	9b01      	ldr	r3, [sp, #4]
 8005236:	685b      	ldr	r3, [r3, #4]
 8005238:	461a      	mov	r2, r3
 800523a:	9b01      	ldr	r3, [sp, #4]
 800523c:	681b      	ldr	r3, [r3, #0]
 800523e:	1ad3      	subs	r3, r2, r3
 8005240:	109b      	asrs	r3, r3, #2
  /*lint -restore*/
}
 8005242:	4618      	mov	r0, r3
 8005244:	b002      	add	sp, #8
 8005246:	4770      	bx	lr
	...

08005250 <chMBGetUsedCountI>:
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 * @return              The number of queued messages.
 *
 * @iclass
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {
 8005250:	b500      	push	{lr}
 8005252:	b083      	sub	sp, #12
 8005254:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005256:	f00a f8d3 	bl	800f400 <chDbgCheckClassI>

  return mbp->cnt;
 800525a:	9b01      	ldr	r3, [sp, #4]
 800525c:	691b      	ldr	r3, [r3, #16]
}
 800525e:	4618      	mov	r0, r3
 8005260:	b003      	add	sp, #12
 8005262:	f85d fb04 	ldr.w	pc, [sp], #4
 8005266:	bf00      	nop
	...

08005270 <chMBGetFreeCountI>:
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline size_t chMBGetFreeCountI(const mailbox_t *mbp) {
 8005270:	b510      	push	{r4, lr}
 8005272:	b082      	sub	sp, #8
 8005274:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005276:	f00a f8c3 	bl	800f400 <chDbgCheckClassI>

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800527a:	9801      	ldr	r0, [sp, #4]
 800527c:	f7ff ffd8 	bl	8005230 <chMBGetSizeI>
 8005280:	4604      	mov	r4, r0
 8005282:	9801      	ldr	r0, [sp, #4]
 8005284:	f7ff ffe4 	bl	8005250 <chMBGetUsedCountI>
 8005288:	4603      	mov	r3, r0
 800528a:	1ae3      	subs	r3, r4, r3
}
 800528c:	4618      	mov	r0, r3
 800528e:	b002      	add	sp, #8
 8005290:	bd10      	pop	{r4, pc}
 8005292:	bf00      	nop
	...

080052a0 <chMBResumeX>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {
 80052a0:	b082      	sub	sp, #8
 80052a2:	9001      	str	r0, [sp, #4]

  mbp->reset = false;
 80052a4:	9b01      	ldr	r3, [sp, #4]
 80052a6:	2200      	movs	r2, #0
 80052a8:	751a      	strb	r2, [r3, #20]
}
 80052aa:	b002      	add	sp, #8
 80052ac:	4770      	bx	lr
 80052ae:	bf00      	nop

080052b0 <osalSysLock.lto_priv.37>:
static inline void osalSysLock(void) {
 80052b0:	b508      	push	{r3, lr}
  chSysLock();
 80052b2:	f7ff ff95 	bl	80051e0 <chSysLock.lto_priv.82>
}
 80052b6:	bd08      	pop	{r3, pc}
	...

080052c0 <osalSysUnlock.lto_priv.34>:
static inline void osalSysUnlock(void) {
 80052c0:	b508      	push	{r3, lr}
  chSysUnlock();
 80052c2:	f7ff ff95 	bl	80051f0 <chSysUnlock.lto_priv.46>
}
 80052c6:	bd08      	pop	{r3, pc}
	...

080052d0 <oslib_test_001_001_setup.lto_priv.709>:
 * - [1.1.8] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void oslib_test_001_001_setup(void) {
 80052d0:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
 80052d2:	2204      	movs	r2, #4
 80052d4:	4902      	ldr	r1, [pc, #8]	; (80052e0 <oslib_test_001_001_setup.lto_priv.709+0x10>)
 80052d6:	4803      	ldr	r0, [pc, #12]	; (80052e4 <oslib_test_001_001_setup.lto_priv.709+0x14>)
 80052d8:	f00d fa8a 	bl	80127f0 <chMBObjectInit>
}
 80052dc:	bd08      	pop	{r3, pc}
 80052de:	bf00      	nop
 80052e0:	200020ac 	.word	0x200020ac
 80052e4:	20000878 	.word	0x20000878
	...

080052f0 <oslib_test_001_001_teardown.lto_priv.710>:

static void oslib_test_001_001_teardown(void) {
 80052f0:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 80052f2:	4802      	ldr	r0, [pc, #8]	; (80052fc <oslib_test_001_001_teardown.lto_priv.710+0xc>)
 80052f4:	f00d fab4 	bl	8012860 <chMBReset>
}
 80052f8:	bd08      	pop	{r3, pc}
 80052fa:	bf00      	nop
 80052fc:	20000878 	.word	0x20000878

08005300 <oslib_test_001_001_execute.lto_priv.711>:

static void oslib_test_001_001_execute(void) {
 8005300:	b500      	push	{lr}
 8005302:	b085      	sub	sp, #20
  msg_t msg1, msg2;
  unsigned i;

  /* [1.1.1] Testing the mailbox size.*/
  test_set_step(1);
 8005304:	4ba5      	ldr	r3, [pc, #660]	; (800559c <oslib_test_001_001_execute.lto_priv.711+0x29c>)
 8005306:	2201      	movs	r2, #1
 8005308:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800530a:	f7ff ffd1 	bl	80052b0 <osalSysLock.lto_priv.37>
 800530e:	48a4      	ldr	r0, [pc, #656]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 8005310:	f7ff ffae 	bl	8005270 <chMBGetFreeCountI>
 8005314:	4603      	mov	r3, r0
 8005316:	2b04      	cmp	r3, #4
 8005318:	bf0c      	ite	eq
 800531a:	2301      	moveq	r3, #1
 800531c:	2300      	movne	r3, #0
 800531e:	b2db      	uxtb	r3, r3
 8005320:	49a0      	ldr	r1, [pc, #640]	; (80055a4 <oslib_test_001_001_execute.lto_priv.711+0x2a4>)
 8005322:	4618      	mov	r0, r3
 8005324:	f010 f8ac 	bl	8015480 <_test_assert>
 8005328:	4603      	mov	r3, r0
 800532a:	2b00      	cmp	r3, #0
 800532c:	d002      	beq.n	8005334 <oslib_test_001_001_execute.lto_priv.711+0x34>
 800532e:	f7ff ffc7 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 8005332:	e1f1      	b.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
 8005334:	f7ff ffc4 	bl	80052c0 <osalSysUnlock.lto_priv.34>
  }

  /* [1.1.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
 8005338:	4b98      	ldr	r3, [pc, #608]	; (800559c <oslib_test_001_001_execute.lto_priv.711+0x29c>)
 800533a:	2202      	movs	r2, #2
 800533c:	601a      	str	r2, [r3, #0]
  {
    chMBReset(&mb1);
 800533e:	4898      	ldr	r0, [pc, #608]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 8005340:	f00d fa8e 	bl	8012860 <chMBReset>
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8005344:	f7ff ffb4 	bl	80052b0 <osalSysLock.lto_priv.37>
 8005348:	4895      	ldr	r0, [pc, #596]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 800534a:	f7ff ff91 	bl	8005270 <chMBGetFreeCountI>
 800534e:	4603      	mov	r3, r0
 8005350:	2b04      	cmp	r3, #4
 8005352:	bf0c      	ite	eq
 8005354:	2301      	moveq	r3, #1
 8005356:	2300      	movne	r3, #0
 8005358:	b2db      	uxtb	r3, r3
 800535a:	4993      	ldr	r1, [pc, #588]	; (80055a8 <oslib_test_001_001_execute.lto_priv.711+0x2a8>)
 800535c:	4618      	mov	r0, r3
 800535e:	f010 f88f 	bl	8015480 <_test_assert>
 8005362:	4603      	mov	r3, r0
 8005364:	2b00      	cmp	r3, #0
 8005366:	d002      	beq.n	800536e <oslib_test_001_001_execute.lto_priv.711+0x6e>
 8005368:	f7ff ffaa 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 800536c:	e1d4      	b.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
 800536e:	f7ff ffa7 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8005372:	f7ff ff9d 	bl	80052b0 <osalSysLock.lto_priv.37>
 8005376:	488a      	ldr	r0, [pc, #552]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 8005378:	f7ff ff6a 	bl	8005250 <chMBGetUsedCountI>
 800537c:	4603      	mov	r3, r0
 800537e:	2b00      	cmp	r3, #0
 8005380:	bf0c      	ite	eq
 8005382:	2301      	moveq	r3, #1
 8005384:	2300      	movne	r3, #0
 8005386:	b2db      	uxtb	r3, r3
 8005388:	4988      	ldr	r1, [pc, #544]	; (80055ac <oslib_test_001_001_execute.lto_priv.711+0x2ac>)
 800538a:	4618      	mov	r0, r3
 800538c:	f010 f878 	bl	8015480 <_test_assert>
 8005390:	4603      	mov	r3, r0
 8005392:	2b00      	cmp	r3, #0
 8005394:	d002      	beq.n	800539c <oslib_test_001_001_execute.lto_priv.711+0x9c>
 8005396:	f7ff ff93 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 800539a:	e1bd      	b.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
 800539c:	f7ff ff90 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 80053a0:	f7ff ff86 	bl	80052b0 <osalSysLock.lto_priv.37>
 80053a4:	4b7e      	ldr	r3, [pc, #504]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 80053a6:	681a      	ldr	r2, [r3, #0]
 80053a8:	4b7d      	ldr	r3, [pc, #500]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 80053aa:	689b      	ldr	r3, [r3, #8]
 80053ac:	429a      	cmp	r2, r3
 80053ae:	bf0c      	ite	eq
 80053b0:	2301      	moveq	r3, #1
 80053b2:	2300      	movne	r3, #0
 80053b4:	b2db      	uxtb	r3, r3
 80053b6:	497e      	ldr	r1, [pc, #504]	; (80055b0 <oslib_test_001_001_execute.lto_priv.711+0x2b0>)
 80053b8:	4618      	mov	r0, r3
 80053ba:	f010 f861 	bl	8015480 <_test_assert>
 80053be:	4603      	mov	r3, r0
 80053c0:	2b00      	cmp	r3, #0
 80053c2:	d002      	beq.n	80053ca <oslib_test_001_001_execute.lto_priv.711+0xca>
 80053c4:	f7ff ff7c 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 80053c8:	e1a6      	b.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
 80053ca:	f7ff ff79 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80053ce:	f7ff ff6f 	bl	80052b0 <osalSysLock.lto_priv.37>
 80053d2:	4b73      	ldr	r3, [pc, #460]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 80053d4:	681a      	ldr	r2, [r3, #0]
 80053d6:	4b72      	ldr	r3, [pc, #456]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 80053d8:	68db      	ldr	r3, [r3, #12]
 80053da:	429a      	cmp	r2, r3
 80053dc:	bf0c      	ite	eq
 80053de:	2301      	moveq	r3, #1
 80053e0:	2300      	movne	r3, #0
 80053e2:	b2db      	uxtb	r3, r3
 80053e4:	4973      	ldr	r1, [pc, #460]	; (80055b4 <oslib_test_001_001_execute.lto_priv.711+0x2b4>)
 80053e6:	4618      	mov	r0, r3
 80053e8:	f010 f84a 	bl	8015480 <_test_assert>
 80053ec:	4603      	mov	r3, r0
 80053ee:	2b00      	cmp	r3, #0
 80053f0:	d002      	beq.n	80053f8 <oslib_test_001_001_execute.lto_priv.711+0xf8>
 80053f2:	f7ff ff65 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 80053f6:	e18f      	b.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
 80053f8:	f7ff ff62 	bl	80052c0 <osalSysUnlock.lto_priv.34>
  }

  /* [1.1.3] Testing the behavior of API when the mailbox is in reset
     state then return in active state.*/
  test_set_step(3);
 80053fc:	4b67      	ldr	r3, [pc, #412]	; (800559c <oslib_test_001_001_execute.lto_priv.711+0x29c>)
 80053fe:	2203      	movs	r2, #3
 8005400:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 8005402:	f04f 32ff 	mov.w	r2, #4294967295
 8005406:	2100      	movs	r1, #0
 8005408:	4865      	ldr	r0, [pc, #404]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 800540a:	f00d fa69 	bl	80128e0 <chMBPostTimeout>
 800540e:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8005410:	9b02      	ldr	r3, [sp, #8]
 8005412:	f113 0f02 	cmn.w	r3, #2
 8005416:	bf0c      	ite	eq
 8005418:	2301      	moveq	r3, #1
 800541a:	2300      	movne	r3, #0
 800541c:	b2db      	uxtb	r3, r3
 800541e:	4966      	ldr	r1, [pc, #408]	; (80055b8 <oslib_test_001_001_execute.lto_priv.711+0x2b8>)
 8005420:	4618      	mov	r0, r3
 8005422:	f010 f82d 	bl	8015480 <_test_assert>
 8005426:	4603      	mov	r3, r0
 8005428:	2b00      	cmp	r3, #0
 800542a:	f040 8175 	bne.w	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
    msg1 = chMBPostAheadTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 800542e:	f04f 32ff 	mov.w	r2, #4294967295
 8005432:	2100      	movs	r1, #0
 8005434:	485a      	ldr	r0, [pc, #360]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 8005436:	f00d fafb 	bl	8012a30 <chMBPostAheadTimeout>
 800543a:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_RESET, "not in reset state");
 800543c:	9b02      	ldr	r3, [sp, #8]
 800543e:	f113 0f02 	cmn.w	r3, #2
 8005442:	bf0c      	ite	eq
 8005444:	2301      	moveq	r3, #1
 8005446:	2300      	movne	r3, #0
 8005448:	b2db      	uxtb	r3, r3
 800544a:	495b      	ldr	r1, [pc, #364]	; (80055b8 <oslib_test_001_001_execute.lto_priv.711+0x2b8>)
 800544c:	4618      	mov	r0, r3
 800544e:	f010 f817 	bl	8015480 <_test_assert>
 8005452:	4603      	mov	r3, r0
 8005454:	2b00      	cmp	r3, #0
 8005456:	f040 815f 	bne.w	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 800545a:	ab01      	add	r3, sp, #4
 800545c:	f04f 32ff 	mov.w	r2, #4294967295
 8005460:	4619      	mov	r1, r3
 8005462:	484f      	ldr	r0, [pc, #316]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 8005464:	f00d fb94 	bl	8012b90 <chMBFetchTimeout>
 8005468:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_RESET, "not in reset state");
 800546a:	9b02      	ldr	r3, [sp, #8]
 800546c:	f113 0f02 	cmn.w	r3, #2
 8005470:	bf0c      	ite	eq
 8005472:	2301      	moveq	r3, #1
 8005474:	2300      	movne	r3, #0
 8005476:	b2db      	uxtb	r3, r3
 8005478:	494f      	ldr	r1, [pc, #316]	; (80055b8 <oslib_test_001_001_execute.lto_priv.711+0x2b8>)
 800547a:	4618      	mov	r0, r3
 800547c:	f010 f800 	bl	8015480 <_test_assert>
 8005480:	4603      	mov	r3, r0
 8005482:	2b00      	cmp	r3, #0
 8005484:	f040 8148 	bne.w	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
    chMBResumeX(&mb1);
 8005488:	4845      	ldr	r0, [pc, #276]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 800548a:	f7ff ff09 	bl	80052a0 <chMBResumeX>
  }

  /* [1.1.4] Filling the mailbox using chMBPostTimeout() and
     chMBPostAheadTimeout() once, no errors expected.*/
  test_set_step(4);
 800548e:	4b43      	ldr	r3, [pc, #268]	; (800559c <oslib_test_001_001_execute.lto_priv.711+0x29c>)
 8005490:	2204      	movs	r2, #4
 8005492:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 8005494:	2300      	movs	r3, #0
 8005496:	9303      	str	r3, [sp, #12]
 8005498:	e019      	b.n	80054ce <oslib_test_001_001_execute.lto_priv.711+0x1ce>
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 800549a:	9b03      	ldr	r3, [sp, #12]
 800549c:	3342      	adds	r3, #66	; 0x42
 800549e:	f04f 32ff 	mov.w	r2, #4294967295
 80054a2:	4619      	mov	r1, r3
 80054a4:	483e      	ldr	r0, [pc, #248]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 80054a6:	f00d fa1b 	bl	80128e0 <chMBPostTimeout>
 80054aa:	9002      	str	r0, [sp, #8]
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80054ac:	9b02      	ldr	r3, [sp, #8]
 80054ae:	2b00      	cmp	r3, #0
 80054b0:	bf0c      	ite	eq
 80054b2:	2301      	moveq	r3, #1
 80054b4:	2300      	movne	r3, #0
 80054b6:	b2db      	uxtb	r3, r3
 80054b8:	4940      	ldr	r1, [pc, #256]	; (80055bc <oslib_test_001_001_execute.lto_priv.711+0x2bc>)
 80054ba:	4618      	mov	r0, r3
 80054bc:	f00f ffe0 	bl	8015480 <_test_assert>
 80054c0:	4603      	mov	r3, r0
 80054c2:	2b00      	cmp	r3, #0
 80054c4:	f040 8128 	bne.w	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
    for (i = 0; i < MB_SIZE - 1; i++) {
 80054c8:	9b03      	ldr	r3, [sp, #12]
 80054ca:	3301      	adds	r3, #1
 80054cc:	9303      	str	r3, [sp, #12]
 80054ce:	9b03      	ldr	r3, [sp, #12]
 80054d0:	2b02      	cmp	r3, #2
 80054d2:	d9e2      	bls.n	800549a <oslib_test_001_001_execute.lto_priv.711+0x19a>
    }
    msg1 = chMBPostAheadTimeout(&mb1, 'A', TIME_INFINITE);
 80054d4:	f04f 32ff 	mov.w	r2, #4294967295
 80054d8:	2141      	movs	r1, #65	; 0x41
 80054da:	4831      	ldr	r0, [pc, #196]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 80054dc:	f00d faa8 	bl	8012a30 <chMBPostAheadTimeout>
 80054e0:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80054e2:	9b02      	ldr	r3, [sp, #8]
 80054e4:	2b00      	cmp	r3, #0
 80054e6:	bf0c      	ite	eq
 80054e8:	2301      	moveq	r3, #1
 80054ea:	2300      	movne	r3, #0
 80054ec:	b2db      	uxtb	r3, r3
 80054ee:	4933      	ldr	r1, [pc, #204]	; (80055bc <oslib_test_001_001_execute.lto_priv.711+0x2bc>)
 80054f0:	4618      	mov	r0, r3
 80054f2:	f00f ffc5 	bl	8015480 <_test_assert>
 80054f6:	4603      	mov	r3, r0
 80054f8:	2b00      	cmp	r3, #0
 80054fa:	f040 810d 	bne.w	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
  }

  /* [1.1.5] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(5);
 80054fe:	4b27      	ldr	r3, [pc, #156]	; (800559c <oslib_test_001_001_execute.lto_priv.711+0x29c>)
 8005500:	2205      	movs	r2, #5
 8005502:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 8005504:	f7ff fed4 	bl	80052b0 <osalSysLock.lto_priv.37>
 8005508:	4825      	ldr	r0, [pc, #148]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 800550a:	f7ff feb1 	bl	8005270 <chMBGetFreeCountI>
 800550e:	4603      	mov	r3, r0
 8005510:	2b00      	cmp	r3, #0
 8005512:	bf0c      	ite	eq
 8005514:	2301      	moveq	r3, #1
 8005516:	2300      	movne	r3, #0
 8005518:	b2db      	uxtb	r3, r3
 800551a:	4929      	ldr	r1, [pc, #164]	; (80055c0 <oslib_test_001_001_execute.lto_priv.711+0x2c0>)
 800551c:	4618      	mov	r0, r3
 800551e:	f00f ffaf 	bl	8015480 <_test_assert>
 8005522:	4603      	mov	r3, r0
 8005524:	2b00      	cmp	r3, #0
 8005526:	d002      	beq.n	800552e <oslib_test_001_001_execute.lto_priv.711+0x22e>
 8005528:	f7ff feca 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 800552c:	e0f4      	b.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
 800552e:	f7ff fec7 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8005532:	f7ff febd 	bl	80052b0 <osalSysLock.lto_priv.37>
 8005536:	481a      	ldr	r0, [pc, #104]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 8005538:	f7ff fe8a 	bl	8005250 <chMBGetUsedCountI>
 800553c:	4603      	mov	r3, r0
 800553e:	2b04      	cmp	r3, #4
 8005540:	bf0c      	ite	eq
 8005542:	2301      	moveq	r3, #1
 8005544:	2300      	movne	r3, #0
 8005546:	b2db      	uxtb	r3, r3
 8005548:	491e      	ldr	r1, [pc, #120]	; (80055c4 <oslib_test_001_001_execute.lto_priv.711+0x2c4>)
 800554a:	4618      	mov	r0, r3
 800554c:	f00f ff98 	bl	8015480 <_test_assert>
 8005550:	4603      	mov	r3, r0
 8005552:	2b00      	cmp	r3, #0
 8005554:	d002      	beq.n	800555c <oslib_test_001_001_execute.lto_priv.711+0x25c>
 8005556:	f7ff feb3 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 800555a:	e0dd      	b.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
 800555c:	f7ff feb0 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8005560:	f7ff fea6 	bl	80052b0 <osalSysLock.lto_priv.37>
 8005564:	4b0e      	ldr	r3, [pc, #56]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 8005566:	68da      	ldr	r2, [r3, #12]
 8005568:	4b0d      	ldr	r3, [pc, #52]	; (80055a0 <oslib_test_001_001_execute.lto_priv.711+0x2a0>)
 800556a:	689b      	ldr	r3, [r3, #8]
 800556c:	429a      	cmp	r2, r3
 800556e:	bf0c      	ite	eq
 8005570:	2301      	moveq	r3, #1
 8005572:	2300      	movne	r3, #0
 8005574:	b2db      	uxtb	r3, r3
 8005576:	4914      	ldr	r1, [pc, #80]	; (80055c8 <oslib_test_001_001_execute.lto_priv.711+0x2c8>)
 8005578:	4618      	mov	r0, r3
 800557a:	f00f ff81 	bl	8015480 <_test_assert>
 800557e:	4603      	mov	r3, r0
 8005580:	2b00      	cmp	r3, #0
 8005582:	d002      	beq.n	800558a <oslib_test_001_001_execute.lto_priv.711+0x28a>
 8005584:	f7ff fe9c 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 8005588:	e0c6      	b.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
 800558a:	f7ff fe99 	bl	80052c0 <osalSysUnlock.lto_priv.34>
  }

  /* [1.1.6] Emptying the mailbox using chMBFetchTimeout(), no errors
     expected.*/
  test_set_step(6);
 800558e:	4b03      	ldr	r3, [pc, #12]	; (800559c <oslib_test_001_001_execute.lto_priv.711+0x29c>)
 8005590:	2206      	movs	r2, #6
 8005592:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
 8005594:	2300      	movs	r3, #0
 8005596:	9303      	str	r3, [sp, #12]
 8005598:	e036      	b.n	8005608 <oslib_test_001_001_execute.lto_priv.711+0x308>
 800559a:	bf00      	nop
 800559c:	20001988 	.word	0x20001988
 80055a0:	20000878 	.word	0x20000878
 80055a4:	08018754 	.word	0x08018754
 80055a8:	08018760 	.word	0x08018760
 80055ac:	0801876c 	.word	0x0801876c
 80055b0:	08018778 	.word	0x08018778
 80055b4:	0801879c 	.word	0x0801879c
 80055b8:	080187c0 	.word	0x080187c0
 80055bc:	080180b8 	.word	0x080180b8
 80055c0:	080187d4 	.word	0x080187d4
 80055c4:	080187e0 	.word	0x080187e0
 80055c8:	080187ec 	.word	0x080187ec
      msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 80055cc:	ab01      	add	r3, sp, #4
 80055ce:	f04f 32ff 	mov.w	r2, #4294967295
 80055d2:	4619      	mov	r1, r3
 80055d4:	4852      	ldr	r0, [pc, #328]	; (8005720 <oslib_test_001_001_execute.lto_priv.711+0x420>)
 80055d6:	f00d fadb 	bl	8012b90 <chMBFetchTimeout>
 80055da:	9002      	str	r0, [sp, #8]
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80055dc:	9b02      	ldr	r3, [sp, #8]
 80055de:	2b00      	cmp	r3, #0
 80055e0:	bf0c      	ite	eq
 80055e2:	2301      	moveq	r3, #1
 80055e4:	2300      	movne	r3, #0
 80055e6:	b2db      	uxtb	r3, r3
 80055e8:	494e      	ldr	r1, [pc, #312]	; (8005724 <oslib_test_001_001_execute.lto_priv.711+0x424>)
 80055ea:	4618      	mov	r0, r3
 80055ec:	f00f ff48 	bl	8015480 <_test_assert>
 80055f0:	4603      	mov	r3, r0
 80055f2:	2b00      	cmp	r3, #0
 80055f4:	f040 8090 	bne.w	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
      test_emit_token(msg2);
 80055f8:	9b01      	ldr	r3, [sp, #4]
 80055fa:	b2db      	uxtb	r3, r3
 80055fc:	4618      	mov	r0, r3
 80055fe:	f010 f81f 	bl	8015640 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 8005602:	9b03      	ldr	r3, [sp, #12]
 8005604:	3301      	adds	r3, #1
 8005606:	9303      	str	r3, [sp, #12]
 8005608:	9b03      	ldr	r3, [sp, #12]
 800560a:	2b03      	cmp	r3, #3
 800560c:	d9de      	bls.n	80055cc <oslib_test_001_001_execute.lto_priv.711+0x2cc>
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 800560e:	4946      	ldr	r1, [pc, #280]	; (8005728 <oslib_test_001_001_execute.lto_priv.711+0x428>)
 8005610:	4846      	ldr	r0, [pc, #280]	; (800572c <oslib_test_001_001_execute.lto_priv.711+0x42c>)
 8005612:	f00f ff4d 	bl	80154b0 <_test_assert_sequence>
 8005616:	4603      	mov	r3, r0
 8005618:	2b00      	cmp	r3, #0
 800561a:	d17d      	bne.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
  }

  /* [1.1.7] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(7);
 800561c:	4b44      	ldr	r3, [pc, #272]	; (8005730 <oslib_test_001_001_execute.lto_priv.711+0x430>)
 800561e:	2207      	movs	r2, #7
 8005620:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8005622:	9b03      	ldr	r3, [sp, #12]
 8005624:	3342      	adds	r3, #66	; 0x42
 8005626:	f04f 32ff 	mov.w	r2, #4294967295
 800562a:	4619      	mov	r1, r3
 800562c:	483c      	ldr	r0, [pc, #240]	; (8005720 <oslib_test_001_001_execute.lto_priv.711+0x420>)
 800562e:	f00d f957 	bl	80128e0 <chMBPostTimeout>
 8005632:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005634:	9b02      	ldr	r3, [sp, #8]
 8005636:	2b00      	cmp	r3, #0
 8005638:	bf0c      	ite	eq
 800563a:	2301      	moveq	r3, #1
 800563c:	2300      	movne	r3, #0
 800563e:	b2db      	uxtb	r3, r3
 8005640:	4938      	ldr	r1, [pc, #224]	; (8005724 <oslib_test_001_001_execute.lto_priv.711+0x424>)
 8005642:	4618      	mov	r0, r3
 8005644:	f00f ff1c 	bl	8015480 <_test_assert>
 8005648:	4603      	mov	r3, r0
 800564a:	2b00      	cmp	r3, #0
 800564c:	d164      	bne.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 800564e:	ab01      	add	r3, sp, #4
 8005650:	f04f 32ff 	mov.w	r2, #4294967295
 8005654:	4619      	mov	r1, r3
 8005656:	4832      	ldr	r0, [pc, #200]	; (8005720 <oslib_test_001_001_execute.lto_priv.711+0x420>)
 8005658:	f00d fa9a 	bl	8012b90 <chMBFetchTimeout>
 800565c:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800565e:	9b02      	ldr	r3, [sp, #8]
 8005660:	2b00      	cmp	r3, #0
 8005662:	bf0c      	ite	eq
 8005664:	2301      	moveq	r3, #1
 8005666:	2300      	movne	r3, #0
 8005668:	b2db      	uxtb	r3, r3
 800566a:	492e      	ldr	r1, [pc, #184]	; (8005724 <oslib_test_001_001_execute.lto_priv.711+0x424>)
 800566c:	4618      	mov	r0, r3
 800566e:	f00f ff07 	bl	8015480 <_test_assert>
 8005672:	4603      	mov	r3, r0
 8005674:	2b00      	cmp	r3, #0
 8005676:	d14f      	bne.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
  }

  /* [1.1.8] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(8);
 8005678:	4b2d      	ldr	r3, [pc, #180]	; (8005730 <oslib_test_001_001_execute.lto_priv.711+0x430>)
 800567a:	2208      	movs	r2, #8
 800567c:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800567e:	f7ff fe17 	bl	80052b0 <osalSysLock.lto_priv.37>
 8005682:	4827      	ldr	r0, [pc, #156]	; (8005720 <oslib_test_001_001_execute.lto_priv.711+0x420>)
 8005684:	f7ff fdf4 	bl	8005270 <chMBGetFreeCountI>
 8005688:	4603      	mov	r3, r0
 800568a:	2b04      	cmp	r3, #4
 800568c:	bf0c      	ite	eq
 800568e:	2301      	moveq	r3, #1
 8005690:	2300      	movne	r3, #0
 8005692:	b2db      	uxtb	r3, r3
 8005694:	4927      	ldr	r1, [pc, #156]	; (8005734 <oslib_test_001_001_execute.lto_priv.711+0x434>)
 8005696:	4618      	mov	r0, r3
 8005698:	f00f fef2 	bl	8015480 <_test_assert>
 800569c:	4603      	mov	r3, r0
 800569e:	2b00      	cmp	r3, #0
 80056a0:	d002      	beq.n	80056a8 <oslib_test_001_001_execute.lto_priv.711+0x3a8>
 80056a2:	f7ff fe0d 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 80056a6:	e037      	b.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
 80056a8:	f7ff fe0a 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 80056ac:	f7ff fe00 	bl	80052b0 <osalSysLock.lto_priv.37>
 80056b0:	481b      	ldr	r0, [pc, #108]	; (8005720 <oslib_test_001_001_execute.lto_priv.711+0x420>)
 80056b2:	f7ff fdcd 	bl	8005250 <chMBGetUsedCountI>
 80056b6:	4603      	mov	r3, r0
 80056b8:	2b00      	cmp	r3, #0
 80056ba:	bf0c      	ite	eq
 80056bc:	2301      	moveq	r3, #1
 80056be:	2300      	movne	r3, #0
 80056c0:	b2db      	uxtb	r3, r3
 80056c2:	491d      	ldr	r1, [pc, #116]	; (8005738 <oslib_test_001_001_execute.lto_priv.711+0x438>)
 80056c4:	4618      	mov	r0, r3
 80056c6:	f00f fedb 	bl	8015480 <_test_assert>
 80056ca:	4603      	mov	r3, r0
 80056cc:	2b00      	cmp	r3, #0
 80056ce:	d002      	beq.n	80056d6 <oslib_test_001_001_execute.lto_priv.711+0x3d6>
 80056d0:	f7ff fdf6 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 80056d4:	e020      	b.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
 80056d6:	f7ff fdf3 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 80056da:	4b11      	ldr	r3, [pc, #68]	; (8005720 <oslib_test_001_001_execute.lto_priv.711+0x420>)
 80056dc:	681a      	ldr	r2, [r3, #0]
 80056de:	4b10      	ldr	r3, [pc, #64]	; (8005720 <oslib_test_001_001_execute.lto_priv.711+0x420>)
 80056e0:	689b      	ldr	r3, [r3, #8]
 80056e2:	429a      	cmp	r2, r3
 80056e4:	bf0c      	ite	eq
 80056e6:	2301      	moveq	r3, #1
 80056e8:	2300      	movne	r3, #0
 80056ea:	b2db      	uxtb	r3, r3
 80056ec:	4913      	ldr	r1, [pc, #76]	; (800573c <oslib_test_001_001_execute.lto_priv.711+0x43c>)
 80056ee:	4618      	mov	r0, r3
 80056f0:	f00f fec6 	bl	8015480 <_test_assert>
 80056f4:	4603      	mov	r3, r0
 80056f6:	2b00      	cmp	r3, #0
 80056f8:	d10e      	bne.n	8005718 <oslib_test_001_001_execute.lto_priv.711+0x418>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80056fa:	4b09      	ldr	r3, [pc, #36]	; (8005720 <oslib_test_001_001_execute.lto_priv.711+0x420>)
 80056fc:	681a      	ldr	r2, [r3, #0]
 80056fe:	4b08      	ldr	r3, [pc, #32]	; (8005720 <oslib_test_001_001_execute.lto_priv.711+0x420>)
 8005700:	68db      	ldr	r3, [r3, #12]
 8005702:	429a      	cmp	r2, r3
 8005704:	bf0c      	ite	eq
 8005706:	2301      	moveq	r3, #1
 8005708:	2300      	movne	r3, #0
 800570a:	b2db      	uxtb	r3, r3
 800570c:	490c      	ldr	r1, [pc, #48]	; (8005740 <oslib_test_001_001_execute.lto_priv.711+0x440>)
 800570e:	4618      	mov	r0, r3
 8005710:	f00f feb6 	bl	8015480 <_test_assert>
 8005714:	4603      	mov	r3, r0
 8005716:	2b00      	cmp	r3, #0
  }
}
 8005718:	b005      	add	sp, #20
 800571a:	f85d fb04 	ldr.w	pc, [sp], #4
 800571e:	bf00      	nop
 8005720:	20000878 	.word	0x20000878
 8005724:	080180b8 	.word	0x080180b8
 8005728:	08018804 	.word	0x08018804
 800572c:	08018288 	.word	0x08018288
 8005730:	20001988 	.word	0x20001988
 8005734:	08018760 	.word	0x08018760
 8005738:	0801876c 	.word	0x0801876c
 800573c:	08018778 	.word	0x08018778
 8005740:	0801879c 	.word	0x0801879c
	...

08005750 <oslib_test_001_002_setup.lto_priv.712>:
 * - [1.2.7] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void oslib_test_001_002_setup(void) {
 8005750:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
 8005752:	2204      	movs	r2, #4
 8005754:	4902      	ldr	r1, [pc, #8]	; (8005760 <oslib_test_001_002_setup.lto_priv.712+0x10>)
 8005756:	4803      	ldr	r0, [pc, #12]	; (8005764 <oslib_test_001_002_setup.lto_priv.712+0x14>)
 8005758:	f00d f84a 	bl	80127f0 <chMBObjectInit>
}
 800575c:	bd08      	pop	{r3, pc}
 800575e:	bf00      	nop
 8005760:	200020ac 	.word	0x200020ac
 8005764:	20000878 	.word	0x20000878
	...

08005770 <oslib_test_001_002_teardown.lto_priv.713>:

static void oslib_test_001_002_teardown(void) {
 8005770:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 8005772:	4802      	ldr	r0, [pc, #8]	; (800577c <oslib_test_001_002_teardown.lto_priv.713+0xc>)
 8005774:	f00d f874 	bl	8012860 <chMBReset>
}
 8005778:	bd08      	pop	{r3, pc}
 800577a:	bf00      	nop
 800577c:	20000878 	.word	0x20000878

08005780 <oslib_test_001_002_execute.lto_priv.714>:

static void oslib_test_001_002_execute(void) {
 8005780:	b500      	push	{lr}
 8005782:	b085      	sub	sp, #20
  msg_t msg1, msg2;
  unsigned i;

  /* [1.2.1] Testing the mailbox size.*/
  test_set_step(1);
 8005784:	4b86      	ldr	r3, [pc, #536]	; (80059a0 <oslib_test_001_002_execute.lto_priv.714+0x220>)
 8005786:	2201      	movs	r2, #1
 8005788:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800578a:	f7ff fd91 	bl	80052b0 <osalSysLock.lto_priv.37>
 800578e:	4885      	ldr	r0, [pc, #532]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 8005790:	f7ff fd6e 	bl	8005270 <chMBGetFreeCountI>
 8005794:	4603      	mov	r3, r0
 8005796:	2b04      	cmp	r3, #4
 8005798:	bf0c      	ite	eq
 800579a:	2301      	moveq	r3, #1
 800579c:	2300      	movne	r3, #0
 800579e:	b2db      	uxtb	r3, r3
 80057a0:	4981      	ldr	r1, [pc, #516]	; (80059a8 <oslib_test_001_002_execute.lto_priv.714+0x228>)
 80057a2:	4618      	mov	r0, r3
 80057a4:	f00f fe6c 	bl	8015480 <_test_assert>
 80057a8:	4603      	mov	r3, r0
 80057aa:	2b00      	cmp	r3, #0
 80057ac:	d002      	beq.n	80057b4 <oslib_test_001_002_execute.lto_priv.714+0x34>
 80057ae:	f7ff fd87 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 80057b2:	e1b3      	b.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
 80057b4:	f7ff fd84 	bl	80052c0 <osalSysUnlock.lto_priv.34>
  }

  /* [1.2.2] Resetting the mailbox, conditions are checked, no errors
     expected. The mailbox is then returned in active state.*/
  test_set_step(2);
 80057b8:	4b79      	ldr	r3, [pc, #484]	; (80059a0 <oslib_test_001_002_execute.lto_priv.714+0x220>)
 80057ba:	2202      	movs	r2, #2
 80057bc:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 80057be:	f7ff fd0f 	bl	80051e0 <chSysLock.lto_priv.82>
    chMBResetI(&mb1);
 80057c2:	4878      	ldr	r0, [pc, #480]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 80057c4:	f00d f85c 	bl	8012880 <chMBResetI>
    chSysUnlock();
 80057c8:	f7ff fd12 	bl	80051f0 <chSysUnlock.lto_priv.46>
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80057cc:	f7ff fd70 	bl	80052b0 <osalSysLock.lto_priv.37>
 80057d0:	4874      	ldr	r0, [pc, #464]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 80057d2:	f7ff fd4d 	bl	8005270 <chMBGetFreeCountI>
 80057d6:	4603      	mov	r3, r0
 80057d8:	2b04      	cmp	r3, #4
 80057da:	bf0c      	ite	eq
 80057dc:	2301      	moveq	r3, #1
 80057de:	2300      	movne	r3, #0
 80057e0:	b2db      	uxtb	r3, r3
 80057e2:	4972      	ldr	r1, [pc, #456]	; (80059ac <oslib_test_001_002_execute.lto_priv.714+0x22c>)
 80057e4:	4618      	mov	r0, r3
 80057e6:	f00f fe4b 	bl	8015480 <_test_assert>
 80057ea:	4603      	mov	r3, r0
 80057ec:	2b00      	cmp	r3, #0
 80057ee:	d002      	beq.n	80057f6 <oslib_test_001_002_execute.lto_priv.714+0x76>
 80057f0:	f7ff fd66 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 80057f4:	e192      	b.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
 80057f6:	f7ff fd63 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 80057fa:	f7ff fd59 	bl	80052b0 <osalSysLock.lto_priv.37>
 80057fe:	4869      	ldr	r0, [pc, #420]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 8005800:	f7ff fd26 	bl	8005250 <chMBGetUsedCountI>
 8005804:	4603      	mov	r3, r0
 8005806:	2b00      	cmp	r3, #0
 8005808:	bf0c      	ite	eq
 800580a:	2301      	moveq	r3, #1
 800580c:	2300      	movne	r3, #0
 800580e:	b2db      	uxtb	r3, r3
 8005810:	4967      	ldr	r1, [pc, #412]	; (80059b0 <oslib_test_001_002_execute.lto_priv.714+0x230>)
 8005812:	4618      	mov	r0, r3
 8005814:	f00f fe34 	bl	8015480 <_test_assert>
 8005818:	4603      	mov	r3, r0
 800581a:	2b00      	cmp	r3, #0
 800581c:	d002      	beq.n	8005824 <oslib_test_001_002_execute.lto_priv.714+0xa4>
 800581e:	f7ff fd4f 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 8005822:	e17b      	b.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
 8005824:	f7ff fd4c 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8005828:	f7ff fd42 	bl	80052b0 <osalSysLock.lto_priv.37>
 800582c:	4b5d      	ldr	r3, [pc, #372]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 800582e:	681a      	ldr	r2, [r3, #0]
 8005830:	4b5c      	ldr	r3, [pc, #368]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 8005832:	689b      	ldr	r3, [r3, #8]
 8005834:	429a      	cmp	r2, r3
 8005836:	bf0c      	ite	eq
 8005838:	2301      	moveq	r3, #1
 800583a:	2300      	movne	r3, #0
 800583c:	b2db      	uxtb	r3, r3
 800583e:	495d      	ldr	r1, [pc, #372]	; (80059b4 <oslib_test_001_002_execute.lto_priv.714+0x234>)
 8005840:	4618      	mov	r0, r3
 8005842:	f00f fe1d 	bl	8015480 <_test_assert>
 8005846:	4603      	mov	r3, r0
 8005848:	2b00      	cmp	r3, #0
 800584a:	d002      	beq.n	8005852 <oslib_test_001_002_execute.lto_priv.714+0xd2>
 800584c:	f7ff fd38 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 8005850:	e164      	b.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
 8005852:	f7ff fd35 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8005856:	f7ff fd2b 	bl	80052b0 <osalSysLock.lto_priv.37>
 800585a:	4b52      	ldr	r3, [pc, #328]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 800585c:	681a      	ldr	r2, [r3, #0]
 800585e:	4b51      	ldr	r3, [pc, #324]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 8005860:	68db      	ldr	r3, [r3, #12]
 8005862:	429a      	cmp	r2, r3
 8005864:	bf0c      	ite	eq
 8005866:	2301      	moveq	r3, #1
 8005868:	2300      	movne	r3, #0
 800586a:	b2db      	uxtb	r3, r3
 800586c:	4952      	ldr	r1, [pc, #328]	; (80059b8 <oslib_test_001_002_execute.lto_priv.714+0x238>)
 800586e:	4618      	mov	r0, r3
 8005870:	f00f fe06 	bl	8015480 <_test_assert>
 8005874:	4603      	mov	r3, r0
 8005876:	2b00      	cmp	r3, #0
 8005878:	d002      	beq.n	8005880 <oslib_test_001_002_execute.lto_priv.714+0x100>
 800587a:	f7ff fd21 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 800587e:	e14d      	b.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
 8005880:	f7ff fd1e 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    chMBResumeX(&mb1);
 8005884:	4847      	ldr	r0, [pc, #284]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 8005886:	f7ff fd0b 	bl	80052a0 <chMBResumeX>
  }

  /* [1.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
 800588a:	4b45      	ldr	r3, [pc, #276]	; (80059a0 <oslib_test_001_002_execute.lto_priv.714+0x220>)
 800588c:	2203      	movs	r2, #3
 800588e:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 8005890:	2300      	movs	r3, #0
 8005892:	9303      	str	r3, [sp, #12]
 8005894:	e01b      	b.n	80058ce <oslib_test_001_002_execute.lto_priv.714+0x14e>
      chSysLock();
 8005896:	f7ff fca3 	bl	80051e0 <chSysLock.lto_priv.82>
      msg1 = chMBPostI(&mb1, 'B' + i);
 800589a:	9b03      	ldr	r3, [sp, #12]
 800589c:	3342      	adds	r3, #66	; 0x42
 800589e:	4619      	mov	r1, r3
 80058a0:	4840      	ldr	r0, [pc, #256]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 80058a2:	f00d f885 	bl	80129b0 <chMBPostI>
 80058a6:	9002      	str	r0, [sp, #8]
      chSysUnlock();
 80058a8:	f7ff fca2 	bl	80051f0 <chSysUnlock.lto_priv.46>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80058ac:	9b02      	ldr	r3, [sp, #8]
 80058ae:	2b00      	cmp	r3, #0
 80058b0:	bf0c      	ite	eq
 80058b2:	2301      	moveq	r3, #1
 80058b4:	2300      	movne	r3, #0
 80058b6:	b2db      	uxtb	r3, r3
 80058b8:	4940      	ldr	r1, [pc, #256]	; (80059bc <oslib_test_001_002_execute.lto_priv.714+0x23c>)
 80058ba:	4618      	mov	r0, r3
 80058bc:	f00f fde0 	bl	8015480 <_test_assert>
 80058c0:	4603      	mov	r3, r0
 80058c2:	2b00      	cmp	r3, #0
 80058c4:	f040 812a 	bne.w	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
    for (i = 0; i < MB_SIZE - 1; i++) {
 80058c8:	9b03      	ldr	r3, [sp, #12]
 80058ca:	3301      	adds	r3, #1
 80058cc:	9303      	str	r3, [sp, #12]
 80058ce:	9b03      	ldr	r3, [sp, #12]
 80058d0:	2b02      	cmp	r3, #2
 80058d2:	d9e0      	bls.n	8005896 <oslib_test_001_002_execute.lto_priv.714+0x116>
    }
    chSysLock();
 80058d4:	f7ff fc84 	bl	80051e0 <chSysLock.lto_priv.82>
    msg1 = chMBPostAheadI(&mb1, 'A');
 80058d8:	2141      	movs	r1, #65	; 0x41
 80058da:	4832      	ldr	r0, [pc, #200]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 80058dc:	f00d f910 	bl	8012b00 <chMBPostAheadI>
 80058e0:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 80058e2:	f7ff fc85 	bl	80051f0 <chSysUnlock.lto_priv.46>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80058e6:	9b02      	ldr	r3, [sp, #8]
 80058e8:	2b00      	cmp	r3, #0
 80058ea:	bf0c      	ite	eq
 80058ec:	2301      	moveq	r3, #1
 80058ee:	2300      	movne	r3, #0
 80058f0:	b2db      	uxtb	r3, r3
 80058f2:	4932      	ldr	r1, [pc, #200]	; (80059bc <oslib_test_001_002_execute.lto_priv.714+0x23c>)
 80058f4:	4618      	mov	r0, r3
 80058f6:	f00f fdc3 	bl	8015480 <_test_assert>
 80058fa:	4603      	mov	r3, r0
 80058fc:	2b00      	cmp	r3, #0
 80058fe:	f040 810d 	bne.w	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
  }

  /* [1.2.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
 8005902:	4b27      	ldr	r3, [pc, #156]	; (80059a0 <oslib_test_001_002_execute.lto_priv.714+0x220>)
 8005904:	2204      	movs	r2, #4
 8005906:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 8005908:	f7ff fcd2 	bl	80052b0 <osalSysLock.lto_priv.37>
 800590c:	4825      	ldr	r0, [pc, #148]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 800590e:	f7ff fcaf 	bl	8005270 <chMBGetFreeCountI>
 8005912:	4603      	mov	r3, r0
 8005914:	2b00      	cmp	r3, #0
 8005916:	bf0c      	ite	eq
 8005918:	2301      	moveq	r3, #1
 800591a:	2300      	movne	r3, #0
 800591c:	b2db      	uxtb	r3, r3
 800591e:	4928      	ldr	r1, [pc, #160]	; (80059c0 <oslib_test_001_002_execute.lto_priv.714+0x240>)
 8005920:	4618      	mov	r0, r3
 8005922:	f00f fdad 	bl	8015480 <_test_assert>
 8005926:	4603      	mov	r3, r0
 8005928:	2b00      	cmp	r3, #0
 800592a:	d002      	beq.n	8005932 <oslib_test_001_002_execute.lto_priv.714+0x1b2>
 800592c:	f7ff fcc8 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 8005930:	e0f4      	b.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
 8005932:	f7ff fcc5 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8005936:	f7ff fcbb 	bl	80052b0 <osalSysLock.lto_priv.37>
 800593a:	481a      	ldr	r0, [pc, #104]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 800593c:	f7ff fc88 	bl	8005250 <chMBGetUsedCountI>
 8005940:	4603      	mov	r3, r0
 8005942:	2b04      	cmp	r3, #4
 8005944:	bf0c      	ite	eq
 8005946:	2301      	moveq	r3, #1
 8005948:	2300      	movne	r3, #0
 800594a:	b2db      	uxtb	r3, r3
 800594c:	491d      	ldr	r1, [pc, #116]	; (80059c4 <oslib_test_001_002_execute.lto_priv.714+0x244>)
 800594e:	4618      	mov	r0, r3
 8005950:	f00f fd96 	bl	8015480 <_test_assert>
 8005954:	4603      	mov	r3, r0
 8005956:	2b00      	cmp	r3, #0
 8005958:	d002      	beq.n	8005960 <oslib_test_001_002_execute.lto_priv.714+0x1e0>
 800595a:	f7ff fcb1 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 800595e:	e0dd      	b.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
 8005960:	f7ff fcae 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8005964:	f7ff fca4 	bl	80052b0 <osalSysLock.lto_priv.37>
 8005968:	4b0e      	ldr	r3, [pc, #56]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 800596a:	68da      	ldr	r2, [r3, #12]
 800596c:	4b0d      	ldr	r3, [pc, #52]	; (80059a4 <oslib_test_001_002_execute.lto_priv.714+0x224>)
 800596e:	689b      	ldr	r3, [r3, #8]
 8005970:	429a      	cmp	r2, r3
 8005972:	bf0c      	ite	eq
 8005974:	2301      	moveq	r3, #1
 8005976:	2300      	movne	r3, #0
 8005978:	b2db      	uxtb	r3, r3
 800597a:	4913      	ldr	r1, [pc, #76]	; (80059c8 <oslib_test_001_002_execute.lto_priv.714+0x248>)
 800597c:	4618      	mov	r0, r3
 800597e:	f00f fd7f 	bl	8015480 <_test_assert>
 8005982:	4603      	mov	r3, r0
 8005984:	2b00      	cmp	r3, #0
 8005986:	d002      	beq.n	800598e <oslib_test_001_002_execute.lto_priv.714+0x20e>
 8005988:	f7ff fc9a 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 800598c:	e0c6      	b.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
 800598e:	f7ff fc97 	bl	80052c0 <osalSysUnlock.lto_priv.34>
  }

  /* [1.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
 8005992:	4b03      	ldr	r3, [pc, #12]	; (80059a0 <oslib_test_001_002_execute.lto_priv.714+0x220>)
 8005994:	2205      	movs	r2, #5
 8005996:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
 8005998:	2300      	movs	r3, #0
 800599a:	9303      	str	r3, [sp, #12]
 800599c:	e036      	b.n	8005a0c <oslib_test_001_002_execute.lto_priv.714+0x28c>
 800599e:	bf00      	nop
 80059a0:	20001988 	.word	0x20001988
 80059a4:	20000878 	.word	0x20000878
 80059a8:	08018754 	.word	0x08018754
 80059ac:	08018760 	.word	0x08018760
 80059b0:	0801876c 	.word	0x0801876c
 80059b4:	08018778 	.word	0x08018778
 80059b8:	0801879c 	.word	0x0801879c
 80059bc:	080180b8 	.word	0x080180b8
 80059c0:	080187d4 	.word	0x080187d4
 80059c4:	080187e0 	.word	0x080187e0
 80059c8:	080187ec 	.word	0x080187ec
      chSysLock();
 80059cc:	f7ff fc08 	bl	80051e0 <chSysLock.lto_priv.82>
      msg1 = chMBFetchI(&mb1, &msg2);
 80059d0:	ab01      	add	r3, sp, #4
 80059d2:	4619      	mov	r1, r3
 80059d4:	4853      	ldr	r0, [pc, #332]	; (8005b24 <oslib_test_001_002_execute.lto_priv.714+0x3a4>)
 80059d6:	f00d f943 	bl	8012c60 <chMBFetchI>
 80059da:	9002      	str	r0, [sp, #8]
      chSysUnlock();
 80059dc:	f7ff fc08 	bl	80051f0 <chSysUnlock.lto_priv.46>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80059e0:	9b02      	ldr	r3, [sp, #8]
 80059e2:	2b00      	cmp	r3, #0
 80059e4:	bf0c      	ite	eq
 80059e6:	2301      	moveq	r3, #1
 80059e8:	2300      	movne	r3, #0
 80059ea:	b2db      	uxtb	r3, r3
 80059ec:	494e      	ldr	r1, [pc, #312]	; (8005b28 <oslib_test_001_002_execute.lto_priv.714+0x3a8>)
 80059ee:	4618      	mov	r0, r3
 80059f0:	f00f fd46 	bl	8015480 <_test_assert>
 80059f4:	4603      	mov	r3, r0
 80059f6:	2b00      	cmp	r3, #0
 80059f8:	f040 8090 	bne.w	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
      test_emit_token(msg2);
 80059fc:	9b01      	ldr	r3, [sp, #4]
 80059fe:	b2db      	uxtb	r3, r3
 8005a00:	4618      	mov	r0, r3
 8005a02:	f00f fe1d 	bl	8015640 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 8005a06:	9b03      	ldr	r3, [sp, #12]
 8005a08:	3301      	adds	r3, #1
 8005a0a:	9303      	str	r3, [sp, #12]
 8005a0c:	9b03      	ldr	r3, [sp, #12]
 8005a0e:	2b03      	cmp	r3, #3
 8005a10:	d9dc      	bls.n	80059cc <oslib_test_001_002_execute.lto_priv.714+0x24c>
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 8005a12:	4946      	ldr	r1, [pc, #280]	; (8005b2c <oslib_test_001_002_execute.lto_priv.714+0x3ac>)
 8005a14:	4846      	ldr	r0, [pc, #280]	; (8005b30 <oslib_test_001_002_execute.lto_priv.714+0x3b0>)
 8005a16:	f00f fd4b 	bl	80154b0 <_test_assert_sequence>
 8005a1a:	4603      	mov	r3, r0
 8005a1c:	2b00      	cmp	r3, #0
 8005a1e:	d17d      	bne.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
  }

  /* [1.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 8005a20:	4b44      	ldr	r3, [pc, #272]	; (8005b34 <oslib_test_001_002_execute.lto_priv.714+0x3b4>)
 8005a22:	2206      	movs	r2, #6
 8005a24:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8005a26:	9b03      	ldr	r3, [sp, #12]
 8005a28:	3342      	adds	r3, #66	; 0x42
 8005a2a:	f04f 32ff 	mov.w	r2, #4294967295
 8005a2e:	4619      	mov	r1, r3
 8005a30:	483c      	ldr	r0, [pc, #240]	; (8005b24 <oslib_test_001_002_execute.lto_priv.714+0x3a4>)
 8005a32:	f00c ff55 	bl	80128e0 <chMBPostTimeout>
 8005a36:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005a38:	9b02      	ldr	r3, [sp, #8]
 8005a3a:	2b00      	cmp	r3, #0
 8005a3c:	bf0c      	ite	eq
 8005a3e:	2301      	moveq	r3, #1
 8005a40:	2300      	movne	r3, #0
 8005a42:	b2db      	uxtb	r3, r3
 8005a44:	4938      	ldr	r1, [pc, #224]	; (8005b28 <oslib_test_001_002_execute.lto_priv.714+0x3a8>)
 8005a46:	4618      	mov	r0, r3
 8005a48:	f00f fd1a 	bl	8015480 <_test_assert>
 8005a4c:	4603      	mov	r3, r0
 8005a4e:	2b00      	cmp	r3, #0
 8005a50:	d164      	bne.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8005a52:	ab01      	add	r3, sp, #4
 8005a54:	f04f 32ff 	mov.w	r2, #4294967295
 8005a58:	4619      	mov	r1, r3
 8005a5a:	4832      	ldr	r0, [pc, #200]	; (8005b24 <oslib_test_001_002_execute.lto_priv.714+0x3a4>)
 8005a5c:	f00d f898 	bl	8012b90 <chMBFetchTimeout>
 8005a60:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005a62:	9b02      	ldr	r3, [sp, #8]
 8005a64:	2b00      	cmp	r3, #0
 8005a66:	bf0c      	ite	eq
 8005a68:	2301      	moveq	r3, #1
 8005a6a:	2300      	movne	r3, #0
 8005a6c:	b2db      	uxtb	r3, r3
 8005a6e:	492e      	ldr	r1, [pc, #184]	; (8005b28 <oslib_test_001_002_execute.lto_priv.714+0x3a8>)
 8005a70:	4618      	mov	r0, r3
 8005a72:	f00f fd05 	bl	8015480 <_test_assert>
 8005a76:	4603      	mov	r3, r0
 8005a78:	2b00      	cmp	r3, #0
 8005a7a:	d14f      	bne.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
  }

  /* [1.2.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
 8005a7c:	4b2d      	ldr	r3, [pc, #180]	; (8005b34 <oslib_test_001_002_execute.lto_priv.714+0x3b4>)
 8005a7e:	2207      	movs	r2, #7
 8005a80:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8005a82:	f7ff fc15 	bl	80052b0 <osalSysLock.lto_priv.37>
 8005a86:	4827      	ldr	r0, [pc, #156]	; (8005b24 <oslib_test_001_002_execute.lto_priv.714+0x3a4>)
 8005a88:	f7ff fbf2 	bl	8005270 <chMBGetFreeCountI>
 8005a8c:	4603      	mov	r3, r0
 8005a8e:	2b04      	cmp	r3, #4
 8005a90:	bf0c      	ite	eq
 8005a92:	2301      	moveq	r3, #1
 8005a94:	2300      	movne	r3, #0
 8005a96:	b2db      	uxtb	r3, r3
 8005a98:	4927      	ldr	r1, [pc, #156]	; (8005b38 <oslib_test_001_002_execute.lto_priv.714+0x3b8>)
 8005a9a:	4618      	mov	r0, r3
 8005a9c:	f00f fcf0 	bl	8015480 <_test_assert>
 8005aa0:	4603      	mov	r3, r0
 8005aa2:	2b00      	cmp	r3, #0
 8005aa4:	d002      	beq.n	8005aac <oslib_test_001_002_execute.lto_priv.714+0x32c>
 8005aa6:	f7ff fc0b 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 8005aaa:	e037      	b.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
 8005aac:	f7ff fc08 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8005ab0:	f7ff fbfe 	bl	80052b0 <osalSysLock.lto_priv.37>
 8005ab4:	481b      	ldr	r0, [pc, #108]	; (8005b24 <oslib_test_001_002_execute.lto_priv.714+0x3a4>)
 8005ab6:	f7ff fbcb 	bl	8005250 <chMBGetUsedCountI>
 8005aba:	4603      	mov	r3, r0
 8005abc:	2b00      	cmp	r3, #0
 8005abe:	bf0c      	ite	eq
 8005ac0:	2301      	moveq	r3, #1
 8005ac2:	2300      	movne	r3, #0
 8005ac4:	b2db      	uxtb	r3, r3
 8005ac6:	491d      	ldr	r1, [pc, #116]	; (8005b3c <oslib_test_001_002_execute.lto_priv.714+0x3bc>)
 8005ac8:	4618      	mov	r0, r3
 8005aca:	f00f fcd9 	bl	8015480 <_test_assert>
 8005ace:	4603      	mov	r3, r0
 8005ad0:	2b00      	cmp	r3, #0
 8005ad2:	d002      	beq.n	8005ada <oslib_test_001_002_execute.lto_priv.714+0x35a>
 8005ad4:	f7ff fbf4 	bl	80052c0 <osalSysUnlock.lto_priv.34>
 8005ad8:	e020      	b.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
 8005ada:	f7ff fbf1 	bl	80052c0 <osalSysUnlock.lto_priv.34>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8005ade:	4b11      	ldr	r3, [pc, #68]	; (8005b24 <oslib_test_001_002_execute.lto_priv.714+0x3a4>)
 8005ae0:	681a      	ldr	r2, [r3, #0]
 8005ae2:	4b10      	ldr	r3, [pc, #64]	; (8005b24 <oslib_test_001_002_execute.lto_priv.714+0x3a4>)
 8005ae4:	689b      	ldr	r3, [r3, #8]
 8005ae6:	429a      	cmp	r2, r3
 8005ae8:	bf0c      	ite	eq
 8005aea:	2301      	moveq	r3, #1
 8005aec:	2300      	movne	r3, #0
 8005aee:	b2db      	uxtb	r3, r3
 8005af0:	4913      	ldr	r1, [pc, #76]	; (8005b40 <oslib_test_001_002_execute.lto_priv.714+0x3c0>)
 8005af2:	4618      	mov	r0, r3
 8005af4:	f00f fcc4 	bl	8015480 <_test_assert>
 8005af8:	4603      	mov	r3, r0
 8005afa:	2b00      	cmp	r3, #0
 8005afc:	d10e      	bne.n	8005b1c <oslib_test_001_002_execute.lto_priv.714+0x39c>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8005afe:	4b09      	ldr	r3, [pc, #36]	; (8005b24 <oslib_test_001_002_execute.lto_priv.714+0x3a4>)
 8005b00:	681a      	ldr	r2, [r3, #0]
 8005b02:	4b08      	ldr	r3, [pc, #32]	; (8005b24 <oslib_test_001_002_execute.lto_priv.714+0x3a4>)
 8005b04:	68db      	ldr	r3, [r3, #12]
 8005b06:	429a      	cmp	r2, r3
 8005b08:	bf0c      	ite	eq
 8005b0a:	2301      	moveq	r3, #1
 8005b0c:	2300      	movne	r3, #0
 8005b0e:	b2db      	uxtb	r3, r3
 8005b10:	490c      	ldr	r1, [pc, #48]	; (8005b44 <oslib_test_001_002_execute.lto_priv.714+0x3c4>)
 8005b12:	4618      	mov	r0, r3
 8005b14:	f00f fcb4 	bl	8015480 <_test_assert>
 8005b18:	4603      	mov	r3, r0
 8005b1a:	2b00      	cmp	r3, #0
  }
}
 8005b1c:	b005      	add	sp, #20
 8005b1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b22:	bf00      	nop
 8005b24:	20000878 	.word	0x20000878
 8005b28:	080180b8 	.word	0x080180b8
 8005b2c:	08018804 	.word	0x08018804
 8005b30:	08018288 	.word	0x08018288
 8005b34:	20001988 	.word	0x20001988
 8005b38:	08018760 	.word	0x08018760
 8005b3c:	0801876c 	.word	0x0801876c
 8005b40:	08018778 	.word	0x08018778
 8005b44:	0801879c 	.word	0x0801879c
	...

08005b50 <oslib_test_001_003_setup.lto_priv.715>:
 *   active state.
 * - [1.3.4] Testing chMBFetchTimeout() and chMBFetchI() timeout.
 * .
 */

static void oslib_test_001_003_setup(void) {
 8005b50:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
 8005b52:	2204      	movs	r2, #4
 8005b54:	4902      	ldr	r1, [pc, #8]	; (8005b60 <oslib_test_001_003_setup.lto_priv.715+0x10>)
 8005b56:	4803      	ldr	r0, [pc, #12]	; (8005b64 <oslib_test_001_003_setup.lto_priv.715+0x14>)
 8005b58:	f00c fe4a 	bl	80127f0 <chMBObjectInit>
}
 8005b5c:	bd08      	pop	{r3, pc}
 8005b5e:	bf00      	nop
 8005b60:	200020ac 	.word	0x200020ac
 8005b64:	20000878 	.word	0x20000878
	...

08005b70 <oslib_test_001_003_teardown.lto_priv.716>:

static void oslib_test_001_003_teardown(void) {
 8005b70:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 8005b72:	4802      	ldr	r0, [pc, #8]	; (8005b7c <oslib_test_001_003_teardown.lto_priv.716+0xc>)
 8005b74:	f00c fe74 	bl	8012860 <chMBReset>
}
 8005b78:	bd08      	pop	{r3, pc}
 8005b7a:	bf00      	nop
 8005b7c:	20000878 	.word	0x20000878

08005b80 <oslib_test_001_003_execute.lto_priv.717>:

static void oslib_test_001_003_execute(void) {
 8005b80:	b500      	push	{lr}
 8005b82:	b085      	sub	sp, #20
  msg_t msg1, msg2;
  unsigned i;

  /* [1.3.1] Filling the mailbox.*/
  test_set_step(1);
 8005b84:	4b5b      	ldr	r3, [pc, #364]	; (8005cf4 <oslib_test_001_003_execute.lto_priv.717+0x174>)
 8005b86:	2201      	movs	r2, #1
 8005b88:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
 8005b8a:	2300      	movs	r3, #0
 8005b8c:	9303      	str	r3, [sp, #12]
 8005b8e:	e019      	b.n	8005bc4 <oslib_test_001_003_execute.lto_priv.717+0x44>
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8005b90:	9b03      	ldr	r3, [sp, #12]
 8005b92:	3342      	adds	r3, #66	; 0x42
 8005b94:	f04f 32ff 	mov.w	r2, #4294967295
 8005b98:	4619      	mov	r1, r3
 8005b9a:	4857      	ldr	r0, [pc, #348]	; (8005cf8 <oslib_test_001_003_execute.lto_priv.717+0x178>)
 8005b9c:	f00c fea0 	bl	80128e0 <chMBPostTimeout>
 8005ba0:	9002      	str	r0, [sp, #8]
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005ba2:	9b02      	ldr	r3, [sp, #8]
 8005ba4:	2b00      	cmp	r3, #0
 8005ba6:	bf0c      	ite	eq
 8005ba8:	2301      	moveq	r3, #1
 8005baa:	2300      	movne	r3, #0
 8005bac:	b2db      	uxtb	r3, r3
 8005bae:	4953      	ldr	r1, [pc, #332]	; (8005cfc <oslib_test_001_003_execute.lto_priv.717+0x17c>)
 8005bb0:	4618      	mov	r0, r3
 8005bb2:	f00f fc65 	bl	8015480 <_test_assert>
 8005bb6:	4603      	mov	r3, r0
 8005bb8:	2b00      	cmp	r3, #0
 8005bba:	f040 8097 	bne.w	8005cec <oslib_test_001_003_execute.lto_priv.717+0x16c>
    for (i = 0; i < MB_SIZE; i++) {
 8005bbe:	9b03      	ldr	r3, [sp, #12]
 8005bc0:	3301      	adds	r3, #1
 8005bc2:	9303      	str	r3, [sp, #12]
 8005bc4:	9b03      	ldr	r3, [sp, #12]
 8005bc6:	2b03      	cmp	r3, #3
 8005bc8:	d9e2      	bls.n	8005b90 <oslib_test_001_003_execute.lto_priv.717+0x10>
    }
  }

  /* [1.3.2] Testing chMBPostTimeout(), chMBPostI(),
     chMBPostAheadTimeout() and chMBPostAheadI() timeout.*/
  test_set_step(2);
 8005bca:	4b4a      	ldr	r3, [pc, #296]	; (8005cf4 <oslib_test_001_003_execute.lto_priv.717+0x174>)
 8005bcc:	2202      	movs	r2, #2
 8005bce:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
 8005bd0:	2201      	movs	r2, #1
 8005bd2:	2158      	movs	r1, #88	; 0x58
 8005bd4:	4848      	ldr	r0, [pc, #288]	; (8005cf8 <oslib_test_001_003_execute.lto_priv.717+0x178>)
 8005bd6:	f00c fe83 	bl	80128e0 <chMBPostTimeout>
 8005bda:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005bdc:	9b02      	ldr	r3, [sp, #8]
 8005bde:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005be2:	bf0c      	ite	eq
 8005be4:	2301      	moveq	r3, #1
 8005be6:	2300      	movne	r3, #0
 8005be8:	b2db      	uxtb	r3, r3
 8005bea:	4944      	ldr	r1, [pc, #272]	; (8005cfc <oslib_test_001_003_execute.lto_priv.717+0x17c>)
 8005bec:	4618      	mov	r0, r3
 8005bee:	f00f fc47 	bl	8015480 <_test_assert>
 8005bf2:	4603      	mov	r3, r0
 8005bf4:	2b00      	cmp	r3, #0
 8005bf6:	d179      	bne.n	8005cec <oslib_test_001_003_execute.lto_priv.717+0x16c>
    chSysLock();
 8005bf8:	f7ff faf2 	bl	80051e0 <chSysLock.lto_priv.82>
    msg1 = chMBPostI(&mb1, 'X');
 8005bfc:	2158      	movs	r1, #88	; 0x58
 8005bfe:	483e      	ldr	r0, [pc, #248]	; (8005cf8 <oslib_test_001_003_execute.lto_priv.717+0x178>)
 8005c00:	f00c fed6 	bl	80129b0 <chMBPostI>
 8005c04:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 8005c06:	f7ff faf3 	bl	80051f0 <chSysUnlock.lto_priv.46>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005c0a:	9b02      	ldr	r3, [sp, #8]
 8005c0c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c10:	bf0c      	ite	eq
 8005c12:	2301      	moveq	r3, #1
 8005c14:	2300      	movne	r3, #0
 8005c16:	b2db      	uxtb	r3, r3
 8005c18:	4938      	ldr	r1, [pc, #224]	; (8005cfc <oslib_test_001_003_execute.lto_priv.717+0x17c>)
 8005c1a:	4618      	mov	r0, r3
 8005c1c:	f00f fc30 	bl	8015480 <_test_assert>
 8005c20:	4603      	mov	r3, r0
 8005c22:	2b00      	cmp	r3, #0
 8005c24:	d162      	bne.n	8005cec <oslib_test_001_003_execute.lto_priv.717+0x16c>
    msg1 = chMBPostAheadTimeout(&mb1, 'X', 1);
 8005c26:	2201      	movs	r2, #1
 8005c28:	2158      	movs	r1, #88	; 0x58
 8005c2a:	4833      	ldr	r0, [pc, #204]	; (8005cf8 <oslib_test_001_003_execute.lto_priv.717+0x178>)
 8005c2c:	f00c ff00 	bl	8012a30 <chMBPostAheadTimeout>
 8005c30:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005c32:	9b02      	ldr	r3, [sp, #8]
 8005c34:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c38:	bf0c      	ite	eq
 8005c3a:	2301      	moveq	r3, #1
 8005c3c:	2300      	movne	r3, #0
 8005c3e:	b2db      	uxtb	r3, r3
 8005c40:	492e      	ldr	r1, [pc, #184]	; (8005cfc <oslib_test_001_003_execute.lto_priv.717+0x17c>)
 8005c42:	4618      	mov	r0, r3
 8005c44:	f00f fc1c 	bl	8015480 <_test_assert>
 8005c48:	4603      	mov	r3, r0
 8005c4a:	2b00      	cmp	r3, #0
 8005c4c:	d14e      	bne.n	8005cec <oslib_test_001_003_execute.lto_priv.717+0x16c>
    chSysLock();
 8005c4e:	f7ff fac7 	bl	80051e0 <chSysLock.lto_priv.82>
    msg1 = chMBPostAheadI(&mb1, 'X');
 8005c52:	2158      	movs	r1, #88	; 0x58
 8005c54:	4828      	ldr	r0, [pc, #160]	; (8005cf8 <oslib_test_001_003_execute.lto_priv.717+0x178>)
 8005c56:	f00c ff53 	bl	8012b00 <chMBPostAheadI>
 8005c5a:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 8005c5c:	f7ff fac8 	bl	80051f0 <chSysUnlock.lto_priv.46>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005c60:	9b02      	ldr	r3, [sp, #8]
 8005c62:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c66:	bf0c      	ite	eq
 8005c68:	2301      	moveq	r3, #1
 8005c6a:	2300      	movne	r3, #0
 8005c6c:	b2db      	uxtb	r3, r3
 8005c6e:	4923      	ldr	r1, [pc, #140]	; (8005cfc <oslib_test_001_003_execute.lto_priv.717+0x17c>)
 8005c70:	4618      	mov	r0, r3
 8005c72:	f00f fc05 	bl	8015480 <_test_assert>
 8005c76:	4603      	mov	r3, r0
 8005c78:	2b00      	cmp	r3, #0
 8005c7a:	d137      	bne.n	8005cec <oslib_test_001_003_execute.lto_priv.717+0x16c>
  }

  /* [1.3.3] Resetting the mailbox. The mailbox is then returned in
     active state.*/
  test_set_step(3);
 8005c7c:	4b1d      	ldr	r3, [pc, #116]	; (8005cf4 <oslib_test_001_003_execute.lto_priv.717+0x174>)
 8005c7e:	2203      	movs	r2, #3
 8005c80:	601a      	str	r2, [r3, #0]
  {
    chMBReset(&mb1);
 8005c82:	481d      	ldr	r0, [pc, #116]	; (8005cf8 <oslib_test_001_003_execute.lto_priv.717+0x178>)
 8005c84:	f00c fdec 	bl	8012860 <chMBReset>
    chMBResumeX(&mb1);
 8005c88:	481b      	ldr	r0, [pc, #108]	; (8005cf8 <oslib_test_001_003_execute.lto_priv.717+0x178>)
 8005c8a:	f7ff fb09 	bl	80052a0 <chMBResumeX>
  }

  /* [1.3.4] Testing chMBFetchTimeout() and chMBFetchI() timeout.*/
  test_set_step(4);
 8005c8e:	4b19      	ldr	r3, [pc, #100]	; (8005cf4 <oslib_test_001_003_execute.lto_priv.717+0x174>)
 8005c90:	2204      	movs	r2, #4
 8005c92:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
 8005c94:	ab01      	add	r3, sp, #4
 8005c96:	2201      	movs	r2, #1
 8005c98:	4619      	mov	r1, r3
 8005c9a:	4817      	ldr	r0, [pc, #92]	; (8005cf8 <oslib_test_001_003_execute.lto_priv.717+0x178>)
 8005c9c:	f00c ff78 	bl	8012b90 <chMBFetchTimeout>
 8005ca0:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005ca2:	9b02      	ldr	r3, [sp, #8]
 8005ca4:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005ca8:	bf0c      	ite	eq
 8005caa:	2301      	moveq	r3, #1
 8005cac:	2300      	movne	r3, #0
 8005cae:	b2db      	uxtb	r3, r3
 8005cb0:	4912      	ldr	r1, [pc, #72]	; (8005cfc <oslib_test_001_003_execute.lto_priv.717+0x17c>)
 8005cb2:	4618      	mov	r0, r3
 8005cb4:	f00f fbe4 	bl	8015480 <_test_assert>
 8005cb8:	4603      	mov	r3, r0
 8005cba:	2b00      	cmp	r3, #0
 8005cbc:	d116      	bne.n	8005cec <oslib_test_001_003_execute.lto_priv.717+0x16c>
    chSysLock();
 8005cbe:	f7ff fa8f 	bl	80051e0 <chSysLock.lto_priv.82>
    msg1 = chMBFetchI(&mb1, &msg2);
 8005cc2:	ab01      	add	r3, sp, #4
 8005cc4:	4619      	mov	r1, r3
 8005cc6:	480c      	ldr	r0, [pc, #48]	; (8005cf8 <oslib_test_001_003_execute.lto_priv.717+0x178>)
 8005cc8:	f00c ffca 	bl	8012c60 <chMBFetchI>
 8005ccc:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 8005cce:	f7ff fa8f 	bl	80051f0 <chSysUnlock.lto_priv.46>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005cd2:	9b02      	ldr	r3, [sp, #8]
 8005cd4:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005cd8:	bf0c      	ite	eq
 8005cda:	2301      	moveq	r3, #1
 8005cdc:	2300      	movne	r3, #0
 8005cde:	b2db      	uxtb	r3, r3
 8005ce0:	4906      	ldr	r1, [pc, #24]	; (8005cfc <oslib_test_001_003_execute.lto_priv.717+0x17c>)
 8005ce2:	4618      	mov	r0, r3
 8005ce4:	f00f fbcc 	bl	8015480 <_test_assert>
 8005ce8:	4603      	mov	r3, r0
 8005cea:	2b00      	cmp	r3, #0
  }
}
 8005cec:	b005      	add	sp, #20
 8005cee:	f85d fb04 	ldr.w	pc, [sp], #4
 8005cf2:	bf00      	nop
 8005cf4:	20001988 	.word	0x20001988
 8005cf8:	20000878 	.word	0x20000878
 8005cfc:	080180b8 	.word	0x080180b8

08005d00 <chPipeResume>:
 *
 * @param[in] pp        the pointer to an initialized @p pipe_t object
 *
 * @api
 */
static inline void chPipeResume(pipe_t *pp) {
 8005d00:	b082      	sub	sp, #8
 8005d02:	9001      	str	r0, [sp, #4]

  pp->reset = false;
 8005d04:	9b01      	ldr	r3, [sp, #4]
 8005d06:	2200      	movs	r2, #0
 8005d08:	751a      	strb	r2, [r3, #20]
}
 8005d0a:	b002      	add	sp, #8
 8005d0c:	4770      	bx	lr
 8005d0e:	bf00      	nop

08005d10 <oslib_test_002_001_setup.lto_priv.718>:
 * - [2.1.13] Write wrapping buffer boundary.
 * - [2.1.14] Read wrapping buffer boundary.
 * .
 */

static void oslib_test_002_001_setup(void) {
 8005d10:	b508      	push	{r3, lr}
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE);
 8005d12:	2210      	movs	r2, #16
 8005d14:	4902      	ldr	r1, [pc, #8]	; (8005d20 <oslib_test_002_001_setup.lto_priv.718+0x10>)
 8005d16:	4803      	ldr	r0, [pc, #12]	; (8005d24 <oslib_test_002_001_setup.lto_priv.718+0x14>)
 8005d18:	f00d fdca 	bl	80138b0 <chPipeObjectInit>
}
 8005d1c:	bd08      	pop	{r3, pc}
 8005d1e:	bf00      	nop
 8005d20:	200020bc 	.word	0x200020bc
 8005d24:	200008a0 	.word	0x200008a0
	...

08005d30 <oslib_test_002_001_execute.lto_priv.719>:

static void oslib_test_002_001_execute(void) {
 8005d30:	b500      	push	{lr}
 8005d32:	b0a5      	sub	sp, #148	; 0x94

  /* [2.1.1] Resetting pipe.*/
  test_set_step(1);
 8005d34:	4b89      	ldr	r3, [pc, #548]	; (8005f5c <oslib_test_002_001_execute.lto_priv.719+0x22c>)
 8005d36:	2201      	movs	r2, #1
 8005d38:	601a      	str	r2, [r3, #0]
  {
    chPipeReset(&pipe1);
 8005d3a:	4889      	ldr	r0, [pc, #548]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005d3c:	f00d fdf8 	bl	8013930 <chPipeReset>

    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8005d40:	4b87      	ldr	r3, [pc, #540]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005d42:	68da      	ldr	r2, [r3, #12]
 8005d44:	4b86      	ldr	r3, [pc, #536]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005d46:	681b      	ldr	r3, [r3, #0]
 8005d48:	429a      	cmp	r2, r3
 8005d4a:	d10b      	bne.n	8005d64 <oslib_test_002_001_execute.lto_priv.719+0x34>
 8005d4c:	4b84      	ldr	r3, [pc, #528]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005d4e:	689a      	ldr	r2, [r3, #8]
 8005d50:	4b83      	ldr	r3, [pc, #524]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005d52:	681b      	ldr	r3, [r3, #0]
 8005d54:	429a      	cmp	r2, r3
 8005d56:	d105      	bne.n	8005d64 <oslib_test_002_001_execute.lto_priv.719+0x34>
 8005d58:	4b81      	ldr	r3, [pc, #516]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005d5a:	691b      	ldr	r3, [r3, #16]
 8005d5c:	2b00      	cmp	r3, #0
 8005d5e:	d101      	bne.n	8005d64 <oslib_test_002_001_execute.lto_priv.719+0x34>
 8005d60:	2301      	movs	r3, #1
 8005d62:	e000      	b.n	8005d66 <oslib_test_002_001_execute.lto_priv.719+0x36>
 8005d64:	2300      	movs	r3, #0
 8005d66:	f003 0301 	and.w	r3, r3, #1
 8005d6a:	b2db      	uxtb	r3, r3
 8005d6c:	497d      	ldr	r1, [pc, #500]	; (8005f64 <oslib_test_002_001_execute.lto_priv.719+0x234>)
 8005d6e:	4618      	mov	r0, r3
 8005d70:	f00f fb86 	bl	8015480 <_test_assert>
 8005d74:	4603      	mov	r3, r0
 8005d76:	2b00      	cmp	r3, #0
 8005d78:	f040 832c 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
                (pipe1.cnt == 0),
                "invalid pipe state");
  }

  /* [2.1.2] Writing data, must fail.*/
  test_set_step(2);
 8005d7c:	4b77      	ldr	r3, [pc, #476]	; (8005f5c <oslib_test_002_001_execute.lto_priv.719+0x22c>)
 8005d7e:	2202      	movs	r2, #2
 8005d80:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8005d82:	2300      	movs	r3, #0
 8005d84:	2210      	movs	r2, #16
 8005d86:	4978      	ldr	r1, [pc, #480]	; (8005f68 <oslib_test_002_001_execute.lto_priv.719+0x238>)
 8005d88:	4875      	ldr	r0, [pc, #468]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005d8a:	f00d fe11 	bl	80139b0 <chPipeWriteTimeout>
 8005d8e:	9023      	str	r0, [sp, #140]	; 0x8c
    test_assert(n == 0, "not reset");
 8005d90:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8005d92:	2b00      	cmp	r3, #0
 8005d94:	bf0c      	ite	eq
 8005d96:	2301      	moveq	r3, #1
 8005d98:	2300      	movne	r3, #0
 8005d9a:	b2db      	uxtb	r3, r3
 8005d9c:	4973      	ldr	r1, [pc, #460]	; (8005f6c <oslib_test_002_001_execute.lto_priv.719+0x23c>)
 8005d9e:	4618      	mov	r0, r3
 8005da0:	f00f fb6e 	bl	8015480 <_test_assert>
 8005da4:	4603      	mov	r3, r0
 8005da6:	2b00      	cmp	r3, #0
 8005da8:	f040 8314 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8005dac:	4b6c      	ldr	r3, [pc, #432]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005dae:	68da      	ldr	r2, [r3, #12]
 8005db0:	4b6b      	ldr	r3, [pc, #428]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005db2:	681b      	ldr	r3, [r3, #0]
 8005db4:	429a      	cmp	r2, r3
 8005db6:	d10b      	bne.n	8005dd0 <oslib_test_002_001_execute.lto_priv.719+0xa0>
 8005db8:	4b69      	ldr	r3, [pc, #420]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005dba:	689a      	ldr	r2, [r3, #8]
 8005dbc:	4b68      	ldr	r3, [pc, #416]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005dbe:	681b      	ldr	r3, [r3, #0]
 8005dc0:	429a      	cmp	r2, r3
 8005dc2:	d105      	bne.n	8005dd0 <oslib_test_002_001_execute.lto_priv.719+0xa0>
 8005dc4:	4b66      	ldr	r3, [pc, #408]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005dc6:	691b      	ldr	r3, [r3, #16]
 8005dc8:	2b00      	cmp	r3, #0
 8005dca:	d101      	bne.n	8005dd0 <oslib_test_002_001_execute.lto_priv.719+0xa0>
 8005dcc:	2301      	movs	r3, #1
 8005dce:	e000      	b.n	8005dd2 <oslib_test_002_001_execute.lto_priv.719+0xa2>
 8005dd0:	2300      	movs	r3, #0
 8005dd2:	f003 0301 	and.w	r3, r3, #1
 8005dd6:	b2db      	uxtb	r3, r3
 8005dd8:	4962      	ldr	r1, [pc, #392]	; (8005f64 <oslib_test_002_001_execute.lto_priv.719+0x234>)
 8005dda:	4618      	mov	r0, r3
 8005ddc:	f00f fb50 	bl	8015480 <_test_assert>
 8005de0:	4603      	mov	r3, r0
 8005de2:	2b00      	cmp	r3, #0
 8005de4:	f040 82f6 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
                (pipe1.cnt == 0),
                "invalid pipe state");
  }

  /* [2.1.3] Reading data, must fail.*/
  test_set_step(3);
 8005de8:	4b5c      	ldr	r3, [pc, #368]	; (8005f5c <oslib_test_002_001_execute.lto_priv.719+0x22c>)
 8005dea:	2203      	movs	r2, #3
 8005dec:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8005dee:	4669      	mov	r1, sp
 8005df0:	2300      	movs	r3, #0
 8005df2:	2210      	movs	r2, #16
 8005df4:	485a      	ldr	r0, [pc, #360]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005df6:	f00d fe33 	bl	8013a60 <chPipeReadTimeout>
 8005dfa:	9022      	str	r0, [sp, #136]	; 0x88
    test_assert(n == 0, "not reset");
 8005dfc:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8005dfe:	2b00      	cmp	r3, #0
 8005e00:	bf0c      	ite	eq
 8005e02:	2301      	moveq	r3, #1
 8005e04:	2300      	movne	r3, #0
 8005e06:	b2db      	uxtb	r3, r3
 8005e08:	4958      	ldr	r1, [pc, #352]	; (8005f6c <oslib_test_002_001_execute.lto_priv.719+0x23c>)
 8005e0a:	4618      	mov	r0, r3
 8005e0c:	f00f fb38 	bl	8015480 <_test_assert>
 8005e10:	4603      	mov	r3, r0
 8005e12:	2b00      	cmp	r3, #0
 8005e14:	f040 82d5 	bne.w	80063c2 <oslib_test_002_001_execute.lto_priv.719+0x692>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8005e18:	4b51      	ldr	r3, [pc, #324]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e1a:	68da      	ldr	r2, [r3, #12]
 8005e1c:	4b50      	ldr	r3, [pc, #320]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e1e:	681b      	ldr	r3, [r3, #0]
 8005e20:	429a      	cmp	r2, r3
 8005e22:	d10b      	bne.n	8005e3c <oslib_test_002_001_execute.lto_priv.719+0x10c>
 8005e24:	4b4e      	ldr	r3, [pc, #312]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e26:	689a      	ldr	r2, [r3, #8]
 8005e28:	4b4d      	ldr	r3, [pc, #308]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e2a:	681b      	ldr	r3, [r3, #0]
 8005e2c:	429a      	cmp	r2, r3
 8005e2e:	d105      	bne.n	8005e3c <oslib_test_002_001_execute.lto_priv.719+0x10c>
 8005e30:	4b4b      	ldr	r3, [pc, #300]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e32:	691b      	ldr	r3, [r3, #16]
 8005e34:	2b00      	cmp	r3, #0
 8005e36:	d101      	bne.n	8005e3c <oslib_test_002_001_execute.lto_priv.719+0x10c>
 8005e38:	2301      	movs	r3, #1
 8005e3a:	e000      	b.n	8005e3e <oslib_test_002_001_execute.lto_priv.719+0x10e>
 8005e3c:	2300      	movs	r3, #0
 8005e3e:	f003 0301 	and.w	r3, r3, #1
 8005e42:	b2db      	uxtb	r3, r3
 8005e44:	4947      	ldr	r1, [pc, #284]	; (8005f64 <oslib_test_002_001_execute.lto_priv.719+0x234>)
 8005e46:	4618      	mov	r0, r3
 8005e48:	f00f fb1a 	bl	8015480 <_test_assert>
 8005e4c:	4603      	mov	r3, r0
 8005e4e:	2b00      	cmp	r3, #0
 8005e50:	f040 82b7 	bne.w	80063c2 <oslib_test_002_001_execute.lto_priv.719+0x692>
                (pipe1.cnt == 0),
                "invalid pipe state");
  }

  /* [2.1.4] Reactivating pipe.*/
  test_set_step(4);
 8005e54:	4b41      	ldr	r3, [pc, #260]	; (8005f5c <oslib_test_002_001_execute.lto_priv.719+0x22c>)
 8005e56:	2204      	movs	r2, #4
 8005e58:	601a      	str	r2, [r3, #0]
  {
    chPipeResume(&pipe1);
 8005e5a:	4841      	ldr	r0, [pc, #260]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e5c:	f7ff ff50 	bl	8005d00 <chPipeResume>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8005e60:	4b3f      	ldr	r3, [pc, #252]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e62:	68da      	ldr	r2, [r3, #12]
 8005e64:	4b3e      	ldr	r3, [pc, #248]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e66:	681b      	ldr	r3, [r3, #0]
 8005e68:	429a      	cmp	r2, r3
 8005e6a:	d10b      	bne.n	8005e84 <oslib_test_002_001_execute.lto_priv.719+0x154>
 8005e6c:	4b3c      	ldr	r3, [pc, #240]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e6e:	689a      	ldr	r2, [r3, #8]
 8005e70:	4b3b      	ldr	r3, [pc, #236]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e72:	681b      	ldr	r3, [r3, #0]
 8005e74:	429a      	cmp	r2, r3
 8005e76:	d105      	bne.n	8005e84 <oslib_test_002_001_execute.lto_priv.719+0x154>
 8005e78:	4b39      	ldr	r3, [pc, #228]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005e7a:	691b      	ldr	r3, [r3, #16]
 8005e7c:	2b00      	cmp	r3, #0
 8005e7e:	d101      	bne.n	8005e84 <oslib_test_002_001_execute.lto_priv.719+0x154>
 8005e80:	2301      	movs	r3, #1
 8005e82:	e000      	b.n	8005e86 <oslib_test_002_001_execute.lto_priv.719+0x156>
 8005e84:	2300      	movs	r3, #0
 8005e86:	f003 0301 	and.w	r3, r3, #1
 8005e8a:	b2db      	uxtb	r3, r3
 8005e8c:	4935      	ldr	r1, [pc, #212]	; (8005f64 <oslib_test_002_001_execute.lto_priv.719+0x234>)
 8005e8e:	4618      	mov	r0, r3
 8005e90:	f00f faf6 	bl	8015480 <_test_assert>
 8005e94:	4603      	mov	r3, r0
 8005e96:	2b00      	cmp	r3, #0
 8005e98:	f040 829c 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
                (pipe1.cnt == 0),
                "invalid pipe state");
  }

  /* [2.1.5] Filling whole pipe.*/
  test_set_step(5);
 8005e9c:	4b2f      	ldr	r3, [pc, #188]	; (8005f5c <oslib_test_002_001_execute.lto_priv.719+0x22c>)
 8005e9e:	2205      	movs	r2, #5
 8005ea0:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8005ea2:	2300      	movs	r3, #0
 8005ea4:	2210      	movs	r2, #16
 8005ea6:	4930      	ldr	r1, [pc, #192]	; (8005f68 <oslib_test_002_001_execute.lto_priv.719+0x238>)
 8005ea8:	482d      	ldr	r0, [pc, #180]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005eaa:	f00d fd81 	bl	80139b0 <chPipeWriteTimeout>
 8005eae:	9021      	str	r0, [sp, #132]	; 0x84
    test_assert(n == PIPE_SIZE, "wrong size");
 8005eb0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8005eb2:	2b10      	cmp	r3, #16
 8005eb4:	bf0c      	ite	eq
 8005eb6:	2301      	moveq	r3, #1
 8005eb8:	2300      	movne	r3, #0
 8005eba:	b2db      	uxtb	r3, r3
 8005ebc:	492c      	ldr	r1, [pc, #176]	; (8005f70 <oslib_test_002_001_execute.lto_priv.719+0x240>)
 8005ebe:	4618      	mov	r0, r3
 8005ec0:	f00f fade 	bl	8015480 <_test_assert>
 8005ec4:	4603      	mov	r3, r0
 8005ec6:	2b00      	cmp	r3, #0
 8005ec8:	f040 8284 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8005ecc:	4b24      	ldr	r3, [pc, #144]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005ece:	68da      	ldr	r2, [r3, #12]
 8005ed0:	4b23      	ldr	r3, [pc, #140]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005ed2:	681b      	ldr	r3, [r3, #0]
 8005ed4:	429a      	cmp	r2, r3
 8005ed6:	d10b      	bne.n	8005ef0 <oslib_test_002_001_execute.lto_priv.719+0x1c0>
 8005ed8:	4b21      	ldr	r3, [pc, #132]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005eda:	689a      	ldr	r2, [r3, #8]
 8005edc:	4b20      	ldr	r3, [pc, #128]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005ede:	681b      	ldr	r3, [r3, #0]
 8005ee0:	429a      	cmp	r2, r3
 8005ee2:	d105      	bne.n	8005ef0 <oslib_test_002_001_execute.lto_priv.719+0x1c0>
 8005ee4:	4b1e      	ldr	r3, [pc, #120]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005ee6:	691b      	ldr	r3, [r3, #16]
 8005ee8:	2b10      	cmp	r3, #16
 8005eea:	d101      	bne.n	8005ef0 <oslib_test_002_001_execute.lto_priv.719+0x1c0>
 8005eec:	2301      	movs	r3, #1
 8005eee:	e000      	b.n	8005ef2 <oslib_test_002_001_execute.lto_priv.719+0x1c2>
 8005ef0:	2300      	movs	r3, #0
 8005ef2:	f003 0301 	and.w	r3, r3, #1
 8005ef6:	b2db      	uxtb	r3, r3
 8005ef8:	491a      	ldr	r1, [pc, #104]	; (8005f64 <oslib_test_002_001_execute.lto_priv.719+0x234>)
 8005efa:	4618      	mov	r0, r3
 8005efc:	f00f fac0 	bl	8015480 <_test_assert>
 8005f00:	4603      	mov	r3, r0
 8005f02:	2b00      	cmp	r3, #0
 8005f04:	f040 8266 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
                (pipe1.cnt == PIPE_SIZE),
                "invalid pipe state");
  }

  /* [2.1.6] Emptying pipe.*/
  test_set_step(6);
 8005f08:	4b14      	ldr	r3, [pc, #80]	; (8005f5c <oslib_test_002_001_execute.lto_priv.719+0x22c>)
 8005f0a:	2206      	movs	r2, #6
 8005f0c:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8005f0e:	a904      	add	r1, sp, #16
 8005f10:	2300      	movs	r3, #0
 8005f12:	2210      	movs	r2, #16
 8005f14:	4812      	ldr	r0, [pc, #72]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005f16:	f00d fda3 	bl	8013a60 <chPipeReadTimeout>
 8005f1a:	9020      	str	r0, [sp, #128]	; 0x80
    test_assert(n == PIPE_SIZE, "wrong size");
 8005f1c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8005f1e:	2b10      	cmp	r3, #16
 8005f20:	bf0c      	ite	eq
 8005f22:	2301      	moveq	r3, #1
 8005f24:	2300      	movne	r3, #0
 8005f26:	b2db      	uxtb	r3, r3
 8005f28:	4911      	ldr	r1, [pc, #68]	; (8005f70 <oslib_test_002_001_execute.lto_priv.719+0x240>)
 8005f2a:	4618      	mov	r0, r3
 8005f2c:	f00f faa8 	bl	8015480 <_test_assert>
 8005f30:	4603      	mov	r3, r0
 8005f32:	2b00      	cmp	r3, #0
 8005f34:	f040 8247 	bne.w	80063c6 <oslib_test_002_001_execute.lto_priv.719+0x696>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8005f38:	4b09      	ldr	r3, [pc, #36]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005f3a:	68da      	ldr	r2, [r3, #12]
 8005f3c:	4b08      	ldr	r3, [pc, #32]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005f3e:	681b      	ldr	r3, [r3, #0]
 8005f40:	429a      	cmp	r2, r3
 8005f42:	d117      	bne.n	8005f74 <oslib_test_002_001_execute.lto_priv.719+0x244>
 8005f44:	4b06      	ldr	r3, [pc, #24]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005f46:	689a      	ldr	r2, [r3, #8]
 8005f48:	4b05      	ldr	r3, [pc, #20]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005f4a:	681b      	ldr	r3, [r3, #0]
 8005f4c:	429a      	cmp	r2, r3
 8005f4e:	d111      	bne.n	8005f74 <oslib_test_002_001_execute.lto_priv.719+0x244>
 8005f50:	4b03      	ldr	r3, [pc, #12]	; (8005f60 <oslib_test_002_001_execute.lto_priv.719+0x230>)
 8005f52:	691b      	ldr	r3, [r3, #16]
 8005f54:	2b00      	cmp	r3, #0
 8005f56:	d10d      	bne.n	8005f74 <oslib_test_002_001_execute.lto_priv.719+0x244>
 8005f58:	2301      	movs	r3, #1
 8005f5a:	e00c      	b.n	8005f76 <oslib_test_002_001_execute.lto_priv.719+0x246>
 8005f5c:	20001988 	.word	0x20001988
 8005f60:	200008a0 	.word	0x200008a0
 8005f64:	08018880 	.word	0x08018880
 8005f68:	0801886c 	.word	0x0801886c
 8005f6c:	08018894 	.word	0x08018894
 8005f70:	08018754 	.word	0x08018754
 8005f74:	2300      	movs	r3, #0
 8005f76:	f003 0301 	and.w	r3, r3, #1
 8005f7a:	b2db      	uxtb	r3, r3
 8005f7c:	49a2      	ldr	r1, [pc, #648]	; (8006208 <oslib_test_002_001_execute.lto_priv.719+0x4d8>)
 8005f7e:	4618      	mov	r0, r3
 8005f80:	f00f fa7e 	bl	8015480 <_test_assert>
 8005f84:	4603      	mov	r3, r0
 8005f86:	2b00      	cmp	r3, #0
 8005f88:	f040 821d 	bne.w	80063c6 <oslib_test_002_001_execute.lto_priv.719+0x696>
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == 0),
                "invalid pipe state");
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
 8005f8c:	ab04      	add	r3, sp, #16
 8005f8e:	2210      	movs	r2, #16
 8005f90:	4619      	mov	r1, r3
 8005f92:	489e      	ldr	r0, [pc, #632]	; (800620c <oslib_test_002_001_execute.lto_priv.719+0x4dc>)
 8005f94:	f00f fb72 	bl	801567c <memcmp>
 8005f98:	4603      	mov	r3, r0
 8005f9a:	2b00      	cmp	r3, #0
 8005f9c:	bf0c      	ite	eq
 8005f9e:	2301      	moveq	r3, #1
 8005fa0:	2300      	movne	r3, #0
 8005fa2:	b2db      	uxtb	r3, r3
 8005fa4:	499a      	ldr	r1, [pc, #616]	; (8006210 <oslib_test_002_001_execute.lto_priv.719+0x4e0>)
 8005fa6:	4618      	mov	r0, r3
 8005fa8:	f00f fa6a 	bl	8015480 <_test_assert>
 8005fac:	4603      	mov	r3, r0
 8005fae:	2b00      	cmp	r3, #0
 8005fb0:	f040 8209 	bne.w	80063c6 <oslib_test_002_001_execute.lto_priv.719+0x696>
  }

  /* [2.1.7] Small write.*/
  test_set_step(7);
 8005fb4:	4b97      	ldr	r3, [pc, #604]	; (8006214 <oslib_test_002_001_execute.lto_priv.719+0x4e4>)
 8005fb6:	2207      	movs	r2, #7
 8005fb8:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 4, TIME_IMMEDIATE);
 8005fba:	2300      	movs	r3, #0
 8005fbc:	2204      	movs	r2, #4
 8005fbe:	4993      	ldr	r1, [pc, #588]	; (800620c <oslib_test_002_001_execute.lto_priv.719+0x4dc>)
 8005fc0:	4895      	ldr	r0, [pc, #596]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8005fc2:	f00d fcf5 	bl	80139b0 <chPipeWriteTimeout>
 8005fc6:	901f      	str	r0, [sp, #124]	; 0x7c
    test_assert(n == 4, "wrong size");
 8005fc8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8005fca:	2b04      	cmp	r3, #4
 8005fcc:	bf0c      	ite	eq
 8005fce:	2301      	moveq	r3, #1
 8005fd0:	2300      	movne	r3, #0
 8005fd2:	b2db      	uxtb	r3, r3
 8005fd4:	4991      	ldr	r1, [pc, #580]	; (800621c <oslib_test_002_001_execute.lto_priv.719+0x4ec>)
 8005fd6:	4618      	mov	r0, r3
 8005fd8:	f00f fa52 	bl	8015480 <_test_assert>
 8005fdc:	4603      	mov	r3, r0
 8005fde:	2b00      	cmp	r3, #0
 8005fe0:	f040 81f8 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
 8005fe4:	4b8c      	ldr	r3, [pc, #560]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8005fe6:	68da      	ldr	r2, [r3, #12]
 8005fe8:	4b8b      	ldr	r3, [pc, #556]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8005fea:	689b      	ldr	r3, [r3, #8]
 8005fec:	429a      	cmp	r2, r3
 8005fee:	d00b      	beq.n	8006008 <oslib_test_002_001_execute.lto_priv.719+0x2d8>
 8005ff0:	4b89      	ldr	r3, [pc, #548]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8005ff2:	68da      	ldr	r2, [r3, #12]
 8005ff4:	4b88      	ldr	r3, [pc, #544]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8005ff6:	681b      	ldr	r3, [r3, #0]
 8005ff8:	429a      	cmp	r2, r3
 8005ffa:	d105      	bne.n	8006008 <oslib_test_002_001_execute.lto_priv.719+0x2d8>
 8005ffc:	4b86      	ldr	r3, [pc, #536]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8005ffe:	691b      	ldr	r3, [r3, #16]
 8006000:	2b04      	cmp	r3, #4
 8006002:	d101      	bne.n	8006008 <oslib_test_002_001_execute.lto_priv.719+0x2d8>
 8006004:	2301      	movs	r3, #1
 8006006:	e000      	b.n	800600a <oslib_test_002_001_execute.lto_priv.719+0x2da>
 8006008:	2300      	movs	r3, #0
 800600a:	f003 0301 	and.w	r3, r3, #1
 800600e:	b2db      	uxtb	r3, r3
 8006010:	497d      	ldr	r1, [pc, #500]	; (8006208 <oslib_test_002_001_execute.lto_priv.719+0x4d8>)
 8006012:	4618      	mov	r0, r3
 8006014:	f00f fa34 	bl	8015480 <_test_assert>
 8006018:	4603      	mov	r3, r0
 800601a:	2b00      	cmp	r3, #0
 800601c:	f040 81da 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
                (pipe1.cnt == 4),
                "invalid pipe state");
  }

  /* [2.1.8] Filling remaining space.*/
  test_set_step(8);
 8006020:	4b7c      	ldr	r3, [pc, #496]	; (8006214 <oslib_test_002_001_execute.lto_priv.719+0x4e4>)
 8006022:	2208      	movs	r2, #8
 8006024:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE - 4, TIME_IMMEDIATE);
 8006026:	2300      	movs	r3, #0
 8006028:	220c      	movs	r2, #12
 800602a:	4978      	ldr	r1, [pc, #480]	; (800620c <oslib_test_002_001_execute.lto_priv.719+0x4dc>)
 800602c:	487a      	ldr	r0, [pc, #488]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 800602e:	f00d fcbf 	bl	80139b0 <chPipeWriteTimeout>
 8006032:	901e      	str	r0, [sp, #120]	; 0x78
    test_assert(n == PIPE_SIZE - 4, "wrong size");
 8006034:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8006036:	2b0c      	cmp	r3, #12
 8006038:	bf0c      	ite	eq
 800603a:	2301      	moveq	r3, #1
 800603c:	2300      	movne	r3, #0
 800603e:	b2db      	uxtb	r3, r3
 8006040:	4976      	ldr	r1, [pc, #472]	; (800621c <oslib_test_002_001_execute.lto_priv.719+0x4ec>)
 8006042:	4618      	mov	r0, r3
 8006044:	f00f fa1c 	bl	8015480 <_test_assert>
 8006048:	4603      	mov	r3, r0
 800604a:	2b00      	cmp	r3, #0
 800604c:	f040 81c2 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006050:	4b71      	ldr	r3, [pc, #452]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8006052:	68da      	ldr	r2, [r3, #12]
 8006054:	4b70      	ldr	r3, [pc, #448]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8006056:	681b      	ldr	r3, [r3, #0]
 8006058:	429a      	cmp	r2, r3
 800605a:	d10b      	bne.n	8006074 <oslib_test_002_001_execute.lto_priv.719+0x344>
 800605c:	4b6e      	ldr	r3, [pc, #440]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 800605e:	689a      	ldr	r2, [r3, #8]
 8006060:	4b6d      	ldr	r3, [pc, #436]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8006062:	681b      	ldr	r3, [r3, #0]
 8006064:	429a      	cmp	r2, r3
 8006066:	d105      	bne.n	8006074 <oslib_test_002_001_execute.lto_priv.719+0x344>
 8006068:	4b6b      	ldr	r3, [pc, #428]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 800606a:	691b      	ldr	r3, [r3, #16]
 800606c:	2b10      	cmp	r3, #16
 800606e:	d101      	bne.n	8006074 <oslib_test_002_001_execute.lto_priv.719+0x344>
 8006070:	2301      	movs	r3, #1
 8006072:	e000      	b.n	8006076 <oslib_test_002_001_execute.lto_priv.719+0x346>
 8006074:	2300      	movs	r3, #0
 8006076:	f003 0301 	and.w	r3, r3, #1
 800607a:	b2db      	uxtb	r3, r3
 800607c:	4962      	ldr	r1, [pc, #392]	; (8006208 <oslib_test_002_001_execute.lto_priv.719+0x4d8>)
 800607e:	4618      	mov	r0, r3
 8006080:	f00f f9fe 	bl	8015480 <_test_assert>
 8006084:	4603      	mov	r3, r0
 8006086:	2b00      	cmp	r3, #0
 8006088:	f040 81a4 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
                (pipe1.cnt == PIPE_SIZE),
                "invalid pipe state");
  }

  /* [2.1.9] Small Read.*/
  test_set_step(9);
 800608c:	4b61      	ldr	r3, [pc, #388]	; (8006214 <oslib_test_002_001_execute.lto_priv.719+0x4e4>)
 800608e:	2209      	movs	r2, #9
 8006090:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, 4, TIME_IMMEDIATE);
 8006092:	a908      	add	r1, sp, #32
 8006094:	2300      	movs	r3, #0
 8006096:	2204      	movs	r2, #4
 8006098:	485f      	ldr	r0, [pc, #380]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 800609a:	f00d fce1 	bl	8013a60 <chPipeReadTimeout>
 800609e:	901d      	str	r0, [sp, #116]	; 0x74
    test_assert(n == 4, "wrong size");
 80060a0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80060a2:	2b04      	cmp	r3, #4
 80060a4:	bf0c      	ite	eq
 80060a6:	2301      	moveq	r3, #1
 80060a8:	2300      	movne	r3, #0
 80060aa:	b2db      	uxtb	r3, r3
 80060ac:	495b      	ldr	r1, [pc, #364]	; (800621c <oslib_test_002_001_execute.lto_priv.719+0x4ec>)
 80060ae:	4618      	mov	r0, r3
 80060b0:	f00f f9e6 	bl	8015480 <_test_assert>
 80060b4:	4603      	mov	r3, r0
 80060b6:	2b00      	cmp	r3, #0
 80060b8:	f040 8187 	bne.w	80063ca <oslib_test_002_001_execute.lto_priv.719+0x69a>
    test_assert((pipe1.rdptr != pipe1.buffer) &&
 80060bc:	4b56      	ldr	r3, [pc, #344]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80060be:	68da      	ldr	r2, [r3, #12]
 80060c0:	4b55      	ldr	r3, [pc, #340]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80060c2:	681b      	ldr	r3, [r3, #0]
 80060c4:	429a      	cmp	r2, r3
 80060c6:	d00b      	beq.n	80060e0 <oslib_test_002_001_execute.lto_priv.719+0x3b0>
 80060c8:	4b53      	ldr	r3, [pc, #332]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80060ca:	689a      	ldr	r2, [r3, #8]
 80060cc:	4b52      	ldr	r3, [pc, #328]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80060ce:	681b      	ldr	r3, [r3, #0]
 80060d0:	429a      	cmp	r2, r3
 80060d2:	d105      	bne.n	80060e0 <oslib_test_002_001_execute.lto_priv.719+0x3b0>
 80060d4:	4b50      	ldr	r3, [pc, #320]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80060d6:	691b      	ldr	r3, [r3, #16]
 80060d8:	2b0c      	cmp	r3, #12
 80060da:	d101      	bne.n	80060e0 <oslib_test_002_001_execute.lto_priv.719+0x3b0>
 80060dc:	2301      	movs	r3, #1
 80060de:	e000      	b.n	80060e2 <oslib_test_002_001_execute.lto_priv.719+0x3b2>
 80060e0:	2300      	movs	r3, #0
 80060e2:	f003 0301 	and.w	r3, r3, #1
 80060e6:	b2db      	uxtb	r3, r3
 80060e8:	4947      	ldr	r1, [pc, #284]	; (8006208 <oslib_test_002_001_execute.lto_priv.719+0x4d8>)
 80060ea:	4618      	mov	r0, r3
 80060ec:	f00f f9c8 	bl	8015480 <_test_assert>
 80060f0:	4603      	mov	r3, r0
 80060f2:	2b00      	cmp	r3, #0
 80060f4:	f040 8169 	bne.w	80063ca <oslib_test_002_001_execute.lto_priv.719+0x69a>
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == PIPE_SIZE - 4),
                "invalid pipe state");
    test_assert(memcmp(pipe_pattern, buf, 4) == 0, "content mismatch");
 80060f8:	ab08      	add	r3, sp, #32
 80060fa:	2204      	movs	r2, #4
 80060fc:	4619      	mov	r1, r3
 80060fe:	4843      	ldr	r0, [pc, #268]	; (800620c <oslib_test_002_001_execute.lto_priv.719+0x4dc>)
 8006100:	f00f fabc 	bl	801567c <memcmp>
 8006104:	4603      	mov	r3, r0
 8006106:	2b00      	cmp	r3, #0
 8006108:	bf0c      	ite	eq
 800610a:	2301      	moveq	r3, #1
 800610c:	2300      	movne	r3, #0
 800610e:	b2db      	uxtb	r3, r3
 8006110:	493f      	ldr	r1, [pc, #252]	; (8006210 <oslib_test_002_001_execute.lto_priv.719+0x4e0>)
 8006112:	4618      	mov	r0, r3
 8006114:	f00f f9b4 	bl	8015480 <_test_assert>
 8006118:	4603      	mov	r3, r0
 800611a:	2b00      	cmp	r3, #0
 800611c:	f040 8155 	bne.w	80063ca <oslib_test_002_001_execute.lto_priv.719+0x69a>
  }

  /* [2.1.10] Reading remaining data.*/
  test_set_step(10);
 8006120:	4b3c      	ldr	r3, [pc, #240]	; (8006214 <oslib_test_002_001_execute.lto_priv.719+0x4e4>)
 8006122:	220a      	movs	r2, #10
 8006124:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE - 4, TIME_IMMEDIATE);
 8006126:	a90c      	add	r1, sp, #48	; 0x30
 8006128:	2300      	movs	r3, #0
 800612a:	220c      	movs	r2, #12
 800612c:	483a      	ldr	r0, [pc, #232]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 800612e:	f00d fc97 	bl	8013a60 <chPipeReadTimeout>
 8006132:	901c      	str	r0, [sp, #112]	; 0x70
    test_assert(n == PIPE_SIZE - 4, "wrong size");
 8006134:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8006136:	2b0c      	cmp	r3, #12
 8006138:	bf0c      	ite	eq
 800613a:	2301      	moveq	r3, #1
 800613c:	2300      	movne	r3, #0
 800613e:	b2db      	uxtb	r3, r3
 8006140:	4936      	ldr	r1, [pc, #216]	; (800621c <oslib_test_002_001_execute.lto_priv.719+0x4ec>)
 8006142:	4618      	mov	r0, r3
 8006144:	f00f f99c 	bl	8015480 <_test_assert>
 8006148:	4603      	mov	r3, r0
 800614a:	2b00      	cmp	r3, #0
 800614c:	f040 813f 	bne.w	80063ce <oslib_test_002_001_execute.lto_priv.719+0x69e>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006150:	4b31      	ldr	r3, [pc, #196]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8006152:	68da      	ldr	r2, [r3, #12]
 8006154:	4b30      	ldr	r3, [pc, #192]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8006156:	681b      	ldr	r3, [r3, #0]
 8006158:	429a      	cmp	r2, r3
 800615a:	d10b      	bne.n	8006174 <oslib_test_002_001_execute.lto_priv.719+0x444>
 800615c:	4b2e      	ldr	r3, [pc, #184]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 800615e:	689a      	ldr	r2, [r3, #8]
 8006160:	4b2d      	ldr	r3, [pc, #180]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 8006162:	681b      	ldr	r3, [r3, #0]
 8006164:	429a      	cmp	r2, r3
 8006166:	d105      	bne.n	8006174 <oslib_test_002_001_execute.lto_priv.719+0x444>
 8006168:	4b2b      	ldr	r3, [pc, #172]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 800616a:	691b      	ldr	r3, [r3, #16]
 800616c:	2b00      	cmp	r3, #0
 800616e:	d101      	bne.n	8006174 <oslib_test_002_001_execute.lto_priv.719+0x444>
 8006170:	2301      	movs	r3, #1
 8006172:	e000      	b.n	8006176 <oslib_test_002_001_execute.lto_priv.719+0x446>
 8006174:	2300      	movs	r3, #0
 8006176:	f003 0301 	and.w	r3, r3, #1
 800617a:	b2db      	uxtb	r3, r3
 800617c:	4922      	ldr	r1, [pc, #136]	; (8006208 <oslib_test_002_001_execute.lto_priv.719+0x4d8>)
 800617e:	4618      	mov	r0, r3
 8006180:	f00f f97e 	bl	8015480 <_test_assert>
 8006184:	4603      	mov	r3, r0
 8006186:	2b00      	cmp	r3, #0
 8006188:	f040 8121 	bne.w	80063ce <oslib_test_002_001_execute.lto_priv.719+0x69e>
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == 0),
                "invalid pipe state");
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE - 4) == 0, "content mismatch");
 800618c:	ab0c      	add	r3, sp, #48	; 0x30
 800618e:	220c      	movs	r2, #12
 8006190:	4619      	mov	r1, r3
 8006192:	481e      	ldr	r0, [pc, #120]	; (800620c <oslib_test_002_001_execute.lto_priv.719+0x4dc>)
 8006194:	f00f fa72 	bl	801567c <memcmp>
 8006198:	4603      	mov	r3, r0
 800619a:	2b00      	cmp	r3, #0
 800619c:	bf0c      	ite	eq
 800619e:	2301      	moveq	r3, #1
 80061a0:	2300      	movne	r3, #0
 80061a2:	b2db      	uxtb	r3, r3
 80061a4:	491a      	ldr	r1, [pc, #104]	; (8006210 <oslib_test_002_001_execute.lto_priv.719+0x4e0>)
 80061a6:	4618      	mov	r0, r3
 80061a8:	f00f f96a 	bl	8015480 <_test_assert>
 80061ac:	4603      	mov	r3, r0
 80061ae:	2b00      	cmp	r3, #0
 80061b0:	f040 810d 	bne.w	80063ce <oslib_test_002_001_execute.lto_priv.719+0x69e>
  }

  /* [2.1.11] Small Write.*/
  test_set_step(11);
 80061b4:	4b17      	ldr	r3, [pc, #92]	; (8006214 <oslib_test_002_001_execute.lto_priv.719+0x4e4>)
 80061b6:	220b      	movs	r2, #11
 80061b8:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 5, TIME_IMMEDIATE);
 80061ba:	2300      	movs	r3, #0
 80061bc:	2205      	movs	r2, #5
 80061be:	4913      	ldr	r1, [pc, #76]	; (800620c <oslib_test_002_001_execute.lto_priv.719+0x4dc>)
 80061c0:	4815      	ldr	r0, [pc, #84]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80061c2:	f00d fbf5 	bl	80139b0 <chPipeWriteTimeout>
 80061c6:	901b      	str	r0, [sp, #108]	; 0x6c
    test_assert(n == 5, "wrong size");
 80061c8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80061ca:	2b05      	cmp	r3, #5
 80061cc:	bf0c      	ite	eq
 80061ce:	2301      	moveq	r3, #1
 80061d0:	2300      	movne	r3, #0
 80061d2:	b2db      	uxtb	r3, r3
 80061d4:	4911      	ldr	r1, [pc, #68]	; (800621c <oslib_test_002_001_execute.lto_priv.719+0x4ec>)
 80061d6:	4618      	mov	r0, r3
 80061d8:	f00f f952 	bl	8015480 <_test_assert>
 80061dc:	4603      	mov	r3, r0
 80061de:	2b00      	cmp	r3, #0
 80061e0:	f040 80f8 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
 80061e4:	4b0c      	ldr	r3, [pc, #48]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80061e6:	68da      	ldr	r2, [r3, #12]
 80061e8:	4b0b      	ldr	r3, [pc, #44]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80061ea:	689b      	ldr	r3, [r3, #8]
 80061ec:	429a      	cmp	r2, r3
 80061ee:	d017      	beq.n	8006220 <oslib_test_002_001_execute.lto_priv.719+0x4f0>
 80061f0:	4b09      	ldr	r3, [pc, #36]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80061f2:	68da      	ldr	r2, [r3, #12]
 80061f4:	4b08      	ldr	r3, [pc, #32]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80061f6:	681b      	ldr	r3, [r3, #0]
 80061f8:	429a      	cmp	r2, r3
 80061fa:	d111      	bne.n	8006220 <oslib_test_002_001_execute.lto_priv.719+0x4f0>
 80061fc:	4b06      	ldr	r3, [pc, #24]	; (8006218 <oslib_test_002_001_execute.lto_priv.719+0x4e8>)
 80061fe:	691b      	ldr	r3, [r3, #16]
 8006200:	2b05      	cmp	r3, #5
 8006202:	d10d      	bne.n	8006220 <oslib_test_002_001_execute.lto_priv.719+0x4f0>
 8006204:	2301      	movs	r3, #1
 8006206:	e00c      	b.n	8006222 <oslib_test_002_001_execute.lto_priv.719+0x4f2>
 8006208:	08018880 	.word	0x08018880
 800620c:	0801886c 	.word	0x0801886c
 8006210:	080188a0 	.word	0x080188a0
 8006214:	20001988 	.word	0x20001988
 8006218:	200008a0 	.word	0x200008a0
 800621c:	08018754 	.word	0x08018754
 8006220:	2300      	movs	r3, #0
 8006222:	f003 0301 	and.w	r3, r3, #1
 8006226:	b2db      	uxtb	r3, r3
 8006228:	496c      	ldr	r1, [pc, #432]	; (80063dc <oslib_test_002_001_execute.lto_priv.719+0x6ac>)
 800622a:	4618      	mov	r0, r3
 800622c:	f00f f928 	bl	8015480 <_test_assert>
 8006230:	4603      	mov	r3, r0
 8006232:	2b00      	cmp	r3, #0
 8006234:	f040 80ce 	bne.w	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
                (pipe1.cnt == 5),
                "invalid pipe state");
  }

  /* [2.1.12] Small Read.*/
  test_set_step(12);
 8006238:	4b69      	ldr	r3, [pc, #420]	; (80063e0 <oslib_test_002_001_execute.lto_priv.719+0x6b0>)
 800623a:	220c      	movs	r2, #12
 800623c:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, 5, TIME_IMMEDIATE);
 800623e:	a910      	add	r1, sp, #64	; 0x40
 8006240:	2300      	movs	r3, #0
 8006242:	2205      	movs	r2, #5
 8006244:	4867      	ldr	r0, [pc, #412]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006246:	f00d fc0b 	bl	8013a60 <chPipeReadTimeout>
 800624a:	901a      	str	r0, [sp, #104]	; 0x68
    test_assert(n == 5, "wrong size");
 800624c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800624e:	2b05      	cmp	r3, #5
 8006250:	bf0c      	ite	eq
 8006252:	2301      	moveq	r3, #1
 8006254:	2300      	movne	r3, #0
 8006256:	b2db      	uxtb	r3, r3
 8006258:	4963      	ldr	r1, [pc, #396]	; (80063e8 <oslib_test_002_001_execute.lto_priv.719+0x6b8>)
 800625a:	4618      	mov	r0, r3
 800625c:	f00f f910 	bl	8015480 <_test_assert>
 8006260:	4603      	mov	r3, r0
 8006262:	2b00      	cmp	r3, #0
 8006264:	f040 80b5 	bne.w	80063d2 <oslib_test_002_001_execute.lto_priv.719+0x6a2>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8006268:	4b5e      	ldr	r3, [pc, #376]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 800626a:	68da      	ldr	r2, [r3, #12]
 800626c:	4b5d      	ldr	r3, [pc, #372]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 800626e:	689b      	ldr	r3, [r3, #8]
 8006270:	429a      	cmp	r2, r3
 8006272:	d10b      	bne.n	800628c <oslib_test_002_001_execute.lto_priv.719+0x55c>
 8006274:	4b5b      	ldr	r3, [pc, #364]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006276:	689a      	ldr	r2, [r3, #8]
 8006278:	4b5a      	ldr	r3, [pc, #360]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 800627a:	681b      	ldr	r3, [r3, #0]
 800627c:	429a      	cmp	r2, r3
 800627e:	d005      	beq.n	800628c <oslib_test_002_001_execute.lto_priv.719+0x55c>
 8006280:	4b58      	ldr	r3, [pc, #352]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006282:	691b      	ldr	r3, [r3, #16]
 8006284:	2b00      	cmp	r3, #0
 8006286:	d101      	bne.n	800628c <oslib_test_002_001_execute.lto_priv.719+0x55c>
 8006288:	2301      	movs	r3, #1
 800628a:	e000      	b.n	800628e <oslib_test_002_001_execute.lto_priv.719+0x55e>
 800628c:	2300      	movs	r3, #0
 800628e:	f003 0301 	and.w	r3, r3, #1
 8006292:	b2db      	uxtb	r3, r3
 8006294:	4951      	ldr	r1, [pc, #324]	; (80063dc <oslib_test_002_001_execute.lto_priv.719+0x6ac>)
 8006296:	4618      	mov	r0, r3
 8006298:	f00f f8f2 	bl	8015480 <_test_assert>
 800629c:	4603      	mov	r3, r0
 800629e:	2b00      	cmp	r3, #0
 80062a0:	f040 8097 	bne.w	80063d2 <oslib_test_002_001_execute.lto_priv.719+0x6a2>
                (pipe1.wrptr != pipe1.buffer) &&
                (pipe1.cnt == 0),
                "invalid pipe state");
    test_assert(memcmp(pipe_pattern, buf, 5) == 0, "content mismatch");
 80062a4:	ab10      	add	r3, sp, #64	; 0x40
 80062a6:	2205      	movs	r2, #5
 80062a8:	4619      	mov	r1, r3
 80062aa:	4850      	ldr	r0, [pc, #320]	; (80063ec <oslib_test_002_001_execute.lto_priv.719+0x6bc>)
 80062ac:	f00f f9e6 	bl	801567c <memcmp>
 80062b0:	4603      	mov	r3, r0
 80062b2:	2b00      	cmp	r3, #0
 80062b4:	bf0c      	ite	eq
 80062b6:	2301      	moveq	r3, #1
 80062b8:	2300      	movne	r3, #0
 80062ba:	b2db      	uxtb	r3, r3
 80062bc:	494c      	ldr	r1, [pc, #304]	; (80063f0 <oslib_test_002_001_execute.lto_priv.719+0x6c0>)
 80062be:	4618      	mov	r0, r3
 80062c0:	f00f f8de 	bl	8015480 <_test_assert>
 80062c4:	4603      	mov	r3, r0
 80062c6:	2b00      	cmp	r3, #0
 80062c8:	f040 8083 	bne.w	80063d2 <oslib_test_002_001_execute.lto_priv.719+0x6a2>
  }

  /* [2.1.13] Write wrapping buffer boundary.*/
  test_set_step(13);
 80062cc:	4b44      	ldr	r3, [pc, #272]	; (80063e0 <oslib_test_002_001_execute.lto_priv.719+0x6b0>)
 80062ce:	220d      	movs	r2, #13
 80062d0:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 80062d2:	2300      	movs	r3, #0
 80062d4:	2210      	movs	r2, #16
 80062d6:	4945      	ldr	r1, [pc, #276]	; (80063ec <oslib_test_002_001_execute.lto_priv.719+0x6bc>)
 80062d8:	4842      	ldr	r0, [pc, #264]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 80062da:	f00d fb69 	bl	80139b0 <chPipeWriteTimeout>
 80062de:	9019      	str	r0, [sp, #100]	; 0x64
    test_assert(n == PIPE_SIZE, "wrong size");
 80062e0:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80062e2:	2b10      	cmp	r3, #16
 80062e4:	bf0c      	ite	eq
 80062e6:	2301      	moveq	r3, #1
 80062e8:	2300      	movne	r3, #0
 80062ea:	b2db      	uxtb	r3, r3
 80062ec:	493e      	ldr	r1, [pc, #248]	; (80063e8 <oslib_test_002_001_execute.lto_priv.719+0x6b8>)
 80062ee:	4618      	mov	r0, r3
 80062f0:	f00f f8c6 	bl	8015480 <_test_assert>
 80062f4:	4603      	mov	r3, r0
 80062f6:	2b00      	cmp	r3, #0
 80062f8:	d16c      	bne.n	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 80062fa:	4b3a      	ldr	r3, [pc, #232]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 80062fc:	68da      	ldr	r2, [r3, #12]
 80062fe:	4b39      	ldr	r3, [pc, #228]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006300:	689b      	ldr	r3, [r3, #8]
 8006302:	429a      	cmp	r2, r3
 8006304:	d10b      	bne.n	800631e <oslib_test_002_001_execute.lto_priv.719+0x5ee>
 8006306:	4b37      	ldr	r3, [pc, #220]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006308:	689a      	ldr	r2, [r3, #8]
 800630a:	4b36      	ldr	r3, [pc, #216]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 800630c:	681b      	ldr	r3, [r3, #0]
 800630e:	429a      	cmp	r2, r3
 8006310:	d005      	beq.n	800631e <oslib_test_002_001_execute.lto_priv.719+0x5ee>
 8006312:	4b34      	ldr	r3, [pc, #208]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006314:	691b      	ldr	r3, [r3, #16]
 8006316:	2b10      	cmp	r3, #16
 8006318:	d101      	bne.n	800631e <oslib_test_002_001_execute.lto_priv.719+0x5ee>
 800631a:	2301      	movs	r3, #1
 800631c:	e000      	b.n	8006320 <oslib_test_002_001_execute.lto_priv.719+0x5f0>
 800631e:	2300      	movs	r3, #0
 8006320:	f003 0301 	and.w	r3, r3, #1
 8006324:	b2db      	uxtb	r3, r3
 8006326:	492d      	ldr	r1, [pc, #180]	; (80063dc <oslib_test_002_001_execute.lto_priv.719+0x6ac>)
 8006328:	4618      	mov	r0, r3
 800632a:	f00f f8a9 	bl	8015480 <_test_assert>
 800632e:	4603      	mov	r3, r0
 8006330:	2b00      	cmp	r3, #0
 8006332:	d14f      	bne.n	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
                (pipe1.cnt == PIPE_SIZE),
                "invalid pipe state");
  }

  /* [2.1.14] Read wrapping buffer boundary.*/
  test_set_step(14);
 8006334:	4b2a      	ldr	r3, [pc, #168]	; (80063e0 <oslib_test_002_001_execute.lto_priv.719+0x6b0>)
 8006336:	220e      	movs	r2, #14
 8006338:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 800633a:	a914      	add	r1, sp, #80	; 0x50
 800633c:	2300      	movs	r3, #0
 800633e:	2210      	movs	r2, #16
 8006340:	4828      	ldr	r0, [pc, #160]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006342:	f00d fb8d 	bl	8013a60 <chPipeReadTimeout>
 8006346:	9018      	str	r0, [sp, #96]	; 0x60
    test_assert(n == PIPE_SIZE, "wrong size");
 8006348:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800634a:	2b10      	cmp	r3, #16
 800634c:	bf0c      	ite	eq
 800634e:	2301      	moveq	r3, #1
 8006350:	2300      	movne	r3, #0
 8006352:	b2db      	uxtb	r3, r3
 8006354:	4924      	ldr	r1, [pc, #144]	; (80063e8 <oslib_test_002_001_execute.lto_priv.719+0x6b8>)
 8006356:	4618      	mov	r0, r3
 8006358:	f00f f892 	bl	8015480 <_test_assert>
 800635c:	4603      	mov	r3, r0
 800635e:	2b00      	cmp	r3, #0
 8006360:	d138      	bne.n	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8006362:	4b20      	ldr	r3, [pc, #128]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006364:	68da      	ldr	r2, [r3, #12]
 8006366:	4b1f      	ldr	r3, [pc, #124]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006368:	689b      	ldr	r3, [r3, #8]
 800636a:	429a      	cmp	r2, r3
 800636c:	d10b      	bne.n	8006386 <oslib_test_002_001_execute.lto_priv.719+0x656>
 800636e:	4b1d      	ldr	r3, [pc, #116]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006370:	689a      	ldr	r2, [r3, #8]
 8006372:	4b1c      	ldr	r3, [pc, #112]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 8006374:	681b      	ldr	r3, [r3, #0]
 8006376:	429a      	cmp	r2, r3
 8006378:	d005      	beq.n	8006386 <oslib_test_002_001_execute.lto_priv.719+0x656>
 800637a:	4b1a      	ldr	r3, [pc, #104]	; (80063e4 <oslib_test_002_001_execute.lto_priv.719+0x6b4>)
 800637c:	691b      	ldr	r3, [r3, #16]
 800637e:	2b00      	cmp	r3, #0
 8006380:	d101      	bne.n	8006386 <oslib_test_002_001_execute.lto_priv.719+0x656>
 8006382:	2301      	movs	r3, #1
 8006384:	e000      	b.n	8006388 <oslib_test_002_001_execute.lto_priv.719+0x658>
 8006386:	2300      	movs	r3, #0
 8006388:	f003 0301 	and.w	r3, r3, #1
 800638c:	b2db      	uxtb	r3, r3
 800638e:	4913      	ldr	r1, [pc, #76]	; (80063dc <oslib_test_002_001_execute.lto_priv.719+0x6ac>)
 8006390:	4618      	mov	r0, r3
 8006392:	f00f f875 	bl	8015480 <_test_assert>
 8006396:	4603      	mov	r3, r0
 8006398:	2b00      	cmp	r3, #0
 800639a:	d11b      	bne.n	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
                (pipe1.wrptr != pipe1.buffer) &&
                (pipe1.cnt == 0),
                "invalid pipe state");
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
 800639c:	ab14      	add	r3, sp, #80	; 0x50
 800639e:	2210      	movs	r2, #16
 80063a0:	4619      	mov	r1, r3
 80063a2:	4812      	ldr	r0, [pc, #72]	; (80063ec <oslib_test_002_001_execute.lto_priv.719+0x6bc>)
 80063a4:	f00f f96a 	bl	801567c <memcmp>
 80063a8:	4603      	mov	r3, r0
 80063aa:	2b00      	cmp	r3, #0
 80063ac:	bf0c      	ite	eq
 80063ae:	2301      	moveq	r3, #1
 80063b0:	2300      	movne	r3, #0
 80063b2:	b2db      	uxtb	r3, r3
 80063b4:	490e      	ldr	r1, [pc, #56]	; (80063f0 <oslib_test_002_001_execute.lto_priv.719+0x6c0>)
 80063b6:	4618      	mov	r0, r3
 80063b8:	f00f f862 	bl	8015480 <_test_assert>
 80063bc:	4603      	mov	r3, r0
 80063be:	2b00      	cmp	r3, #0
 80063c0:	e008      	b.n	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert(n == 0, "not reset");
 80063c2:	bf00      	nop
 80063c4:	e006      	b.n	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert(n == PIPE_SIZE, "wrong size");
 80063c6:	bf00      	nop
 80063c8:	e004      	b.n	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert(n == 4, "wrong size");
 80063ca:	bf00      	nop
 80063cc:	e002      	b.n	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert(n == PIPE_SIZE - 4, "wrong size");
 80063ce:	bf00      	nop
 80063d0:	e000      	b.n	80063d4 <oslib_test_002_001_execute.lto_priv.719+0x6a4>
    test_assert(n == 5, "wrong size");
 80063d2:	bf00      	nop
  }
}
 80063d4:	b025      	add	sp, #148	; 0x94
 80063d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80063da:	bf00      	nop
 80063dc:	08018880 	.word	0x08018880
 80063e0:	20001988 	.word	0x20001988
 80063e4:	200008a0 	.word	0x200008a0
 80063e8:	08018754 	.word	0x08018754
 80063ec:	0801886c 	.word	0x0801886c
 80063f0:	080188a0 	.word	0x080188a0
	...

08006400 <oslib_test_002_002_setup.lto_priv.720>:
 * - [2.2.1] Reading while pipe is empty.
 * - [2.2.2] Writing a string larger than pipe buffer.
 * .
 */

static void oslib_test_002_002_setup(void) {
 8006400:	b508      	push	{r3, lr}
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE / 2);
 8006402:	2208      	movs	r2, #8
 8006404:	4902      	ldr	r1, [pc, #8]	; (8006410 <oslib_test_002_002_setup.lto_priv.720+0x10>)
 8006406:	4803      	ldr	r0, [pc, #12]	; (8006414 <oslib_test_002_002_setup.lto_priv.720+0x14>)
 8006408:	f00d fa52 	bl	80138b0 <chPipeObjectInit>
}
 800640c:	bd08      	pop	{r3, pc}
 800640e:	bf00      	nop
 8006410:	200020bc 	.word	0x200020bc
 8006414:	200008a0 	.word	0x200008a0
	...

08006420 <oslib_test_002_002_execute.lto_priv.721>:

static void oslib_test_002_002_execute(void) {
 8006420:	b500      	push	{lr}
 8006422:	b087      	sub	sp, #28

  /* [2.2.1] Reading while pipe is empty.*/
  test_set_step(1);
 8006424:	4b34      	ldr	r3, [pc, #208]	; (80064f8 <oslib_test_002_002_execute.lto_priv.721+0xd8>)
 8006426:	2201      	movs	r2, #1
 8006428:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 800642a:	4669      	mov	r1, sp
 800642c:	2300      	movs	r3, #0
 800642e:	2210      	movs	r2, #16
 8006430:	4832      	ldr	r0, [pc, #200]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 8006432:	f00d fb15 	bl	8013a60 <chPipeReadTimeout>
 8006436:	9005      	str	r0, [sp, #20]
    test_assert(n == 0, "wrong size");
 8006438:	9b05      	ldr	r3, [sp, #20]
 800643a:	2b00      	cmp	r3, #0
 800643c:	bf0c      	ite	eq
 800643e:	2301      	moveq	r3, #1
 8006440:	2300      	movne	r3, #0
 8006442:	b2db      	uxtb	r3, r3
 8006444:	492e      	ldr	r1, [pc, #184]	; (8006500 <oslib_test_002_002_execute.lto_priv.721+0xe0>)
 8006446:	4618      	mov	r0, r3
 8006448:	f00f f81a 	bl	8015480 <_test_assert>
 800644c:	4603      	mov	r3, r0
 800644e:	2b00      	cmp	r3, #0
 8006450:	d14e      	bne.n	80064f0 <oslib_test_002_002_execute.lto_priv.721+0xd0>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8006452:	4b2a      	ldr	r3, [pc, #168]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 8006454:	68da      	ldr	r2, [r3, #12]
 8006456:	4b29      	ldr	r3, [pc, #164]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 8006458:	681b      	ldr	r3, [r3, #0]
 800645a:	429a      	cmp	r2, r3
 800645c:	d10b      	bne.n	8006476 <oslib_test_002_002_execute.lto_priv.721+0x56>
 800645e:	4b27      	ldr	r3, [pc, #156]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 8006460:	689a      	ldr	r2, [r3, #8]
 8006462:	4b26      	ldr	r3, [pc, #152]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 8006464:	681b      	ldr	r3, [r3, #0]
 8006466:	429a      	cmp	r2, r3
 8006468:	d105      	bne.n	8006476 <oslib_test_002_002_execute.lto_priv.721+0x56>
 800646a:	4b24      	ldr	r3, [pc, #144]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 800646c:	691b      	ldr	r3, [r3, #16]
 800646e:	2b00      	cmp	r3, #0
 8006470:	d101      	bne.n	8006476 <oslib_test_002_002_execute.lto_priv.721+0x56>
 8006472:	2301      	movs	r3, #1
 8006474:	e000      	b.n	8006478 <oslib_test_002_002_execute.lto_priv.721+0x58>
 8006476:	2300      	movs	r3, #0
 8006478:	f003 0301 	and.w	r3, r3, #1
 800647c:	b2db      	uxtb	r3, r3
 800647e:	4921      	ldr	r1, [pc, #132]	; (8006504 <oslib_test_002_002_execute.lto_priv.721+0xe4>)
 8006480:	4618      	mov	r0, r3
 8006482:	f00e fffd 	bl	8015480 <_test_assert>
 8006486:	4603      	mov	r3, r0
 8006488:	2b00      	cmp	r3, #0
 800648a:	d131      	bne.n	80064f0 <oslib_test_002_002_execute.lto_priv.721+0xd0>
                (pipe1.cnt == 0),
                "invalid pipe state");
  }

  /* [2.2.2] Writing a string larger than pipe buffer.*/
  test_set_step(2);
 800648c:	4b1a      	ldr	r3, [pc, #104]	; (80064f8 <oslib_test_002_002_execute.lto_priv.721+0xd8>)
 800648e:	2202      	movs	r2, #2
 8006490:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8006492:	2300      	movs	r3, #0
 8006494:	2210      	movs	r2, #16
 8006496:	491c      	ldr	r1, [pc, #112]	; (8006508 <oslib_test_002_002_execute.lto_priv.721+0xe8>)
 8006498:	4818      	ldr	r0, [pc, #96]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 800649a:	f00d fa89 	bl	80139b0 <chPipeWriteTimeout>
 800649e:	9004      	str	r0, [sp, #16]
    test_assert(n == PIPE_SIZE / 2, "wrong size");
 80064a0:	9b04      	ldr	r3, [sp, #16]
 80064a2:	2b08      	cmp	r3, #8
 80064a4:	bf0c      	ite	eq
 80064a6:	2301      	moveq	r3, #1
 80064a8:	2300      	movne	r3, #0
 80064aa:	b2db      	uxtb	r3, r3
 80064ac:	4914      	ldr	r1, [pc, #80]	; (8006500 <oslib_test_002_002_execute.lto_priv.721+0xe0>)
 80064ae:	4618      	mov	r0, r3
 80064b0:	f00e ffe6 	bl	8015480 <_test_assert>
 80064b4:	4603      	mov	r3, r0
 80064b6:	2b00      	cmp	r3, #0
 80064b8:	d11b      	bne.n	80064f2 <oslib_test_002_002_execute.lto_priv.721+0xd2>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 80064ba:	4b10      	ldr	r3, [pc, #64]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 80064bc:	68da      	ldr	r2, [r3, #12]
 80064be:	4b0f      	ldr	r3, [pc, #60]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 80064c0:	689b      	ldr	r3, [r3, #8]
 80064c2:	429a      	cmp	r2, r3
 80064c4:	d10b      	bne.n	80064de <oslib_test_002_002_execute.lto_priv.721+0xbe>
 80064c6:	4b0d      	ldr	r3, [pc, #52]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 80064c8:	689a      	ldr	r2, [r3, #8]
 80064ca:	4b0c      	ldr	r3, [pc, #48]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 80064cc:	681b      	ldr	r3, [r3, #0]
 80064ce:	429a      	cmp	r2, r3
 80064d0:	d105      	bne.n	80064de <oslib_test_002_002_execute.lto_priv.721+0xbe>
 80064d2:	4b0a      	ldr	r3, [pc, #40]	; (80064fc <oslib_test_002_002_execute.lto_priv.721+0xdc>)
 80064d4:	691b      	ldr	r3, [r3, #16]
 80064d6:	2b08      	cmp	r3, #8
 80064d8:	d101      	bne.n	80064de <oslib_test_002_002_execute.lto_priv.721+0xbe>
 80064da:	2301      	movs	r3, #1
 80064dc:	e000      	b.n	80064e0 <oslib_test_002_002_execute.lto_priv.721+0xc0>
 80064de:	2300      	movs	r3, #0
 80064e0:	f003 0301 	and.w	r3, r3, #1
 80064e4:	b2db      	uxtb	r3, r3
 80064e6:	4907      	ldr	r1, [pc, #28]	; (8006504 <oslib_test_002_002_execute.lto_priv.721+0xe4>)
 80064e8:	4618      	mov	r0, r3
 80064ea:	f00e ffc9 	bl	8015480 <_test_assert>
 80064ee:	e000      	b.n	80064f2 <oslib_test_002_002_execute.lto_priv.721+0xd2>
    test_assert(n == 0, "wrong size");
 80064f0:	bf00      	nop
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == PIPE_SIZE / 2),
                "invalid pipe state");
  }
}
 80064f2:	b007      	add	sp, #28
 80064f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80064f8:	20001988 	.word	0x20001988
 80064fc:	200008a0 	.word	0x200008a0
 8006500:	08018754 	.word	0x08018754
 8006504:	08018880 	.word	0x08018880
 8006508:	0801886c 	.word	0x0801886c
 800650c:	00000000 	.word	0x00000000

08006510 <chPoolObjectInit.lto_priv.31>:
                                    memgetfunc_t provider) {
 8006510:	b500      	push	{lr}
 8006512:	b085      	sub	sp, #20
 8006514:	9003      	str	r0, [sp, #12]
 8006516:	9102      	str	r1, [sp, #8]
 8006518:	9201      	str	r2, [sp, #4]
  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 800651a:	9b01      	ldr	r3, [sp, #4]
 800651c:	2204      	movs	r2, #4
 800651e:	9902      	ldr	r1, [sp, #8]
 8006520:	9803      	ldr	r0, [sp, #12]
 8006522:	f00c ff1d 	bl	8013360 <chPoolObjectInitAligned>
}
 8006526:	b005      	add	sp, #20
 8006528:	f85d fb04 	ldr.w	pc, [sp], #4
 800652c:	0000      	movs	r0, r0
	...

08006530 <chGuardedPoolObjectInit>:
 *                      of a pointer to void.
 *
 * @init
 */
static inline void chGuardedPoolObjectInit(guarded_memory_pool_t *gmp,
                                           size_t size) {
 8006530:	b500      	push	{lr}
 8006532:	b083      	sub	sp, #12
 8006534:	9001      	str	r0, [sp, #4]
 8006536:	9100      	str	r1, [sp, #0]

  chGuardedPoolObjectInitAligned(gmp, size, PORT_NATURAL_ALIGN);
 8006538:	2204      	movs	r2, #4
 800653a:	9900      	ldr	r1, [sp, #0]
 800653c:	9801      	ldr	r0, [sp, #4]
 800653e:	f00c ffe7 	bl	8013510 <chGuardedPoolObjectInitAligned>
}
 8006542:	b003      	add	sp, #12
 8006544:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08006550 <null_provider>:

#if CH_CFG_USE_SEMAPHORES
static GUARDEDMEMORYPOOL_DECL(gmp1, sizeof (uint32_t), PORT_NATURAL_ALIGN);
#endif

static void *null_provider(size_t size, unsigned align) {
 8006550:	b082      	sub	sp, #8
 8006552:	9001      	str	r0, [sp, #4]
 8006554:	9100      	str	r1, [sp, #0]

  (void)size;
  (void)align;

  return NULL;
 8006556:	2300      	movs	r3, #0
}
 8006558:	4618      	mov	r0, r3
 800655a:	b002      	add	sp, #8
 800655c:	4770      	bx	lr
 800655e:	bf00      	nop

08006560 <oslib_test_003_001_setup.lto_priv.722>:
 * - [3.1.7] Covering the case where a provider is unable to return
 *   more memory.
 * .
 */

static void oslib_test_003_001_setup(void) {
 8006560:	b508      	push	{r3, lr}
  chPoolObjectInit(&mp1, sizeof (uint32_t), NULL);
 8006562:	2200      	movs	r2, #0
 8006564:	2104      	movs	r1, #4
 8006566:	4802      	ldr	r0, [pc, #8]	; (8006570 <oslib_test_003_001_setup.lto_priv.722+0x10>)
 8006568:	f7ff ffd2 	bl	8006510 <chPoolObjectInit.lto_priv.31>
}
 800656c:	bd08      	pop	{r3, pc}
 800656e:	bf00      	nop
 8006570:	200008f0 	.word	0x200008f0
	...

08006580 <oslib_test_003_001_execute.lto_priv.723>:

static void oslib_test_003_001_execute(void) {
 8006580:	b500      	push	{lr}
 8006582:	b083      	sub	sp, #12
  unsigned i;

  /* [3.1.1] Adding the objects to the pool using chPoolLoadArray().*/
  test_set_step(1);
 8006584:	4b48      	ldr	r3, [pc, #288]	; (80066a8 <oslib_test_003_001_execute.lto_priv.723+0x128>)
 8006586:	2201      	movs	r2, #1
 8006588:	601a      	str	r2, [r3, #0]
  {
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
 800658a:	2204      	movs	r2, #4
 800658c:	4947      	ldr	r1, [pc, #284]	; (80066ac <oslib_test_003_001_execute.lto_priv.723+0x12c>)
 800658e:	4848      	ldr	r0, [pc, #288]	; (80066b0 <oslib_test_003_001_execute.lto_priv.723+0x130>)
 8006590:	f00c ff16 	bl	80133c0 <chPoolLoadArray>
  }

  /* [3.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
 8006594:	4b44      	ldr	r3, [pc, #272]	; (80066a8 <oslib_test_003_001_execute.lto_priv.723+0x128>)
 8006596:	2202      	movs	r2, #2
 8006598:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800659a:	2300      	movs	r3, #0
 800659c:	9301      	str	r3, [sp, #4]
 800659e:	e012      	b.n	80065c6 <oslib_test_003_001_execute.lto_priv.723+0x46>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 80065a0:	4843      	ldr	r0, [pc, #268]	; (80066b0 <oslib_test_003_001_execute.lto_priv.723+0x130>)
 80065a2:	f00c ff6d 	bl	8013480 <chPoolAlloc>
 80065a6:	4603      	mov	r3, r0
 80065a8:	2b00      	cmp	r3, #0
 80065aa:	bf14      	ite	ne
 80065ac:	2301      	movne	r3, #1
 80065ae:	2300      	moveq	r3, #0
 80065b0:	b2db      	uxtb	r3, r3
 80065b2:	4940      	ldr	r1, [pc, #256]	; (80066b4 <oslib_test_003_001_execute.lto_priv.723+0x134>)
 80065b4:	4618      	mov	r0, r3
 80065b6:	f00e ff63 	bl	8015480 <_test_assert>
 80065ba:	4603      	mov	r3, r0
 80065bc:	2b00      	cmp	r3, #0
 80065be:	d170      	bne.n	80066a2 <oslib_test_003_001_execute.lto_priv.723+0x122>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80065c0:	9b01      	ldr	r3, [sp, #4]
 80065c2:	3301      	adds	r3, #1
 80065c4:	9301      	str	r3, [sp, #4]
 80065c6:	9b01      	ldr	r3, [sp, #4]
 80065c8:	2b03      	cmp	r3, #3
 80065ca:	d9e9      	bls.n	80065a0 <oslib_test_003_001_execute.lto_priv.723+0x20>
  }

  /* [3.1.3] Now must be empty.*/
  test_set_step(3);
 80065cc:	4b36      	ldr	r3, [pc, #216]	; (80066a8 <oslib_test_003_001_execute.lto_priv.723+0x128>)
 80065ce:	2203      	movs	r2, #3
 80065d0:	601a      	str	r2, [r3, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80065d2:	4837      	ldr	r0, [pc, #220]	; (80066b0 <oslib_test_003_001_execute.lto_priv.723+0x130>)
 80065d4:	f00c ff54 	bl	8013480 <chPoolAlloc>
 80065d8:	4603      	mov	r3, r0
 80065da:	2b00      	cmp	r3, #0
 80065dc:	bf0c      	ite	eq
 80065de:	2301      	moveq	r3, #1
 80065e0:	2300      	movne	r3, #0
 80065e2:	b2db      	uxtb	r3, r3
 80065e4:	4934      	ldr	r1, [pc, #208]	; (80066b8 <oslib_test_003_001_execute.lto_priv.723+0x138>)
 80065e6:	4618      	mov	r0, r3
 80065e8:	f00e ff4a 	bl	8015480 <_test_assert>
 80065ec:	4603      	mov	r3, r0
 80065ee:	2b00      	cmp	r3, #0
 80065f0:	d157      	bne.n	80066a2 <oslib_test_003_001_execute.lto_priv.723+0x122>
  }

  /* [3.1.4] Adding the objects to the pool using chPoolFree().*/
  test_set_step(4);
 80065f2:	4b2d      	ldr	r3, [pc, #180]	; (80066a8 <oslib_test_003_001_execute.lto_priv.723+0x128>)
 80065f4:	2204      	movs	r2, #4
 80065f6:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80065f8:	2300      	movs	r3, #0
 80065fa:	9301      	str	r3, [sp, #4]
 80065fc:	e00a      	b.n	8006614 <oslib_test_003_001_execute.lto_priv.723+0x94>
      chPoolFree(&mp1, &objects[i]);
 80065fe:	9b01      	ldr	r3, [sp, #4]
 8006600:	009b      	lsls	r3, r3, #2
 8006602:	4a2a      	ldr	r2, [pc, #168]	; (80066ac <oslib_test_003_001_execute.lto_priv.723+0x12c>)
 8006604:	4413      	add	r3, r2
 8006606:	4619      	mov	r1, r3
 8006608:	4829      	ldr	r0, [pc, #164]	; (80066b0 <oslib_test_003_001_execute.lto_priv.723+0x130>)
 800660a:	f00c ff71 	bl	80134f0 <chPoolFree>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800660e:	9b01      	ldr	r3, [sp, #4]
 8006610:	3301      	adds	r3, #1
 8006612:	9301      	str	r3, [sp, #4]
 8006614:	9b01      	ldr	r3, [sp, #4]
 8006616:	2b03      	cmp	r3, #3
 8006618:	d9f1      	bls.n	80065fe <oslib_test_003_001_execute.lto_priv.723+0x7e>
  }

  /* [3.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
 800661a:	4b23      	ldr	r3, [pc, #140]	; (80066a8 <oslib_test_003_001_execute.lto_priv.723+0x128>)
 800661c:	2205      	movs	r2, #5
 800661e:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8006620:	2300      	movs	r3, #0
 8006622:	9301      	str	r3, [sp, #4]
 8006624:	e012      	b.n	800664c <oslib_test_003_001_execute.lto_priv.723+0xcc>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8006626:	4822      	ldr	r0, [pc, #136]	; (80066b0 <oslib_test_003_001_execute.lto_priv.723+0x130>)
 8006628:	f00c ff2a 	bl	8013480 <chPoolAlloc>
 800662c:	4603      	mov	r3, r0
 800662e:	2b00      	cmp	r3, #0
 8006630:	bf14      	ite	ne
 8006632:	2301      	movne	r3, #1
 8006634:	2300      	moveq	r3, #0
 8006636:	b2db      	uxtb	r3, r3
 8006638:	491e      	ldr	r1, [pc, #120]	; (80066b4 <oslib_test_003_001_execute.lto_priv.723+0x134>)
 800663a:	4618      	mov	r0, r3
 800663c:	f00e ff20 	bl	8015480 <_test_assert>
 8006640:	4603      	mov	r3, r0
 8006642:	2b00      	cmp	r3, #0
 8006644:	d12d      	bne.n	80066a2 <oslib_test_003_001_execute.lto_priv.723+0x122>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8006646:	9b01      	ldr	r3, [sp, #4]
 8006648:	3301      	adds	r3, #1
 800664a:	9301      	str	r3, [sp, #4]
 800664c:	9b01      	ldr	r3, [sp, #4]
 800664e:	2b03      	cmp	r3, #3
 8006650:	d9e9      	bls.n	8006626 <oslib_test_003_001_execute.lto_priv.723+0xa6>
  }

  /* [3.1.6] Now must be empty again.*/
  test_set_step(6);
 8006652:	4b15      	ldr	r3, [pc, #84]	; (80066a8 <oslib_test_003_001_execute.lto_priv.723+0x128>)
 8006654:	2206      	movs	r2, #6
 8006656:	601a      	str	r2, [r3, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8006658:	4815      	ldr	r0, [pc, #84]	; (80066b0 <oslib_test_003_001_execute.lto_priv.723+0x130>)
 800665a:	f00c ff11 	bl	8013480 <chPoolAlloc>
 800665e:	4603      	mov	r3, r0
 8006660:	2b00      	cmp	r3, #0
 8006662:	bf0c      	ite	eq
 8006664:	2301      	moveq	r3, #1
 8006666:	2300      	movne	r3, #0
 8006668:	b2db      	uxtb	r3, r3
 800666a:	4913      	ldr	r1, [pc, #76]	; (80066b8 <oslib_test_003_001_execute.lto_priv.723+0x138>)
 800666c:	4618      	mov	r0, r3
 800666e:	f00e ff07 	bl	8015480 <_test_assert>
 8006672:	4603      	mov	r3, r0
 8006674:	2b00      	cmp	r3, #0
 8006676:	d114      	bne.n	80066a2 <oslib_test_003_001_execute.lto_priv.723+0x122>
  }

  /* [3.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
 8006678:	4b0b      	ldr	r3, [pc, #44]	; (80066a8 <oslib_test_003_001_execute.lto_priv.723+0x128>)
 800667a:	2207      	movs	r2, #7
 800667c:	601a      	str	r2, [r3, #0]
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
 800667e:	4a0f      	ldr	r2, [pc, #60]	; (80066bc <oslib_test_003_001_execute.lto_priv.723+0x13c>)
 8006680:	2104      	movs	r1, #4
 8006682:	480b      	ldr	r0, [pc, #44]	; (80066b0 <oslib_test_003_001_execute.lto_priv.723+0x130>)
 8006684:	f7ff ff44 	bl	8006510 <chPoolObjectInit.lto_priv.31>
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8006688:	4809      	ldr	r0, [pc, #36]	; (80066b0 <oslib_test_003_001_execute.lto_priv.723+0x130>)
 800668a:	f00c fef9 	bl	8013480 <chPoolAlloc>
 800668e:	4603      	mov	r3, r0
 8006690:	2b00      	cmp	r3, #0
 8006692:	bf0c      	ite	eq
 8006694:	2301      	moveq	r3, #1
 8006696:	2300      	movne	r3, #0
 8006698:	b2db      	uxtb	r3, r3
 800669a:	4909      	ldr	r1, [pc, #36]	; (80066c0 <oslib_test_003_001_execute.lto_priv.723+0x140>)
 800669c:	4618      	mov	r0, r3
 800669e:	f00e feef 	bl	8015480 <_test_assert>
  }
}
 80066a2:	b003      	add	sp, #12
 80066a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80066a8:	20001988 	.word	0x20001988
 80066ac:	200020cc 	.word	0x200020cc
 80066b0:	200008f0 	.word	0x200008f0
 80066b4:	080188e8 	.word	0x080188e8
 80066b8:	080188f4 	.word	0x080188f4
 80066bc:	08006551 	.word	0x08006551
 80066c0:	08018904 	.word	0x08018904
	...

080066d0 <oslib_test_003_002_setup.lto_priv.724>:
 * - [3.2.5] Emptying the pool using chGuardedPoolAllocTimeout() again.
 * - [3.2.6] Now must be empty again.
 * .
 */

static void oslib_test_003_002_setup(void) {
 80066d0:	b508      	push	{r3, lr}
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
 80066d2:	2104      	movs	r1, #4
 80066d4:	4801      	ldr	r0, [pc, #4]	; (80066dc <oslib_test_003_002_setup.lto_priv.724+0xc>)
 80066d6:	f7ff ff2b 	bl	8006530 <chGuardedPoolObjectInit>
}
 80066da:	bd08      	pop	{r3, pc}
 80066dc:	20000900 	.word	0x20000900

080066e0 <oslib_test_003_002_execute.lto_priv.725>:

static void oslib_test_003_002_execute(void) {
 80066e0:	b500      	push	{lr}
 80066e2:	b083      	sub	sp, #12
  unsigned i;

  /* [3.2.1] Adding the objects to the pool using
     chGuardedPoolLoadArray().*/
  test_set_step(1);
 80066e4:	4b3e      	ldr	r3, [pc, #248]	; (80067e0 <oslib_test_003_002_execute.lto_priv.725+0x100>)
 80066e6:	2201      	movs	r2, #1
 80066e8:	601a      	str	r2, [r3, #0]
  {
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 80066ea:	2204      	movs	r2, #4
 80066ec:	493d      	ldr	r1, [pc, #244]	; (80067e4 <oslib_test_003_002_execute.lto_priv.725+0x104>)
 80066ee:	483e      	ldr	r0, [pc, #248]	; (80067e8 <oslib_test_003_002_execute.lto_priv.725+0x108>)
 80066f0:	f00c ff26 	bl	8013540 <chGuardedPoolLoadArray>
  }

  /* [3.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
 80066f4:	4b3a      	ldr	r3, [pc, #232]	; (80067e0 <oslib_test_003_002_execute.lto_priv.725+0x100>)
 80066f6:	2202      	movs	r2, #2
 80066f8:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80066fa:	2300      	movs	r3, #0
 80066fc:	9301      	str	r3, [sp, #4]
 80066fe:	e013      	b.n	8006728 <oslib_test_003_002_execute.lto_priv.725+0x48>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8006700:	2100      	movs	r1, #0
 8006702:	4839      	ldr	r0, [pc, #228]	; (80067e8 <oslib_test_003_002_execute.lto_priv.725+0x108>)
 8006704:	f00c ff64 	bl	80135d0 <chGuardedPoolAllocTimeout>
 8006708:	4603      	mov	r3, r0
 800670a:	2b00      	cmp	r3, #0
 800670c:	bf14      	ite	ne
 800670e:	2301      	movne	r3, #1
 8006710:	2300      	moveq	r3, #0
 8006712:	b2db      	uxtb	r3, r3
 8006714:	4935      	ldr	r1, [pc, #212]	; (80067ec <oslib_test_003_002_execute.lto_priv.725+0x10c>)
 8006716:	4618      	mov	r0, r3
 8006718:	f00e feb2 	bl	8015480 <_test_assert>
 800671c:	4603      	mov	r3, r0
 800671e:	2b00      	cmp	r3, #0
 8006720:	d15b      	bne.n	80067da <oslib_test_003_002_execute.lto_priv.725+0xfa>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8006722:	9b01      	ldr	r3, [sp, #4]
 8006724:	3301      	adds	r3, #1
 8006726:	9301      	str	r3, [sp, #4]
 8006728:	9b01      	ldr	r3, [sp, #4]
 800672a:	2b03      	cmp	r3, #3
 800672c:	d9e8      	bls.n	8006700 <oslib_test_003_002_execute.lto_priv.725+0x20>
  }

  /* [3.2.3] Now must be empty.*/
  test_set_step(3);
 800672e:	4b2c      	ldr	r3, [pc, #176]	; (80067e0 <oslib_test_003_002_execute.lto_priv.725+0x100>)
 8006730:	2203      	movs	r2, #3
 8006732:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8006734:	2100      	movs	r1, #0
 8006736:	482c      	ldr	r0, [pc, #176]	; (80067e8 <oslib_test_003_002_execute.lto_priv.725+0x108>)
 8006738:	f00c ff4a 	bl	80135d0 <chGuardedPoolAllocTimeout>
 800673c:	4603      	mov	r3, r0
 800673e:	2b00      	cmp	r3, #0
 8006740:	bf0c      	ite	eq
 8006742:	2301      	moveq	r3, #1
 8006744:	2300      	movne	r3, #0
 8006746:	b2db      	uxtb	r3, r3
 8006748:	4929      	ldr	r1, [pc, #164]	; (80067f0 <oslib_test_003_002_execute.lto_priv.725+0x110>)
 800674a:	4618      	mov	r0, r3
 800674c:	f00e fe98 	bl	8015480 <_test_assert>
 8006750:	4603      	mov	r3, r0
 8006752:	2b00      	cmp	r3, #0
 8006754:	d141      	bne.n	80067da <oslib_test_003_002_execute.lto_priv.725+0xfa>
  }

  /* [3.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
 8006756:	4b22      	ldr	r3, [pc, #136]	; (80067e0 <oslib_test_003_002_execute.lto_priv.725+0x100>)
 8006758:	2204      	movs	r2, #4
 800675a:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800675c:	2300      	movs	r3, #0
 800675e:	9301      	str	r3, [sp, #4]
 8006760:	e00a      	b.n	8006778 <oslib_test_003_002_execute.lto_priv.725+0x98>
      chGuardedPoolFree(&gmp1, &objects[i]);
 8006762:	9b01      	ldr	r3, [sp, #4]
 8006764:	009b      	lsls	r3, r3, #2
 8006766:	4a1f      	ldr	r2, [pc, #124]	; (80067e4 <oslib_test_003_002_execute.lto_priv.725+0x104>)
 8006768:	4413      	add	r3, r2
 800676a:	4619      	mov	r1, r3
 800676c:	481e      	ldr	r0, [pc, #120]	; (80067e8 <oslib_test_003_002_execute.lto_priv.725+0x108>)
 800676e:	f00c ff47 	bl	8013600 <chGuardedPoolFree>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8006772:	9b01      	ldr	r3, [sp, #4]
 8006774:	3301      	adds	r3, #1
 8006776:	9301      	str	r3, [sp, #4]
 8006778:	9b01      	ldr	r3, [sp, #4]
 800677a:	2b03      	cmp	r3, #3
 800677c:	d9f1      	bls.n	8006762 <oslib_test_003_002_execute.lto_priv.725+0x82>
  }

  /* [3.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
 800677e:	4b18      	ldr	r3, [pc, #96]	; (80067e0 <oslib_test_003_002_execute.lto_priv.725+0x100>)
 8006780:	2205      	movs	r2, #5
 8006782:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8006784:	2300      	movs	r3, #0
 8006786:	9301      	str	r3, [sp, #4]
 8006788:	e013      	b.n	80067b2 <oslib_test_003_002_execute.lto_priv.725+0xd2>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 800678a:	2100      	movs	r1, #0
 800678c:	4816      	ldr	r0, [pc, #88]	; (80067e8 <oslib_test_003_002_execute.lto_priv.725+0x108>)
 800678e:	f00c ff1f 	bl	80135d0 <chGuardedPoolAllocTimeout>
 8006792:	4603      	mov	r3, r0
 8006794:	2b00      	cmp	r3, #0
 8006796:	bf14      	ite	ne
 8006798:	2301      	movne	r3, #1
 800679a:	2300      	moveq	r3, #0
 800679c:	b2db      	uxtb	r3, r3
 800679e:	4913      	ldr	r1, [pc, #76]	; (80067ec <oslib_test_003_002_execute.lto_priv.725+0x10c>)
 80067a0:	4618      	mov	r0, r3
 80067a2:	f00e fe6d 	bl	8015480 <_test_assert>
 80067a6:	4603      	mov	r3, r0
 80067a8:	2b00      	cmp	r3, #0
 80067aa:	d116      	bne.n	80067da <oslib_test_003_002_execute.lto_priv.725+0xfa>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80067ac:	9b01      	ldr	r3, [sp, #4]
 80067ae:	3301      	adds	r3, #1
 80067b0:	9301      	str	r3, [sp, #4]
 80067b2:	9b01      	ldr	r3, [sp, #4]
 80067b4:	2b03      	cmp	r3, #3
 80067b6:	d9e8      	bls.n	800678a <oslib_test_003_002_execute.lto_priv.725+0xaa>
  }

  /* [3.2.6] Now must be empty again.*/
  test_set_step(6);
 80067b8:	4b09      	ldr	r3, [pc, #36]	; (80067e0 <oslib_test_003_002_execute.lto_priv.725+0x100>)
 80067ba:	2206      	movs	r2, #6
 80067bc:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80067be:	2100      	movs	r1, #0
 80067c0:	4809      	ldr	r0, [pc, #36]	; (80067e8 <oslib_test_003_002_execute.lto_priv.725+0x108>)
 80067c2:	f00c ff05 	bl	80135d0 <chGuardedPoolAllocTimeout>
 80067c6:	4603      	mov	r3, r0
 80067c8:	2b00      	cmp	r3, #0
 80067ca:	bf0c      	ite	eq
 80067cc:	2301      	moveq	r3, #1
 80067ce:	2300      	movne	r3, #0
 80067d0:	b2db      	uxtb	r3, r3
 80067d2:	4907      	ldr	r1, [pc, #28]	; (80067f0 <oslib_test_003_002_execute.lto_priv.725+0x110>)
 80067d4:	4618      	mov	r0, r3
 80067d6:	f00e fe53 	bl	8015480 <_test_assert>
  }
}
 80067da:	b003      	add	sp, #12
 80067dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80067e0:	20001988 	.word	0x20001988
 80067e4:	200020cc 	.word	0x200020cc
 80067e8:	20000900 	.word	0x20000900
 80067ec:	080188e8 	.word	0x080188e8
 80067f0:	080188f4 	.word	0x080188f4
	...

08006800 <oslib_test_003_003_setup.lto_priv.726>:
 * - [3.3.1] Trying to allocate with 100mS timeout, must fail because
 *   the pool is empty.
 * .
 */

static void oslib_test_003_003_setup(void) {
 8006800:	b508      	push	{r3, lr}
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
 8006802:	2104      	movs	r1, #4
 8006804:	4801      	ldr	r0, [pc, #4]	; (800680c <oslib_test_003_003_setup.lto_priv.726+0xc>)
 8006806:	f7ff fe93 	bl	8006530 <chGuardedPoolObjectInit>
}
 800680a:	bd08      	pop	{r3, pc}
 800680c:	20000900 	.word	0x20000900

08006810 <oslib_test_003_003_execute.lto_priv.727>:

static void oslib_test_003_003_execute(void) {
 8006810:	b508      	push	{r3, lr}

  /* [3.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8006812:	4b09      	ldr	r3, [pc, #36]	; (8006838 <oslib_test_003_003_execute.lto_priv.727+0x28>)
 8006814:	2201      	movs	r2, #1
 8006816:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 8006818:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800681c:	4807      	ldr	r0, [pc, #28]	; (800683c <oslib_test_003_003_execute.lto_priv.727+0x2c>)
 800681e:	f00c fed7 	bl	80135d0 <chGuardedPoolAllocTimeout>
 8006822:	4603      	mov	r3, r0
 8006824:	2b00      	cmp	r3, #0
 8006826:	bf0c      	ite	eq
 8006828:	2301      	moveq	r3, #1
 800682a:	2300      	movne	r3, #0
 800682c:	b2db      	uxtb	r3, r3
 800682e:	4904      	ldr	r1, [pc, #16]	; (8006840 <oslib_test_003_003_execute.lto_priv.727+0x30>)
 8006830:	4618      	mov	r0, r3
 8006832:	f00e fe25 	bl	8015480 <_test_assert>
  }
}
 8006836:	bd08      	pop	{r3, pc}
 8006838:	20001988 	.word	0x20001988
 800683c:	20000900 	.word	0x20000900
 8006840:	080188f4 	.word	0x080188f4
	...

08006850 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8006850:	b500      	push	{lr}
 8006852:	b083      	sub	sp, #12
 8006854:	9001      	str	r0, [sp, #4]
 8006856:	9100      	str	r1, [sp, #0]

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 8006858:	2208      	movs	r2, #8
 800685a:	9900      	ldr	r1, [sp, #0]
 800685c:	9801      	ldr	r0, [sp, #4]
 800685e:	f00c fb4f 	bl	8012f00 <chHeapAllocAligned>
 8006862:	4603      	mov	r3, r0
}
 8006864:	4618      	mov	r0, r3
 8006866:	b003      	add	sp, #12
 8006868:	f85d fb04 	ldr.w	pc, [sp], #4
 800686c:	0000      	movs	r0, r0
	...

08006870 <oslib_test_004_001_setup.lto_priv.728>:
 * - [4.1.10] Testing final conditions. The heap geometry must be the
 *   same than the one registered at beginning.
 * .
 */

static void oslib_test_004_001_setup(void) {
 8006870:	b508      	push	{r3, lr}
  chHeapObjectInit(&test_heap, test_heap_buffer, sizeof(test_heap_buffer));
 8006872:	2280      	movs	r2, #128	; 0x80
 8006874:	4902      	ldr	r1, [pc, #8]	; (8006880 <oslib_test_004_001_setup.lto_priv.728+0x10>)
 8006876:	4803      	ldr	r0, [pc, #12]	; (8006884 <oslib_test_004_001_setup.lto_priv.728+0x14>)
 8006878:	f00c fb0a 	bl	8012e90 <chHeapObjectInit>
}
 800687c:	bd08      	pop	{r3, pc}
 800687e:	bf00      	nop
 8006880:	200020f8 	.word	0x200020f8
 8006884:	200020dc 	.word	0x200020dc
	...

08006890 <oslib_test_004_001_execute.lto_priv.729>:

static void oslib_test_004_001_execute(void) {
 8006890:	b500      	push	{lr}
 8006892:	b089      	sub	sp, #36	; 0x24
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [4.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 8006894:	4b8b      	ldr	r3, [pc, #556]	; (8006ac4 <oslib_test_004_001_execute.lto_priv.729+0x234>)
 8006896:	2201      	movs	r2, #1
 8006898:	601a      	str	r2, [r3, #0]
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 800689a:	ab03      	add	r3, sp, #12
 800689c:	2200      	movs	r2, #0
 800689e:	4619      	mov	r1, r3
 80068a0:	4889      	ldr	r0, [pc, #548]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 80068a2:	f00c fc9d 	bl	80131e0 <chHeapStatus>
 80068a6:	4603      	mov	r3, r0
 80068a8:	2b01      	cmp	r3, #1
 80068aa:	bf0c      	ite	eq
 80068ac:	2301      	moveq	r3, #1
 80068ae:	2300      	movne	r3, #0
 80068b0:	b2db      	uxtb	r3, r3
 80068b2:	4986      	ldr	r1, [pc, #536]	; (8006acc <oslib_test_004_001_execute.lto_priv.729+0x23c>)
 80068b4:	4618      	mov	r0, r3
 80068b6:	f00e fde3 	bl	8015480 <_test_assert>
 80068ba:	4603      	mov	r3, r0
 80068bc:	2b00      	cmp	r3, #0
 80068be:	f040 81ce 	bne.w	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
  }

  /* [4.1.2] Trying to allocate an block bigger than available space,
     an error is expected.*/
  test_set_step(2);
 80068c2:	4b80      	ldr	r3, [pc, #512]	; (8006ac4 <oslib_test_004_001_execute.lto_priv.729+0x234>)
 80068c4:	2202      	movs	r2, #2
 80068c6:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, sizeof test_heap_buffer * 2);
 80068c8:	f44f 7180 	mov.w	r1, #256	; 0x100
 80068cc:	487e      	ldr	r0, [pc, #504]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 80068ce:	f7ff ffbf 	bl	8006850 <chHeapAlloc>
 80068d2:	9007      	str	r0, [sp, #28]
    test_assert(p1 == NULL, "allocation not failed");
 80068d4:	9b07      	ldr	r3, [sp, #28]
 80068d6:	2b00      	cmp	r3, #0
 80068d8:	bf0c      	ite	eq
 80068da:	2301      	moveq	r3, #1
 80068dc:	2300      	movne	r3, #0
 80068de:	b2db      	uxtb	r3, r3
 80068e0:	497b      	ldr	r1, [pc, #492]	; (8006ad0 <oslib_test_004_001_execute.lto_priv.729+0x240>)
 80068e2:	4618      	mov	r0, r3
 80068e4:	f00e fdcc 	bl	8015480 <_test_assert>
 80068e8:	4603      	mov	r3, r0
 80068ea:	2b00      	cmp	r3, #0
 80068ec:	f040 81b7 	bne.w	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
  }

  /* [4.1.3] Single block allocation using chHeapAlloc() then the block
     is freed using chHeapFree(), must not fail.*/
  test_set_step(3);
 80068f0:	4b74      	ldr	r3, [pc, #464]	; (8006ac4 <oslib_test_004_001_execute.lto_priv.729+0x234>)
 80068f2:	2203      	movs	r2, #3
 80068f4:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 80068f6:	2110      	movs	r1, #16
 80068f8:	4873      	ldr	r0, [pc, #460]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 80068fa:	f7ff ffa9 	bl	8006850 <chHeapAlloc>
 80068fe:	9007      	str	r0, [sp, #28]
    test_assert(p1 != NULL, "allocation failed");
 8006900:	9b07      	ldr	r3, [sp, #28]
 8006902:	2b00      	cmp	r3, #0
 8006904:	bf14      	ite	ne
 8006906:	2301      	movne	r3, #1
 8006908:	2300      	moveq	r3, #0
 800690a:	b2db      	uxtb	r3, r3
 800690c:	4971      	ldr	r1, [pc, #452]	; (8006ad4 <oslib_test_004_001_execute.lto_priv.729+0x244>)
 800690e:	4618      	mov	r0, r3
 8006910:	f00e fdb6 	bl	8015480 <_test_assert>
 8006914:	4603      	mov	r3, r0
 8006916:	2b00      	cmp	r3, #0
 8006918:	f040 81a1 	bne.w	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
    chHeapFree(p1);
 800691c:	9807      	ldr	r0, [sp, #28]
 800691e:	f00c fbd7 	bl	80130d0 <chHeapFree>
  }

  /* [4.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 8006922:	4b68      	ldr	r3, [pc, #416]	; (8006ac4 <oslib_test_004_001_execute.lto_priv.729+0x234>)
 8006924:	2204      	movs	r2, #4
 8006926:	601a      	str	r2, [r3, #0]
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8006928:	aa01      	add	r2, sp, #4
 800692a:	ab02      	add	r3, sp, #8
 800692c:	4619      	mov	r1, r3
 800692e:	4866      	ldr	r0, [pc, #408]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006930:	f00c fc56 	bl	80131e0 <chHeapStatus>
 8006934:	4603      	mov	r3, r0
 8006936:	9304      	str	r3, [sp, #16]
    test_assert(n == 1, "missing free block");
 8006938:	9b04      	ldr	r3, [sp, #16]
 800693a:	2b01      	cmp	r3, #1
 800693c:	bf0c      	ite	eq
 800693e:	2301      	moveq	r3, #1
 8006940:	2300      	movne	r3, #0
 8006942:	b2db      	uxtb	r3, r3
 8006944:	4964      	ldr	r1, [pc, #400]	; (8006ad8 <oslib_test_004_001_execute.lto_priv.729+0x248>)
 8006946:	4618      	mov	r0, r3
 8006948:	f00e fd9a 	bl	8015480 <_test_assert>
 800694c:	4603      	mov	r3, r0
 800694e:	2b00      	cmp	r3, #0
 8006950:	f040 8184 	bne.w	8006c5c <oslib_test_004_001_execute.lto_priv.729+0x3cc>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 8006954:	9b02      	ldr	r3, [sp, #8]
 8006956:	2b0f      	cmp	r3, #15
 8006958:	bf8c      	ite	hi
 800695a:	2301      	movhi	r3, #1
 800695c:	2300      	movls	r3, #0
 800695e:	b2db      	uxtb	r3, r3
 8006960:	495e      	ldr	r1, [pc, #376]	; (8006adc <oslib_test_004_001_execute.lto_priv.729+0x24c>)
 8006962:	4618      	mov	r0, r3
 8006964:	f00e fd8c 	bl	8015480 <_test_assert>
 8006968:	4603      	mov	r3, r0
 800696a:	2b00      	cmp	r3, #0
 800696c:	f040 8176 	bne.w	8006c5c <oslib_test_004_001_execute.lto_priv.729+0x3cc>
    test_assert(total_size == largest_size, "unexpected heap state");
 8006970:	9a02      	ldr	r2, [sp, #8]
 8006972:	9b01      	ldr	r3, [sp, #4]
 8006974:	429a      	cmp	r2, r3
 8006976:	bf0c      	ite	eq
 8006978:	2301      	moveq	r3, #1
 800697a:	2300      	movne	r3, #0
 800697c:	b2db      	uxtb	r3, r3
 800697e:	4957      	ldr	r1, [pc, #348]	; (8006adc <oslib_test_004_001_execute.lto_priv.729+0x24c>)
 8006980:	4618      	mov	r0, r3
 8006982:	f00e fd7d 	bl	8015480 <_test_assert>
 8006986:	4603      	mov	r3, r0
 8006988:	2b00      	cmp	r3, #0
 800698a:	f040 8167 	bne.w	8006c5c <oslib_test_004_001_execute.lto_priv.729+0x3cc>
  }

  /* [4.1.5] Allocating then freeing in the same order.*/
  test_set_step(5);
 800698e:	4b4d      	ldr	r3, [pc, #308]	; (8006ac4 <oslib_test_004_001_execute.lto_priv.729+0x234>)
 8006990:	2205      	movs	r2, #5
 8006992:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 8006994:	2110      	movs	r1, #16
 8006996:	484c      	ldr	r0, [pc, #304]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006998:	f7ff ff5a 	bl	8006850 <chHeapAlloc>
 800699c:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800699e:	2110      	movs	r1, #16
 80069a0:	4849      	ldr	r0, [pc, #292]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 80069a2:	f7ff ff55 	bl	8006850 <chHeapAlloc>
 80069a6:	9006      	str	r0, [sp, #24]
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 80069a8:	2110      	movs	r1, #16
 80069aa:	4847      	ldr	r0, [pc, #284]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 80069ac:	f7ff ff50 	bl	8006850 <chHeapAlloc>
 80069b0:	9005      	str	r0, [sp, #20]
    chHeapFree(p1);                                 /* Does not merge.*/
 80069b2:	9807      	ldr	r0, [sp, #28]
 80069b4:	f00c fb8c 	bl	80130d0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 80069b8:	9806      	ldr	r0, [sp, #24]
 80069ba:	f00c fb89 	bl	80130d0 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 80069be:	9805      	ldr	r0, [sp, #20]
 80069c0:	f00c fb86 	bl	80130d0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80069c4:	ab04      	add	r3, sp, #16
 80069c6:	2200      	movs	r2, #0
 80069c8:	4619      	mov	r1, r3
 80069ca:	483f      	ldr	r0, [pc, #252]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 80069cc:	f00c fc08 	bl	80131e0 <chHeapStatus>
 80069d0:	4603      	mov	r3, r0
 80069d2:	2b01      	cmp	r3, #1
 80069d4:	bf0c      	ite	eq
 80069d6:	2301      	moveq	r3, #1
 80069d8:	2300      	movne	r3, #0
 80069da:	b2db      	uxtb	r3, r3
 80069dc:	493b      	ldr	r1, [pc, #236]	; (8006acc <oslib_test_004_001_execute.lto_priv.729+0x23c>)
 80069de:	4618      	mov	r0, r3
 80069e0:	f00e fd4e 	bl	8015480 <_test_assert>
 80069e4:	4603      	mov	r3, r0
 80069e6:	2b00      	cmp	r3, #0
 80069e8:	f040 8139 	bne.w	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
  }

  /* [4.1.6] Allocating then freeing in reverse order.*/
  test_set_step(6);
 80069ec:	4b35      	ldr	r3, [pc, #212]	; (8006ac4 <oslib_test_004_001_execute.lto_priv.729+0x234>)
 80069ee:	2206      	movs	r2, #6
 80069f0:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 80069f2:	2110      	movs	r1, #16
 80069f4:	4834      	ldr	r0, [pc, #208]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 80069f6:	f7ff ff2b 	bl	8006850 <chHeapAlloc>
 80069fa:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 80069fc:	2110      	movs	r1, #16
 80069fe:	4832      	ldr	r0, [pc, #200]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006a00:	f7ff ff26 	bl	8006850 <chHeapAlloc>
 8006a04:	9006      	str	r0, [sp, #24]
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 8006a06:	2110      	movs	r1, #16
 8006a08:	482f      	ldr	r0, [pc, #188]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006a0a:	f7ff ff21 	bl	8006850 <chHeapAlloc>
 8006a0e:	9005      	str	r0, [sp, #20]
    chHeapFree(p3);                                 /* Merges forward.*/
 8006a10:	9805      	ldr	r0, [sp, #20]
 8006a12:	f00c fb5d 	bl	80130d0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 8006a16:	9806      	ldr	r0, [sp, #24]
 8006a18:	f00c fb5a 	bl	80130d0 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 8006a1c:	9807      	ldr	r0, [sp, #28]
 8006a1e:	f00c fb57 	bl	80130d0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006a22:	ab04      	add	r3, sp, #16
 8006a24:	2200      	movs	r2, #0
 8006a26:	4619      	mov	r1, r3
 8006a28:	4827      	ldr	r0, [pc, #156]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006a2a:	f00c fbd9 	bl	80131e0 <chHeapStatus>
 8006a2e:	4603      	mov	r3, r0
 8006a30:	2b01      	cmp	r3, #1
 8006a32:	bf0c      	ite	eq
 8006a34:	2301      	moveq	r3, #1
 8006a36:	2300      	movne	r3, #0
 8006a38:	b2db      	uxtb	r3, r3
 8006a3a:	4924      	ldr	r1, [pc, #144]	; (8006acc <oslib_test_004_001_execute.lto_priv.729+0x23c>)
 8006a3c:	4618      	mov	r0, r3
 8006a3e:	f00e fd1f 	bl	8015480 <_test_assert>
 8006a42:	4603      	mov	r3, r0
 8006a44:	2b00      	cmp	r3, #0
 8006a46:	f040 810a 	bne.w	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
  }

  /* [4.1.7] Small fragments handling. Checking the behavior when
     allocating blocks with size not multiple of alignment unit.*/
  test_set_step(7);
 8006a4a:	4b1e      	ldr	r3, [pc, #120]	; (8006ac4 <oslib_test_004_001_execute.lto_priv.729+0x234>)
 8006a4c:	2207      	movs	r2, #7
 8006a4e:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE + 1);
 8006a50:	2111      	movs	r1, #17
 8006a52:	481d      	ldr	r0, [pc, #116]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006a54:	f7ff fefc 	bl	8006850 <chHeapAlloc>
 8006a58:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 8006a5a:	2110      	movs	r1, #16
 8006a5c:	481a      	ldr	r0, [pc, #104]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006a5e:	f7ff fef7 	bl	8006850 <chHeapAlloc>
 8006a62:	9006      	str	r0, [sp, #24]
    chHeapFree(p1);
 8006a64:	9807      	ldr	r0, [sp, #28]
 8006a66:	f00c fb33 	bl	80130d0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8006a6a:	ab04      	add	r3, sp, #16
 8006a6c:	2200      	movs	r2, #0
 8006a6e:	4619      	mov	r1, r3
 8006a70:	4815      	ldr	r0, [pc, #84]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006a72:	f00c fbb5 	bl	80131e0 <chHeapStatus>
 8006a76:	4603      	mov	r3, r0
 8006a78:	2b02      	cmp	r3, #2
 8006a7a:	bf0c      	ite	eq
 8006a7c:	2301      	moveq	r3, #1
 8006a7e:	2300      	movne	r3, #0
 8006a80:	b2db      	uxtb	r3, r3
 8006a82:	4917      	ldr	r1, [pc, #92]	; (8006ae0 <oslib_test_004_001_execute.lto_priv.729+0x250>)
 8006a84:	4618      	mov	r0, r3
 8006a86:	f00e fcfb 	bl	8015480 <_test_assert>
 8006a8a:	4603      	mov	r3, r0
 8006a8c:	2b00      	cmp	r3, #0
 8006a8e:	f040 80e6 	bne.w	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 8006a92:	2110      	movs	r1, #16
 8006a94:	480c      	ldr	r0, [pc, #48]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006a96:	f7ff fedb 	bl	8006850 <chHeapAlloc>
 8006a9a:	9007      	str	r0, [sp, #28]
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8006a9c:	ab04      	add	r3, sp, #16
 8006a9e:	2200      	movs	r2, #0
 8006aa0:	4619      	mov	r1, r3
 8006aa2:	4809      	ldr	r0, [pc, #36]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006aa4:	f00c fb9c 	bl	80131e0 <chHeapStatus>
 8006aa8:	4603      	mov	r3, r0
 8006aaa:	2b01      	cmp	r3, #1
 8006aac:	d008      	beq.n	8006ac0 <oslib_test_004_001_execute.lto_priv.729+0x230>
 8006aae:	ab04      	add	r3, sp, #16
 8006ab0:	2200      	movs	r2, #0
 8006ab2:	4619      	mov	r1, r3
 8006ab4:	4804      	ldr	r0, [pc, #16]	; (8006ac8 <oslib_test_004_001_execute.lto_priv.729+0x238>)
 8006ab6:	f00c fb93 	bl	80131e0 <chHeapStatus>
 8006aba:	4603      	mov	r3, r0
 8006abc:	2b02      	cmp	r3, #2
 8006abe:	d111      	bne.n	8006ae4 <oslib_test_004_001_execute.lto_priv.729+0x254>
 8006ac0:	2301      	movs	r3, #1
 8006ac2:	e010      	b.n	8006ae6 <oslib_test_004_001_execute.lto_priv.729+0x256>
 8006ac4:	20001988 	.word	0x20001988
 8006ac8:	200020dc 	.word	0x200020dc
 8006acc:	080183f8 	.word	0x080183f8
 8006ad0:	08018968 	.word	0x08018968
 8006ad4:	08018980 	.word	0x08018980
 8006ad8:	08018994 	.word	0x08018994
 8006adc:	080189a8 	.word	0x080189a8
 8006ae0:	080189c0 	.word	0x080189c0
 8006ae4:	2300      	movs	r3, #0
 8006ae6:	f003 0301 	and.w	r3, r3, #1
 8006aea:	b2db      	uxtb	r3, r3
 8006aec:	495d      	ldr	r1, [pc, #372]	; (8006c64 <oslib_test_004_001_execute.lto_priv.729+0x3d4>)
 8006aee:	4618      	mov	r0, r3
 8006af0:	f00e fcc6 	bl	8015480 <_test_assert>
 8006af4:	4603      	mov	r3, r0
 8006af6:	2b00      	cmp	r3, #0
 8006af8:	f040 80b1 	bne.w	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
                (chHeapStatus(&test_heap, &n, NULL) == 2), "heap fragmented");
    chHeapFree(p2);
 8006afc:	9806      	ldr	r0, [sp, #24]
 8006afe:	f00c fae7 	bl	80130d0 <chHeapFree>
    chHeapFree(p1);
 8006b02:	9807      	ldr	r0, [sp, #28]
 8006b04:	f00c fae4 	bl	80130d0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006b08:	ab04      	add	r3, sp, #16
 8006b0a:	2200      	movs	r2, #0
 8006b0c:	4619      	mov	r1, r3
 8006b0e:	4856      	ldr	r0, [pc, #344]	; (8006c68 <oslib_test_004_001_execute.lto_priv.729+0x3d8>)
 8006b10:	f00c fb66 	bl	80131e0 <chHeapStatus>
 8006b14:	4603      	mov	r3, r0
 8006b16:	2b01      	cmp	r3, #1
 8006b18:	bf0c      	ite	eq
 8006b1a:	2301      	moveq	r3, #1
 8006b1c:	2300      	movne	r3, #0
 8006b1e:	b2db      	uxtb	r3, r3
 8006b20:	4950      	ldr	r1, [pc, #320]	; (8006c64 <oslib_test_004_001_execute.lto_priv.729+0x3d4>)
 8006b22:	4618      	mov	r0, r3
 8006b24:	f00e fcac 	bl	8015480 <_test_assert>
 8006b28:	4603      	mov	r3, r0
 8006b2a:	2b00      	cmp	r3, #0
 8006b2c:	f040 8097 	bne.w	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
  }

  /* [4.1.8] Skipping a fragment, the first fragment in the list is too
     small so the allocator must pick the second one.*/
  test_set_step(8);
 8006b30:	4b4e      	ldr	r3, [pc, #312]	; (8006c6c <oslib_test_004_001_execute.lto_priv.729+0x3dc>)
 8006b32:	2208      	movs	r2, #8
 8006b34:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 8006b36:	2110      	movs	r1, #16
 8006b38:	484b      	ldr	r0, [pc, #300]	; (8006c68 <oslib_test_004_001_execute.lto_priv.729+0x3d8>)
 8006b3a:	f7ff fe89 	bl	8006850 <chHeapAlloc>
 8006b3e:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 8006b40:	2110      	movs	r1, #16
 8006b42:	4849      	ldr	r0, [pc, #292]	; (8006c68 <oslib_test_004_001_execute.lto_priv.729+0x3d8>)
 8006b44:	f7ff fe84 	bl	8006850 <chHeapAlloc>
 8006b48:	9006      	str	r0, [sp, #24]
    chHeapFree(p1);
 8006b4a:	9807      	ldr	r0, [sp, #28]
 8006b4c:	f00c fac0 	bl	80130d0 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8006b50:	ab04      	add	r3, sp, #16
 8006b52:	2200      	movs	r2, #0
 8006b54:	4619      	mov	r1, r3
 8006b56:	4844      	ldr	r0, [pc, #272]	; (8006c68 <oslib_test_004_001_execute.lto_priv.729+0x3d8>)
 8006b58:	f00c fb42 	bl	80131e0 <chHeapStatus>
 8006b5c:	4603      	mov	r3, r0
 8006b5e:	2b02      	cmp	r3, #2
 8006b60:	bf0c      	ite	eq
 8006b62:	2301      	moveq	r3, #1
 8006b64:	2300      	movne	r3, #0
 8006b66:	b2db      	uxtb	r3, r3
 8006b68:	4941      	ldr	r1, [pc, #260]	; (8006c70 <oslib_test_004_001_execute.lto_priv.729+0x3e0>)
 8006b6a:	4618      	mov	r0, r3
 8006b6c:	f00e fc88 	bl	8015480 <_test_assert>
 8006b70:	4603      	mov	r3, r0
 8006b72:	2b00      	cmp	r3, #0
 8006b74:	d173      	bne.n	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE * 2); /* Skips first fragment.*/
 8006b76:	2120      	movs	r1, #32
 8006b78:	483b      	ldr	r0, [pc, #236]	; (8006c68 <oslib_test_004_001_execute.lto_priv.729+0x3d8>)
 8006b7a:	f7ff fe69 	bl	8006850 <chHeapAlloc>
 8006b7e:	9007      	str	r0, [sp, #28]
    chHeapFree(p1);
 8006b80:	9807      	ldr	r0, [sp, #28]
 8006b82:	f00c faa5 	bl	80130d0 <chHeapFree>
    chHeapFree(p2);
 8006b86:	9806      	ldr	r0, [sp, #24]
 8006b88:	f00c faa2 	bl	80130d0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006b8c:	ab04      	add	r3, sp, #16
 8006b8e:	2200      	movs	r2, #0
 8006b90:	4619      	mov	r1, r3
 8006b92:	4835      	ldr	r0, [pc, #212]	; (8006c68 <oslib_test_004_001_execute.lto_priv.729+0x3d8>)
 8006b94:	f00c fb24 	bl	80131e0 <chHeapStatus>
 8006b98:	4603      	mov	r3, r0
 8006b9a:	2b01      	cmp	r3, #1
 8006b9c:	bf0c      	ite	eq
 8006b9e:	2301      	moveq	r3, #1
 8006ba0:	2300      	movne	r3, #0
 8006ba2:	b2db      	uxtb	r3, r3
 8006ba4:	492f      	ldr	r1, [pc, #188]	; (8006c64 <oslib_test_004_001_execute.lto_priv.729+0x3d4>)
 8006ba6:	4618      	mov	r0, r3
 8006ba8:	f00e fc6a 	bl	8015480 <_test_assert>
 8006bac:	4603      	mov	r3, r0
 8006bae:	2b00      	cmp	r3, #0
 8006bb0:	d155      	bne.n	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
  }

  /* [4.1.9] Allocating the whole available space.*/
  test_set_step(9);
 8006bb2:	4b2e      	ldr	r3, [pc, #184]	; (8006c6c <oslib_test_004_001_execute.lto_priv.729+0x3dc>)
 8006bb4:	2209      	movs	r2, #9
 8006bb6:	601a      	str	r2, [r3, #0]
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 8006bb8:	ab04      	add	r3, sp, #16
 8006bba:	2200      	movs	r2, #0
 8006bbc:	4619      	mov	r1, r3
 8006bbe:	482a      	ldr	r0, [pc, #168]	; (8006c68 <oslib_test_004_001_execute.lto_priv.729+0x3d8>)
 8006bc0:	f00c fb0e 	bl	80131e0 <chHeapStatus>
    p1 = chHeapAlloc(&test_heap, n);
 8006bc4:	9b04      	ldr	r3, [sp, #16]
 8006bc6:	4619      	mov	r1, r3
 8006bc8:	4827      	ldr	r0, [pc, #156]	; (8006c68 <oslib_test_004_001_execute.lto_priv.729+0x3d8>)
 8006bca:	f7ff fe41 	bl	8006850 <chHeapAlloc>
 8006bce:	9007      	str	r0, [sp, #28]
    test_assert(p1 != NULL, "allocation failed");
 8006bd0:	9b07      	ldr	r3, [sp, #28]
 8006bd2:	2b00      	cmp	r3, #0
 8006bd4:	bf14      	ite	ne
 8006bd6:	2301      	movne	r3, #1
 8006bd8:	2300      	moveq	r3, #0
 8006bda:	b2db      	uxtb	r3, r3
 8006bdc:	4925      	ldr	r1, [pc, #148]	; (8006c74 <oslib_test_004_001_execute.lto_priv.729+0x3e4>)
 8006bde:	4618      	mov	r0, r3
 8006be0:	f00e fc4e 	bl	8015480 <_test_assert>
 8006be4:	4603      	mov	r3, r0
 8006be6:	2b00      	cmp	r3, #0
 8006be8:	d139      	bne.n	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 8006bea:	2200      	movs	r2, #0
 8006bec:	2100      	movs	r1, #0
 8006bee:	481e      	ldr	r0, [pc, #120]	; (8006c68 <oslib_test_004_001_execute.lto_priv.729+0x3d8>)
 8006bf0:	f00c faf6 	bl	80131e0 <chHeapStatus>
 8006bf4:	4603      	mov	r3, r0
 8006bf6:	2b00      	cmp	r3, #0
 8006bf8:	bf0c      	ite	eq
 8006bfa:	2301      	moveq	r3, #1
 8006bfc:	2300      	movne	r3, #0
 8006bfe:	b2db      	uxtb	r3, r3
 8006c00:	491d      	ldr	r1, [pc, #116]	; (8006c78 <oslib_test_004_001_execute.lto_priv.729+0x3e8>)
 8006c02:	4618      	mov	r0, r3
 8006c04:	f00e fc3c 	bl	8015480 <_test_assert>
 8006c08:	4603      	mov	r3, r0
 8006c0a:	2b00      	cmp	r3, #0
 8006c0c:	d127      	bne.n	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
    chHeapFree(p1);
 8006c0e:	9807      	ldr	r0, [sp, #28]
 8006c10:	f00c fa5e 	bl	80130d0 <chHeapFree>
  }

  /* [4.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 8006c14:	4b15      	ldr	r3, [pc, #84]	; (8006c6c <oslib_test_004_001_execute.lto_priv.729+0x3dc>)
 8006c16:	220a      	movs	r2, #10
 8006c18:	601a      	str	r2, [r3, #0]
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006c1a:	ab04      	add	r3, sp, #16
 8006c1c:	2200      	movs	r2, #0
 8006c1e:	4619      	mov	r1, r3
 8006c20:	4811      	ldr	r0, [pc, #68]	; (8006c68 <oslib_test_004_001_execute.lto_priv.729+0x3d8>)
 8006c22:	f00c fadd 	bl	80131e0 <chHeapStatus>
 8006c26:	4603      	mov	r3, r0
 8006c28:	2b01      	cmp	r3, #1
 8006c2a:	bf0c      	ite	eq
 8006c2c:	2301      	moveq	r3, #1
 8006c2e:	2300      	movne	r3, #0
 8006c30:	b2db      	uxtb	r3, r3
 8006c32:	490c      	ldr	r1, [pc, #48]	; (8006c64 <oslib_test_004_001_execute.lto_priv.729+0x3d4>)
 8006c34:	4618      	mov	r0, r3
 8006c36:	f00e fc23 	bl	8015480 <_test_assert>
 8006c3a:	4603      	mov	r3, r0
 8006c3c:	2b00      	cmp	r3, #0
 8006c3e:	d10e      	bne.n	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
    test_assert(n == sz, "size changed");
 8006c40:	9a04      	ldr	r2, [sp, #16]
 8006c42:	9b03      	ldr	r3, [sp, #12]
 8006c44:	429a      	cmp	r2, r3
 8006c46:	bf0c      	ite	eq
 8006c48:	2301      	moveq	r3, #1
 8006c4a:	2300      	movne	r3, #0
 8006c4c:	b2db      	uxtb	r3, r3
 8006c4e:	490b      	ldr	r1, [pc, #44]	; (8006c7c <oslib_test_004_001_execute.lto_priv.729+0x3ec>)
 8006c50:	4618      	mov	r0, r3
 8006c52:	f00e fc15 	bl	8015480 <_test_assert>
 8006c56:	4603      	mov	r3, r0
 8006c58:	2b00      	cmp	r3, #0
 8006c5a:	e000      	b.n	8006c5e <oslib_test_004_001_execute.lto_priv.729+0x3ce>
    test_assert(n == 1, "missing free block");
 8006c5c:	bf00      	nop
  }
}
 8006c5e:	b009      	add	sp, #36	; 0x24
 8006c60:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c64:	080183f8 	.word	0x080183f8
 8006c68:	200020dc 	.word	0x200020dc
 8006c6c:	20001988 	.word	0x20001988
 8006c70:	080189c0 	.word	0x080189c0
 8006c74:	08018980 	.word	0x08018980
 8006c78:	08018760 	.word	0x08018760
 8006c7c:	080189d0 	.word	0x080189d0

08006c80 <oslib_test_004_002_execute.lto_priv.730>:
 *   is freed using chHeapFree(), must not fail.
 * - [4.2.2] Testing allocation failure.
 * .
 */

static void oslib_test_004_002_execute(void) {
 8006c80:	b500      	push	{lr}
 8006c82:	b085      	sub	sp, #20
  void *p1;
  size_t total_size, largest_size;

  /* [4.2.1] Single block allocation using chHeapAlloc() then the block
     is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8006c84:	4b1a      	ldr	r3, [pc, #104]	; (8006cf0 <oslib_test_004_002_execute.lto_priv.730+0x70>)
 8006c86:	2201      	movs	r2, #1
 8006c88:	601a      	str	r2, [r3, #0]
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8006c8a:	aa01      	add	r2, sp, #4
 8006c8c:	ab02      	add	r3, sp, #8
 8006c8e:	4619      	mov	r1, r3
 8006c90:	2000      	movs	r0, #0
 8006c92:	f00c faa5 	bl	80131e0 <chHeapStatus>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 8006c96:	2110      	movs	r1, #16
 8006c98:	4816      	ldr	r0, [pc, #88]	; (8006cf4 <oslib_test_004_002_execute.lto_priv.730+0x74>)
 8006c9a:	f7ff fdd9 	bl	8006850 <chHeapAlloc>
 8006c9e:	9003      	str	r0, [sp, #12]
    test_assert(p1 != NULL, "allocation failed");
 8006ca0:	9b03      	ldr	r3, [sp, #12]
 8006ca2:	2b00      	cmp	r3, #0
 8006ca4:	bf14      	ite	ne
 8006ca6:	2301      	movne	r3, #1
 8006ca8:	2300      	moveq	r3, #0
 8006caa:	b2db      	uxtb	r3, r3
 8006cac:	4912      	ldr	r1, [pc, #72]	; (8006cf8 <oslib_test_004_002_execute.lto_priv.730+0x78>)
 8006cae:	4618      	mov	r0, r3
 8006cb0:	f00e fbe6 	bl	8015480 <_test_assert>
 8006cb4:	4603      	mov	r3, r0
 8006cb6:	2b00      	cmp	r3, #0
 8006cb8:	d117      	bne.n	8006cea <oslib_test_004_002_execute.lto_priv.730+0x6a>
    chHeapFree(p1);
 8006cba:	9803      	ldr	r0, [sp, #12]
 8006cbc:	f00c fa08 	bl	80130d0 <chHeapFree>
  }

  /* [4.2.2] Testing allocation failure.*/
  test_set_step(2);
 8006cc0:	4b0b      	ldr	r3, [pc, #44]	; (8006cf0 <oslib_test_004_002_execute.lto_priv.730+0x70>)
 8006cc2:	2202      	movs	r2, #2
 8006cc4:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
 8006cc6:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 8006cca:	2000      	movs	r0, #0
 8006ccc:	f7ff fdc0 	bl	8006850 <chHeapAlloc>
 8006cd0:	9003      	str	r0, [sp, #12]
    test_assert(p1 == NULL, "allocation not failed");
 8006cd2:	9b03      	ldr	r3, [sp, #12]
 8006cd4:	2b00      	cmp	r3, #0
 8006cd6:	bf0c      	ite	eq
 8006cd8:	2301      	moveq	r3, #1
 8006cda:	2300      	movne	r3, #0
 8006cdc:	b2db      	uxtb	r3, r3
 8006cde:	4907      	ldr	r1, [pc, #28]	; (8006cfc <oslib_test_004_002_execute.lto_priv.730+0x7c>)
 8006ce0:	4618      	mov	r0, r3
 8006ce2:	f00e fbcd 	bl	8015480 <_test_assert>
 8006ce6:	4603      	mov	r3, r0
 8006ce8:	2b00      	cmp	r3, #0
  }
}
 8006cea:	b005      	add	sp, #20
 8006cec:	f85d fb04 	ldr.w	pc, [sp], #4
 8006cf0:	20001988 	.word	0x20001988
 8006cf4:	200020dc 	.word	0x200020dc
 8006cf8:	08018980 	.word	0x08018980
 8006cfc:	08018968 	.word	0x08018968

08006d00 <chFactoryDuplicateReference>:
 * @param[in] dep       pointer to the element field of the object
 * @return              The duplicated object reference.
 *
 * @api
 */
static inline dyn_element_t *chFactoryDuplicateReference(dyn_element_t *dep) {
 8006d00:	b082      	sub	sp, #8
 8006d02:	9001      	str	r0, [sp, #4]

  dep->refs++;
 8006d04:	9b01      	ldr	r3, [sp, #4]
 8006d06:	685b      	ldr	r3, [r3, #4]
 8006d08:	1c5a      	adds	r2, r3, #1
 8006d0a:	9b01      	ldr	r3, [sp, #4]
 8006d0c:	605a      	str	r2, [r3, #4]

  return dep;
 8006d0e:	9b01      	ldr	r3, [sp, #4]
}
 8006d10:	4618      	mov	r0, r3
 8006d12:	b002      	add	sp, #8
 8006d14:	4770      	bx	lr
 8006d16:	bf00      	nop
	...

08006d20 <oslib_test_005_001_teardown.lto_priv.731>:
 * - [5.1.6] Retrieving the registered object by name again, must not
 *   exist.
 * .
 */

static void oslib_test_005_001_teardown(void) {
 8006d20:	b500      	push	{lr}
 8006d22:	b083      	sub	sp, #12
  registered_object_t *rop;

  rop = chFactoryFindObject("myobj");
 8006d24:	4808      	ldr	r0, [pc, #32]	; (8006d48 <oslib_test_005_001_teardown.lto_priv.731+0x28>)
 8006d26:	f00d f8e3 	bl	8013ef0 <chFactoryFindObject>
 8006d2a:	9001      	str	r0, [sp, #4]
  if (rop != NULL) {
 8006d2c:	9b01      	ldr	r3, [sp, #4]
 8006d2e:	2b00      	cmp	r3, #0
 8006d30:	d103      	bne.n	8006d3a <oslib_test_005_001_teardown.lto_priv.731+0x1a>
 8006d32:	e006      	b.n	8006d42 <oslib_test_005_001_teardown.lto_priv.731+0x22>
    while (rop->element.refs > 0U) {
      chFactoryReleaseObject(rop);
 8006d34:	9801      	ldr	r0, [sp, #4]
 8006d36:	f00d f8f3 	bl	8013f20 <chFactoryReleaseObject>
    while (rop->element.refs > 0U) {
 8006d3a:	9b01      	ldr	r3, [sp, #4]
 8006d3c:	685b      	ldr	r3, [r3, #4]
 8006d3e:	2b00      	cmp	r3, #0
 8006d40:	d1f8      	bne.n	8006d34 <oslib_test_005_001_teardown.lto_priv.731+0x14>
    }
  }
}
 8006d42:	b003      	add	sp, #12
 8006d44:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d48:	08018a14 	.word	0x08018a14
 8006d4c:	00000000 	.word	0x00000000

08006d50 <oslib_test_005_001_execute.lto_priv.732>:

static void oslib_test_005_001_execute(void) {
 8006d50:	b500      	push	{lr}
 8006d52:	b085      	sub	sp, #20
  registered_object_t *rop;

  /* [5.1.1] Retrieving a registered object by name, must not exist.*/
  test_set_step(1);
 8006d54:	4b78      	ldr	r3, [pc, #480]	; (8006f38 <oslib_test_005_001_execute.lto_priv.732+0x1e8>)
 8006d56:	2201      	movs	r2, #1
 8006d58:	601a      	str	r2, [r3, #0]
  {
    rop = chFactoryFindObject("myobj");
 8006d5a:	4878      	ldr	r0, [pc, #480]	; (8006f3c <oslib_test_005_001_execute.lto_priv.732+0x1ec>)
 8006d5c:	f00d f8c8 	bl	8013ef0 <chFactoryFindObject>
 8006d60:	9003      	str	r0, [sp, #12]
    test_assert(rop == NULL, "found");
 8006d62:	9b03      	ldr	r3, [sp, #12]
 8006d64:	2b00      	cmp	r3, #0
 8006d66:	bf0c      	ite	eq
 8006d68:	2301      	moveq	r3, #1
 8006d6a:	2300      	movne	r3, #0
 8006d6c:	b2db      	uxtb	r3, r3
 8006d6e:	4974      	ldr	r1, [pc, #464]	; (8006f40 <oslib_test_005_001_execute.lto_priv.732+0x1f0>)
 8006d70:	4618      	mov	r0, r3
 8006d72:	f00e fb85 	bl	8015480 <_test_assert>
 8006d76:	4603      	mov	r3, r0
 8006d78:	2b00      	cmp	r3, #0
 8006d7a:	f040 80da 	bne.w	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>
  }

  /* [5.1.2] Registering an object, it must not exists, must succeed.*/
  test_set_step(2);
 8006d7e:	4b6e      	ldr	r3, [pc, #440]	; (8006f38 <oslib_test_005_001_execute.lto_priv.732+0x1e8>)
 8006d80:	2202      	movs	r2, #2
 8006d82:	601a      	str	r2, [r3, #0]
  {
    static uint32_t myobj = 0x55aa;

    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
 8006d84:	496f      	ldr	r1, [pc, #444]	; (8006f44 <oslib_test_005_001_execute.lto_priv.732+0x1f4>)
 8006d86:	486d      	ldr	r0, [pc, #436]	; (8006f3c <oslib_test_005_001_execute.lto_priv.732+0x1ec>)
 8006d88:	f00d f88a 	bl	8013ea0 <chFactoryRegisterObject>
 8006d8c:	9003      	str	r0, [sp, #12]
    test_assert(rop != NULL, "cannot register");
 8006d8e:	9b03      	ldr	r3, [sp, #12]
 8006d90:	2b00      	cmp	r3, #0
 8006d92:	bf14      	ite	ne
 8006d94:	2301      	movne	r3, #1
 8006d96:	2300      	moveq	r3, #0
 8006d98:	b2db      	uxtb	r3, r3
 8006d9a:	496b      	ldr	r1, [pc, #428]	; (8006f48 <oslib_test_005_001_execute.lto_priv.732+0x1f8>)
 8006d9c:	4618      	mov	r0, r3
 8006d9e:	f00e fb6f 	bl	8015480 <_test_assert>
 8006da2:	4603      	mov	r3, r0
 8006da4:	2b00      	cmp	r3, #0
 8006da6:	f040 80c4 	bne.w	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>
  }

  /* [5.1.3] Registering an object with the same name, must fail.*/
  test_set_step(3);
 8006daa:	4b63      	ldr	r3, [pc, #396]	; (8006f38 <oslib_test_005_001_execute.lto_priv.732+0x1e8>)
 8006dac:	2203      	movs	r2, #3
 8006dae:	601a      	str	r2, [r3, #0]
  {
    registered_object_t *rop1;
    static uint32_t myobj = 0x55aa;

    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
 8006db0:	4966      	ldr	r1, [pc, #408]	; (8006f4c <oslib_test_005_001_execute.lto_priv.732+0x1fc>)
 8006db2:	4862      	ldr	r0, [pc, #392]	; (8006f3c <oslib_test_005_001_execute.lto_priv.732+0x1ec>)
 8006db4:	f00d f874 	bl	8013ea0 <chFactoryRegisterObject>
 8006db8:	9002      	str	r0, [sp, #8]
    test_assert(rop1 == NULL, "can register");
 8006dba:	9b02      	ldr	r3, [sp, #8]
 8006dbc:	2b00      	cmp	r3, #0
 8006dbe:	bf0c      	ite	eq
 8006dc0:	2301      	moveq	r3, #1
 8006dc2:	2300      	movne	r3, #0
 8006dc4:	b2db      	uxtb	r3, r3
 8006dc6:	4962      	ldr	r1, [pc, #392]	; (8006f50 <oslib_test_005_001_execute.lto_priv.732+0x200>)
 8006dc8:	4618      	mov	r0, r3
 8006dca:	f00e fb59 	bl	8015480 <_test_assert>
 8006dce:	4603      	mov	r3, r0
 8006dd0:	2b00      	cmp	r3, #0
 8006dd2:	f040 80ae 	bne.w	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>
  }

  /* [5.1.4] Retrieving the registered object by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
 8006dd6:	4b58      	ldr	r3, [pc, #352]	; (8006f38 <oslib_test_005_001_execute.lto_priv.732+0x1e8>)
 8006dd8:	2204      	movs	r2, #4
 8006dda:	601a      	str	r2, [r3, #0]
  {
    registered_object_t *rop1, *rop2;

    rop1 = chFactoryFindObject("myobj");
 8006ddc:	4857      	ldr	r0, [pc, #348]	; (8006f3c <oslib_test_005_001_execute.lto_priv.732+0x1ec>)
 8006dde:	f00d f887 	bl	8013ef0 <chFactoryFindObject>
 8006de2:	9001      	str	r0, [sp, #4]
    test_assert(rop1 != NULL, "not found");
 8006de4:	9b01      	ldr	r3, [sp, #4]
 8006de6:	2b00      	cmp	r3, #0
 8006de8:	bf14      	ite	ne
 8006dea:	2301      	movne	r3, #1
 8006dec:	2300      	moveq	r3, #0
 8006dee:	b2db      	uxtb	r3, r3
 8006df0:	4958      	ldr	r1, [pc, #352]	; (8006f54 <oslib_test_005_001_execute.lto_priv.732+0x204>)
 8006df2:	4618      	mov	r0, r3
 8006df4:	f00e fb44 	bl	8015480 <_test_assert>
 8006df8:	4603      	mov	r3, r0
 8006dfa:	2b00      	cmp	r3, #0
 8006dfc:	f040 8099 	bne.w	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>
    test_assert(*(uint32_t *)(rop1->objp) == 0x55aa, "object mismatch");
 8006e00:	9b01      	ldr	r3, [sp, #4]
 8006e02:	691b      	ldr	r3, [r3, #16]
 8006e04:	681b      	ldr	r3, [r3, #0]
 8006e06:	f245 52aa 	movw	r2, #21930	; 0x55aa
 8006e0a:	4293      	cmp	r3, r2
 8006e0c:	bf0c      	ite	eq
 8006e0e:	2301      	moveq	r3, #1
 8006e10:	2300      	movne	r3, #0
 8006e12:	b2db      	uxtb	r3, r3
 8006e14:	4950      	ldr	r1, [pc, #320]	; (8006f58 <oslib_test_005_001_execute.lto_priv.732+0x208>)
 8006e16:	4618      	mov	r0, r3
 8006e18:	f00e fb32 	bl	8015480 <_test_assert>
 8006e1c:	4603      	mov	r3, r0
 8006e1e:	2b00      	cmp	r3, #0
 8006e20:	f040 8087 	bne.w	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>
    test_assert(rop == rop1, "object reference mismatch");
 8006e24:	9a03      	ldr	r2, [sp, #12]
 8006e26:	9b01      	ldr	r3, [sp, #4]
 8006e28:	429a      	cmp	r2, r3
 8006e2a:	bf0c      	ite	eq
 8006e2c:	2301      	moveq	r3, #1
 8006e2e:	2300      	movne	r3, #0
 8006e30:	b2db      	uxtb	r3, r3
 8006e32:	494a      	ldr	r1, [pc, #296]	; (8006f5c <oslib_test_005_001_execute.lto_priv.732+0x20c>)
 8006e34:	4618      	mov	r0, r3
 8006e36:	f00e fb23 	bl	8015480 <_test_assert>
 8006e3a:	4603      	mov	r3, r0
 8006e3c:	2b00      	cmp	r3, #0
 8006e3e:	d178      	bne.n	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>
    test_assert(rop1->element.refs == 2, "object reference mismatch");
 8006e40:	9b01      	ldr	r3, [sp, #4]
 8006e42:	685b      	ldr	r3, [r3, #4]
 8006e44:	2b02      	cmp	r3, #2
 8006e46:	bf0c      	ite	eq
 8006e48:	2301      	moveq	r3, #1
 8006e4a:	2300      	movne	r3, #0
 8006e4c:	b2db      	uxtb	r3, r3
 8006e4e:	4943      	ldr	r1, [pc, #268]	; (8006f5c <oslib_test_005_001_execute.lto_priv.732+0x20c>)
 8006e50:	4618      	mov	r0, r3
 8006e52:	f00e fb15 	bl	8015480 <_test_assert>
 8006e56:	4603      	mov	r3, r0
 8006e58:	2b00      	cmp	r3, #0
 8006e5a:	d16a      	bne.n	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>

    rop2 = (registered_object_t *)chFactoryDuplicateReference(&rop1->element);
 8006e5c:	9b01      	ldr	r3, [sp, #4]
 8006e5e:	4618      	mov	r0, r3
 8006e60:	f7ff ff4e 	bl	8006d00 <chFactoryDuplicateReference>
 8006e64:	9000      	str	r0, [sp, #0]
    test_assert(rop1 == rop2, "object reference mismatch");
 8006e66:	9a01      	ldr	r2, [sp, #4]
 8006e68:	9b00      	ldr	r3, [sp, #0]
 8006e6a:	429a      	cmp	r2, r3
 8006e6c:	bf0c      	ite	eq
 8006e6e:	2301      	moveq	r3, #1
 8006e70:	2300      	movne	r3, #0
 8006e72:	b2db      	uxtb	r3, r3
 8006e74:	4939      	ldr	r1, [pc, #228]	; (8006f5c <oslib_test_005_001_execute.lto_priv.732+0x20c>)
 8006e76:	4618      	mov	r0, r3
 8006e78:	f00e fb02 	bl	8015480 <_test_assert>
 8006e7c:	4603      	mov	r3, r0
 8006e7e:	2b00      	cmp	r3, #0
 8006e80:	d157      	bne.n	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>
    test_assert(*(uint32_t *)(rop2->objp) == 0x55aa, "object mismatch");
 8006e82:	9b00      	ldr	r3, [sp, #0]
 8006e84:	691b      	ldr	r3, [r3, #16]
 8006e86:	681b      	ldr	r3, [r3, #0]
 8006e88:	f245 52aa 	movw	r2, #21930	; 0x55aa
 8006e8c:	4293      	cmp	r3, r2
 8006e8e:	bf0c      	ite	eq
 8006e90:	2301      	moveq	r3, #1
 8006e92:	2300      	movne	r3, #0
 8006e94:	b2db      	uxtb	r3, r3
 8006e96:	4930      	ldr	r1, [pc, #192]	; (8006f58 <oslib_test_005_001_execute.lto_priv.732+0x208>)
 8006e98:	4618      	mov	r0, r3
 8006e9a:	f00e faf1 	bl	8015480 <_test_assert>
 8006e9e:	4603      	mov	r3, r0
 8006ea0:	2b00      	cmp	r3, #0
 8006ea2:	d146      	bne.n	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>
    test_assert(rop2->element.refs == 3, "object reference mismatch");
 8006ea4:	9b00      	ldr	r3, [sp, #0]
 8006ea6:	685b      	ldr	r3, [r3, #4]
 8006ea8:	2b03      	cmp	r3, #3
 8006eaa:	bf0c      	ite	eq
 8006eac:	2301      	moveq	r3, #1
 8006eae:	2300      	movne	r3, #0
 8006eb0:	b2db      	uxtb	r3, r3
 8006eb2:	492a      	ldr	r1, [pc, #168]	; (8006f5c <oslib_test_005_001_execute.lto_priv.732+0x20c>)
 8006eb4:	4618      	mov	r0, r3
 8006eb6:	f00e fae3 	bl	8015480 <_test_assert>
 8006eba:	4603      	mov	r3, r0
 8006ebc:	2b00      	cmp	r3, #0
 8006ebe:	d138      	bne.n	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>

    chFactoryReleaseObject(rop2);
 8006ec0:	9800      	ldr	r0, [sp, #0]
 8006ec2:	f00d f82d 	bl	8013f20 <chFactoryReleaseObject>
    test_assert(rop1->element.refs == 2, "references mismatch");
 8006ec6:	9b01      	ldr	r3, [sp, #4]
 8006ec8:	685b      	ldr	r3, [r3, #4]
 8006eca:	2b02      	cmp	r3, #2
 8006ecc:	bf0c      	ite	eq
 8006ece:	2301      	moveq	r3, #1
 8006ed0:	2300      	movne	r3, #0
 8006ed2:	b2db      	uxtb	r3, r3
 8006ed4:	4922      	ldr	r1, [pc, #136]	; (8006f60 <oslib_test_005_001_execute.lto_priv.732+0x210>)
 8006ed6:	4618      	mov	r0, r3
 8006ed8:	f00e fad2 	bl	8015480 <_test_assert>
 8006edc:	4603      	mov	r3, r0
 8006ede:	2b00      	cmp	r3, #0
 8006ee0:	d127      	bne.n	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>

    chFactoryReleaseObject(rop1);
 8006ee2:	9801      	ldr	r0, [sp, #4]
 8006ee4:	f00d f81c 	bl	8013f20 <chFactoryReleaseObject>
    test_assert(rop->element.refs == 1, "references mismatch");
 8006ee8:	9b03      	ldr	r3, [sp, #12]
 8006eea:	685b      	ldr	r3, [r3, #4]
 8006eec:	2b01      	cmp	r3, #1
 8006eee:	bf0c      	ite	eq
 8006ef0:	2301      	moveq	r3, #1
 8006ef2:	2300      	movne	r3, #0
 8006ef4:	b2db      	uxtb	r3, r3
 8006ef6:	491a      	ldr	r1, [pc, #104]	; (8006f60 <oslib_test_005_001_execute.lto_priv.732+0x210>)
 8006ef8:	4618      	mov	r0, r3
 8006efa:	f00e fac1 	bl	8015480 <_test_assert>
 8006efe:	4603      	mov	r3, r0
 8006f00:	2b00      	cmp	r3, #0
 8006f02:	d116      	bne.n	8006f32 <oslib_test_005_001_execute.lto_priv.732+0x1e2>
  }

  /* [5.1.5] Releasing the first reference to the object, must not
     trigger an assertion.*/
  test_set_step(5);
 8006f04:	4b0c      	ldr	r3, [pc, #48]	; (8006f38 <oslib_test_005_001_execute.lto_priv.732+0x1e8>)
 8006f06:	2205      	movs	r2, #5
 8006f08:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleaseObject(rop);
 8006f0a:	9803      	ldr	r0, [sp, #12]
 8006f0c:	f00d f808 	bl	8013f20 <chFactoryReleaseObject>
  }

  /* [5.1.6] Retrieving the registered object by name again, must not
     exist.*/
  test_set_step(6);
 8006f10:	4b09      	ldr	r3, [pc, #36]	; (8006f38 <oslib_test_005_001_execute.lto_priv.732+0x1e8>)
 8006f12:	2206      	movs	r2, #6
 8006f14:	601a      	str	r2, [r3, #0]
  {
    rop = chFactoryFindObject("myobj");
 8006f16:	4809      	ldr	r0, [pc, #36]	; (8006f3c <oslib_test_005_001_execute.lto_priv.732+0x1ec>)
 8006f18:	f00c ffea 	bl	8013ef0 <chFactoryFindObject>
 8006f1c:	9003      	str	r0, [sp, #12]
    test_assert(rop == NULL, "found");
 8006f1e:	9b03      	ldr	r3, [sp, #12]
 8006f20:	2b00      	cmp	r3, #0
 8006f22:	bf0c      	ite	eq
 8006f24:	2301      	moveq	r3, #1
 8006f26:	2300      	movne	r3, #0
 8006f28:	b2db      	uxtb	r3, r3
 8006f2a:	4905      	ldr	r1, [pc, #20]	; (8006f40 <oslib_test_005_001_execute.lto_priv.732+0x1f0>)
 8006f2c:	4618      	mov	r0, r3
 8006f2e:	f00e faa7 	bl	8015480 <_test_assert>
  }
}
 8006f32:	b005      	add	sp, #20
 8006f34:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f38:	20001988 	.word	0x20001988
 8006f3c:	08018a14 	.word	0x08018a14
 8006f40:	08018a40 	.word	0x08018a40
 8006f44:	2000091c 	.word	0x2000091c
 8006f48:	08018a1c 	.word	0x08018a1c
 8006f4c:	20000920 	.word	0x20000920
 8006f50:	08018a2c 	.word	0x08018a2c
 8006f54:	08018a3c 	.word	0x08018a3c
 8006f58:	08018a48 	.word	0x08018a48
 8006f5c:	08018a58 	.word	0x08018a58
 8006f60:	08018a74 	.word	0x08018a74
	...

08006f70 <oslib_test_005_002_teardown.lto_priv.733>:
 * - [5.2.6] Retrieving the dynamic buffer by name again, must not
 *   exist.
 * .
 */

static void oslib_test_005_002_teardown(void) {
 8006f70:	b500      	push	{lr}
 8006f72:	b083      	sub	sp, #12
  dyn_buffer_t *dbp;

  dbp = chFactoryFindBuffer("mybuf");
 8006f74:	4808      	ldr	r0, [pc, #32]	; (8006f98 <oslib_test_005_002_teardown.lto_priv.733+0x28>)
 8006f76:	f00d f813 	bl	8013fa0 <chFactoryFindBuffer>
 8006f7a:	9001      	str	r0, [sp, #4]
  if (dbp != NULL) {
 8006f7c:	9b01      	ldr	r3, [sp, #4]
 8006f7e:	2b00      	cmp	r3, #0
 8006f80:	d103      	bne.n	8006f8a <oslib_test_005_002_teardown.lto_priv.733+0x1a>
 8006f82:	e006      	b.n	8006f92 <oslib_test_005_002_teardown.lto_priv.733+0x22>
    while (dbp->element.refs > 0U) {
      chFactoryReleaseBuffer(dbp);
 8006f84:	9801      	ldr	r0, [sp, #4]
 8006f86:	f00d f823 	bl	8013fd0 <chFactoryReleaseBuffer>
    while (dbp->element.refs > 0U) {
 8006f8a:	9b01      	ldr	r3, [sp, #4]
 8006f8c:	685b      	ldr	r3, [r3, #4]
 8006f8e:	2b00      	cmp	r3, #0
 8006f90:	d1f8      	bne.n	8006f84 <oslib_test_005_002_teardown.lto_priv.733+0x14>
    }
  }
}
 8006f92:	b003      	add	sp, #12
 8006f94:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f98:	08018a98 	.word	0x08018a98
 8006f9c:	00000000 	.word	0x00000000

08006fa0 <oslib_test_005_002_execute.lto_priv.734>:

static void oslib_test_005_002_execute(void) {
 8006fa0:	b500      	push	{lr}
 8006fa2:	b085      	sub	sp, #20
  dyn_buffer_t *dbp;

  /* [5.2.1] Retrieving a dynamic buffer by name, must not exist.*/
  test_set_step(1);
 8006fa4:	4b66      	ldr	r3, [pc, #408]	; (8007140 <oslib_test_005_002_execute.lto_priv.734+0x1a0>)
 8006fa6:	2201      	movs	r2, #1
 8006fa8:	601a      	str	r2, [r3, #0]
  {
    dbp = chFactoryFindBuffer("mybuf");
 8006faa:	4866      	ldr	r0, [pc, #408]	; (8007144 <oslib_test_005_002_execute.lto_priv.734+0x1a4>)
 8006fac:	f00c fff8 	bl	8013fa0 <chFactoryFindBuffer>
 8006fb0:	9003      	str	r0, [sp, #12]
    test_assert(dbp == NULL, "found");
 8006fb2:	9b03      	ldr	r3, [sp, #12]
 8006fb4:	2b00      	cmp	r3, #0
 8006fb6:	bf0c      	ite	eq
 8006fb8:	2301      	moveq	r3, #1
 8006fba:	2300      	movne	r3, #0
 8006fbc:	b2db      	uxtb	r3, r3
 8006fbe:	4962      	ldr	r1, [pc, #392]	; (8007148 <oslib_test_005_002_execute.lto_priv.734+0x1a8>)
 8006fc0:	4618      	mov	r0, r3
 8006fc2:	f00e fa5d 	bl	8015480 <_test_assert>
 8006fc6:	4603      	mov	r3, r0
 8006fc8:	2b00      	cmp	r3, #0
 8006fca:	f040 80b6 	bne.w	800713a <oslib_test_005_002_execute.lto_priv.734+0x19a>
  }

  /* [5.2.2] Creating a dynamic buffer it must not exists, must
     succeed.*/
  test_set_step(2);
 8006fce:	4b5c      	ldr	r3, [pc, #368]	; (8007140 <oslib_test_005_002_execute.lto_priv.734+0x1a0>)
 8006fd0:	2202      	movs	r2, #2
 8006fd2:	601a      	str	r2, [r3, #0]
  {
    dbp = chFactoryCreateBuffer("mybuf", 128U);
 8006fd4:	2180      	movs	r1, #128	; 0x80
 8006fd6:	485b      	ldr	r0, [pc, #364]	; (8007144 <oslib_test_005_002_execute.lto_priv.734+0x1a4>)
 8006fd8:	f00c ffba 	bl	8013f50 <chFactoryCreateBuffer>
 8006fdc:	9003      	str	r0, [sp, #12]
    test_assert(dbp != NULL, "cannot create");
 8006fde:	9b03      	ldr	r3, [sp, #12]
 8006fe0:	2b00      	cmp	r3, #0
 8006fe2:	bf14      	ite	ne
 8006fe4:	2301      	movne	r3, #1
 8006fe6:	2300      	moveq	r3, #0
 8006fe8:	b2db      	uxtb	r3, r3
 8006fea:	4958      	ldr	r1, [pc, #352]	; (800714c <oslib_test_005_002_execute.lto_priv.734+0x1ac>)
 8006fec:	4618      	mov	r0, r3
 8006fee:	f00e fa47 	bl	8015480 <_test_assert>
 8006ff2:	4603      	mov	r3, r0
 8006ff4:	2b00      	cmp	r3, #0
 8006ff6:	f040 80a0 	bne.w	800713a <oslib_test_005_002_execute.lto_priv.734+0x19a>
  }

  /* [5.2.3] Creating a dynamic buffer with the same name, must fail.*/
  test_set_step(3);
 8006ffa:	4b51      	ldr	r3, [pc, #324]	; (8007140 <oslib_test_005_002_execute.lto_priv.734+0x1a0>)
 8006ffc:	2203      	movs	r2, #3
 8006ffe:	601a      	str	r2, [r3, #0]
  {
    dyn_buffer_t *dbp1;

    dbp1 = chFactoryCreateBuffer("mybuf", 128U);
 8007000:	2180      	movs	r1, #128	; 0x80
 8007002:	4850      	ldr	r0, [pc, #320]	; (8007144 <oslib_test_005_002_execute.lto_priv.734+0x1a4>)
 8007004:	f00c ffa4 	bl	8013f50 <chFactoryCreateBuffer>
 8007008:	9002      	str	r0, [sp, #8]
    test_assert(dbp1 == NULL, "can create");
 800700a:	9b02      	ldr	r3, [sp, #8]
 800700c:	2b00      	cmp	r3, #0
 800700e:	bf0c      	ite	eq
 8007010:	2301      	moveq	r3, #1
 8007012:	2300      	movne	r3, #0
 8007014:	b2db      	uxtb	r3, r3
 8007016:	494e      	ldr	r1, [pc, #312]	; (8007150 <oslib_test_005_002_execute.lto_priv.734+0x1b0>)
 8007018:	4618      	mov	r0, r3
 800701a:	f00e fa31 	bl	8015480 <_test_assert>
 800701e:	4603      	mov	r3, r0
 8007020:	2b00      	cmp	r3, #0
 8007022:	f040 808a 	bne.w	800713a <oslib_test_005_002_execute.lto_priv.734+0x19a>
  }

  /* [5.2.4] Retrieving the dynamic buffer by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
 8007026:	4b46      	ldr	r3, [pc, #280]	; (8007140 <oslib_test_005_002_execute.lto_priv.734+0x1a0>)
 8007028:	2204      	movs	r2, #4
 800702a:	601a      	str	r2, [r3, #0]
  {
    dyn_buffer_t *dbp1, *dbp2;

    dbp1 = chFactoryFindBuffer("mybuf");
 800702c:	4845      	ldr	r0, [pc, #276]	; (8007144 <oslib_test_005_002_execute.lto_priv.734+0x1a4>)
 800702e:	f00c ffb7 	bl	8013fa0 <chFactoryFindBuffer>
 8007032:	9001      	str	r0, [sp, #4]
    test_assert(dbp1 != NULL, "not found");
 8007034:	9b01      	ldr	r3, [sp, #4]
 8007036:	2b00      	cmp	r3, #0
 8007038:	bf14      	ite	ne
 800703a:	2301      	movne	r3, #1
 800703c:	2300      	moveq	r3, #0
 800703e:	b2db      	uxtb	r3, r3
 8007040:	4944      	ldr	r1, [pc, #272]	; (8007154 <oslib_test_005_002_execute.lto_priv.734+0x1b4>)
 8007042:	4618      	mov	r0, r3
 8007044:	f00e fa1c 	bl	8015480 <_test_assert>
 8007048:	4603      	mov	r3, r0
 800704a:	2b00      	cmp	r3, #0
 800704c:	d175      	bne.n	800713a <oslib_test_005_002_execute.lto_priv.734+0x19a>
    test_assert(dbp == dbp1, "object reference mismatch");
 800704e:	9a03      	ldr	r2, [sp, #12]
 8007050:	9b01      	ldr	r3, [sp, #4]
 8007052:	429a      	cmp	r2, r3
 8007054:	bf0c      	ite	eq
 8007056:	2301      	moveq	r3, #1
 8007058:	2300      	movne	r3, #0
 800705a:	b2db      	uxtb	r3, r3
 800705c:	493e      	ldr	r1, [pc, #248]	; (8007158 <oslib_test_005_002_execute.lto_priv.734+0x1b8>)
 800705e:	4618      	mov	r0, r3
 8007060:	f00e fa0e 	bl	8015480 <_test_assert>
 8007064:	4603      	mov	r3, r0
 8007066:	2b00      	cmp	r3, #0
 8007068:	d167      	bne.n	800713a <oslib_test_005_002_execute.lto_priv.734+0x19a>
    test_assert(dbp1->element.refs == 2, "object reference mismatch");
 800706a:	9b01      	ldr	r3, [sp, #4]
 800706c:	685b      	ldr	r3, [r3, #4]
 800706e:	2b02      	cmp	r3, #2
 8007070:	bf0c      	ite	eq
 8007072:	2301      	moveq	r3, #1
 8007074:	2300      	movne	r3, #0
 8007076:	b2db      	uxtb	r3, r3
 8007078:	4937      	ldr	r1, [pc, #220]	; (8007158 <oslib_test_005_002_execute.lto_priv.734+0x1b8>)
 800707a:	4618      	mov	r0, r3
 800707c:	f00e fa00 	bl	8015480 <_test_assert>
 8007080:	4603      	mov	r3, r0
 8007082:	2b00      	cmp	r3, #0
 8007084:	d159      	bne.n	800713a <oslib_test_005_002_execute.lto_priv.734+0x19a>

    dbp2 = (dyn_buffer_t *)chFactoryDuplicateReference(&dbp1->element);
 8007086:	9b01      	ldr	r3, [sp, #4]
 8007088:	4618      	mov	r0, r3
 800708a:	f7ff fe39 	bl	8006d00 <chFactoryDuplicateReference>
 800708e:	9000      	str	r0, [sp, #0]
    test_assert(dbp1 == dbp2, "object reference mismatch");
 8007090:	9a01      	ldr	r2, [sp, #4]
 8007092:	9b00      	ldr	r3, [sp, #0]
 8007094:	429a      	cmp	r2, r3
 8007096:	bf0c      	ite	eq
 8007098:	2301      	moveq	r3, #1
 800709a:	2300      	movne	r3, #0
 800709c:	b2db      	uxtb	r3, r3
 800709e:	492e      	ldr	r1, [pc, #184]	; (8007158 <oslib_test_005_002_execute.lto_priv.734+0x1b8>)
 80070a0:	4618      	mov	r0, r3
 80070a2:	f00e f9ed 	bl	8015480 <_test_assert>
 80070a6:	4603      	mov	r3, r0
 80070a8:	2b00      	cmp	r3, #0
 80070aa:	d146      	bne.n	800713a <oslib_test_005_002_execute.lto_priv.734+0x19a>
    test_assert(dbp2->element.refs == 3, "object reference mismatch");
 80070ac:	9b00      	ldr	r3, [sp, #0]
 80070ae:	685b      	ldr	r3, [r3, #4]
 80070b0:	2b03      	cmp	r3, #3
 80070b2:	bf0c      	ite	eq
 80070b4:	2301      	moveq	r3, #1
 80070b6:	2300      	movne	r3, #0
 80070b8:	b2db      	uxtb	r3, r3
 80070ba:	4927      	ldr	r1, [pc, #156]	; (8007158 <oslib_test_005_002_execute.lto_priv.734+0x1b8>)
 80070bc:	4618      	mov	r0, r3
 80070be:	f00e f9df 	bl	8015480 <_test_assert>
 80070c2:	4603      	mov	r3, r0
 80070c4:	2b00      	cmp	r3, #0
 80070c6:	d138      	bne.n	800713a <oslib_test_005_002_execute.lto_priv.734+0x19a>

    chFactoryReleaseBuffer(dbp2);
 80070c8:	9800      	ldr	r0, [sp, #0]
 80070ca:	f00c ff81 	bl	8013fd0 <chFactoryReleaseBuffer>
    test_assert(dbp1->element.refs == 2, "references mismatch");
 80070ce:	9b01      	ldr	r3, [sp, #4]
 80070d0:	685b      	ldr	r3, [r3, #4]
 80070d2:	2b02      	cmp	r3, #2
 80070d4:	bf0c      	ite	eq
 80070d6:	2301      	moveq	r3, #1
 80070d8:	2300      	movne	r3, #0
 80070da:	b2db      	uxtb	r3, r3
 80070dc:	491f      	ldr	r1, [pc, #124]	; (800715c <oslib_test_005_002_execute.lto_priv.734+0x1bc>)
 80070de:	4618      	mov	r0, r3
 80070e0:	f00e f9ce 	bl	8015480 <_test_assert>
 80070e4:	4603      	mov	r3, r0
 80070e6:	2b00      	cmp	r3, #0
 80070e8:	d127      	bne.n	800713a <oslib_test_005_002_execute.lto_priv.734+0x19a>

    chFactoryReleaseBuffer(dbp1);
 80070ea:	9801      	ldr	r0, [sp, #4]
 80070ec:	f00c ff70 	bl	8013fd0 <chFactoryReleaseBuffer>
    test_assert(dbp->element.refs == 1, "references mismatch");
 80070f0:	9b03      	ldr	r3, [sp, #12]
 80070f2:	685b      	ldr	r3, [r3, #4]
 80070f4:	2b01      	cmp	r3, #1
 80070f6:	bf0c      	ite	eq
 80070f8:	2301      	moveq	r3, #1
 80070fa:	2300      	movne	r3, #0
 80070fc:	b2db      	uxtb	r3, r3
 80070fe:	4917      	ldr	r1, [pc, #92]	; (800715c <oslib_test_005_002_execute.lto_priv.734+0x1bc>)
 8007100:	4618      	mov	r0, r3
 8007102:	f00e f9bd 	bl	8015480 <_test_assert>
 8007106:	4603      	mov	r3, r0
 8007108:	2b00      	cmp	r3, #0
 800710a:	d116      	bne.n	800713a <oslib_test_005_002_execute.lto_priv.734+0x19a>
  }

  /* [5.2.5] Releasing the first reference to the dynamic buffer, must
     not trigger an assertion.*/
  test_set_step(5);
 800710c:	4b0c      	ldr	r3, [pc, #48]	; (8007140 <oslib_test_005_002_execute.lto_priv.734+0x1a0>)
 800710e:	2205      	movs	r2, #5
 8007110:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleaseBuffer(dbp);
 8007112:	9803      	ldr	r0, [sp, #12]
 8007114:	f00c ff5c 	bl	8013fd0 <chFactoryReleaseBuffer>
  }

  /* [5.2.6] Retrieving the dynamic buffer by name again, must not
     exist.*/
  test_set_step(6);
 8007118:	4b09      	ldr	r3, [pc, #36]	; (8007140 <oslib_test_005_002_execute.lto_priv.734+0x1a0>)
 800711a:	2206      	movs	r2, #6
 800711c:	601a      	str	r2, [r3, #0]
  {
    dbp = chFactoryFindBuffer("mybuf");
 800711e:	4809      	ldr	r0, [pc, #36]	; (8007144 <oslib_test_005_002_execute.lto_priv.734+0x1a4>)
 8007120:	f00c ff3e 	bl	8013fa0 <chFactoryFindBuffer>
 8007124:	9003      	str	r0, [sp, #12]
    test_assert(dbp == NULL, "found");
 8007126:	9b03      	ldr	r3, [sp, #12]
 8007128:	2b00      	cmp	r3, #0
 800712a:	bf0c      	ite	eq
 800712c:	2301      	moveq	r3, #1
 800712e:	2300      	movne	r3, #0
 8007130:	b2db      	uxtb	r3, r3
 8007132:	4905      	ldr	r1, [pc, #20]	; (8007148 <oslib_test_005_002_execute.lto_priv.734+0x1a8>)
 8007134:	4618      	mov	r0, r3
 8007136:	f00e f9a3 	bl	8015480 <_test_assert>
  }
}
 800713a:	b005      	add	sp, #20
 800713c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007140:	20001988 	.word	0x20001988
 8007144:	08018a98 	.word	0x08018a98
 8007148:	08018a40 	.word	0x08018a40
 800714c:	08018aa0 	.word	0x08018aa0
 8007150:	08018ab0 	.word	0x08018ab0
 8007154:	08018a3c 	.word	0x08018a3c
 8007158:	08018a58 	.word	0x08018a58
 800715c:	08018a74 	.word	0x08018a74

08007160 <oslib_test_005_003_teardown.lto_priv.735>:
 * - [5.3.6] Retrieving the dynamic semaphore by name again, must not
 *   exist.
 * .
 */

static void oslib_test_005_003_teardown(void) {
 8007160:	b500      	push	{lr}
 8007162:	b083      	sub	sp, #12
  dyn_semaphore_t *dsp;

  dsp = chFactoryFindSemaphore("mysem");
 8007164:	4808      	ldr	r0, [pc, #32]	; (8007188 <oslib_test_005_003_teardown.lto_priv.735+0x28>)
 8007166:	f00c ff73 	bl	8014050 <chFactoryFindSemaphore>
 800716a:	9001      	str	r0, [sp, #4]
  if (dsp != NULL) {
 800716c:	9b01      	ldr	r3, [sp, #4]
 800716e:	2b00      	cmp	r3, #0
 8007170:	d103      	bne.n	800717a <oslib_test_005_003_teardown.lto_priv.735+0x1a>
 8007172:	e006      	b.n	8007182 <oslib_test_005_003_teardown.lto_priv.735+0x22>
    while (dsp->element.refs > 0U) {
      chFactoryReleaseSemaphore(dsp);
 8007174:	9801      	ldr	r0, [sp, #4]
 8007176:	f00c ff83 	bl	8014080 <chFactoryReleaseSemaphore>
    while (dsp->element.refs > 0U) {
 800717a:	9b01      	ldr	r3, [sp, #4]
 800717c:	685b      	ldr	r3, [r3, #4]
 800717e:	2b00      	cmp	r3, #0
 8007180:	d1f8      	bne.n	8007174 <oslib_test_005_003_teardown.lto_priv.735+0x14>
    }
  }
}
 8007182:	b003      	add	sp, #12
 8007184:	f85d fb04 	ldr.w	pc, [sp], #4
 8007188:	08018acc 	.word	0x08018acc
 800718c:	00000000 	.word	0x00000000

08007190 <oslib_test_005_003_execute.lto_priv.736>:

static void oslib_test_005_003_execute(void) {
 8007190:	b500      	push	{lr}
 8007192:	b085      	sub	sp, #20
  dyn_semaphore_t *dsp;

  /* [5.3.1] Retrieving a dynamic semaphore by name, must not exist.*/
  test_set_step(1);
 8007194:	4b66      	ldr	r3, [pc, #408]	; (8007330 <oslib_test_005_003_execute.lto_priv.736+0x1a0>)
 8007196:	2201      	movs	r2, #1
 8007198:	601a      	str	r2, [r3, #0]
  {
    dsp = chFactoryFindSemaphore("mysem");
 800719a:	4866      	ldr	r0, [pc, #408]	; (8007334 <oslib_test_005_003_execute.lto_priv.736+0x1a4>)
 800719c:	f00c ff58 	bl	8014050 <chFactoryFindSemaphore>
 80071a0:	9003      	str	r0, [sp, #12]
    test_assert(dsp == NULL, "found");
 80071a2:	9b03      	ldr	r3, [sp, #12]
 80071a4:	2b00      	cmp	r3, #0
 80071a6:	bf0c      	ite	eq
 80071a8:	2301      	moveq	r3, #1
 80071aa:	2300      	movne	r3, #0
 80071ac:	b2db      	uxtb	r3, r3
 80071ae:	4962      	ldr	r1, [pc, #392]	; (8007338 <oslib_test_005_003_execute.lto_priv.736+0x1a8>)
 80071b0:	4618      	mov	r0, r3
 80071b2:	f00e f965 	bl	8015480 <_test_assert>
 80071b6:	4603      	mov	r3, r0
 80071b8:	2b00      	cmp	r3, #0
 80071ba:	f040 80b6 	bne.w	800732a <oslib_test_005_003_execute.lto_priv.736+0x19a>
  }

  /* [5.3.2] Creating a dynamic semaphore it must not exists, must
     succeed.*/
  test_set_step(2);
 80071be:	4b5c      	ldr	r3, [pc, #368]	; (8007330 <oslib_test_005_003_execute.lto_priv.736+0x1a0>)
 80071c0:	2202      	movs	r2, #2
 80071c2:	601a      	str	r2, [r3, #0]
  {
    dsp = chFactoryCreateSemaphore("mysem", 0);
 80071c4:	2100      	movs	r1, #0
 80071c6:	485b      	ldr	r0, [pc, #364]	; (8007334 <oslib_test_005_003_execute.lto_priv.736+0x1a4>)
 80071c8:	f00c ff1a 	bl	8014000 <chFactoryCreateSemaphore>
 80071cc:	9003      	str	r0, [sp, #12]
    test_assert(dsp != NULL, "cannot create");
 80071ce:	9b03      	ldr	r3, [sp, #12]
 80071d0:	2b00      	cmp	r3, #0
 80071d2:	bf14      	ite	ne
 80071d4:	2301      	movne	r3, #1
 80071d6:	2300      	moveq	r3, #0
 80071d8:	b2db      	uxtb	r3, r3
 80071da:	4958      	ldr	r1, [pc, #352]	; (800733c <oslib_test_005_003_execute.lto_priv.736+0x1ac>)
 80071dc:	4618      	mov	r0, r3
 80071de:	f00e f94f 	bl	8015480 <_test_assert>
 80071e2:	4603      	mov	r3, r0
 80071e4:	2b00      	cmp	r3, #0
 80071e6:	f040 80a0 	bne.w	800732a <oslib_test_005_003_execute.lto_priv.736+0x19a>
  }

  /* [5.3.3] Creating a dynamic semaphore with the same name, must
     fail.*/
  test_set_step(3);
 80071ea:	4b51      	ldr	r3, [pc, #324]	; (8007330 <oslib_test_005_003_execute.lto_priv.736+0x1a0>)
 80071ec:	2203      	movs	r2, #3
 80071ee:	601a      	str	r2, [r3, #0]
  {
    dyn_semaphore_t *dsp1;

    dsp1 = chFactoryCreateSemaphore("mysem", 0);
 80071f0:	2100      	movs	r1, #0
 80071f2:	4850      	ldr	r0, [pc, #320]	; (8007334 <oslib_test_005_003_execute.lto_priv.736+0x1a4>)
 80071f4:	f00c ff04 	bl	8014000 <chFactoryCreateSemaphore>
 80071f8:	9002      	str	r0, [sp, #8]
    test_assert(dsp1 == NULL, "can create");
 80071fa:	9b02      	ldr	r3, [sp, #8]
 80071fc:	2b00      	cmp	r3, #0
 80071fe:	bf0c      	ite	eq
 8007200:	2301      	moveq	r3, #1
 8007202:	2300      	movne	r3, #0
 8007204:	b2db      	uxtb	r3, r3
 8007206:	494e      	ldr	r1, [pc, #312]	; (8007340 <oslib_test_005_003_execute.lto_priv.736+0x1b0>)
 8007208:	4618      	mov	r0, r3
 800720a:	f00e f939 	bl	8015480 <_test_assert>
 800720e:	4603      	mov	r3, r0
 8007210:	2b00      	cmp	r3, #0
 8007212:	f040 808a 	bne.w	800732a <oslib_test_005_003_execute.lto_priv.736+0x19a>
  }

  /* [5.3.4] Retrieving the dynamic semaphore by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
 8007216:	4b46      	ldr	r3, [pc, #280]	; (8007330 <oslib_test_005_003_execute.lto_priv.736+0x1a0>)
 8007218:	2204      	movs	r2, #4
 800721a:	601a      	str	r2, [r3, #0]
  {
    dyn_semaphore_t *dsp1, *dsp2;

    dsp1 = chFactoryFindSemaphore("mysem");
 800721c:	4845      	ldr	r0, [pc, #276]	; (8007334 <oslib_test_005_003_execute.lto_priv.736+0x1a4>)
 800721e:	f00c ff17 	bl	8014050 <chFactoryFindSemaphore>
 8007222:	9001      	str	r0, [sp, #4]
    test_assert(dsp1 != NULL, "not found");
 8007224:	9b01      	ldr	r3, [sp, #4]
 8007226:	2b00      	cmp	r3, #0
 8007228:	bf14      	ite	ne
 800722a:	2301      	movne	r3, #1
 800722c:	2300      	moveq	r3, #0
 800722e:	b2db      	uxtb	r3, r3
 8007230:	4944      	ldr	r1, [pc, #272]	; (8007344 <oslib_test_005_003_execute.lto_priv.736+0x1b4>)
 8007232:	4618      	mov	r0, r3
 8007234:	f00e f924 	bl	8015480 <_test_assert>
 8007238:	4603      	mov	r3, r0
 800723a:	2b00      	cmp	r3, #0
 800723c:	d175      	bne.n	800732a <oslib_test_005_003_execute.lto_priv.736+0x19a>
    test_assert(dsp == dsp1, "object reference mismatch");
 800723e:	9a03      	ldr	r2, [sp, #12]
 8007240:	9b01      	ldr	r3, [sp, #4]
 8007242:	429a      	cmp	r2, r3
 8007244:	bf0c      	ite	eq
 8007246:	2301      	moveq	r3, #1
 8007248:	2300      	movne	r3, #0
 800724a:	b2db      	uxtb	r3, r3
 800724c:	493e      	ldr	r1, [pc, #248]	; (8007348 <oslib_test_005_003_execute.lto_priv.736+0x1b8>)
 800724e:	4618      	mov	r0, r3
 8007250:	f00e f916 	bl	8015480 <_test_assert>
 8007254:	4603      	mov	r3, r0
 8007256:	2b00      	cmp	r3, #0
 8007258:	d167      	bne.n	800732a <oslib_test_005_003_execute.lto_priv.736+0x19a>
    test_assert(dsp1->element.refs == 2, "object reference mismatch");
 800725a:	9b01      	ldr	r3, [sp, #4]
 800725c:	685b      	ldr	r3, [r3, #4]
 800725e:	2b02      	cmp	r3, #2
 8007260:	bf0c      	ite	eq
 8007262:	2301      	moveq	r3, #1
 8007264:	2300      	movne	r3, #0
 8007266:	b2db      	uxtb	r3, r3
 8007268:	4937      	ldr	r1, [pc, #220]	; (8007348 <oslib_test_005_003_execute.lto_priv.736+0x1b8>)
 800726a:	4618      	mov	r0, r3
 800726c:	f00e f908 	bl	8015480 <_test_assert>
 8007270:	4603      	mov	r3, r0
 8007272:	2b00      	cmp	r3, #0
 8007274:	d159      	bne.n	800732a <oslib_test_005_003_execute.lto_priv.736+0x19a>

    dsp2 = (dyn_semaphore_t *)chFactoryDuplicateReference(&dsp1->element);
 8007276:	9b01      	ldr	r3, [sp, #4]
 8007278:	4618      	mov	r0, r3
 800727a:	f7ff fd41 	bl	8006d00 <chFactoryDuplicateReference>
 800727e:	9000      	str	r0, [sp, #0]
    test_assert(dsp1 == dsp2, "object reference mismatch");
 8007280:	9a01      	ldr	r2, [sp, #4]
 8007282:	9b00      	ldr	r3, [sp, #0]
 8007284:	429a      	cmp	r2, r3
 8007286:	bf0c      	ite	eq
 8007288:	2301      	moveq	r3, #1
 800728a:	2300      	movne	r3, #0
 800728c:	b2db      	uxtb	r3, r3
 800728e:	492e      	ldr	r1, [pc, #184]	; (8007348 <oslib_test_005_003_execute.lto_priv.736+0x1b8>)
 8007290:	4618      	mov	r0, r3
 8007292:	f00e f8f5 	bl	8015480 <_test_assert>
 8007296:	4603      	mov	r3, r0
 8007298:	2b00      	cmp	r3, #0
 800729a:	d146      	bne.n	800732a <oslib_test_005_003_execute.lto_priv.736+0x19a>
    test_assert(dsp2->element.refs == 3, "object reference mismatch");
 800729c:	9b00      	ldr	r3, [sp, #0]
 800729e:	685b      	ldr	r3, [r3, #4]
 80072a0:	2b03      	cmp	r3, #3
 80072a2:	bf0c      	ite	eq
 80072a4:	2301      	moveq	r3, #1
 80072a6:	2300      	movne	r3, #0
 80072a8:	b2db      	uxtb	r3, r3
 80072aa:	4927      	ldr	r1, [pc, #156]	; (8007348 <oslib_test_005_003_execute.lto_priv.736+0x1b8>)
 80072ac:	4618      	mov	r0, r3
 80072ae:	f00e f8e7 	bl	8015480 <_test_assert>
 80072b2:	4603      	mov	r3, r0
 80072b4:	2b00      	cmp	r3, #0
 80072b6:	d138      	bne.n	800732a <oslib_test_005_003_execute.lto_priv.736+0x19a>

    chFactoryReleaseSemaphore(dsp2);
 80072b8:	9800      	ldr	r0, [sp, #0]
 80072ba:	f00c fee1 	bl	8014080 <chFactoryReleaseSemaphore>
    test_assert(dsp1->element.refs == 2, "references mismatch");
 80072be:	9b01      	ldr	r3, [sp, #4]
 80072c0:	685b      	ldr	r3, [r3, #4]
 80072c2:	2b02      	cmp	r3, #2
 80072c4:	bf0c      	ite	eq
 80072c6:	2301      	moveq	r3, #1
 80072c8:	2300      	movne	r3, #0
 80072ca:	b2db      	uxtb	r3, r3
 80072cc:	491f      	ldr	r1, [pc, #124]	; (800734c <oslib_test_005_003_execute.lto_priv.736+0x1bc>)
 80072ce:	4618      	mov	r0, r3
 80072d0:	f00e f8d6 	bl	8015480 <_test_assert>
 80072d4:	4603      	mov	r3, r0
 80072d6:	2b00      	cmp	r3, #0
 80072d8:	d127      	bne.n	800732a <oslib_test_005_003_execute.lto_priv.736+0x19a>

    chFactoryReleaseSemaphore(dsp1);
 80072da:	9801      	ldr	r0, [sp, #4]
 80072dc:	f00c fed0 	bl	8014080 <chFactoryReleaseSemaphore>
    test_assert(dsp->element.refs == 1, "references mismatch");
 80072e0:	9b03      	ldr	r3, [sp, #12]
 80072e2:	685b      	ldr	r3, [r3, #4]
 80072e4:	2b01      	cmp	r3, #1
 80072e6:	bf0c      	ite	eq
 80072e8:	2301      	moveq	r3, #1
 80072ea:	2300      	movne	r3, #0
 80072ec:	b2db      	uxtb	r3, r3
 80072ee:	4917      	ldr	r1, [pc, #92]	; (800734c <oslib_test_005_003_execute.lto_priv.736+0x1bc>)
 80072f0:	4618      	mov	r0, r3
 80072f2:	f00e f8c5 	bl	8015480 <_test_assert>
 80072f6:	4603      	mov	r3, r0
 80072f8:	2b00      	cmp	r3, #0
 80072fa:	d116      	bne.n	800732a <oslib_test_005_003_execute.lto_priv.736+0x19a>
  }

  /* [5.3.5] Releasing the first reference to the dynamic semaphore
     must not trigger an assertion.*/
  test_set_step(5);
 80072fc:	4b0c      	ldr	r3, [pc, #48]	; (8007330 <oslib_test_005_003_execute.lto_priv.736+0x1a0>)
 80072fe:	2205      	movs	r2, #5
 8007300:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleaseSemaphore(dsp);
 8007302:	9803      	ldr	r0, [sp, #12]
 8007304:	f00c febc 	bl	8014080 <chFactoryReleaseSemaphore>
  }

  /* [5.3.6] Retrieving the dynamic semaphore by name again, must not
     exist.*/
  test_set_step(6);
 8007308:	4b09      	ldr	r3, [pc, #36]	; (8007330 <oslib_test_005_003_execute.lto_priv.736+0x1a0>)
 800730a:	2206      	movs	r2, #6
 800730c:	601a      	str	r2, [r3, #0]
  {
    dsp = chFactoryFindSemaphore("mysem");
 800730e:	4809      	ldr	r0, [pc, #36]	; (8007334 <oslib_test_005_003_execute.lto_priv.736+0x1a4>)
 8007310:	f00c fe9e 	bl	8014050 <chFactoryFindSemaphore>
 8007314:	9003      	str	r0, [sp, #12]
    test_assert(dsp == NULL, "found");
 8007316:	9b03      	ldr	r3, [sp, #12]
 8007318:	2b00      	cmp	r3, #0
 800731a:	bf0c      	ite	eq
 800731c:	2301      	moveq	r3, #1
 800731e:	2300      	movne	r3, #0
 8007320:	b2db      	uxtb	r3, r3
 8007322:	4905      	ldr	r1, [pc, #20]	; (8007338 <oslib_test_005_003_execute.lto_priv.736+0x1a8>)
 8007324:	4618      	mov	r0, r3
 8007326:	f00e f8ab 	bl	8015480 <_test_assert>
  }
}
 800732a:	b005      	add	sp, #20
 800732c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007330:	20001988 	.word	0x20001988
 8007334:	08018acc 	.word	0x08018acc
 8007338:	08018a40 	.word	0x08018a40
 800733c:	08018aa0 	.word	0x08018aa0
 8007340:	08018ab0 	.word	0x08018ab0
 8007344:	08018a3c 	.word	0x08018a3c
 8007348:	08018a58 	.word	0x08018a58
 800734c:	08018a74 	.word	0x08018a74

08007350 <oslib_test_005_004_teardown.lto_priv.737>:
 * - [5.4.6] Retrieving the dynamic mailbox by name again, must not
 *   exist.
 * .
 */

static void oslib_test_005_004_teardown(void) {
 8007350:	b500      	push	{lr}
 8007352:	b083      	sub	sp, #12
  dyn_mailbox_t *dmp;

  dmp = chFactoryFindMailbox("mymbx");
 8007354:	4808      	ldr	r0, [pc, #32]	; (8007378 <oslib_test_005_004_teardown.lto_priv.737+0x28>)
 8007356:	f00c fed3 	bl	8014100 <chFactoryFindMailbox>
 800735a:	9001      	str	r0, [sp, #4]
  if (dmp != NULL) {
 800735c:	9b01      	ldr	r3, [sp, #4]
 800735e:	2b00      	cmp	r3, #0
 8007360:	d103      	bne.n	800736a <oslib_test_005_004_teardown.lto_priv.737+0x1a>
 8007362:	e006      	b.n	8007372 <oslib_test_005_004_teardown.lto_priv.737+0x22>
    while (dmp->element.refs > 0U) {
      chFactoryReleaseMailbox(dmp);
 8007364:	9801      	ldr	r0, [sp, #4]
 8007366:	f00c fee3 	bl	8014130 <chFactoryReleaseMailbox>
    while (dmp->element.refs > 0U) {
 800736a:	9b01      	ldr	r3, [sp, #4]
 800736c:	685b      	ldr	r3, [r3, #4]
 800736e:	2b00      	cmp	r3, #0
 8007370:	d1f8      	bne.n	8007364 <oslib_test_005_004_teardown.lto_priv.737+0x14>
    }
  }
}
 8007372:	b003      	add	sp, #12
 8007374:	f85d fb04 	ldr.w	pc, [sp], #4
 8007378:	08018ae4 	.word	0x08018ae4
 800737c:	00000000 	.word	0x00000000

08007380 <oslib_test_005_004_execute.lto_priv.738>:

static void oslib_test_005_004_execute(void) {
 8007380:	b500      	push	{lr}
 8007382:	b085      	sub	sp, #20
  dyn_mailbox_t *dmp;

  /* [5.4.1] Retrieving a dynamic mailbox by name, must not exist.*/
  test_set_step(1);
 8007384:	4b66      	ldr	r3, [pc, #408]	; (8007520 <oslib_test_005_004_execute.lto_priv.738+0x1a0>)
 8007386:	2201      	movs	r2, #1
 8007388:	601a      	str	r2, [r3, #0]
  {
    dmp = chFactoryFindMailbox("mymbx");
 800738a:	4866      	ldr	r0, [pc, #408]	; (8007524 <oslib_test_005_004_execute.lto_priv.738+0x1a4>)
 800738c:	f00c feb8 	bl	8014100 <chFactoryFindMailbox>
 8007390:	9003      	str	r0, [sp, #12]
    test_assert(dmp == NULL, "found");
 8007392:	9b03      	ldr	r3, [sp, #12]
 8007394:	2b00      	cmp	r3, #0
 8007396:	bf0c      	ite	eq
 8007398:	2301      	moveq	r3, #1
 800739a:	2300      	movne	r3, #0
 800739c:	b2db      	uxtb	r3, r3
 800739e:	4962      	ldr	r1, [pc, #392]	; (8007528 <oslib_test_005_004_execute.lto_priv.738+0x1a8>)
 80073a0:	4618      	mov	r0, r3
 80073a2:	f00e f86d 	bl	8015480 <_test_assert>
 80073a6:	4603      	mov	r3, r0
 80073a8:	2b00      	cmp	r3, #0
 80073aa:	f040 80b6 	bne.w	800751a <oslib_test_005_004_execute.lto_priv.738+0x19a>
  }

  /* [5.4.2] Creating a dynamic mailbox it must not exists, must
     succeed.*/
  test_set_step(2);
 80073ae:	4b5c      	ldr	r3, [pc, #368]	; (8007520 <oslib_test_005_004_execute.lto_priv.738+0x1a0>)
 80073b0:	2202      	movs	r2, #2
 80073b2:	601a      	str	r2, [r3, #0]
  {
    dmp = chFactoryCreateMailbox("mymbx", 16U);
 80073b4:	2110      	movs	r1, #16
 80073b6:	485b      	ldr	r0, [pc, #364]	; (8007524 <oslib_test_005_004_execute.lto_priv.738+0x1a4>)
 80073b8:	f00c fe7a 	bl	80140b0 <chFactoryCreateMailbox>
 80073bc:	9003      	str	r0, [sp, #12]
    test_assert(dmp != NULL, "cannot create");
 80073be:	9b03      	ldr	r3, [sp, #12]
 80073c0:	2b00      	cmp	r3, #0
 80073c2:	bf14      	ite	ne
 80073c4:	2301      	movne	r3, #1
 80073c6:	2300      	moveq	r3, #0
 80073c8:	b2db      	uxtb	r3, r3
 80073ca:	4958      	ldr	r1, [pc, #352]	; (800752c <oslib_test_005_004_execute.lto_priv.738+0x1ac>)
 80073cc:	4618      	mov	r0, r3
 80073ce:	f00e f857 	bl	8015480 <_test_assert>
 80073d2:	4603      	mov	r3, r0
 80073d4:	2b00      	cmp	r3, #0
 80073d6:	f040 80a0 	bne.w	800751a <oslib_test_005_004_execute.lto_priv.738+0x19a>
  }

  /* [5.4.3] Creating a dynamic mailbox with the same name, must
     fail.*/
  test_set_step(3);
 80073da:	4b51      	ldr	r3, [pc, #324]	; (8007520 <oslib_test_005_004_execute.lto_priv.738+0x1a0>)
 80073dc:	2203      	movs	r2, #3
 80073de:	601a      	str	r2, [r3, #0]
  {
    dyn_mailbox_t *dmp1;

    dmp1 = chFactoryCreateMailbox("mymbx", 16U);
 80073e0:	2110      	movs	r1, #16
 80073e2:	4850      	ldr	r0, [pc, #320]	; (8007524 <oslib_test_005_004_execute.lto_priv.738+0x1a4>)
 80073e4:	f00c fe64 	bl	80140b0 <chFactoryCreateMailbox>
 80073e8:	9002      	str	r0, [sp, #8]
    test_assert(dmp1 == NULL, "can create");
 80073ea:	9b02      	ldr	r3, [sp, #8]
 80073ec:	2b00      	cmp	r3, #0
 80073ee:	bf0c      	ite	eq
 80073f0:	2301      	moveq	r3, #1
 80073f2:	2300      	movne	r3, #0
 80073f4:	b2db      	uxtb	r3, r3
 80073f6:	494e      	ldr	r1, [pc, #312]	; (8007530 <oslib_test_005_004_execute.lto_priv.738+0x1b0>)
 80073f8:	4618      	mov	r0, r3
 80073fa:	f00e f841 	bl	8015480 <_test_assert>
 80073fe:	4603      	mov	r3, r0
 8007400:	2b00      	cmp	r3, #0
 8007402:	f040 808a 	bne.w	800751a <oslib_test_005_004_execute.lto_priv.738+0x19a>
  }

  /* [5.4.4] Retrieving the dynamic mailbox by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
 8007406:	4b46      	ldr	r3, [pc, #280]	; (8007520 <oslib_test_005_004_execute.lto_priv.738+0x1a0>)
 8007408:	2204      	movs	r2, #4
 800740a:	601a      	str	r2, [r3, #0]
  {
    dyn_mailbox_t *dmp1, *dmp2;

    dmp1 = chFactoryFindMailbox("mymbx");
 800740c:	4845      	ldr	r0, [pc, #276]	; (8007524 <oslib_test_005_004_execute.lto_priv.738+0x1a4>)
 800740e:	f00c fe77 	bl	8014100 <chFactoryFindMailbox>
 8007412:	9001      	str	r0, [sp, #4]
    test_assert(dmp1 != NULL, "not found");
 8007414:	9b01      	ldr	r3, [sp, #4]
 8007416:	2b00      	cmp	r3, #0
 8007418:	bf14      	ite	ne
 800741a:	2301      	movne	r3, #1
 800741c:	2300      	moveq	r3, #0
 800741e:	b2db      	uxtb	r3, r3
 8007420:	4944      	ldr	r1, [pc, #272]	; (8007534 <oslib_test_005_004_execute.lto_priv.738+0x1b4>)
 8007422:	4618      	mov	r0, r3
 8007424:	f00e f82c 	bl	8015480 <_test_assert>
 8007428:	4603      	mov	r3, r0
 800742a:	2b00      	cmp	r3, #0
 800742c:	d175      	bne.n	800751a <oslib_test_005_004_execute.lto_priv.738+0x19a>
    test_assert(dmp == dmp1, "object reference mismatch");
 800742e:	9a03      	ldr	r2, [sp, #12]
 8007430:	9b01      	ldr	r3, [sp, #4]
 8007432:	429a      	cmp	r2, r3
 8007434:	bf0c      	ite	eq
 8007436:	2301      	moveq	r3, #1
 8007438:	2300      	movne	r3, #0
 800743a:	b2db      	uxtb	r3, r3
 800743c:	493e      	ldr	r1, [pc, #248]	; (8007538 <oslib_test_005_004_execute.lto_priv.738+0x1b8>)
 800743e:	4618      	mov	r0, r3
 8007440:	f00e f81e 	bl	8015480 <_test_assert>
 8007444:	4603      	mov	r3, r0
 8007446:	2b00      	cmp	r3, #0
 8007448:	d167      	bne.n	800751a <oslib_test_005_004_execute.lto_priv.738+0x19a>
    test_assert(dmp1->element.refs == 2, "object reference mismatch");
 800744a:	9b01      	ldr	r3, [sp, #4]
 800744c:	685b      	ldr	r3, [r3, #4]
 800744e:	2b02      	cmp	r3, #2
 8007450:	bf0c      	ite	eq
 8007452:	2301      	moveq	r3, #1
 8007454:	2300      	movne	r3, #0
 8007456:	b2db      	uxtb	r3, r3
 8007458:	4937      	ldr	r1, [pc, #220]	; (8007538 <oslib_test_005_004_execute.lto_priv.738+0x1b8>)
 800745a:	4618      	mov	r0, r3
 800745c:	f00e f810 	bl	8015480 <_test_assert>
 8007460:	4603      	mov	r3, r0
 8007462:	2b00      	cmp	r3, #0
 8007464:	d159      	bne.n	800751a <oslib_test_005_004_execute.lto_priv.738+0x19a>

    dmp2 = (dyn_mailbox_t *)chFactoryDuplicateReference(&dmp1->element);
 8007466:	9b01      	ldr	r3, [sp, #4]
 8007468:	4618      	mov	r0, r3
 800746a:	f7ff fc49 	bl	8006d00 <chFactoryDuplicateReference>
 800746e:	9000      	str	r0, [sp, #0]
    test_assert(dmp1 == dmp2, "object reference mismatch");
 8007470:	9a01      	ldr	r2, [sp, #4]
 8007472:	9b00      	ldr	r3, [sp, #0]
 8007474:	429a      	cmp	r2, r3
 8007476:	bf0c      	ite	eq
 8007478:	2301      	moveq	r3, #1
 800747a:	2300      	movne	r3, #0
 800747c:	b2db      	uxtb	r3, r3
 800747e:	492e      	ldr	r1, [pc, #184]	; (8007538 <oslib_test_005_004_execute.lto_priv.738+0x1b8>)
 8007480:	4618      	mov	r0, r3
 8007482:	f00d fffd 	bl	8015480 <_test_assert>
 8007486:	4603      	mov	r3, r0
 8007488:	2b00      	cmp	r3, #0
 800748a:	d146      	bne.n	800751a <oslib_test_005_004_execute.lto_priv.738+0x19a>
    test_assert(dmp2->element.refs == 3, "object reference mismatch");
 800748c:	9b00      	ldr	r3, [sp, #0]
 800748e:	685b      	ldr	r3, [r3, #4]
 8007490:	2b03      	cmp	r3, #3
 8007492:	bf0c      	ite	eq
 8007494:	2301      	moveq	r3, #1
 8007496:	2300      	movne	r3, #0
 8007498:	b2db      	uxtb	r3, r3
 800749a:	4927      	ldr	r1, [pc, #156]	; (8007538 <oslib_test_005_004_execute.lto_priv.738+0x1b8>)
 800749c:	4618      	mov	r0, r3
 800749e:	f00d ffef 	bl	8015480 <_test_assert>
 80074a2:	4603      	mov	r3, r0
 80074a4:	2b00      	cmp	r3, #0
 80074a6:	d138      	bne.n	800751a <oslib_test_005_004_execute.lto_priv.738+0x19a>

    chFactoryReleaseMailbox(dmp2);
 80074a8:	9800      	ldr	r0, [sp, #0]
 80074aa:	f00c fe41 	bl	8014130 <chFactoryReleaseMailbox>
    test_assert(dmp1->element.refs == 2, "references mismatch");
 80074ae:	9b01      	ldr	r3, [sp, #4]
 80074b0:	685b      	ldr	r3, [r3, #4]
 80074b2:	2b02      	cmp	r3, #2
 80074b4:	bf0c      	ite	eq
 80074b6:	2301      	moveq	r3, #1
 80074b8:	2300      	movne	r3, #0
 80074ba:	b2db      	uxtb	r3, r3
 80074bc:	491f      	ldr	r1, [pc, #124]	; (800753c <oslib_test_005_004_execute.lto_priv.738+0x1bc>)
 80074be:	4618      	mov	r0, r3
 80074c0:	f00d ffde 	bl	8015480 <_test_assert>
 80074c4:	4603      	mov	r3, r0
 80074c6:	2b00      	cmp	r3, #0
 80074c8:	d127      	bne.n	800751a <oslib_test_005_004_execute.lto_priv.738+0x19a>

    chFactoryReleaseMailbox(dmp1);
 80074ca:	9801      	ldr	r0, [sp, #4]
 80074cc:	f00c fe30 	bl	8014130 <chFactoryReleaseMailbox>
    test_assert(dmp->element.refs == 1, "references mismatch");
 80074d0:	9b03      	ldr	r3, [sp, #12]
 80074d2:	685b      	ldr	r3, [r3, #4]
 80074d4:	2b01      	cmp	r3, #1
 80074d6:	bf0c      	ite	eq
 80074d8:	2301      	moveq	r3, #1
 80074da:	2300      	movne	r3, #0
 80074dc:	b2db      	uxtb	r3, r3
 80074de:	4917      	ldr	r1, [pc, #92]	; (800753c <oslib_test_005_004_execute.lto_priv.738+0x1bc>)
 80074e0:	4618      	mov	r0, r3
 80074e2:	f00d ffcd 	bl	8015480 <_test_assert>
 80074e6:	4603      	mov	r3, r0
 80074e8:	2b00      	cmp	r3, #0
 80074ea:	d116      	bne.n	800751a <oslib_test_005_004_execute.lto_priv.738+0x19a>
  }

  /* [5.4.5] Releasing the first reference to the dynamic mailbox must
     not trigger an assertion.*/
  test_set_step(5);
 80074ec:	4b0c      	ldr	r3, [pc, #48]	; (8007520 <oslib_test_005_004_execute.lto_priv.738+0x1a0>)
 80074ee:	2205      	movs	r2, #5
 80074f0:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleaseMailbox(dmp);
 80074f2:	9803      	ldr	r0, [sp, #12]
 80074f4:	f00c fe1c 	bl	8014130 <chFactoryReleaseMailbox>
  }

  /* [5.4.6] Retrieving the dynamic mailbox by name again, must not
     exist.*/
  test_set_step(6);
 80074f8:	4b09      	ldr	r3, [pc, #36]	; (8007520 <oslib_test_005_004_execute.lto_priv.738+0x1a0>)
 80074fa:	2206      	movs	r2, #6
 80074fc:	601a      	str	r2, [r3, #0]
  {
    dmp = chFactoryFindMailbox("mymbx");
 80074fe:	4809      	ldr	r0, [pc, #36]	; (8007524 <oslib_test_005_004_execute.lto_priv.738+0x1a4>)
 8007500:	f00c fdfe 	bl	8014100 <chFactoryFindMailbox>
 8007504:	9003      	str	r0, [sp, #12]
    test_assert(dmp == NULL, "found");
 8007506:	9b03      	ldr	r3, [sp, #12]
 8007508:	2b00      	cmp	r3, #0
 800750a:	bf0c      	ite	eq
 800750c:	2301      	moveq	r3, #1
 800750e:	2300      	movne	r3, #0
 8007510:	b2db      	uxtb	r3, r3
 8007512:	4905      	ldr	r1, [pc, #20]	; (8007528 <oslib_test_005_004_execute.lto_priv.738+0x1a8>)
 8007514:	4618      	mov	r0, r3
 8007516:	f00d ffb3 	bl	8015480 <_test_assert>
  }
}
 800751a:	b005      	add	sp, #20
 800751c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007520:	20001988 	.word	0x20001988
 8007524:	08018ae4 	.word	0x08018ae4
 8007528:	08018a40 	.word	0x08018a40
 800752c:	08018aa0 	.word	0x08018aa0
 8007530:	08018ab0 	.word	0x08018ab0
 8007534:	08018a3c 	.word	0x08018a3c
 8007538:	08018a58 	.word	0x08018a58
 800753c:	08018a74 	.word	0x08018a74

08007540 <oslib_test_005_005_teardown.lto_priv.739>:
 * - [5.5.6] Retrieving the dynamic objects FIFO by name again, must
 *   not exist.
 * .
 */

static void oslib_test_005_005_teardown(void) {
 8007540:	b500      	push	{lr}
 8007542:	b083      	sub	sp, #12
  dyn_objects_fifo_t *dofp;

  dofp = chFactoryFindObjectsFIFO("myfifo");
 8007544:	4808      	ldr	r0, [pc, #32]	; (8007568 <oslib_test_005_005_teardown.lto_priv.739+0x28>)
 8007546:	f00c fe43 	bl	80141d0 <chFactoryFindObjectsFIFO>
 800754a:	9001      	str	r0, [sp, #4]
  if (dofp != NULL) {
 800754c:	9b01      	ldr	r3, [sp, #4]
 800754e:	2b00      	cmp	r3, #0
 8007550:	d103      	bne.n	800755a <oslib_test_005_005_teardown.lto_priv.739+0x1a>
 8007552:	e006      	b.n	8007562 <oslib_test_005_005_teardown.lto_priv.739+0x22>
    while (dofp->element.refs > 0U) {
      chFactoryReleaseObjectsFIFO(dofp);
 8007554:	9801      	ldr	r0, [sp, #4]
 8007556:	f00c fe53 	bl	8014200 <chFactoryReleaseObjectsFIFO>
    while (dofp->element.refs > 0U) {
 800755a:	9b01      	ldr	r3, [sp, #4]
 800755c:	685b      	ldr	r3, [r3, #4]
 800755e:	2b00      	cmp	r3, #0
 8007560:	d1f8      	bne.n	8007554 <oslib_test_005_005_teardown.lto_priv.739+0x14>
    }
  }
}
 8007562:	b003      	add	sp, #12
 8007564:	f85d fb04 	ldr.w	pc, [sp], #4
 8007568:	08018afc 	.word	0x08018afc
 800756c:	00000000 	.word	0x00000000

08007570 <oslib_test_005_005_execute.lto_priv.740>:

static void oslib_test_005_005_execute(void) {
 8007570:	b500      	push	{lr}
 8007572:	b085      	sub	sp, #20
  dyn_objects_fifo_t *dofp;

  /* [5.5.1] Retrieving a dynamic objects FIFO by name, must not
     exist.*/
  test_set_step(1);
 8007574:	4b68      	ldr	r3, [pc, #416]	; (8007718 <oslib_test_005_005_execute.lto_priv.740+0x1a8>)
 8007576:	2201      	movs	r2, #1
 8007578:	601a      	str	r2, [r3, #0]
  {
    dofp = chFactoryFindObjectsFIFO("myfifo");
 800757a:	4868      	ldr	r0, [pc, #416]	; (800771c <oslib_test_005_005_execute.lto_priv.740+0x1ac>)
 800757c:	f00c fe28 	bl	80141d0 <chFactoryFindObjectsFIFO>
 8007580:	9003      	str	r0, [sp, #12]
    test_assert(dofp == NULL, "found");
 8007582:	9b03      	ldr	r3, [sp, #12]
 8007584:	2b00      	cmp	r3, #0
 8007586:	bf0c      	ite	eq
 8007588:	2301      	moveq	r3, #1
 800758a:	2300      	movne	r3, #0
 800758c:	b2db      	uxtb	r3, r3
 800758e:	4964      	ldr	r1, [pc, #400]	; (8007720 <oslib_test_005_005_execute.lto_priv.740+0x1b0>)
 8007590:	4618      	mov	r0, r3
 8007592:	f00d ff75 	bl	8015480 <_test_assert>
 8007596:	4603      	mov	r3, r0
 8007598:	2b00      	cmp	r3, #0
 800759a:	f040 80ba 	bne.w	8007712 <oslib_test_005_005_execute.lto_priv.740+0x1a2>
  }

  /* [5.5.2] Creating a dynamic objects FIFO it must not exists, must
     succeed.*/
  test_set_step(2);
 800759e:	4b5e      	ldr	r3, [pc, #376]	; (8007718 <oslib_test_005_005_execute.lto_priv.740+0x1a8>)
 80075a0:	2202      	movs	r2, #2
 80075a2:	601a      	str	r2, [r3, #0]
  {
    dofp = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 80075a4:	2304      	movs	r3, #4
 80075a6:	2210      	movs	r2, #16
 80075a8:	2110      	movs	r1, #16
 80075aa:	485c      	ldr	r0, [pc, #368]	; (800771c <oslib_test_005_005_execute.lto_priv.740+0x1ac>)
 80075ac:	f00c fdd8 	bl	8014160 <chFactoryCreateObjectsFIFO>
 80075b0:	9003      	str	r0, [sp, #12]
    test_assert(dofp != NULL, "cannot create");
 80075b2:	9b03      	ldr	r3, [sp, #12]
 80075b4:	2b00      	cmp	r3, #0
 80075b6:	bf14      	ite	ne
 80075b8:	2301      	movne	r3, #1
 80075ba:	2300      	moveq	r3, #0
 80075bc:	b2db      	uxtb	r3, r3
 80075be:	4959      	ldr	r1, [pc, #356]	; (8007724 <oslib_test_005_005_execute.lto_priv.740+0x1b4>)
 80075c0:	4618      	mov	r0, r3
 80075c2:	f00d ff5d 	bl	8015480 <_test_assert>
 80075c6:	4603      	mov	r3, r0
 80075c8:	2b00      	cmp	r3, #0
 80075ca:	f040 80a2 	bne.w	8007712 <oslib_test_005_005_execute.lto_priv.740+0x1a2>
  }

  /* [5.5.3] Creating a dynamic objects FIFO with the same name, must
     fail.*/
  test_set_step(3);
 80075ce:	4b52      	ldr	r3, [pc, #328]	; (8007718 <oslib_test_005_005_execute.lto_priv.740+0x1a8>)
 80075d0:	2203      	movs	r2, #3
 80075d2:	601a      	str	r2, [r3, #0]
  {
    dyn_objects_fifo_t *dofp1;

    dofp1 = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 80075d4:	2304      	movs	r3, #4
 80075d6:	2210      	movs	r2, #16
 80075d8:	2110      	movs	r1, #16
 80075da:	4850      	ldr	r0, [pc, #320]	; (800771c <oslib_test_005_005_execute.lto_priv.740+0x1ac>)
 80075dc:	f00c fdc0 	bl	8014160 <chFactoryCreateObjectsFIFO>
 80075e0:	9002      	str	r0, [sp, #8]
    test_assert(dofp1 == NULL, "can create");
 80075e2:	9b02      	ldr	r3, [sp, #8]
 80075e4:	2b00      	cmp	r3, #0
 80075e6:	bf0c      	ite	eq
 80075e8:	2301      	moveq	r3, #1
 80075ea:	2300      	movne	r3, #0
 80075ec:	b2db      	uxtb	r3, r3
 80075ee:	494e      	ldr	r1, [pc, #312]	; (8007728 <oslib_test_005_005_execute.lto_priv.740+0x1b8>)
 80075f0:	4618      	mov	r0, r3
 80075f2:	f00d ff45 	bl	8015480 <_test_assert>
 80075f6:	4603      	mov	r3, r0
 80075f8:	2b00      	cmp	r3, #0
 80075fa:	f040 808a 	bne.w	8007712 <oslib_test_005_005_execute.lto_priv.740+0x1a2>
  }

  /* [5.5.4] Retrieving the dynamic objects FIFO by name, must exist,
     then increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
 80075fe:	4b46      	ldr	r3, [pc, #280]	; (8007718 <oslib_test_005_005_execute.lto_priv.740+0x1a8>)
 8007600:	2204      	movs	r2, #4
 8007602:	601a      	str	r2, [r3, #0]
  {
    dyn_objects_fifo_t *dofp1, *dofp2;

    dofp1 = chFactoryFindObjectsFIFO("myfifo");
 8007604:	4845      	ldr	r0, [pc, #276]	; (800771c <oslib_test_005_005_execute.lto_priv.740+0x1ac>)
 8007606:	f00c fde3 	bl	80141d0 <chFactoryFindObjectsFIFO>
 800760a:	9001      	str	r0, [sp, #4]
    test_assert(dofp1 != NULL, "not found");
 800760c:	9b01      	ldr	r3, [sp, #4]
 800760e:	2b00      	cmp	r3, #0
 8007610:	bf14      	ite	ne
 8007612:	2301      	movne	r3, #1
 8007614:	2300      	moveq	r3, #0
 8007616:	b2db      	uxtb	r3, r3
 8007618:	4944      	ldr	r1, [pc, #272]	; (800772c <oslib_test_005_005_execute.lto_priv.740+0x1bc>)
 800761a:	4618      	mov	r0, r3
 800761c:	f00d ff30 	bl	8015480 <_test_assert>
 8007620:	4603      	mov	r3, r0
 8007622:	2b00      	cmp	r3, #0
 8007624:	d175      	bne.n	8007712 <oslib_test_005_005_execute.lto_priv.740+0x1a2>
    test_assert(dofp == dofp1, "object reference mismatch");
 8007626:	9a03      	ldr	r2, [sp, #12]
 8007628:	9b01      	ldr	r3, [sp, #4]
 800762a:	429a      	cmp	r2, r3
 800762c:	bf0c      	ite	eq
 800762e:	2301      	moveq	r3, #1
 8007630:	2300      	movne	r3, #0
 8007632:	b2db      	uxtb	r3, r3
 8007634:	493e      	ldr	r1, [pc, #248]	; (8007730 <oslib_test_005_005_execute.lto_priv.740+0x1c0>)
 8007636:	4618      	mov	r0, r3
 8007638:	f00d ff22 	bl	8015480 <_test_assert>
 800763c:	4603      	mov	r3, r0
 800763e:	2b00      	cmp	r3, #0
 8007640:	d167      	bne.n	8007712 <oslib_test_005_005_execute.lto_priv.740+0x1a2>
    test_assert(dofp1->element.refs == 2, "object reference mismatch");
 8007642:	9b01      	ldr	r3, [sp, #4]
 8007644:	685b      	ldr	r3, [r3, #4]
 8007646:	2b02      	cmp	r3, #2
 8007648:	bf0c      	ite	eq
 800764a:	2301      	moveq	r3, #1
 800764c:	2300      	movne	r3, #0
 800764e:	b2db      	uxtb	r3, r3
 8007650:	4937      	ldr	r1, [pc, #220]	; (8007730 <oslib_test_005_005_execute.lto_priv.740+0x1c0>)
 8007652:	4618      	mov	r0, r3
 8007654:	f00d ff14 	bl	8015480 <_test_assert>
 8007658:	4603      	mov	r3, r0
 800765a:	2b00      	cmp	r3, #0
 800765c:	d159      	bne.n	8007712 <oslib_test_005_005_execute.lto_priv.740+0x1a2>

    dofp2 = (dyn_objects_fifo_t *)chFactoryDuplicateReference(&dofp1->element);
 800765e:	9b01      	ldr	r3, [sp, #4]
 8007660:	4618      	mov	r0, r3
 8007662:	f7ff fb4d 	bl	8006d00 <chFactoryDuplicateReference>
 8007666:	9000      	str	r0, [sp, #0]
    test_assert(dofp1 == dofp2, "object reference mismatch");
 8007668:	9a01      	ldr	r2, [sp, #4]
 800766a:	9b00      	ldr	r3, [sp, #0]
 800766c:	429a      	cmp	r2, r3
 800766e:	bf0c      	ite	eq
 8007670:	2301      	moveq	r3, #1
 8007672:	2300      	movne	r3, #0
 8007674:	b2db      	uxtb	r3, r3
 8007676:	492e      	ldr	r1, [pc, #184]	; (8007730 <oslib_test_005_005_execute.lto_priv.740+0x1c0>)
 8007678:	4618      	mov	r0, r3
 800767a:	f00d ff01 	bl	8015480 <_test_assert>
 800767e:	4603      	mov	r3, r0
 8007680:	2b00      	cmp	r3, #0
 8007682:	d146      	bne.n	8007712 <oslib_test_005_005_execute.lto_priv.740+0x1a2>
    test_assert(dofp2->element.refs == 3, "object reference mismatch");
 8007684:	9b00      	ldr	r3, [sp, #0]
 8007686:	685b      	ldr	r3, [r3, #4]
 8007688:	2b03      	cmp	r3, #3
 800768a:	bf0c      	ite	eq
 800768c:	2301      	moveq	r3, #1
 800768e:	2300      	movne	r3, #0
 8007690:	b2db      	uxtb	r3, r3
 8007692:	4927      	ldr	r1, [pc, #156]	; (8007730 <oslib_test_005_005_execute.lto_priv.740+0x1c0>)
 8007694:	4618      	mov	r0, r3
 8007696:	f00d fef3 	bl	8015480 <_test_assert>
 800769a:	4603      	mov	r3, r0
 800769c:	2b00      	cmp	r3, #0
 800769e:	d138      	bne.n	8007712 <oslib_test_005_005_execute.lto_priv.740+0x1a2>

    chFactoryReleaseObjectsFIFO(dofp2);
 80076a0:	9800      	ldr	r0, [sp, #0]
 80076a2:	f00c fdad 	bl	8014200 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp1->element.refs == 2, "references mismatch");
 80076a6:	9b01      	ldr	r3, [sp, #4]
 80076a8:	685b      	ldr	r3, [r3, #4]
 80076aa:	2b02      	cmp	r3, #2
 80076ac:	bf0c      	ite	eq
 80076ae:	2301      	moveq	r3, #1
 80076b0:	2300      	movne	r3, #0
 80076b2:	b2db      	uxtb	r3, r3
 80076b4:	491f      	ldr	r1, [pc, #124]	; (8007734 <oslib_test_005_005_execute.lto_priv.740+0x1c4>)
 80076b6:	4618      	mov	r0, r3
 80076b8:	f00d fee2 	bl	8015480 <_test_assert>
 80076bc:	4603      	mov	r3, r0
 80076be:	2b00      	cmp	r3, #0
 80076c0:	d127      	bne.n	8007712 <oslib_test_005_005_execute.lto_priv.740+0x1a2>

    chFactoryReleaseObjectsFIFO(dofp1);
 80076c2:	9801      	ldr	r0, [sp, #4]
 80076c4:	f00c fd9c 	bl	8014200 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp->element.refs == 1, "references mismatch");
 80076c8:	9b03      	ldr	r3, [sp, #12]
 80076ca:	685b      	ldr	r3, [r3, #4]
 80076cc:	2b01      	cmp	r3, #1
 80076ce:	bf0c      	ite	eq
 80076d0:	2301      	moveq	r3, #1
 80076d2:	2300      	movne	r3, #0
 80076d4:	b2db      	uxtb	r3, r3
 80076d6:	4917      	ldr	r1, [pc, #92]	; (8007734 <oslib_test_005_005_execute.lto_priv.740+0x1c4>)
 80076d8:	4618      	mov	r0, r3
 80076da:	f00d fed1 	bl	8015480 <_test_assert>
 80076de:	4603      	mov	r3, r0
 80076e0:	2b00      	cmp	r3, #0
 80076e2:	d116      	bne.n	8007712 <oslib_test_005_005_execute.lto_priv.740+0x1a2>
  }

  /* [5.5.5] Releasing the first reference to the dynamic objects FIFO
     must not trigger an assertion.*/
  test_set_step(5);
 80076e4:	4b0c      	ldr	r3, [pc, #48]	; (8007718 <oslib_test_005_005_execute.lto_priv.740+0x1a8>)
 80076e6:	2205      	movs	r2, #5
 80076e8:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleaseObjectsFIFO(dofp);
 80076ea:	9803      	ldr	r0, [sp, #12]
 80076ec:	f00c fd88 	bl	8014200 <chFactoryReleaseObjectsFIFO>
  }

  /* [5.5.6] Retrieving the dynamic objects FIFO by name again, must
     not exist.*/
  test_set_step(6);
 80076f0:	4b09      	ldr	r3, [pc, #36]	; (8007718 <oslib_test_005_005_execute.lto_priv.740+0x1a8>)
 80076f2:	2206      	movs	r2, #6
 80076f4:	601a      	str	r2, [r3, #0]
  {
    dofp = chFactoryFindObjectsFIFO("myfifo");
 80076f6:	4809      	ldr	r0, [pc, #36]	; (800771c <oslib_test_005_005_execute.lto_priv.740+0x1ac>)
 80076f8:	f00c fd6a 	bl	80141d0 <chFactoryFindObjectsFIFO>
 80076fc:	9003      	str	r0, [sp, #12]
    test_assert(dofp == NULL, "found");
 80076fe:	9b03      	ldr	r3, [sp, #12]
 8007700:	2b00      	cmp	r3, #0
 8007702:	bf0c      	ite	eq
 8007704:	2301      	moveq	r3, #1
 8007706:	2300      	movne	r3, #0
 8007708:	b2db      	uxtb	r3, r3
 800770a:	4905      	ldr	r1, [pc, #20]	; (8007720 <oslib_test_005_005_execute.lto_priv.740+0x1b0>)
 800770c:	4618      	mov	r0, r3
 800770e:	f00d feb7 	bl	8015480 <_test_assert>
  }
}
 8007712:	b005      	add	sp, #20
 8007714:	f85d fb04 	ldr.w	pc, [sp], #4
 8007718:	20001988 	.word	0x20001988
 800771c:	08018afc 	.word	0x08018afc
 8007720:	08018a40 	.word	0x08018a40
 8007724:	08018aa0 	.word	0x08018aa0
 8007728:	08018ab0 	.word	0x08018ab0
 800772c:	08018a3c 	.word	0x08018a3c
 8007730:	08018a58 	.word	0x08018a58
 8007734:	08018a74 	.word	0x08018a74
	...

08007740 <oslib_test_005_006_teardown.lto_priv.741>:
 *   trigger an assertion.
 * - [5.6.6] Retrieving the dynamic pipe by name again, must not exist.
 * .
 */

static void oslib_test_005_006_teardown(void) {
 8007740:	b500      	push	{lr}
 8007742:	b083      	sub	sp, #12
  dyn_pipe_t *dpp;

  dpp = chFactoryFindPipe("mypipe");
 8007744:	4808      	ldr	r0, [pc, #32]	; (8007768 <oslib_test_005_006_teardown.lto_priv.741+0x28>)
 8007746:	f00c fd9b 	bl	8014280 <chFactoryFindPipe>
 800774a:	9001      	str	r0, [sp, #4]
  if (dpp != NULL) {
 800774c:	9b01      	ldr	r3, [sp, #4]
 800774e:	2b00      	cmp	r3, #0
 8007750:	d103      	bne.n	800775a <oslib_test_005_006_teardown.lto_priv.741+0x1a>
 8007752:	e006      	b.n	8007762 <oslib_test_005_006_teardown.lto_priv.741+0x22>
    while (dpp->element.refs > 0U) {
      chFactoryReleasePipe(dpp);
 8007754:	9801      	ldr	r0, [sp, #4]
 8007756:	f00c fdab 	bl	80142b0 <chFactoryReleasePipe>
    while (dpp->element.refs > 0U) {
 800775a:	9b01      	ldr	r3, [sp, #4]
 800775c:	685b      	ldr	r3, [r3, #4]
 800775e:	2b00      	cmp	r3, #0
 8007760:	d1f8      	bne.n	8007754 <oslib_test_005_006_teardown.lto_priv.741+0x14>
    }
  }
}
 8007762:	b003      	add	sp, #12
 8007764:	f85d fb04 	ldr.w	pc, [sp], #4
 8007768:	08018b14 	.word	0x08018b14
 800776c:	00000000 	.word	0x00000000

08007770 <oslib_test_005_006_execute.lto_priv.742>:

static void oslib_test_005_006_execute(void) {
 8007770:	b500      	push	{lr}
 8007772:	b085      	sub	sp, #20
  dyn_pipe_t *dpp;

  /* [5.6.1] Retrieving a dynamic pipe by name, must not exist.*/
  test_set_step(1);
 8007774:	4b66      	ldr	r3, [pc, #408]	; (8007910 <oslib_test_005_006_execute.lto_priv.742+0x1a0>)
 8007776:	2201      	movs	r2, #1
 8007778:	601a      	str	r2, [r3, #0]
  {
    dpp = chFactoryFindPipe("mypipe");
 800777a:	4866      	ldr	r0, [pc, #408]	; (8007914 <oslib_test_005_006_execute.lto_priv.742+0x1a4>)
 800777c:	f00c fd80 	bl	8014280 <chFactoryFindPipe>
 8007780:	9003      	str	r0, [sp, #12]
    test_assert(dpp == NULL, "found");
 8007782:	9b03      	ldr	r3, [sp, #12]
 8007784:	2b00      	cmp	r3, #0
 8007786:	bf0c      	ite	eq
 8007788:	2301      	moveq	r3, #1
 800778a:	2300      	movne	r3, #0
 800778c:	b2db      	uxtb	r3, r3
 800778e:	4962      	ldr	r1, [pc, #392]	; (8007918 <oslib_test_005_006_execute.lto_priv.742+0x1a8>)
 8007790:	4618      	mov	r0, r3
 8007792:	f00d fe75 	bl	8015480 <_test_assert>
 8007796:	4603      	mov	r3, r0
 8007798:	2b00      	cmp	r3, #0
 800779a:	f040 80b6 	bne.w	800790a <oslib_test_005_006_execute.lto_priv.742+0x19a>
  }

  /* [5.6.2] Creating a dynamic pipe it must not exists, must
     succeed.*/
  test_set_step(2);
 800779e:	4b5c      	ldr	r3, [pc, #368]	; (8007910 <oslib_test_005_006_execute.lto_priv.742+0x1a0>)
 80077a0:	2202      	movs	r2, #2
 80077a2:	601a      	str	r2, [r3, #0]
  {
    dpp = chFactoryCreatePipe("mypipe", 16U);
 80077a4:	2110      	movs	r1, #16
 80077a6:	485b      	ldr	r0, [pc, #364]	; (8007914 <oslib_test_005_006_execute.lto_priv.742+0x1a4>)
 80077a8:	f00c fd42 	bl	8014230 <chFactoryCreatePipe>
 80077ac:	9003      	str	r0, [sp, #12]
    test_assert(dpp != NULL, "cannot create");
 80077ae:	9b03      	ldr	r3, [sp, #12]
 80077b0:	2b00      	cmp	r3, #0
 80077b2:	bf14      	ite	ne
 80077b4:	2301      	movne	r3, #1
 80077b6:	2300      	moveq	r3, #0
 80077b8:	b2db      	uxtb	r3, r3
 80077ba:	4958      	ldr	r1, [pc, #352]	; (800791c <oslib_test_005_006_execute.lto_priv.742+0x1ac>)
 80077bc:	4618      	mov	r0, r3
 80077be:	f00d fe5f 	bl	8015480 <_test_assert>
 80077c2:	4603      	mov	r3, r0
 80077c4:	2b00      	cmp	r3, #0
 80077c6:	f040 80a0 	bne.w	800790a <oslib_test_005_006_execute.lto_priv.742+0x19a>
  }

  /* [5.6.3] Creating a dynamic pipe with the same name, must fail.*/
  test_set_step(3);
 80077ca:	4b51      	ldr	r3, [pc, #324]	; (8007910 <oslib_test_005_006_execute.lto_priv.742+0x1a0>)
 80077cc:	2203      	movs	r2, #3
 80077ce:	601a      	str	r2, [r3, #0]
  {
    dyn_pipe_t *dpp1;

    dpp1 = chFactoryCreatePipe("mypipe", 16U);
 80077d0:	2110      	movs	r1, #16
 80077d2:	4850      	ldr	r0, [pc, #320]	; (8007914 <oslib_test_005_006_execute.lto_priv.742+0x1a4>)
 80077d4:	f00c fd2c 	bl	8014230 <chFactoryCreatePipe>
 80077d8:	9002      	str	r0, [sp, #8]
    test_assert(dpp1 == NULL, "can create");
 80077da:	9b02      	ldr	r3, [sp, #8]
 80077dc:	2b00      	cmp	r3, #0
 80077de:	bf0c      	ite	eq
 80077e0:	2301      	moveq	r3, #1
 80077e2:	2300      	movne	r3, #0
 80077e4:	b2db      	uxtb	r3, r3
 80077e6:	494e      	ldr	r1, [pc, #312]	; (8007920 <oslib_test_005_006_execute.lto_priv.742+0x1b0>)
 80077e8:	4618      	mov	r0, r3
 80077ea:	f00d fe49 	bl	8015480 <_test_assert>
 80077ee:	4603      	mov	r3, r0
 80077f0:	2b00      	cmp	r3, #0
 80077f2:	f040 808a 	bne.w	800790a <oslib_test_005_006_execute.lto_priv.742+0x19a>
  }

  /* [5.6.4] Retrieving the dynamic pipe by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
 80077f6:	4b46      	ldr	r3, [pc, #280]	; (8007910 <oslib_test_005_006_execute.lto_priv.742+0x1a0>)
 80077f8:	2204      	movs	r2, #4
 80077fa:	601a      	str	r2, [r3, #0]
  {
    dyn_pipe_t *dpp1, *dpp2;

    dpp1 = chFactoryFindPipe("mypipe");
 80077fc:	4845      	ldr	r0, [pc, #276]	; (8007914 <oslib_test_005_006_execute.lto_priv.742+0x1a4>)
 80077fe:	f00c fd3f 	bl	8014280 <chFactoryFindPipe>
 8007802:	9001      	str	r0, [sp, #4]
    test_assert(dpp1 != NULL, "not found");
 8007804:	9b01      	ldr	r3, [sp, #4]
 8007806:	2b00      	cmp	r3, #0
 8007808:	bf14      	ite	ne
 800780a:	2301      	movne	r3, #1
 800780c:	2300      	moveq	r3, #0
 800780e:	b2db      	uxtb	r3, r3
 8007810:	4944      	ldr	r1, [pc, #272]	; (8007924 <oslib_test_005_006_execute.lto_priv.742+0x1b4>)
 8007812:	4618      	mov	r0, r3
 8007814:	f00d fe34 	bl	8015480 <_test_assert>
 8007818:	4603      	mov	r3, r0
 800781a:	2b00      	cmp	r3, #0
 800781c:	d175      	bne.n	800790a <oslib_test_005_006_execute.lto_priv.742+0x19a>
    test_assert(dpp == dpp1, "object reference mismatch");
 800781e:	9a03      	ldr	r2, [sp, #12]
 8007820:	9b01      	ldr	r3, [sp, #4]
 8007822:	429a      	cmp	r2, r3
 8007824:	bf0c      	ite	eq
 8007826:	2301      	moveq	r3, #1
 8007828:	2300      	movne	r3, #0
 800782a:	b2db      	uxtb	r3, r3
 800782c:	493e      	ldr	r1, [pc, #248]	; (8007928 <oslib_test_005_006_execute.lto_priv.742+0x1b8>)
 800782e:	4618      	mov	r0, r3
 8007830:	f00d fe26 	bl	8015480 <_test_assert>
 8007834:	4603      	mov	r3, r0
 8007836:	2b00      	cmp	r3, #0
 8007838:	d167      	bne.n	800790a <oslib_test_005_006_execute.lto_priv.742+0x19a>
    test_assert(dpp1->element.refs == 2, "object reference mismatch");
 800783a:	9b01      	ldr	r3, [sp, #4]
 800783c:	685b      	ldr	r3, [r3, #4]
 800783e:	2b02      	cmp	r3, #2
 8007840:	bf0c      	ite	eq
 8007842:	2301      	moveq	r3, #1
 8007844:	2300      	movne	r3, #0
 8007846:	b2db      	uxtb	r3, r3
 8007848:	4937      	ldr	r1, [pc, #220]	; (8007928 <oslib_test_005_006_execute.lto_priv.742+0x1b8>)
 800784a:	4618      	mov	r0, r3
 800784c:	f00d fe18 	bl	8015480 <_test_assert>
 8007850:	4603      	mov	r3, r0
 8007852:	2b00      	cmp	r3, #0
 8007854:	d159      	bne.n	800790a <oslib_test_005_006_execute.lto_priv.742+0x19a>

    dpp2 = (dyn_pipe_t *)chFactoryDuplicateReference(&dpp1->element);
 8007856:	9b01      	ldr	r3, [sp, #4]
 8007858:	4618      	mov	r0, r3
 800785a:	f7ff fa51 	bl	8006d00 <chFactoryDuplicateReference>
 800785e:	9000      	str	r0, [sp, #0]
    test_assert(dpp1 == dpp2, "object reference mismatch");
 8007860:	9a01      	ldr	r2, [sp, #4]
 8007862:	9b00      	ldr	r3, [sp, #0]
 8007864:	429a      	cmp	r2, r3
 8007866:	bf0c      	ite	eq
 8007868:	2301      	moveq	r3, #1
 800786a:	2300      	movne	r3, #0
 800786c:	b2db      	uxtb	r3, r3
 800786e:	492e      	ldr	r1, [pc, #184]	; (8007928 <oslib_test_005_006_execute.lto_priv.742+0x1b8>)
 8007870:	4618      	mov	r0, r3
 8007872:	f00d fe05 	bl	8015480 <_test_assert>
 8007876:	4603      	mov	r3, r0
 8007878:	2b00      	cmp	r3, #0
 800787a:	d146      	bne.n	800790a <oslib_test_005_006_execute.lto_priv.742+0x19a>
    test_assert(dpp2->element.refs == 3, "object reference mismatch");
 800787c:	9b00      	ldr	r3, [sp, #0]
 800787e:	685b      	ldr	r3, [r3, #4]
 8007880:	2b03      	cmp	r3, #3
 8007882:	bf0c      	ite	eq
 8007884:	2301      	moveq	r3, #1
 8007886:	2300      	movne	r3, #0
 8007888:	b2db      	uxtb	r3, r3
 800788a:	4927      	ldr	r1, [pc, #156]	; (8007928 <oslib_test_005_006_execute.lto_priv.742+0x1b8>)
 800788c:	4618      	mov	r0, r3
 800788e:	f00d fdf7 	bl	8015480 <_test_assert>
 8007892:	4603      	mov	r3, r0
 8007894:	2b00      	cmp	r3, #0
 8007896:	d138      	bne.n	800790a <oslib_test_005_006_execute.lto_priv.742+0x19a>

    chFactoryReleasePipe(dpp2);
 8007898:	9800      	ldr	r0, [sp, #0]
 800789a:	f00c fd09 	bl	80142b0 <chFactoryReleasePipe>
    test_assert(dpp1->element.refs == 2, "references mismatch");
 800789e:	9b01      	ldr	r3, [sp, #4]
 80078a0:	685b      	ldr	r3, [r3, #4]
 80078a2:	2b02      	cmp	r3, #2
 80078a4:	bf0c      	ite	eq
 80078a6:	2301      	moveq	r3, #1
 80078a8:	2300      	movne	r3, #0
 80078aa:	b2db      	uxtb	r3, r3
 80078ac:	491f      	ldr	r1, [pc, #124]	; (800792c <oslib_test_005_006_execute.lto_priv.742+0x1bc>)
 80078ae:	4618      	mov	r0, r3
 80078b0:	f00d fde6 	bl	8015480 <_test_assert>
 80078b4:	4603      	mov	r3, r0
 80078b6:	2b00      	cmp	r3, #0
 80078b8:	d127      	bne.n	800790a <oslib_test_005_006_execute.lto_priv.742+0x19a>

    chFactoryReleasePipe(dpp1);
 80078ba:	9801      	ldr	r0, [sp, #4]
 80078bc:	f00c fcf8 	bl	80142b0 <chFactoryReleasePipe>
    test_assert(dpp->element.refs == 1, "references mismatch");
 80078c0:	9b03      	ldr	r3, [sp, #12]
 80078c2:	685b      	ldr	r3, [r3, #4]
 80078c4:	2b01      	cmp	r3, #1
 80078c6:	bf0c      	ite	eq
 80078c8:	2301      	moveq	r3, #1
 80078ca:	2300      	movne	r3, #0
 80078cc:	b2db      	uxtb	r3, r3
 80078ce:	4917      	ldr	r1, [pc, #92]	; (800792c <oslib_test_005_006_execute.lto_priv.742+0x1bc>)
 80078d0:	4618      	mov	r0, r3
 80078d2:	f00d fdd5 	bl	8015480 <_test_assert>
 80078d6:	4603      	mov	r3, r0
 80078d8:	2b00      	cmp	r3, #0
 80078da:	d116      	bne.n	800790a <oslib_test_005_006_execute.lto_priv.742+0x19a>
  }

  /* [5.6.5] Releasing the first reference to the dynamic pipe must not
     trigger an assertion.*/
  test_set_step(5);
 80078dc:	4b0c      	ldr	r3, [pc, #48]	; (8007910 <oslib_test_005_006_execute.lto_priv.742+0x1a0>)
 80078de:	2205      	movs	r2, #5
 80078e0:	601a      	str	r2, [r3, #0]
  {
    chFactoryReleasePipe(dpp);
 80078e2:	9803      	ldr	r0, [sp, #12]
 80078e4:	f00c fce4 	bl	80142b0 <chFactoryReleasePipe>
  }

  /* [5.6.6] Retrieving the dynamic pipe by name again, must not
     exist.*/
  test_set_step(6);
 80078e8:	4b09      	ldr	r3, [pc, #36]	; (8007910 <oslib_test_005_006_execute.lto_priv.742+0x1a0>)
 80078ea:	2206      	movs	r2, #6
 80078ec:	601a      	str	r2, [r3, #0]
  {
    dpp = chFactoryFindPipe("mypipe");
 80078ee:	4809      	ldr	r0, [pc, #36]	; (8007914 <oslib_test_005_006_execute.lto_priv.742+0x1a4>)
 80078f0:	f00c fcc6 	bl	8014280 <chFactoryFindPipe>
 80078f4:	9003      	str	r0, [sp, #12]
    test_assert(dpp == NULL, "found");
 80078f6:	9b03      	ldr	r3, [sp, #12]
 80078f8:	2b00      	cmp	r3, #0
 80078fa:	bf0c      	ite	eq
 80078fc:	2301      	moveq	r3, #1
 80078fe:	2300      	movne	r3, #0
 8007900:	b2db      	uxtb	r3, r3
 8007902:	4905      	ldr	r1, [pc, #20]	; (8007918 <oslib_test_005_006_execute.lto_priv.742+0x1a8>)
 8007904:	4618      	mov	r0, r3
 8007906:	f00d fdbb 	bl	8015480 <_test_assert>
  }
}
 800790a:	b005      	add	sp, #20
 800790c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007910:	20001988 	.word	0x20001988
 8007914:	08018b14 	.word	0x08018b14
 8007918:	08018a40 	.word	0x08018a40
 800791c:	08018aa0 	.word	0x08018aa0
 8007920:	08018ab0 	.word	0x08018ab0
 8007924:	08018a3c 	.word	0x08018a3c
 8007928:	08018a58 	.word	0x08018a58
 800792c:	08018a74 	.word	0x08018a74

08007930 <cmd_write>:
/*===========================================================================*/



/* Can be measured using dd if=/dev/xxxx of=/dev/null bs=512 count=10000.*/
void cmd_write(BaseSequentialStream *chp, int argc, char *argv[]) {
 8007930:	b500      	push	{lr}
 8007932:	b085      	sub	sp, #20
 8007934:	9003      	str	r0, [sp, #12]
 8007936:	9102      	str	r1, [sp, #8]
 8007938:	9201      	str	r2, [sp, #4]
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";

  (void)argv;
  if (argc > 0) {
 800793a:	9b02      	ldr	r3, [sp, #8]
 800793c:	2b00      	cmp	r3, #0
 800793e:	dd0c      	ble.n	800795a <cmd_write+0x2a>
    chprintf(chp, "Usage: write\r\n");
 8007940:	490e      	ldr	r1, [pc, #56]	; (800797c <cmd_write+0x4c>)
 8007942:	9803      	ldr	r0, [sp, #12]
 8007944:	f00c ffc4 	bl	80148d0 <chprintf>
 8007948:	e015      	b.n	8007976 <cmd_write+0x46>
  }

  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
#if 1
    /* Writing in channel mode.*/
    chnWrite(&SDU1, buf, sizeof buf - 1);
 800794a:	4b0d      	ldr	r3, [pc, #52]	; (8007980 <cmd_write+0x50>)
 800794c:	681b      	ldr	r3, [r3, #0]
 800794e:	685b      	ldr	r3, [r3, #4]
 8007950:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8007954:	490b      	ldr	r1, [pc, #44]	; (8007984 <cmd_write+0x54>)
 8007956:	480a      	ldr	r0, [pc, #40]	; (8007980 <cmd_write+0x50>)
 8007958:	4798      	blx	r3
  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
 800795a:	9b03      	ldr	r3, [sp, #12]
 800795c:	681b      	ldr	r3, [r3, #0]
 800795e:	699b      	ldr	r3, [r3, #24]
 8007960:	2100      	movs	r1, #0
 8007962:	9803      	ldr	r0, [sp, #12]
 8007964:	4798      	blx	r3
 8007966:	4603      	mov	r3, r0
 8007968:	f1b3 3fff 	cmp.w	r3, #4294967295
 800796c:	d0ed      	beq.n	800794a <cmd_write+0x1a>
    (void) obqGetEmptyBufferTimeout(&SDU1.obqueue, TIME_INFINITE);
    memcpy(SDU1.obqueue.ptr, buf, SERIAL_USB_BUFFERS_SIZE);
    obqPostFullBuffer(&SDU1.obqueue, SERIAL_USB_BUFFERS_SIZE);
#endif
  }
  chprintf(chp, "\r\n\nstopped\r\n");
 800796e:	4906      	ldr	r1, [pc, #24]	; (8007988 <cmd_write+0x58>)
 8007970:	9803      	ldr	r0, [sp, #12]
 8007972:	f00c ffad 	bl	80148d0 <chprintf>
}
 8007976:	b005      	add	sp, #20
 8007978:	f85d fb04 	ldr.w	pc, [sp], #4
 800797c:	08018b50 	.word	0x08018b50
 8007980:	20002178 	.word	0x20002178
 8007984:	20000924 	.word	0x20000924
 8007988:	08018b60 	.word	0x08018b60
 800798c:	00000000 	.word	0x00000000

08007990 <cmd_led>:

void cmd_led(BaseSequentialStream *chp, int argc, char *argv[])
{
 8007990:	b500      	push	{lr}
 8007992:	b085      	sub	sp, #20
 8007994:	9003      	str	r0, [sp, #12]
 8007996:	9102      	str	r1, [sp, #8]
 8007998:	9201      	str	r2, [sp, #4]
  (void)argv;
   if (argc > 0) {
 800799a:	9b02      	ldr	r3, [sp, #8]
 800799c:	2b00      	cmp	r3, #0
 800799e:	dd04      	ble.n	80079aa <cmd_led+0x1a>
     chprintf(chp, "Usage: led\r\n Will Toggle the RED LED \r\n");
 80079a0:	4906      	ldr	r1, [pc, #24]	; (80079bc <cmd_led+0x2c>)
 80079a2:	9803      	ldr	r0, [sp, #12]
 80079a4:	f00c ff94 	bl	80148d0 <chprintf>
 80079a8:	e005      	b.n	80079b6 <cmd_led+0x26>
     return;
   }
   palToggleLine(LINE_LED6);
 80079aa:	4b05      	ldr	r3, [pc, #20]	; (80079c0 <cmd_led+0x30>)
 80079ac:	695b      	ldr	r3, [r3, #20]
 80079ae:	4a04      	ldr	r2, [pc, #16]	; (80079c0 <cmd_led+0x30>)
 80079b0:	f483 4300 	eor.w	r3, r3, #32768	; 0x8000
 80079b4:	6153      	str	r3, [r2, #20]
}
 80079b6:	b005      	add	sp, #20
 80079b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80079bc:	08018b70 	.word	0x08018b70
 80079c0:	40020c00 	.word	0x40020c00
	...

080079d0 <cmd_spi>:

#define TEST TETA

void cmd_spi(BaseSequentialStream *chp, int argc, char *argv[])
{
 80079d0:	b500      	push	{lr}
 80079d2:	b085      	sub	sp, #20
 80079d4:	9003      	str	r0, [sp, #12]
 80079d6:	9102      	str	r1, [sp, #8]
 80079d8:	9201      	str	r2, [sp, #4]
  (void)argv;
   if (argc > 0) {
 80079da:	9b02      	ldr	r3, [sp, #8]
 80079dc:	2b00      	cmp	r3, #0
 80079de:	dd04      	ble.n	80079ea <cmd_spi+0x1a>
     chprintf(chp, "Usage: led\r\n Will Send a SPI frame  \r\n");
 80079e0:	4908      	ldr	r1, [pc, #32]	; (8007a04 <cmd_spi+0x34>)
 80079e2:	9803      	ldr	r0, [sp, #12]
 80079e4:	f00c ff74 	bl	80148d0 <chprintf>
 80079e8:	e009      	b.n	80079fe <cmd_spi+0x2e>
     return;
   }
  //basicSpiInitFrame();
   basicSpiComTest();
 80079ea:	f000 fd41 	bl	8008470 <basicSpiComTest>
   test();
 80079ee:	f000 fd37 	bl	8008460 <test>
   sdPutTimeout(&SD2, (int8_t)'t',TIME_MS2I(50));
 80079f2:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80079f6:	2174      	movs	r1, #116	; 0x74
 80079f8:	4803      	ldr	r0, [pc, #12]	; (8007a08 <cmd_spi+0x38>)
 80079fa:	f002 f871 	bl	8009ae0 <oqPutTimeout>
}
 80079fe:	b005      	add	sp, #20
 8007a00:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a04:	08018b98 	.word	0x08018b98
 8007a08:	20000f68 	.word	0x20000f68
 8007a0c:	00000000 	.word	0x00000000

08007a10 <port_lock.lto_priv.27>:
static inline void port_lock(void) {
 8007a10:	b082      	sub	sp, #8
 8007a12:	2320      	movs	r3, #32
 8007a14:	9301      	str	r3, [sp, #4]
 8007a16:	9b01      	ldr	r3, [sp, #4]
 8007a18:	f383 8811 	msr	BASEPRI, r3
}
 8007a1c:	b002      	add	sp, #8
 8007a1e:	4770      	bx	lr

08007a20 <port_unlock.lto_priv.17>:
static inline void port_unlock(void) {
 8007a20:	b082      	sub	sp, #8
 8007a22:	2300      	movs	r3, #0
 8007a24:	9301      	str	r3, [sp, #4]
 8007a26:	9b01      	ldr	r3, [sp, #4]
 8007a28:	f383 8811 	msr	BASEPRI, r3
}
 8007a2c:	b002      	add	sp, #8
 8007a2e:	4770      	bx	lr

08007a30 <port_lock_from_isr.lto_priv.7>:
static inline void port_lock_from_isr(void) {
 8007a30:	b508      	push	{r3, lr}
  port_lock();
 8007a32:	f7ff ffed 	bl	8007a10 <port_lock.lto_priv.27>
}
 8007a36:	bd08      	pop	{r3, pc}
	...

08007a40 <port_unlock_from_isr.lto_priv.5>:
static inline void port_unlock_from_isr(void) {
 8007a40:	b508      	push	{r3, lr}
  port_unlock();
 8007a42:	f7ff ffed 	bl	8007a20 <port_unlock.lto_priv.17>
}
 8007a46:	bd08      	pop	{r3, pc}
	...

08007a50 <chSysLockFromISR.lto_priv.3>:
static inline void chSysLockFromISR(void) {
 8007a50:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8007a52:	f7ff ffed 	bl	8007a30 <port_lock_from_isr.lto_priv.7>
  _dbg_check_lock_from_isr();
 8007a56:	f007 fc63 	bl	800f320 <_dbg_check_lock_from_isr>
}
 8007a5a:	bd08      	pop	{r3, pc}
 8007a5c:	0000      	movs	r0, r0
	...

08007a60 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
 8007a60:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8007a62:	f007 fc75 	bl	800f350 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8007a66:	f7ff ffeb 	bl	8007a40 <port_unlock_from_isr.lto_priv.5>
}
 8007a6a:	bd08      	pop	{r3, pc}
 8007a6c:	0000      	movs	r0, r0
	...

08007a70 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8007a70:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8007a72:	f7ff ffed 	bl	8007a50 <chSysLockFromISR.lto_priv.3>
}
 8007a76:	bd08      	pop	{r3, pc}
	...

08007a80 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8007a80:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8007a82:	f7ff ffed 	bl	8007a60 <chSysUnlockFromISR.lto_priv.1>
}
 8007a86:	bd08      	pop	{r3, pc}
	...

08007a90 <get_descriptor>:
 * handled here.
 */
static const USBDescriptor *get_descriptor(USBDriver *usbp,
                                           uint8_t dtype,
                                           uint8_t dindex,
                                           uint16_t lang) {
 8007a90:	b082      	sub	sp, #8
 8007a92:	9001      	str	r0, [sp, #4]
 8007a94:	4608      	mov	r0, r1
 8007a96:	4611      	mov	r1, r2
 8007a98:	461a      	mov	r2, r3
 8007a9a:	4603      	mov	r3, r0
 8007a9c:	f88d 3003 	strb.w	r3, [sp, #3]
 8007aa0:	460b      	mov	r3, r1
 8007aa2:	f88d 3002 	strb.w	r3, [sp, #2]
 8007aa6:	4613      	mov	r3, r2
 8007aa8:	f8ad 3000 	strh.w	r3, [sp]

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8007aac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007ab0:	2b02      	cmp	r3, #2
 8007ab2:	d005      	beq.n	8007ac0 <get_descriptor+0x30>
 8007ab4:	2b03      	cmp	r3, #3
 8007ab6:	d005      	beq.n	8007ac4 <get_descriptor+0x34>
 8007ab8:	2b01      	cmp	r3, #1
 8007aba:	d10d      	bne.n	8007ad8 <get_descriptor+0x48>
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
 8007abc:	4b08      	ldr	r3, [pc, #32]	; (8007ae0 <get_descriptor+0x50>)
 8007abe:	e00c      	b.n	8007ada <get_descriptor+0x4a>
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
 8007ac0:	4b08      	ldr	r3, [pc, #32]	; (8007ae4 <get_descriptor+0x54>)
 8007ac2:	e00a      	b.n	8007ada <get_descriptor+0x4a>
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8007ac4:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8007ac8:	2b03      	cmp	r3, #3
 8007aca:	d805      	bhi.n	8007ad8 <get_descriptor+0x48>
      return &vcom_strings[dindex];
 8007acc:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8007ad0:	00db      	lsls	r3, r3, #3
 8007ad2:	4a05      	ldr	r2, [pc, #20]	; (8007ae8 <get_descriptor+0x58>)
 8007ad4:	4413      	add	r3, r2
 8007ad6:	e000      	b.n	8007ada <get_descriptor+0x4a>
  }
  return NULL;
 8007ad8:	2300      	movs	r3, #0
}
 8007ada:	4618      	mov	r0, r3
 8007adc:	b002      	add	sp, #8
 8007ade:	4770      	bx	lr
 8007ae0:	08018bfc 	.word	0x08018bfc
 8007ae4:	08018c48 	.word	0x08018c48
 8007ae8:	08018cbc 	.word	0x08018cbc
 8007aec:	00000000 	.word	0x00000000

08007af0 <usb_event>:
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8007af0:	b500      	push	{lr}
 8007af2:	b083      	sub	sp, #12
 8007af4:	9001      	str	r0, [sp, #4]
 8007af6:	460b      	mov	r3, r1
 8007af8:	f88d 3003 	strb.w	r3, [sp, #3]
  extern SerialUSBDriver SDU1;

  switch (event) {
 8007afc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007b00:	2b06      	cmp	r3, #6
 8007b02:	d832      	bhi.n	8007b6a <usb_event+0x7a>
 8007b04:	a201      	add	r2, pc, #4	; (adr r2, 8007b0c <usb_event+0x1c>)
 8007b06:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007b0a:	bf00      	nop
 8007b0c:	08007b4d 	.word	0x08007b4d
 8007b10:	08007b6b 	.word	0x08007b6b
 8007b14:	08007b29 	.word	0x08007b29
 8007b18:	08007b4d 	.word	0x08007b4d
 8007b1c:	08007b4d 	.word	0x08007b4d
 8007b20:	08007b5d 	.word	0x08007b5d
 8007b24:	08007b6b 	.word	0x08007b6b
  case USB_EVENT_ADDRESS:
    return;
  case USB_EVENT_CONFIGURED:
    chSysLockFromISR();
 8007b28:	f7ff ff92 	bl	8007a50 <chSysLockFromISR.lto_priv.3>

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USB1_DATA_REQUEST_EP, &ep1config);
 8007b2c:	4a10      	ldr	r2, [pc, #64]	; (8007b70 <usb_event+0x80>)
 8007b2e:	2101      	movs	r1, #1
 8007b30:	9801      	ldr	r0, [sp, #4]
 8007b32:	f003 fc6d 	bl	800b410 <usbInitEndpointI>
    usbInitEndpointI(usbp, USB1_INTERRUPT_REQUEST_EP, &ep2config);
 8007b36:	4a0f      	ldr	r2, [pc, #60]	; (8007b74 <usb_event+0x84>)
 8007b38:	2102      	movs	r1, #2
 8007b3a:	9801      	ldr	r0, [sp, #4]
 8007b3c:	f003 fc68 	bl	800b410 <usbInitEndpointI>

    /* Resetting the state of the CDC subsystem.*/
    sduConfigureHookI(&SDU1);
 8007b40:	480d      	ldr	r0, [pc, #52]	; (8007b78 <usb_event+0x88>)
 8007b42:	f002 fe65 	bl	800a810 <sduConfigureHookI>

    chSysUnlockFromISR();
 8007b46:	f7ff ff8b 	bl	8007a60 <chSysUnlockFromISR.lto_priv.1>
 8007b4a:	e00e      	b.n	8007b6a <usb_event+0x7a>
  case USB_EVENT_RESET:
    /* Falls into.*/
  case USB_EVENT_UNCONFIGURED:
    /* Falls into.*/
  case USB_EVENT_SUSPEND:
    chSysLockFromISR();
 8007b4c:	f7ff ff80 	bl	8007a50 <chSysLockFromISR.lto_priv.3>

    /* Disconnection event on suspend.*/
    sduSuspendHookI(&SDU1);
 8007b50:	4809      	ldr	r0, [pc, #36]	; (8007b78 <usb_event+0x88>)
 8007b52:	f002 fe15 	bl	800a780 <sduSuspendHookI>

    chSysUnlockFromISR();
 8007b56:	f7ff ff83 	bl	8007a60 <chSysUnlockFromISR.lto_priv.1>
 8007b5a:	e006      	b.n	8007b6a <usb_event+0x7a>
    return;
  case USB_EVENT_WAKEUP:
    chSysLockFromISR();
 8007b5c:	f7ff ff78 	bl	8007a50 <chSysLockFromISR.lto_priv.3>

    /* Connection event on wakeup.*/
    sduWakeupHookI(&SDU1);
 8007b60:	4805      	ldr	r0, [pc, #20]	; (8007b78 <usb_event+0x88>)
 8007b62:	f002 fe3d 	bl	800a7e0 <sduWakeupHookI>

    chSysUnlockFromISR();
 8007b66:	f7ff ff7b 	bl	8007a60 <chSysUnlockFromISR.lto_priv.1>
    return;
  case USB_EVENT_STALLED:
    return;
  }
  return;
}
 8007b6a:	b003      	add	sp, #12
 8007b6c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007b70:	08018cdc 	.word	0x08018cdc
 8007b74:	08018d00 	.word	0x08018d00
 8007b78:	20002178 	.word	0x20002178
 8007b7c:	00000000 	.word	0x00000000

08007b80 <sof_handler>:

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 8007b80:	b500      	push	{lr}
 8007b82:	b083      	sub	sp, #12
 8007b84:	9001      	str	r0, [sp, #4]

  (void)usbp;

  osalSysLockFromISR();
 8007b86:	f7ff ff73 	bl	8007a70 <osalSysLockFromISR>
  sduSOFHookI(&SDU1);
 8007b8a:	4804      	ldr	r0, [pc, #16]	; (8007b9c <sof_handler+0x1c>)
 8007b8c:	f002 fea0 	bl	800a8d0 <sduSOFHookI>
  osalSysUnlockFromISR();
 8007b90:	f7ff ff76 	bl	8007a80 <osalSysUnlockFromISR>
}
 8007b94:	b003      	add	sp, #12
 8007b96:	f85d fb04 	ldr.w	pc, [sp], #4
 8007b9a:	bf00      	nop
 8007b9c:	20002178 	.word	0x20002178

08007ba0 <_ZN8IcHausMuC1Eh>:

#include "IcHausMu.hpp"

// ############################### Constructors ###############################

IcHausMu::IcHausMu(const unsigned char hwRev)
 8007ba0:	b500      	push	{lr}
 8007ba2:	b083      	sub	sp, #12
 8007ba4:	9001      	str	r0, [sp, #4]
 8007ba6:	460b      	mov	r3, r1
 8007ba8:	f88d 3003 	strb.w	r3, [sp, #3]
 8007bac:	9b01      	ldr	r3, [sp, #4]
 8007bae:	4a20      	ldr	r2, [pc, #128]	; (8007c30 <_ZN8IcHausMuC1Eh+0x90>)
 8007bb0:	3301      	adds	r3, #1
 8007bb2:	4611      	mov	r1, r2
 8007bb4:	227f      	movs	r2, #127	; 0x7f
 8007bb6:	4618      	mov	r0, r3
 8007bb8:	f7f8 fbac 	bl	8000314 <memcpy>
 8007bbc:	9b01      	ldr	r3, [sp, #4]
 8007bbe:	4a1d      	ldr	r2, [pc, #116]	; (8007c34 <_ZN8IcHausMuC1Eh+0x94>)
 8007bc0:	3380      	adds	r3, #128	; 0x80
 8007bc2:	4611      	mov	r1, r2
 8007bc4:	227f      	movs	r2, #127	; 0x7f
 8007bc6:	4618      	mov	r0, r3
 8007bc8:	f7f8 fba4 	bl	8000314 <memcpy>
//  : _address(0x00) // can be used to initialize as list method
{
    debugVal = 0;
 8007bcc:	9b01      	ldr	r3, [sp, #4]
 8007bce:	2200      	movs	r2, #0
 8007bd0:	701a      	strb	r2, [r3, #0]
    _tmpBuff64.dwords.msb.dword = 0x00000000;
 8007bd2:	9b01      	ldr	r3, [sp, #4]
 8007bd4:	2200      	movs	r2, #0
 8007bd6:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    _tmpBuff64.dwords.lsb.dword = 0x00000000;
 8007bda:	9b01      	ldr	r3, [sp, #4]
 8007bdc:	2200      	movs	r2, #0
 8007bde:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    _address = 0x00;
 8007be2:	9b01      	ldr	r3, [sp, #4]
 8007be4:	2200      	movs	r2, #0
 8007be6:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
    _hardRev = hwRev;
 8007bea:	9b01      	ldr	r3, [sp, #4]
 8007bec:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007bf0:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
    _csFct_ptr = NULL;
 8007bf4:	9b01      	ldr	r3, [sp, #4]
 8007bf6:	2200      	movs	r2, #0
 8007bf8:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    _streamFct_ptr = NULL;
 8007bfc:	9b01      	ldr	r3, [sp, #4]
 8007bfe:	2200      	movs	r2, #0
 8007c00:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    _initStatus = RET_W_UNINIT;
 8007c04:	9b01      	ldr	r3, [sp, #4]
 8007c06:	220a      	movs	r2, #10
 8007c08:	f883 210d 	strb.w	r2, [r3, #269]	; 0x10d
    _sdadOutMsb = 0;
 8007c0c:	9b01      	ldr	r3, [sp, #4]
 8007c0e:	2200      	movs	r2, #0
 8007c10:	f883 210a 	strb.w	r2, [r3, #266]	; 0x10a
    _sdadOutLsb = 0;
 8007c14:	9b01      	ldr	r3, [sp, #4]
 8007c16:	2200      	movs	r2, #0
 8007c18:	f883 210b 	strb.w	r2, [r3, #267]	; 0x10b
    _sdadOutSize = 1;
 8007c1c:	9b01      	ldr	r3, [sp, #4]
 8007c1e:	2201      	movs	r2, #1
 8007c20:	f883 210c 	strb.w	r2, [r3, #268]	; 0x10c
}
 8007c24:	9b01      	ldr	r3, [sp, #4]
 8007c26:	4618      	mov	r0, r3
 8007c28:	b003      	add	sp, #12
 8007c2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8007c2e:	bf00      	nop
 8007c30:	080159d0 	.word	0x080159d0
 8007c34:	08015a50 	.word	0x08015a50
	...

08007c40 <_ZN8IcHausMu16csFunctionAttachEPFvbE>:

// ############################### Public Methods ###############################

// ---------------- low level functions ----------------

void IcHausMu::csFunctionAttach(void (*fct_ptr)(const bool)) {
 8007c40:	b082      	sub	sp, #8
 8007c42:	9001      	str	r0, [sp, #4]
 8007c44:	9100      	str	r1, [sp, #0]
    _csFct_ptr = fct_ptr;
 8007c46:	9b01      	ldr	r3, [sp, #4]
 8007c48:	9a00      	ldr	r2, [sp, #0]
 8007c4a:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
 8007c4e:	b002      	add	sp, #8
 8007c50:	4770      	bx	lr
 8007c52:	bf00      	nop
	...

08007c60 <_ZN8IcHausMu20streamFunctionAttachEPFvPhS0_jE>:

void IcHausMu::streamFunctionAttach(void (*fct_ptr)(unsigned char* const, unsigned char*, const unsigned int)) {
 8007c60:	b082      	sub	sp, #8
 8007c62:	9001      	str	r0, [sp, #4]
 8007c64:	9100      	str	r1, [sp, #0]
    _streamFct_ptr = fct_ptr;
 8007c66:	9b01      	ldr	r3, [sp, #4]
 8007c68:	9a00      	ldr	r2, [sp, #0]
 8007c6a:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
 8007c6e:	b002      	add	sp, #8
 8007c70:	4770      	bx	lr
 8007c72:	bf00      	nop
	...

08007c80 <_ZN8IcHausMu11icMuRegSizeE12icMuRegister>:

unsigned char IcHausMu::getIcMuMask(const icMuRegister_t reg) {
    return _icMuRegisterMask[reg];
}

unsigned char IcHausMu::icMuRegSize(const icMuRegister_t reg) {
 8007c80:	b084      	sub	sp, #16
 8007c82:	9001      	str	r0, [sp, #4]
 8007c84:	460b      	mov	r3, r1
 8007c86:	f88d 3003 	strb.w	r3, [sp, #3]
    unsigned char tmpVal = 0;
 8007c8a:	2300      	movs	r3, #0
 8007c8c:	f88d 300f 	strb.w	r3, [sp, #15]

    tmpVal = _icMuRegisterMask[reg];                    // this tab contains masks and register unions size (x), identified by 0x8x (x!=0, mask must be contiguous by definition)
 8007c90:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c94:	9a01      	ldr	r2, [sp, #4]
 8007c96:	4413      	add	r3, r2
 8007c98:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8007c9c:	f88d 300f 	strb.w	r3, [sp, #15]
    if (0x80<tmpVal && 0x90>tmpVal) {tmpVal &= 0x0F;}   // the union size is returned.
 8007ca0:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007ca4:	2b80      	cmp	r3, #128	; 0x80
 8007ca6:	d90a      	bls.n	8007cbe <_ZN8IcHausMu11icMuRegSizeE12icMuRegister+0x3e>
 8007ca8:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007cac:	2b8f      	cmp	r3, #143	; 0x8f
 8007cae:	d806      	bhi.n	8007cbe <_ZN8IcHausMu11icMuRegSizeE12icMuRegister+0x3e>
 8007cb0:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007cb4:	f003 030f 	and.w	r3, r3, #15
 8007cb8:	f88d 300f 	strb.w	r3, [sp, #15]
 8007cbc:	e002      	b.n	8007cc4 <_ZN8IcHausMu11icMuRegSizeE12icMuRegister+0x44>
    else {tmpVal = 1;}                                  // single register, size = 1
 8007cbe:	2301      	movs	r3, #1
 8007cc0:	f88d 300f 	strb.w	r3, [sp, #15]
    return tmpVal;
 8007cc4:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8007cc8:	4618      	mov	r0, r3
 8007cca:	b004      	add	sp, #16
 8007ccc:	4770      	bx	lr
 8007cce:	bf00      	nop

08007cd0 <_ZN8IcHausMu16getLastByteValueEv>:

unsigned char IcHausMu::getLastByteValue(void) {
 8007cd0:	b082      	sub	sp, #8
 8007cd2:	9001      	str	r0, [sp, #4]
    return _tmpBuff64.bytes_le.lsb;
 8007cd4:	9b01      	ldr	r3, [sp, #4]
 8007cd6:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
}
 8007cda:	4618      	mov	r0, r3
 8007cdc:	b002      	add	sp, #8
 8007cde:	4770      	bx	lr

08007ce0 <_ZN8IcHausMu19getLastUint_16ValueEv>:

uint16_u IcHausMu::getLastUint_16Value(void) {
 8007ce0:	b084      	sub	sp, #16
 8007ce2:	9001      	str	r0, [sp, #4]
    uint16_u tmp;
    tmp.bytes.msb = _tmpBuff64.bytes_le.byte1;
 8007ce4:	9b01      	ldr	r3, [sp, #4]
 8007ce6:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8007cea:	f88d 300c 	strb.w	r3, [sp, #12]
    tmp.bytes.lsb = _tmpBuff64.bytes_le.lsb;
 8007cee:	9b01      	ldr	r3, [sp, #4]
 8007cf0:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 8007cf4:	f88d 300d 	strb.w	r3, [sp, #13]
    return tmp;
 8007cf8:	f8bd 300c 	ldrh.w	r3, [sp, #12]
}
 8007cfc:	4618      	mov	r0, r3
 8007cfe:	b004      	add	sp, #16
 8007d00:	4770      	bx	lr
 8007d02:	bf00      	nop
	...

08007d10 <_ZN8IcHausMu16readIcMuRegisterE12icMuRegister>:
    tmp.bytes.byte1 = _tmpBuff64.bytes_le.byte1;
    tmp.bytes.lsb   = _tmpBuff64.bytes_le.lsb;
    return tmp;
}

fctStatus IcHausMu::readIcMuRegister(const icMuRegister_t reg) {
 8007d10:	b500      	push	{lr}
 8007d12:	b085      	sub	sp, #20
 8007d14:	9001      	str	r0, [sp, #4]
 8007d16:	460b      	mov	r3, r1
 8007d18:	f88d 3003 	strb.w	r3, [sp, #3]
    // trig a reading. Value can be accessed through the getLastValue functions
    fctStatus retVal = RET_OK;
 8007d1c:	2300      	movs	r3, #0
 8007d1e:	f88d 300f 	strb.w	r3, [sp, #15]

    _tmpBuff64.dwords.msb.dword = 0x00000000;
 8007d22:	9b01      	ldr	r3, [sp, #4]
 8007d24:	2200      	movs	r2, #0
 8007d26:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    _tmpBuff64.dwords.lsb.dword = 0x00000000;
 8007d2a:	9b01      	ldr	r3, [sp, #4]
 8007d2c:	2200      	movs	r2, #0
 8007d2e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

    retVal = readIcMuRegister_leu(reg, &_tmpBuff64);
 8007d32:	9b01      	ldr	r3, [sp, #4]
 8007d34:	f503 7280 	add.w	r2, r3, #256	; 0x100
 8007d38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d3c:	4619      	mov	r1, r3
 8007d3e:	9801      	ldr	r0, [sp, #4]
 8007d40:	f000 f80e 	bl	8007d60 <_ZN8IcHausMu20readIcMuRegister_leuE12icMuRegisterP10uint64_leu>
 8007d44:	4603      	mov	r3, r0
 8007d46:	f88d 300f 	strb.w	r3, [sp, #15]

    return retVal;
 8007d4a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8007d4e:	4618      	mov	r0, r3
 8007d50:	b005      	add	sp, #20
 8007d52:	f85d fb04 	ldr.w	pc, [sp], #4
 8007d56:	bf00      	nop
	...

08007d60 <_ZN8IcHausMu20readIcMuRegister_leuE12icMuRegisterP10uint64_leu>:

fctStatus IcHausMu::readIcMuRegister_leu(const icMuRegister_t reg, uint64_leu* buffPtr) {
 8007d60:	b500      	push	{lr}
 8007d62:	b087      	sub	sp, #28
 8007d64:	9003      	str	r0, [sp, #12]
 8007d66:	460b      	mov	r3, r1
 8007d68:	9201      	str	r2, [sp, #4]
 8007d6a:	f88d 300b 	strb.w	r3, [sp, #11]
    unsigned char regSize = 0;
 8007d6e:	2300      	movs	r3, #0
 8007d70:	f88d 3016 	strb.w	r3, [sp, #22]
    unsigned char tmpRegAddr = 0;
 8007d74:	2300      	movs	r3, #0
 8007d76:	f88d 3017 	strb.w	r3, [sp, #23]
    fctStatus retVal = RET_OK;
 8007d7a:	2300      	movs	r3, #0
 8007d7c:	f88d 3015 	strb.w	r3, [sp, #21]

    regSize = icMuRegSize(reg);
 8007d80:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8007d84:	4619      	mov	r1, r3
 8007d86:	9803      	ldr	r0, [sp, #12]
 8007d88:	f7ff ff7a 	bl	8007c80 <_ZN8IcHausMu11icMuRegSizeE12icMuRegister>
 8007d8c:	4603      	mov	r3, r0
 8007d8e:	f88d 3016 	strb.w	r3, [sp, #22]
    if (1 < regSize) {
 8007d92:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007d96:	2b01      	cmp	r3, #1
 8007d98:	d905      	bls.n	8007da6 <_ZN8IcHausMu20readIcMuRegister_leuE12icMuRegisterP10uint64_leu+0x46>
        // The icMuRegister is an union. Point to the 1st union element (LSB).
        tmpRegAddr = reg+1;
 8007d9a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8007d9e:	3301      	adds	r3, #1
 8007da0:	f88d 3017 	strb.w	r3, [sp, #23]
 8007da4:	e003      	b.n	8007dae <_ZN8IcHausMu20readIcMuRegister_leuE12icMuRegisterP10uint64_leu+0x4e>
    }
    else {
        tmpRegAddr = reg;
 8007da6:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8007daa:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    retVal = _readRegister(_icMuRegisterAddress[tmpRegAddr], regSize, buffPtr->tab);
 8007dae:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8007db2:	9a03      	ldr	r2, [sp, #12]
 8007db4:	4413      	add	r3, r2
 8007db6:	7859      	ldrb	r1, [r3, #1]
 8007db8:	f89d 2016 	ldrb.w	r2, [sp, #22]
 8007dbc:	9b01      	ldr	r3, [sp, #4]
 8007dbe:	9803      	ldr	r0, [sp, #12]
 8007dc0:	f000 fa0e 	bl	80081e0 <_ZN8IcHausMu13_readRegisterEhjPh>
 8007dc4:	4603      	mov	r3, r0
 8007dc6:	f88d 3015 	strb.w	r3, [sp, #21]
    // Apply the mask on MSB & LSB
    if (1 < regSize) {
 8007dca:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007dce:	2b01      	cmp	r3, #1
 8007dd0:	d919      	bls.n	8007e06 <_ZN8IcHausMu20readIcMuRegister_leuE12icMuRegisterP10uint64_leu+0xa6>
        regSize--;
 8007dd2:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007dd6:	3b01      	subs	r3, #1
 8007dd8:	f88d 3016 	strb.w	r3, [sp, #22]
        *(buffPtr->tab+regSize) &= _icMuRegisterMask[tmpRegAddr+regSize];
 8007ddc:	9a01      	ldr	r2, [sp, #4]
 8007dde:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007de2:	4413      	add	r3, r2
 8007de4:	7819      	ldrb	r1, [r3, #0]
 8007de6:	f89d 2017 	ldrb.w	r2, [sp, #23]
 8007dea:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007dee:	4413      	add	r3, r2
 8007df0:	9a03      	ldr	r2, [sp, #12]
 8007df2:	4413      	add	r3, r2
 8007df4:	f893 2080 	ldrb.w	r2, [r3, #128]	; 0x80
 8007df8:	9801      	ldr	r0, [sp, #4]
 8007dfa:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007dfe:	4403      	add	r3, r0
 8007e00:	400a      	ands	r2, r1
 8007e02:	b2d2      	uxtb	r2, r2
 8007e04:	701a      	strb	r2, [r3, #0]
    }
    *(buffPtr->tab) &= _icMuRegisterMask[tmpRegAddr];
 8007e06:	9b01      	ldr	r3, [sp, #4]
 8007e08:	781a      	ldrb	r2, [r3, #0]
 8007e0a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8007e0e:	9903      	ldr	r1, [sp, #12]
 8007e10:	440b      	add	r3, r1
 8007e12:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8007e16:	4013      	ands	r3, r2
 8007e18:	b2da      	uxtb	r2, r3
 8007e1a:	9b01      	ldr	r3, [sp, #4]
 8007e1c:	701a      	strb	r2, [r3, #0]

    return retVal;
 8007e1e:	f89d 3015 	ldrb.w	r3, [sp, #21]
}
 8007e22:	4618      	mov	r0, r3
 8007e24:	b007      	add	sp, #28
 8007e26:	f85d fb04 	ldr.w	pc, [sp], #4
 8007e2a:	bf00      	nop
 8007e2c:	0000      	movs	r0, r0
	...

08007e30 <_ZN8IcHausMu17writeIcMuRegisterE12icMuRegisterh>:

fctStatus IcHausMu::writeIcMuRegister(const icMuRegister_t reg, const unsigned char val) {
 8007e30:	b500      	push	{lr}
 8007e32:	b083      	sub	sp, #12
 8007e34:	9001      	str	r0, [sp, #4]
 8007e36:	460b      	mov	r3, r1
 8007e38:	f88d 3003 	strb.w	r3, [sp, #3]
 8007e3c:	4613      	mov	r3, r2
 8007e3e:	f88d 3002 	strb.w	r3, [sp, #2]
    _tmpBuff64.dwords.msb.dword = 0x00000000;
 8007e42:	9b01      	ldr	r3, [sp, #4]
 8007e44:	2200      	movs	r2, #0
 8007e46:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    _tmpBuff64.dwords.lsb.dword = 0x00000000;
 8007e4a:	9b01      	ldr	r3, [sp, #4]
 8007e4c:	2200      	movs	r2, #0
 8007e4e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    _tmpBuff64.bytes_le.lsb = val;
 8007e52:	9b01      	ldr	r3, [sp, #4]
 8007e54:	f89d 2002 	ldrb.w	r2, [sp, #2]
 8007e58:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100

    return writeIcMuRegister_leu(reg, &_tmpBuff64);
 8007e5c:	9b01      	ldr	r3, [sp, #4]
 8007e5e:	f503 7280 	add.w	r2, r3, #256	; 0x100
 8007e62:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007e66:	4619      	mov	r1, r3
 8007e68:	9801      	ldr	r0, [sp, #4]
 8007e6a:	f000 f809 	bl	8007e80 <_ZN8IcHausMu21writeIcMuRegister_leuE12icMuRegisterP10uint64_leu>
 8007e6e:	4603      	mov	r3, r0
}
 8007e70:	4618      	mov	r0, r3
 8007e72:	b003      	add	sp, #12
 8007e74:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08007e80 <_ZN8IcHausMu21writeIcMuRegister_leuE12icMuRegisterP10uint64_leu>:

fctStatus IcHausMu::writeIcMuRegister_leu(const icMuRegister_t reg, uint64_leu* buffPtr) {
 8007e80:	b500      	push	{lr}
 8007e82:	b087      	sub	sp, #28
 8007e84:	9003      	str	r0, [sp, #12]
 8007e86:	460b      	mov	r3, r1
 8007e88:	9201      	str	r2, [sp, #4]
 8007e8a:	f88d 300b 	strb.w	r3, [sp, #11]
    unsigned char regSize = 0x00;
 8007e8e:	2300      	movs	r3, #0
 8007e90:	f88d 3015 	strb.w	r3, [sp, #21]
    unsigned char tmpRegAddr = 0x00;
 8007e94:	2300      	movs	r3, #0
 8007e96:	f88d 3017 	strb.w	r3, [sp, #23]
    unsigned char tmpData = 0x00;
 8007e9a:	2300      	movs	r3, #0
 8007e9c:	f88d 3014 	strb.w	r3, [sp, #20]
    fctStatus retVal = RET_OK;
 8007ea0:	2300      	movs	r3, #0
 8007ea2:	f88d 3016 	strb.w	r3, [sp, #22]

    regSize = icMuRegSize(reg);
 8007ea6:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8007eaa:	4619      	mov	r1, r3
 8007eac:	9803      	ldr	r0, [sp, #12]
 8007eae:	f7ff fee7 	bl	8007c80 <_ZN8IcHausMu11icMuRegSizeE12icMuRegister>
 8007eb2:	4603      	mov	r3, r0
 8007eb4:	f88d 3015 	strb.w	r3, [sp, #21]
    if (1 < regSize) {
 8007eb8:	f89d 3015 	ldrb.w	r3, [sp, #21]
 8007ebc:	2b01      	cmp	r3, #1
 8007ebe:	d94e      	bls.n	8007f5e <_ZN8IcHausMu21writeIcMuRegister_leuE12icMuRegisterP10uint64_leu+0xde>
        // The icMuRegister is an union.
        // Do mask for MSB
        tmpRegAddr = reg+regSize;
 8007ec0:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8007ec4:	f89d 3015 	ldrb.w	r3, [sp, #21]
 8007ec8:	4413      	add	r3, r2
 8007eca:	f88d 3017 	strb.w	r3, [sp, #23]
        retVal = _readRegister(_icMuRegisterAddress[tmpRegAddr], 1, &tmpData);
 8007ece:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8007ed2:	9a03      	ldr	r2, [sp, #12]
 8007ed4:	4413      	add	r3, r2
 8007ed6:	7859      	ldrb	r1, [r3, #1]
 8007ed8:	ab05      	add	r3, sp, #20
 8007eda:	2201      	movs	r2, #1
 8007edc:	9803      	ldr	r0, [sp, #12]
 8007ede:	f000 f97f 	bl	80081e0 <_ZN8IcHausMu13_readRegisterEhjPh>
 8007ee2:	4603      	mov	r3, r0
 8007ee4:	f88d 3016 	strb.w	r3, [sp, #22]
        tmpData &= ~_icMuRegisterMask[tmpRegAddr];
 8007ee8:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8007eec:	9a03      	ldr	r2, [sp, #12]
 8007eee:	4413      	add	r3, r2
 8007ef0:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8007ef4:	b25b      	sxtb	r3, r3
 8007ef6:	43db      	mvns	r3, r3
 8007ef8:	b25a      	sxtb	r2, r3
 8007efa:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8007efe:	b25b      	sxtb	r3, r3
 8007f00:	4013      	ands	r3, r2
 8007f02:	b25b      	sxtb	r3, r3
 8007f04:	b2db      	uxtb	r3, r3
 8007f06:	f88d 3014 	strb.w	r3, [sp, #20]
        *(buffPtr->tab+regSize-1) &= _icMuRegisterMask[tmpRegAddr];
 8007f0a:	9a01      	ldr	r2, [sp, #4]
 8007f0c:	f89d 3015 	ldrb.w	r3, [sp, #21]
 8007f10:	3b01      	subs	r3, #1
 8007f12:	4413      	add	r3, r2
 8007f14:	7819      	ldrb	r1, [r3, #0]
 8007f16:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8007f1a:	9a03      	ldr	r2, [sp, #12]
 8007f1c:	4413      	add	r3, r2
 8007f1e:	f893 2080 	ldrb.w	r2, [r3, #128]	; 0x80
 8007f22:	9801      	ldr	r0, [sp, #4]
 8007f24:	f89d 3015 	ldrb.w	r3, [sp, #21]
 8007f28:	3b01      	subs	r3, #1
 8007f2a:	4403      	add	r3, r0
 8007f2c:	400a      	ands	r2, r1
 8007f2e:	b2d2      	uxtb	r2, r2
 8007f30:	701a      	strb	r2, [r3, #0]
        *(buffPtr->tab+regSize-1) |= tmpData;
 8007f32:	9a01      	ldr	r2, [sp, #4]
 8007f34:	f89d 3015 	ldrb.w	r3, [sp, #21]
 8007f38:	3b01      	subs	r3, #1
 8007f3a:	4413      	add	r3, r2
 8007f3c:	7819      	ldrb	r1, [r3, #0]
 8007f3e:	f89d 2014 	ldrb.w	r2, [sp, #20]
 8007f42:	9801      	ldr	r0, [sp, #4]
 8007f44:	f89d 3015 	ldrb.w	r3, [sp, #21]
 8007f48:	3b01      	subs	r3, #1
 8007f4a:	4403      	add	r3, r0
 8007f4c:	430a      	orrs	r2, r1
 8007f4e:	b2d2      	uxtb	r2, r2
 8007f50:	701a      	strb	r2, [r3, #0]
        // Point to the 1st union element (LSB).
        tmpRegAddr = reg+1;
 8007f52:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8007f56:	3301      	adds	r3, #1
 8007f58:	f88d 3017 	strb.w	r3, [sp, #23]
 8007f5c:	e003      	b.n	8007f66 <_ZN8IcHausMu21writeIcMuRegister_leuE12icMuRegisterP10uint64_leu+0xe6>
    }
    else {
        tmpRegAddr = reg;
 8007f5e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8007f62:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    // Do mask for LSB
    if (RET_OK == retVal) {
 8007f66:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007f6a:	2b00      	cmp	r3, #0
 8007f6c:	d134      	bne.n	8007fd8 <_ZN8IcHausMu21writeIcMuRegister_leuE12icMuRegisterP10uint64_leu+0x158>
        tmpData = 0x00;
 8007f6e:	2300      	movs	r3, #0
 8007f70:	f88d 3014 	strb.w	r3, [sp, #20]
        retVal = _readRegister(_icMuRegisterAddress[tmpRegAddr], 1, &tmpData);
 8007f74:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8007f78:	9a03      	ldr	r2, [sp, #12]
 8007f7a:	4413      	add	r3, r2
 8007f7c:	7859      	ldrb	r1, [r3, #1]
 8007f7e:	ab05      	add	r3, sp, #20
 8007f80:	2201      	movs	r2, #1
 8007f82:	9803      	ldr	r0, [sp, #12]
 8007f84:	f000 f92c 	bl	80081e0 <_ZN8IcHausMu13_readRegisterEhjPh>
 8007f88:	4603      	mov	r3, r0
 8007f8a:	f88d 3016 	strb.w	r3, [sp, #22]
        tmpData &= ~_icMuRegisterMask[tmpRegAddr];
 8007f8e:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8007f92:	9a03      	ldr	r2, [sp, #12]
 8007f94:	4413      	add	r3, r2
 8007f96:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8007f9a:	b25b      	sxtb	r3, r3
 8007f9c:	43db      	mvns	r3, r3
 8007f9e:	b25a      	sxtb	r2, r3
 8007fa0:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8007fa4:	b25b      	sxtb	r3, r3
 8007fa6:	4013      	ands	r3, r2
 8007fa8:	b25b      	sxtb	r3, r3
 8007faa:	b2db      	uxtb	r3, r3
 8007fac:	f88d 3014 	strb.w	r3, [sp, #20]
        *(buffPtr->tab) &= _icMuRegisterMask[tmpRegAddr];
 8007fb0:	9b01      	ldr	r3, [sp, #4]
 8007fb2:	781a      	ldrb	r2, [r3, #0]
 8007fb4:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8007fb8:	9903      	ldr	r1, [sp, #12]
 8007fba:	440b      	add	r3, r1
 8007fbc:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8007fc0:	4013      	ands	r3, r2
 8007fc2:	b2da      	uxtb	r2, r3
 8007fc4:	9b01      	ldr	r3, [sp, #4]
 8007fc6:	701a      	strb	r2, [r3, #0]
        *(buffPtr->tab) |= tmpData;
 8007fc8:	9b01      	ldr	r3, [sp, #4]
 8007fca:	781a      	ldrb	r2, [r3, #0]
 8007fcc:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8007fd0:	4313      	orrs	r3, r2
 8007fd2:	b2da      	uxtb	r2, r3
 8007fd4:	9b01      	ldr	r3, [sp, #4]
 8007fd6:	701a      	strb	r2, [r3, #0]
    }

    // Write the data
    if (RET_OK == retVal) {
 8007fd8:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007fdc:	2b00      	cmp	r3, #0
 8007fde:	d10d      	bne.n	8007ffc <_ZN8IcHausMu21writeIcMuRegister_leuE12icMuRegisterP10uint64_leu+0x17c>
        retVal = _writeRegister(_icMuRegisterAddress[tmpRegAddr], regSize, buffPtr->tab);
 8007fe0:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8007fe4:	9a03      	ldr	r2, [sp, #12]
 8007fe6:	4413      	add	r3, r2
 8007fe8:	7859      	ldrb	r1, [r3, #1]
 8007fea:	f89d 2015 	ldrb.w	r2, [sp, #21]
 8007fee:	9b01      	ldr	r3, [sp, #4]
 8007ff0:	9803      	ldr	r0, [sp, #12]
 8007ff2:	f000 f95d 	bl	80082b0 <_ZN8IcHausMu14_writeRegisterEhjPh>
 8007ff6:	4603      	mov	r3, r0
 8007ff8:	f88d 3016 	strb.w	r3, [sp, #22]
    }

    return retVal;
 8007ffc:	f89d 3016 	ldrb.w	r3, [sp, #22]
}
 8008000:	4618      	mov	r0, r3
 8008002:	b007      	add	sp, #28
 8008004:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08008010 <_ZN8IcHausMu4initEv>:
    return _writeRegister(startAddress, nbBytes, buffPtr);
}

// ---------------- user level functions ----------------

fctStatus IcHausMu::init(void) {
 8008010:	b500      	push	{lr}
 8008012:	b083      	sub	sp, #12
 8008014:	9001      	str	r0, [sp, #4]
    // function to call before using the sensor

    // Check if the interface function has been linked.
    if (NULL!=_csFct_ptr && NULL!=_streamFct_ptr) {
 8008016:	9b01      	ldr	r3, [sp, #4]
 8008018:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800801c:	2b00      	cmp	r3, #0
 800801e:	d009      	beq.n	8008034 <_ZN8IcHausMu4initEv+0x24>
 8008020:	9b01      	ldr	r3, [sp, #4]
 8008022:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8008026:	2b00      	cmp	r3, #0
 8008028:	d004      	beq.n	8008034 <_ZN8IcHausMu4initEv+0x24>
        _initStatus = RET_OK;
 800802a:	9b01      	ldr	r3, [sp, #4]
 800802c:	2200      	movs	r2, #0
 800802e:	f883 210d 	strb.w	r2, [r3, #269]	; 0x10d
 8008032:	e003      	b.n	800803c <_ZN8IcHausMu4initEv+0x2c>
    }
    else {
        _initStatus = RET_E_NULLPTR;
 8008034:	9b01      	ldr	r3, [sp, #4]
 8008036:	2209      	movs	r2, #9
 8008038:	f883 210d 	strb.w	r2, [r3, #269]	; 0x10d
    }

    // Check the communication by reading the HARD_REV number
    if (RET_OK == _initStatus) {
 800803c:	9b01      	ldr	r3, [sp, #4]
 800803e:	f893 310d 	ldrb.w	r3, [r3, #269]	; 0x10d
 8008042:	2b00      	cmp	r3, #0
 8008044:	d108      	bne.n	8008058 <_ZN8IcHausMu4initEv+0x48>
        _initStatus = readIcMuRegister(HARD_REV);
 8008046:	211c      	movs	r1, #28
 8008048:	9801      	ldr	r0, [sp, #4]
 800804a:	f7ff fe61 	bl	8007d10 <_ZN8IcHausMu16readIcMuRegisterE12icMuRegister>
 800804e:	4603      	mov	r3, r0
 8008050:	461a      	mov	r2, r3
 8008052:	9b01      	ldr	r3, [sp, #4]
 8008054:	f883 210d 	strb.w	r2, [r3, #269]	; 0x10d
    }
    if (RET_OK == _initStatus) {
 8008058:	9b01      	ldr	r3, [sp, #4]
 800805a:	f893 310d 	ldrb.w	r3, [r3, #269]	; 0x10d
 800805e:	2b00      	cmp	r3, #0
 8008060:	d112      	bne.n	8008088 <_ZN8IcHausMu4initEv+0x78>
        if(getLastByteValue() != _hardRev) {    // compare the value read.
 8008062:	9801      	ldr	r0, [sp, #4]
 8008064:	f7ff fe34 	bl	8007cd0 <_ZN8IcHausMu16getLastByteValueEv>
 8008068:	4603      	mov	r3, r0
 800806a:	461a      	mov	r2, r3
 800806c:	9b01      	ldr	r3, [sp, #4]
 800806e:	f893 3109 	ldrb.w	r3, [r3, #265]	; 0x109
 8008072:	429a      	cmp	r2, r3
 8008074:	bf14      	ite	ne
 8008076:	2301      	movne	r3, #1
 8008078:	2300      	moveq	r3, #0
 800807a:	b2db      	uxtb	r3, r3
 800807c:	2b00      	cmp	r3, #0
 800807e:	d003      	beq.n	8008088 <_ZN8IcHausMu4initEv+0x78>
            _initStatus = RET_E_DATA;
 8008080:	9b01      	ldr	r3, [sp, #4]
 8008082:	2207      	movs	r2, #7
 8008084:	f883 210d 	strb.w	r2, [r3, #269]	; 0x10d
        }
    }
    return _initStatus;
 8008088:	9b01      	ldr	r3, [sp, #4]
 800808a:	f893 310d 	ldrb.w	r3, [r3, #269]	; 0x10d
}
 800808e:	4618      	mov	r0, r3
 8008090:	b003      	add	sp, #12
 8008092:	f85d fb04 	ldr.w	pc, [sp], #4
 8008096:	bf00      	nop
	...

080080a0 <_ZN8IcHausMu16setAutomaticGainEh>:

void IcHausMu::uninit(void) {
    _initStatus = RET_W_UNINIT;
}

fctStatus IcHausMu::setAutomaticGain(const unsigned char autoGainEnabled) {
 80080a0:	b500      	push	{lr}
 80080a2:	b085      	sub	sp, #20
 80080a4:	9001      	str	r0, [sp, #4]
 80080a6:	460b      	mov	r3, r1
 80080a8:	f88d 3003 	strb.w	r3, [sp, #3]
    // enable the automatic gain amplitude
    // Values applied by the automatic unit can be read through the ACGAIN_x & AFGAIN_x registers. See p.22
    // Configuration can be checked through PORTB pins in mode 0x04 & 0x05
    fctStatus retVal = RET_E_NOK;
 80080ac:	2301      	movs	r3, #1
 80080ae:	f88d 300e 	strb.w	r3, [sp, #14]
    unsigned char tmpBuff = 0x00;
 80080b2:	2300      	movs	r3, #0
 80080b4:	f88d 300f 	strb.w	r3, [sp, #15]

    // The gain of both amplification stages is automatically controlled when
    // the bit ENAC is set to 1. The register bits GC_x and GF_x have no effect. (p.20).
    if (0x00 != autoGainEnabled) {tmpBuff = 0x80;}
 80080b8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80080bc:	2b00      	cmp	r3, #0
 80080be:	d002      	beq.n	80080c6 <_ZN8IcHausMu16setAutomaticGainEh+0x26>
 80080c0:	2380      	movs	r3, #128	; 0x80
 80080c2:	f88d 300f 	strb.w	r3, [sp, #15]
    retVal = writeIcMuRegister(ENAC, tmpBuff);
 80080c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80080ca:	461a      	mov	r2, r3
 80080cc:	2101      	movs	r1, #1
 80080ce:	9801      	ldr	r0, [sp, #4]
 80080d0:	f7ff feae 	bl	8007e30 <_ZN8IcHausMu17writeIcMuRegisterE12icMuRegisterh>
 80080d4:	4603      	mov	r3, r0
 80080d6:	f88d 300e 	strb.w	r3, [sp, #14]

    return retVal;
 80080da:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
 80080de:	4618      	mov	r0, r3
 80080e0:	b005      	add	sp, #20
 80080e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80080e6:	bf00      	nop
	...

080080f0 <_ZN8IcHausMu7readPosEP8uint16_u>:
    if (RET_OK==retVal && 0x80!=tmpBuff) {retVal = RET_E_SENSORFAIL;}

    return retVal;
}

fctStatus IcHausMu::readPos(uint16_u* posPtr) {
 80080f0:	b500      	push	{lr}
 80080f2:	b085      	sub	sp, #20
 80080f4:	9001      	str	r0, [sp, #4]
 80080f6:	9100      	str	r1, [sp, #0]
    fctStatus retVal = RET_E_SENSORFAIL;
 80080f8:	2303      	movs	r3, #3
 80080fa:	f88d 300f 	strb.w	r3, [sp, #15]
    retVal = _readSdad(_sdadOutSize, (unsigned char*)&_tmpBuff64);
 80080fe:	9b01      	ldr	r3, [sp, #4]
 8008100:	f893 310c 	ldrb.w	r3, [r3, #268]	; 0x10c
 8008104:	4619      	mov	r1, r3
 8008106:	9b01      	ldr	r3, [sp, #4]
 8008108:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800810c:	461a      	mov	r2, r3
 800810e:	9801      	ldr	r0, [sp, #4]
 8008110:	f000 f936 	bl	8008380 <_ZN8IcHausMu9_readSdadEjPh>
 8008114:	4603      	mov	r3, r0
 8008116:	f88d 300f 	strb.w	r3, [sp, #15]
    if (RET_OK == retVal) { *(posPtr)= getLastUint_16Value(); }
 800811a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800811e:	2b00      	cmp	r3, #0
 8008120:	d105      	bne.n	800812e <_ZN8IcHausMu7readPosEP8uint16_u+0x3e>
 8008122:	9801      	ldr	r0, [sp, #4]
 8008124:	f7ff fddc 	bl	8007ce0 <_ZN8IcHausMu19getLastUint_16ValueEv>
 8008128:	4602      	mov	r2, r0
 800812a:	9b00      	ldr	r3, [sp, #0]
 800812c:	801a      	strh	r2, [r3, #0]
    return retVal;
 800812e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8008132:	4618      	mov	r0, r3
 8008134:	b005      	add	sp, #20
 8008136:	f85d fb04 	ldr.w	pc, [sp], #4
 800813a:	bf00      	nop
 800813c:	0000      	movs	r0, r0
	...

08008140 <_ZN8IcHausMu14_readRegStatusEv>:

}

// ############################### Private Methods ###############################

fctStatus IcHausMu::_readRegStatus(void) {
 8008140:	b500      	push	{lr}
 8008142:	b085      	sub	sp, #20
 8008144:	9001      	str	r0, [sp, #4]
    fctStatus retVal = RET_OK;
 8008146:	2300      	movs	r3, #0
 8008148:	f88d 300f 	strb.w	r3, [sp, #15]
    unsigned char internalBuffer[2] = {STATUS_DATA, 0x00};
 800814c:	23ad      	movs	r3, #173	; 0xad
 800814e:	f88d 300c 	strb.w	r3, [sp, #12]
 8008152:	2300      	movs	r3, #0
 8008154:	f88d 300d 	strb.w	r3, [sp, #13]

    // Do the transfert and get the STATUS register
    _streamFct_ptr((unsigned char*)&internalBuffer, (unsigned char*)&internalBuffer, 2);
 8008158:	9b01      	ldr	r3, [sp, #4]
 800815a:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800815e:	a903      	add	r1, sp, #12
 8008160:	a803      	add	r0, sp, #12
 8008162:	2202      	movs	r2, #2
 8008164:	4798      	blx	r3

    if (STATUS_DATA == internalBuffer[0]) {
 8008166:	f89d 300c 	ldrb.w	r3, [sp, #12]
 800816a:	2bad      	cmp	r3, #173	; 0xad
 800816c:	d128      	bne.n	80081c0 <_ZN8IcHausMu14_readRegStatusEv+0x80>
       // Register is correctly addressed
       // Decode the status byte
       if (0x80 <= internalBuffer[1]) {retVal = RET_E_SENSORERROR;}
 800816e:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8008172:	b25b      	sxtb	r3, r3
 8008174:	2b00      	cmp	r3, #0
 8008176:	da03      	bge.n	8008180 <_ZN8IcHausMu14_readRegStatusEv+0x40>
 8008178:	2301      	movs	r3, #1
 800817a:	f88d 300f 	strb.w	r3, [sp, #15]
 800817e:	e022      	b.n	80081c6 <_ZN8IcHausMu14_readRegStatusEv+0x86>
       else if (0x08 <= internalBuffer[1]) {retVal = RET_W_SENSORDISMISS;}
 8008180:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8008184:	2b07      	cmp	r3, #7
 8008186:	d903      	bls.n	8008190 <_ZN8IcHausMu14_readRegStatusEv+0x50>
 8008188:	2304      	movs	r3, #4
 800818a:	f88d 300f 	strb.w	r3, [sp, #15]
 800818e:	e01a      	b.n	80081c6 <_ZN8IcHausMu14_readRegStatusEv+0x86>
       else if (0x04 <= internalBuffer[1]) {retVal = RET_E_SENSORFAIL;}
 8008190:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8008194:	2b03      	cmp	r3, #3
 8008196:	d903      	bls.n	80081a0 <_ZN8IcHausMu14_readRegStatusEv+0x60>
 8008198:	2303      	movs	r3, #3
 800819a:	f88d 300f 	strb.w	r3, [sp, #15]
 800819e:	e012      	b.n	80081c6 <_ZN8IcHausMu14_readRegStatusEv+0x86>
       else if (0x02 <= internalBuffer[1]) {retVal = RET_W_SENSORBUSY;}
 80081a0:	f89d 300d 	ldrb.w	r3, [sp, #13]
 80081a4:	2b01      	cmp	r3, #1
 80081a6:	d903      	bls.n	80081b0 <_ZN8IcHausMu14_readRegStatusEv+0x70>
 80081a8:	2302      	movs	r3, #2
 80081aa:	f88d 300f 	strb.w	r3, [sp, #15]
 80081ae:	e00a      	b.n	80081c6 <_ZN8IcHausMu14_readRegStatusEv+0x86>
       else if (0x00 == internalBuffer[1]) {retVal = RET_E_NOK;}
 80081b0:	f89d 300d 	ldrb.w	r3, [sp, #13]
 80081b4:	2b00      	cmp	r3, #0
 80081b6:	d106      	bne.n	80081c6 <_ZN8IcHausMu14_readRegStatusEv+0x86>
 80081b8:	2301      	movs	r3, #1
 80081ba:	f88d 300f 	strb.w	r3, [sp, #15]
 80081be:	e002      	b.n	80081c6 <_ZN8IcHausMu14_readRegStatusEv+0x86>
       else { /* data is valid. retVal=RET_OK */ }
    }
    else {
        retVal = RET_E_OPCODE;
 80081c0:	2305      	movs	r3, #5
 80081c2:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    return retVal;
 80081c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 80081ca:	4618      	mov	r0, r3
 80081cc:	b005      	add	sp, #20
 80081ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80081d2:	bf00      	nop
	...

080081e0 <_ZN8IcHausMu13_readRegisterEhjPh>:

fctStatus IcHausMu::_readRegister(const unsigned char registerToRead, const unsigned int bytesToRead, unsigned char* buffPtr) {
 80081e0:	b500      	push	{lr}
 80081e2:	b087      	sub	sp, #28
 80081e4:	9003      	str	r0, [sp, #12]
 80081e6:	9201      	str	r2, [sp, #4]
 80081e8:	9300      	str	r3, [sp, #0]
 80081ea:	460b      	mov	r3, r1
 80081ec:	f88d 300b 	strb.w	r3, [sp, #11]
    fctStatus retVal = RET_OK;
 80081f0:	2300      	movs	r3, #0
 80081f2:	f88d 3017 	strb.w	r3, [sp, #23]
    unsigned char internalBuffer[2] = {0x00};           // incoming word from the SPI
 80081f6:	2300      	movs	r3, #0
 80081f8:	f8ad 3014 	strh.w	r3, [sp, #20]

    // check if the functions are available
    if (RET_OK==_initStatus && NULL!=buffPtr) {
 80081fc:	9b03      	ldr	r3, [sp, #12]
 80081fe:	f893 310d 	ldrb.w	r3, [r3, #269]	; 0x10d
 8008202:	2b00      	cmp	r3, #0
 8008204:	d147      	bne.n	8008296 <_ZN8IcHausMu13_readRegisterEhjPh+0xb6>
 8008206:	9b00      	ldr	r3, [sp, #0]
 8008208:	2b00      	cmp	r3, #0
 800820a:	d044      	beq.n	8008296 <_ZN8IcHausMu13_readRegisterEhjPh+0xb6>
        // select the device
        _csFct_ptr(true);
 800820c:	9b03      	ldr	r3, [sp, #12]
 800820e:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8008212:	2001      	movs	r0, #1
 8008214:	4798      	blx	r3

        // send the read command with the register address to read:
        internalBuffer[0] = READ_REG;
 8008216:	2397      	movs	r3, #151	; 0x97
 8008218:	f88d 3014 	strb.w	r3, [sp, #20]
        internalBuffer[1] = registerToRead;
 800821c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8008220:	f88d 3015 	strb.w	r3, [sp, #21]
        _streamFct_ptr((unsigned char *)&internalBuffer, (unsigned char *)&internalBuffer, 2);
 8008224:	9b03      	ldr	r3, [sp, #12]
 8008226:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800822a:	a905      	add	r1, sp, #20
 800822c:	a805      	add	r0, sp, #20
 800822e:	2202      	movs	r2, #2
 8008230:	4798      	blx	r3
        // Check if the register read command has been sent as expected
        if ( READ_REG!=internalBuffer[0] || registerToRead!=internalBuffer[1] ) {
 8008232:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8008236:	2b97      	cmp	r3, #151	; 0x97
 8008238:	d105      	bne.n	8008246 <_ZN8IcHausMu13_readRegisterEhjPh+0x66>
 800823a:	f89d 3015 	ldrb.w	r3, [sp, #21]
 800823e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8008242:	429a      	cmp	r2, r3
 8008244:	d002      	beq.n	800824c <_ZN8IcHausMu13_readRegisterEhjPh+0x6c>
            retVal = RET_E_OPCODE;
 8008246:	2305      	movs	r3, #5
 8008248:	f88d 3017 	strb.w	r3, [sp, #23]
        }

        // unselect the device
        _csFct_ptr(false);
 800824c:	9b03      	ldr	r3, [sp, #12]
 800824e:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8008252:	2000      	movs	r0, #0
 8008254:	4798      	blx	r3

        if (RET_OK == retVal) {
 8008256:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800825a:	2b00      	cmp	r3, #0
 800825c:	d121      	bne.n	80082a2 <_ZN8IcHausMu13_readRegisterEhjPh+0xc2>
            // select the device
            _csFct_ptr(true);
 800825e:	9b03      	ldr	r3, [sp, #12]
 8008260:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8008264:	2001      	movs	r0, #1
 8008266:	4798      	blx	r3

            retVal = _readRegStatus();    // same function is used to read status and data
 8008268:	9803      	ldr	r0, [sp, #12]
 800826a:	f7ff ff69 	bl	8008140 <_ZN8IcHausMu14_readRegStatusEv>
 800826e:	4603      	mov	r3, r0
 8008270:	f88d 3017 	strb.w	r3, [sp, #23]
            if (RET_OK == retVal) {
 8008274:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8008278:	2b00      	cmp	r3, #0
 800827a:	d106      	bne.n	800828a <_ZN8IcHausMu13_readRegisterEhjPh+0xaa>
                _streamFct_ptr(buffPtr, buffPtr, bytesToRead);
 800827c:	9b03      	ldr	r3, [sp, #12]
 800827e:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8008282:	9a01      	ldr	r2, [sp, #4]
 8008284:	9900      	ldr	r1, [sp, #0]
 8008286:	9800      	ldr	r0, [sp, #0]
 8008288:	4798      	blx	r3
            }

            // unselect the device
            _csFct_ptr(false);
 800828a:	9b03      	ldr	r3, [sp, #12]
 800828c:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8008290:	2000      	movs	r0, #0
 8008292:	4798      	blx	r3
 8008294:	e006      	b.n	80082a4 <_ZN8IcHausMu13_readRegisterEhjPh+0xc4>
        }
    }
    else {
        retVal = _initStatus;
 8008296:	9b03      	ldr	r3, [sp, #12]
 8008298:	f893 310d 	ldrb.w	r3, [r3, #269]	; 0x10d
 800829c:	f88d 3017 	strb.w	r3, [sp, #23]
 80082a0:	e000      	b.n	80082a4 <_ZN8IcHausMu13_readRegisterEhjPh+0xc4>
            _csFct_ptr(false);
 80082a2:	bf00      	nop
    }

    // return the function status:
    return retVal;
 80082a4:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 80082a8:	4618      	mov	r0, r3
 80082aa:	b007      	add	sp, #28
 80082ac:	f85d fb04 	ldr.w	pc, [sp], #4

080082b0 <_ZN8IcHausMu14_writeRegisterEhjPh>:

fctStatus IcHausMu::_writeRegister(const unsigned char registerToWrite, const unsigned int bytesToWrite, unsigned char* buffPtr) {
 80082b0:	b500      	push	{lr}
 80082b2:	b087      	sub	sp, #28
 80082b4:	9003      	str	r0, [sp, #12]
 80082b6:	9201      	str	r2, [sp, #4]
 80082b8:	9300      	str	r3, [sp, #0]
 80082ba:	460b      	mov	r3, r1
 80082bc:	f88d 300b 	strb.w	r3, [sp, #11]
    fctStatus retVal = RET_OK;
 80082c0:	2300      	movs	r3, #0
 80082c2:	f88d 3017 	strb.w	r3, [sp, #23]
    unsigned char internalBuffer[2] = {0x00};           // incoming word from the SPI
 80082c6:	2300      	movs	r3, #0
 80082c8:	f8ad 3014 	strh.w	r3, [sp, #20]

    // check if the functions are available
    if (RET_OK==_initStatus && NULL!=buffPtr) {
 80082cc:	9b03      	ldr	r3, [sp, #12]
 80082ce:	f893 310d 	ldrb.w	r3, [r3, #269]	; 0x10d
 80082d2:	2b00      	cmp	r3, #0
 80082d4:	d143      	bne.n	800835e <_ZN8IcHausMu14_writeRegisterEhjPh+0xae>
 80082d6:	9b00      	ldr	r3, [sp, #0]
 80082d8:	2b00      	cmp	r3, #0
 80082da:	d040      	beq.n	800835e <_ZN8IcHausMu14_writeRegisterEhjPh+0xae>
      // select the device
      _csFct_ptr(true);
 80082dc:	9b03      	ldr	r3, [sp, #12]
 80082de:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 80082e2:	2001      	movs	r0, #1
 80082e4:	4798      	blx	r3

      // send the read command with the register address to read:
      internalBuffer[0] = WRITE_REG;
 80082e6:	23d2      	movs	r3, #210	; 0xd2
 80082e8:	f88d 3014 	strb.w	r3, [sp, #20]
      internalBuffer[1] = registerToWrite;
 80082ec:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80082f0:	f88d 3015 	strb.w	r3, [sp, #21]

      _streamFct_ptr((unsigned char *)&internalBuffer, (unsigned char *)&internalBuffer, 2);
 80082f4:	9b03      	ldr	r3, [sp, #12]
 80082f6:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 80082fa:	a905      	add	r1, sp, #20
 80082fc:	a805      	add	r0, sp, #20
 80082fe:	2202      	movs	r2, #2
 8008300:	4798      	blx	r3
      // Check if the register write command has been sent as expected
      if ( WRITE_REG!=internalBuffer[0] || registerToWrite!=internalBuffer[1] ) {
 8008302:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8008306:	2bd2      	cmp	r3, #210	; 0xd2
 8008308:	d105      	bne.n	8008316 <_ZN8IcHausMu14_writeRegisterEhjPh+0x66>
 800830a:	f89d 3015 	ldrb.w	r3, [sp, #21]
 800830e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8008312:	429a      	cmp	r2, r3
 8008314:	d002      	beq.n	800831c <_ZN8IcHausMu14_writeRegisterEhjPh+0x6c>
        retVal = RET_E_OPCODE;
 8008316:	2305      	movs	r3, #5
 8008318:	f88d 3017 	strb.w	r3, [sp, #23]
      }
      if (RET_OK == retVal) {
 800831c:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8008320:	2b00      	cmp	r3, #0
 8008322:	d116      	bne.n	8008352 <_ZN8IcHausMu14_writeRegisterEhjPh+0xa2>
          _streamFct_ptr(buffPtr, buffPtr, bytesToWrite);
 8008324:	9b03      	ldr	r3, [sp, #12]
 8008326:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800832a:	9a01      	ldr	r2, [sp, #4]
 800832c:	9900      	ldr	r1, [sp, #0]
 800832e:	9800      	ldr	r0, [sp, #0]
 8008330:	4798      	blx	r3
          // unselect the device
          _csFct_ptr(false);
 8008332:	9b03      	ldr	r3, [sp, #12]
 8008334:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8008338:	2000      	movs	r0, #0
 800833a:	4798      	blx	r3
          // select the device
          _csFct_ptr(true);
 800833c:	9b03      	ldr	r3, [sp, #12]
 800833e:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8008342:	2001      	movs	r0, #1
 8008344:	4798      	blx	r3
          retVal = _readRegStatus();          // check the validity of the writing operation
 8008346:	9803      	ldr	r0, [sp, #12]
 8008348:	f7ff fefa 	bl	8008140 <_ZN8IcHausMu14_readRegStatusEv>
 800834c:	4603      	mov	r3, r0
 800834e:	f88d 3017 	strb.w	r3, [sp, #23]
      }

      // unselect the device
      _csFct_ptr(false);
 8008352:	9b03      	ldr	r3, [sp, #12]
 8008354:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8008358:	2000      	movs	r0, #0
 800835a:	4798      	blx	r3
 800835c:	e004      	b.n	8008368 <_ZN8IcHausMu14_writeRegisterEhjPh+0xb8>

    }
    else {
      retVal = _initStatus;
 800835e:	9b03      	ldr	r3, [sp, #12]
 8008360:	f893 310d 	ldrb.w	r3, [r3, #269]	; 0x10d
 8008364:	f88d 3017 	strb.w	r3, [sp, #23]
    }

    // return the result:
    return retVal;
 8008368:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 800836c:	4618      	mov	r0, r3
 800836e:	b007      	add	sp, #28
 8008370:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08008380 <_ZN8IcHausMu9_readSdadEjPh>:

fctStatus IcHausMu::_readSdad(const unsigned int bytesToRead, unsigned char* buffPtr) {
 8008380:	b500      	push	{lr}
 8008382:	b087      	sub	sp, #28
 8008384:	9003      	str	r0, [sp, #12]
 8008386:	9102      	str	r1, [sp, #8]
 8008388:	9201      	str	r2, [sp, #4]
    fctStatus retVal = RET_OK;
 800838a:	2300      	movs	r3, #0
 800838c:	f88d 3017 	strb.w	r3, [sp, #23]
    unsigned char internalBuffer = 0x00;           // incoming byte from the SPI
 8008390:	2300      	movs	r3, #0
 8008392:	f88d 3016 	strb.w	r3, [sp, #22]

    // check if the functions are available
    if (RET_OK==_initStatus && NULL!=buffPtr) {
 8008396:	9b03      	ldr	r3, [sp, #12]
 8008398:	f893 310d 	ldrb.w	r3, [r3, #269]	; 0x10d
 800839c:	2b00      	cmp	r3, #0
 800839e:	d128      	bne.n	80083f2 <_ZN8IcHausMu9_readSdadEjPh+0x72>
 80083a0:	9b01      	ldr	r3, [sp, #4]
 80083a2:	2b00      	cmp	r3, #0
 80083a4:	d025      	beq.n	80083f2 <_ZN8IcHausMu9_readSdadEjPh+0x72>
        // select the device
        _csFct_ptr(true);
 80083a6:	9b03      	ldr	r3, [sp, #12]
 80083a8:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 80083ac:	2001      	movs	r0, #1
 80083ae:	4798      	blx	r3

        // send the read command with the register address to read:
        internalBuffer = SDAD_TRANSMIT;
 80083b0:	23a6      	movs	r3, #166	; 0xa6
 80083b2:	f88d 3016 	strb.w	r3, [sp, #22]
        _streamFct_ptr((unsigned char *)&internalBuffer, (unsigned char *)&internalBuffer, 1);
 80083b6:	9b03      	ldr	r3, [sp, #12]
 80083b8:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 80083bc:	f10d 0116 	add.w	r1, sp, #22
 80083c0:	f10d 0016 	add.w	r0, sp, #22
 80083c4:	2201      	movs	r2, #1
 80083c6:	4798      	blx	r3
        // Check if the register read command has been sent as expected
        if (SDAD_TRANSMIT != internalBuffer) {
 80083c8:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80083cc:	2ba6      	cmp	r3, #166	; 0xa6
 80083ce:	d003      	beq.n	80083d8 <_ZN8IcHausMu9_readSdadEjPh+0x58>
            retVal = RET_E_OPCODE;
 80083d0:	2305      	movs	r3, #5
 80083d2:	f88d 3017 	strb.w	r3, [sp, #23]
 80083d6:	e006      	b.n	80083e6 <_ZN8IcHausMu9_readSdadEjPh+0x66>
        }
        else {
            _streamFct_ptr(buffPtr, buffPtr, bytesToRead);
 80083d8:	9b03      	ldr	r3, [sp, #12]
 80083da:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 80083de:	9a02      	ldr	r2, [sp, #8]
 80083e0:	9901      	ldr	r1, [sp, #4]
 80083e2:	9801      	ldr	r0, [sp, #4]
 80083e4:	4798      	blx	r3
        }
        // unselect the device
        _csFct_ptr(false);
 80083e6:	9b03      	ldr	r3, [sp, #12]
 80083e8:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 80083ec:	2000      	movs	r0, #0
 80083ee:	4798      	blx	r3
 80083f0:	e004      	b.n	80083fc <_ZN8IcHausMu9_readSdadEjPh+0x7c>
    }
    else {
        retVal = _initStatus;
 80083f2:	9b03      	ldr	r3, [sp, #12]
 80083f4:	f893 310d 	ldrb.w	r3, [r3, #269]	; 0x10d
 80083f8:	f88d 3017 	strb.w	r3, [sp, #23]
    }

    // return the function status:
    return retVal;
 80083fc:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 8008400:	4618      	mov	r0, r3
 8008402:	b007      	add	sp, #28
 8008404:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08008410 <_ZL18chRegSetThreadNamePKc>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8008410:	b082      	sub	sp, #8
 8008412:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8008414:	4b02      	ldr	r3, [pc, #8]	; (8008420 <_ZL18chRegSetThreadNamePKc+0x10>)
 8008416:	699b      	ldr	r3, [r3, #24]
 8008418:	9a01      	ldr	r2, [sp, #4]
 800841a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800841c:	b002      	add	sp, #8
 800841e:	4770      	bx	lr
 8008420:	20001090 	.word	0x20001090
	...

08008430 <_ZN10chibios_rt6System4initEv>:
     * @note    This function has special, architecture-dependent, requirements,
     *          see the notes into the various port reference manuals.
     *
     * @special
     */
    static void init(void) {
 8008430:	b508      	push	{r3, lr}

      chSysInit();
 8008432:	f006 fd9d 	bl	800ef70 <chSysInit>
    }
 8008436:	bd08      	pop	{r3, pc}
	...

08008440 <_ZN10chibios_rt10BaseThread5sleepEm>:
     *                      - @a TIME_IMMEDIATE this value is not allowed.
     *                      .
     *
     * @api
     */
    static void sleep(sysinterval_t interval) {
 8008440:	b500      	push	{lr}
 8008442:	b083      	sub	sp, #12
 8008444:	9001      	str	r0, [sp, #4]

      chThdSleep(interval);
 8008446:	9801      	ldr	r0, [sp, #4]
 8008448:	f008 f9e2 	bl	8010810 <chThdSleep>
    }
 800844c:	b003      	add	sp, #12
 800844e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008452:	bf00      	nop
	...

08008460 <test>:
IcHausMu* newIcHausMu();

fctStatus wr_readPos(IcHausMu enc, uint16_u* posPtr);


extern void test(){return;};
 8008460:	4770      	bx	lr
 8008462:	bf00      	nop
	...

08008470 <basicSpiComTest>:
//  encoder.writeIcMuRegister(MPC, 0x05);  // Cible 32 ples
//  encoder.readPos(&pos);
//sdPutTimeout(&SD2, pos,TIME_MS2I(50));

extern void basicSpiComTest()
{
 8008470:	b500      	push	{lr}
 8008472:	b083      	sub	sp, #12
  uint16_u pos;
  encoder.readPos(&pos);
 8008474:	466b      	mov	r3, sp
 8008476:	4619      	mov	r1, r3
 8008478:	4820      	ldr	r0, [pc, #128]	; (80084fc <basicSpiComTest+0x8c>)
 800847a:	f7ff fe39 	bl	80080f0 <_ZN8IcHausMu7readPosEP8uint16_u>

  for (int i=0 ; i<BUS_SIZE; i++)
 800847e:	2300      	movs	r3, #0
 8008480:	9301      	str	r3, [sp, #4]
 8008482:	9b01      	ldr	r3, [sp, #4]
 8008484:	2b0f      	cmp	r3, #15
 8008486:	dc23      	bgt.n	80084d0 <basicSpiComTest+0x60>
      {
        txbuf2[i] = (uint8_t)i%255;
 8008488:	9b01      	ldr	r3, [sp, #4]
 800848a:	b2da      	uxtb	r2, r3
 800848c:	4b1c      	ldr	r3, [pc, #112]	; (8008500 <basicSpiComTest+0x90>)
 800848e:	fba3 1302 	umull	r1, r3, r3, r2
 8008492:	09d9      	lsrs	r1, r3, #7
 8008494:	460b      	mov	r3, r1
 8008496:	021b      	lsls	r3, r3, #8
 8008498:	1a5b      	subs	r3, r3, r1
 800849a:	1ad3      	subs	r3, r2, r3
 800849c:	b2d9      	uxtb	r1, r3
 800849e:	4a19      	ldr	r2, [pc, #100]	; (8008504 <basicSpiComTest+0x94>)
 80084a0:	9b01      	ldr	r3, [sp, #4]
 80084a2:	4413      	add	r3, r2
 80084a4:	460a      	mov	r2, r1
 80084a6:	701a      	strb	r2, [r3, #0]
        rxbuf2[i] = (uint8_t)i%255;
 80084a8:	9b01      	ldr	r3, [sp, #4]
 80084aa:	b2da      	uxtb	r2, r3
 80084ac:	4b14      	ldr	r3, [pc, #80]	; (8008500 <basicSpiComTest+0x90>)
 80084ae:	fba3 1302 	umull	r1, r3, r3, r2
 80084b2:	09d9      	lsrs	r1, r3, #7
 80084b4:	460b      	mov	r3, r1
 80084b6:	021b      	lsls	r3, r3, #8
 80084b8:	1a5b      	subs	r3, r3, r1
 80084ba:	1ad3      	subs	r3, r2, r3
 80084bc:	b2d9      	uxtb	r1, r3
 80084be:	4a12      	ldr	r2, [pc, #72]	; (8008508 <basicSpiComTest+0x98>)
 80084c0:	9b01      	ldr	r3, [sp, #4]
 80084c2:	4413      	add	r3, r2
 80084c4:	460a      	mov	r2, r1
 80084c6:	701a      	strb	r2, [r3, #0]
  for (int i=0 ; i<BUS_SIZE; i++)
 80084c8:	9b01      	ldr	r3, [sp, #4]
 80084ca:	3301      	adds	r3, #1
 80084cc:	9301      	str	r3, [sp, #4]
 80084ce:	e7d8      	b.n	8008482 <basicSpiComTest+0x12>
      }

  spiAcquireBus(&SPID2);              // Acquire ownership of the bus.
 80084d0:	480e      	ldr	r0, [pc, #56]	; (800850c <basicSpiComTest+0x9c>)
 80084d2:	f002 fc65 	bl	800ada0 <spiAcquireBus>
  spiSelect(&SPID2);                  // Slave Select assertion.
 80084d6:	480d      	ldr	r0, [pc, #52]	; (800850c <basicSpiComTest+0x9c>)
 80084d8:	f002 fbd2 	bl	800ac80 <spiSelect>
  spiExchange(&SPID2, BUS_SIZE, txbuf2, rxbuf2);
 80084dc:	4b0a      	ldr	r3, [pc, #40]	; (8008508 <basicSpiComTest+0x98>)
 80084de:	4a09      	ldr	r2, [pc, #36]	; (8008504 <basicSpiComTest+0x94>)
 80084e0:	2110      	movs	r1, #16
 80084e2:	480a      	ldr	r0, [pc, #40]	; (800850c <basicSpiComTest+0x9c>)
 80084e4:	f002 fc1c 	bl	800ad20 <spiExchange>
      //spiSend(SPID2,*/
  spiUnselect(&SPID2);                // Slave Select de-assertion.
 80084e8:	4808      	ldr	r0, [pc, #32]	; (800850c <basicSpiComTest+0x9c>)
 80084ea:	f002 fbf1 	bl	800acd0 <spiUnselect>
  spiReleaseBus(&SPID2);
 80084ee:	4807      	ldr	r0, [pc, #28]	; (800850c <basicSpiComTest+0x9c>)
 80084f0:	f002 fc6e 	bl	800add0 <spiReleaseBus>
}
 80084f4:	b003      	add	sp, #12
 80084f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80084fa:	bf00      	nop
 80084fc:	20002638 	.word	0x20002638
 8008500:	80808081 	.word	0x80808081
 8008504:	20002750 	.word	0x20002750
 8008508:	20002760 	.word	0x20002760
 800850c:	20000eec 	.word	0x20000eec

08008510 <ChangeCS>:
//  encoder.writeIcMuRegister(LIN, 0x00);  //Encodeur rotatif mono tour
//  encoder.writeIcMuRegister(MPC, 0x05);  // Cible 32 ples
}

extern void ChangeCS(bool state)
{
 8008510:	b500      	push	{lr}
 8008512:	b083      	sub	sp, #12
 8008514:	4603      	mov	r3, r0
 8008516:	f88d 3007 	strb.w	r3, [sp, #7]
  if(state)
 800851a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800851e:	2b00      	cmp	r3, #0
 8008520:	d003      	beq.n	800852a <ChangeCS+0x1a>
    spiSelect(&SPID2);
 8008522:	4805      	ldr	r0, [pc, #20]	; (8008538 <ChangeCS+0x28>)
 8008524:	f002 fbac 	bl	800ac80 <spiSelect>
 8008528:	e002      	b.n	8008530 <ChangeCS+0x20>
  else
    spiUnselect(&SPID2);
 800852a:	4803      	ldr	r0, [pc, #12]	; (8008538 <ChangeCS+0x28>)
 800852c:	f002 fbd0 	bl	800acd0 <spiUnselect>
 }
 8008530:	b003      	add	sp, #12
 8008532:	f85d fb04 	ldr.w	pc, [sp], #4
 8008536:	bf00      	nop
 8008538:	20000eec 	.word	0x20000eec
 800853c:	00000000 	.word	0x00000000

08008540 <TransferIcMU>:

extern void TransferIcMU(unsigned char* const txBuffer, unsigned char* rxBuffer, const unsigned int bufferLen)
{
 8008540:	b500      	push	{lr}
 8008542:	b085      	sub	sp, #20
 8008544:	9003      	str	r0, [sp, #12]
 8008546:	9102      	str	r1, [sp, #8]
 8008548:	9201      	str	r2, [sp, #4]
  spiExchange(&SPID2, bufferLen, txBuffer, rxBuffer);
 800854a:	9b02      	ldr	r3, [sp, #8]
 800854c:	9a03      	ldr	r2, [sp, #12]
 800854e:	9901      	ldr	r1, [sp, #4]
 8008550:	4802      	ldr	r0, [pc, #8]	; (800855c <TransferIcMU+0x1c>)
 8008552:	f002 fbe5 	bl	800ad20 <spiExchange>
}
 8008556:	b005      	add	sp, #20
 8008558:	f85d fb04 	ldr.w	pc, [sp], #4
 800855c:	20000eec 	.word	0x20000eec

08008560 <_ZL7Thread2Pv>:
/*===========================================================================*/
/* Shell Handler thread to spawn a shell                                                             */
/*===========================================================================*/

static THD_WORKING_AREA(waThread2, 2048);
static THD_FUNCTION(Thread2, arg) {
 8008560:	b500      	push	{lr}
 8008562:	b087      	sub	sp, #28
 8008564:	9003      	str	r0, [sp, #12]
  (void)arg;
  chRegSetThreadName("shell_handler");
 8008566:	4813      	ldr	r0, [pc, #76]	; (80085b4 <_ZL7Thread2Pv+0x54>)
 8008568:	f7ff ff52 	bl	8008410 <_ZL18chRegSetThreadNamePKc>

  while (true){
    if (SDU1.config->usbp->state == USB_ACTIVE) {
 800856c:	4b12      	ldr	r3, [pc, #72]	; (80085b8 <_ZL7Thread2Pv+0x58>)
 800856e:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 8008572:	681b      	ldr	r3, [r3, #0]
 8008574:	781b      	ldrb	r3, [r3, #0]
 8008576:	2b04      	cmp	r3, #4
 8008578:	d116      	bne.n	80085a8 <_ZL7Thread2Pv+0x48>
                palSetLine(LINE_LED5);
 800857a:	4b10      	ldr	r3, [pc, #64]	; (80085bc <_ZL7Thread2Pv+0x5c>)
 800857c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8008580:	831a      	strh	r2, [r3, #24]
                thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
                                                        "shell", NORMALPRIO + 1,
                                                        shellThread, (void *)&shell_cfg1);
 8008582:	4b0f      	ldr	r3, [pc, #60]	; (80085c0 <_ZL7Thread2Pv+0x60>)
 8008584:	9301      	str	r3, [sp, #4]
 8008586:	4b0f      	ldr	r3, [pc, #60]	; (80085c4 <_ZL7Thread2Pv+0x64>)
 8008588:	9300      	str	r3, [sp, #0]
 800858a:	2381      	movs	r3, #129	; 0x81
 800858c:	4a0e      	ldr	r2, [pc, #56]	; (80085c8 <_ZL7Thread2Pv+0x68>)
 800858e:	f640 01c8 	movw	r1, #2248	; 0x8c8
 8008592:	2000      	movs	r0, #0
 8008594:	f00a f814 	bl	80125c0 <chThdCreateFromHeap>
 8008598:	9005      	str	r0, [sp, #20]
                chThdWait(shelltp);               // Waiting termination.
 800859a:	9805      	ldr	r0, [sp, #20]
 800859c:	f008 f8a8 	bl	80106f0 <chThdWait>
                palClearLine(LINE_LED5);
 80085a0:	4b06      	ldr	r3, [pc, #24]	; (80085bc <_ZL7Thread2Pv+0x5c>)
 80085a2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80085a6:	835a      	strh	r2, [r3, #26]
    }
    chThdSleepMilliseconds(1000);
 80085a8:	f242 7010 	movw	r0, #10000	; 0x2710
 80085ac:	f008 f930 	bl	8010810 <chThdSleep>
 80085b0:	e7dc      	b.n	800856c <_ZL7Thread2Pv+0xc>
 80085b2:	bf00      	nop
 80085b4:	08018d50 	.word	0x08018d50
 80085b8:	20002178 	.word	0x20002178
 80085bc:	40020c00 	.word	0x40020c00
 80085c0:	08018be0 	.word	0x08018be0
 80085c4:	08014a91 	.word	0x08014a91
 80085c8:	08018d60 	.word	0x08018d60
 80085cc:	00000000 	.word	0x00000000

080085d0 <_ZL7Thread1Pv>:

/* =============================================================================
 * USB com status blinker thread, times are in milliseconds.
 ===============================================================================*/
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 80085d0:	b570      	push	{r4, r5, r6, lr}
 80085d2:	b084      	sub	sp, #16
 80085d4:	9001      	str	r0, [sp, #4]
  (void)arg;
  chRegSetThreadName("com_status");
 80085d6:	4858      	ldr	r0, [pc, #352]	; (8008738 <_ZL7Thread1Pv+0x168>)
 80085d8:	f7ff ff1a 	bl	8008410 <_ZL18chRegSetThreadNamePKc>
  while (true) {
    systime_t time;
    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 1000;
 80085dc:	4b57      	ldr	r3, [pc, #348]	; (800873c <_ZL7Thread1Pv+0x16c>)
 80085de:	681b      	ldr	r3, [r3, #0]
 80085e0:	781b      	ldrb	r3, [r3, #0]
 80085e2:	2b04      	cmp	r3, #4
 80085e4:	d101      	bne.n	80085ea <_ZL7Thread1Pv+0x1a>
 80085e6:	23fa      	movs	r3, #250	; 0xfa
 80085e8:	e001      	b.n	80085ee <_ZL7Thread1Pv+0x1e>
 80085ea:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80085ee:	9303      	str	r3, [sp, #12]
    palClearLine(LINE_LED3);
 80085f0:	4b53      	ldr	r3, [pc, #332]	; (8008740 <_ZL7Thread1Pv+0x170>)
 80085f2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80085f6:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(time);
 80085f8:	9b03      	ldr	r3, [sp, #12]
 80085fa:	461d      	mov	r5, r3
 80085fc:	f04f 0600 	mov.w	r6, #0
 8008600:	462b      	mov	r3, r5
 8008602:	4634      	mov	r4, r6
 8008604:	f04f 0100 	mov.w	r1, #0
 8008608:	f04f 0200 	mov.w	r2, #0
 800860c:	00a2      	lsls	r2, r4, #2
 800860e:	ea42 7293 	orr.w	r2, r2, r3, lsr #30
 8008612:	0099      	lsls	r1, r3, #2
 8008614:	460b      	mov	r3, r1
 8008616:	4614      	mov	r4, r2
 8008618:	195b      	adds	r3, r3, r5
 800861a:	eb44 0406 	adc.w	r4, r4, r6
 800861e:	f04f 0100 	mov.w	r1, #0
 8008622:	f04f 0200 	mov.w	r2, #0
 8008626:	00e2      	lsls	r2, r4, #3
 8008628:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 800862c:	00d9      	lsls	r1, r3, #3
 800862e:	460b      	mov	r3, r1
 8008630:	4614      	mov	r4, r2
 8008632:	1b5b      	subs	r3, r3, r5
 8008634:	eb64 0406 	sbc.w	r4, r4, r6
 8008638:	f04f 0100 	mov.w	r1, #0
 800863c:	f04f 0200 	mov.w	r2, #0
 8008640:	0122      	lsls	r2, r4, #4
 8008642:	ea42 7213 	orr.w	r2, r2, r3, lsr #28
 8008646:	0119      	lsls	r1, r3, #4
 8008648:	460b      	mov	r3, r1
 800864a:	4614      	mov	r4, r2
 800864c:	195b      	adds	r3, r3, r5
 800864e:	eb44 0406 	adc.w	r4, r4, r6
 8008652:	f04f 0100 	mov.w	r1, #0
 8008656:	f04f 0200 	mov.w	r2, #0
 800865a:	0122      	lsls	r2, r4, #4
 800865c:	ea42 7213 	orr.w	r2, r2, r3, lsr #28
 8008660:	0119      	lsls	r1, r3, #4
 8008662:	460b      	mov	r3, r1
 8008664:	4614      	mov	r4, r2
 8008666:	4619      	mov	r1, r3
 8008668:	4622      	mov	r2, r4
 800866a:	f240 33e7 	movw	r3, #999	; 0x3e7
 800866e:	f04f 0400 	mov.w	r4, #0
 8008672:	18cd      	adds	r5, r1, r3
 8008674:	eb42 0604 	adc.w	r6, r2, r4
 8008678:	4628      	mov	r0, r5
 800867a:	4631      	mov	r1, r6
 800867c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8008680:	f04f 0300 	mov.w	r3, #0
 8008684:	f7f8 f85a 	bl	800073c <__aeabi_uldivmod>
 8008688:	4603      	mov	r3, r0
 800868a:	460c      	mov	r4, r1
 800868c:	4618      	mov	r0, r3
 800868e:	f008 f8bf 	bl	8010810 <chThdSleep>
    palSetLine(LINE_LED3);
 8008692:	4b2b      	ldr	r3, [pc, #172]	; (8008740 <_ZL7Thread1Pv+0x170>)
 8008694:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8008698:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(time);
 800869a:	9b03      	ldr	r3, [sp, #12]
 800869c:	461d      	mov	r5, r3
 800869e:	f04f 0600 	mov.w	r6, #0
 80086a2:	462b      	mov	r3, r5
 80086a4:	4634      	mov	r4, r6
 80086a6:	f04f 0100 	mov.w	r1, #0
 80086aa:	f04f 0200 	mov.w	r2, #0
 80086ae:	00a2      	lsls	r2, r4, #2
 80086b0:	ea42 7293 	orr.w	r2, r2, r3, lsr #30
 80086b4:	0099      	lsls	r1, r3, #2
 80086b6:	460b      	mov	r3, r1
 80086b8:	4614      	mov	r4, r2
 80086ba:	195b      	adds	r3, r3, r5
 80086bc:	eb44 0406 	adc.w	r4, r4, r6
 80086c0:	f04f 0100 	mov.w	r1, #0
 80086c4:	f04f 0200 	mov.w	r2, #0
 80086c8:	00e2      	lsls	r2, r4, #3
 80086ca:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 80086ce:	00d9      	lsls	r1, r3, #3
 80086d0:	460b      	mov	r3, r1
 80086d2:	4614      	mov	r4, r2
 80086d4:	1b5b      	subs	r3, r3, r5
 80086d6:	eb64 0406 	sbc.w	r4, r4, r6
 80086da:	f04f 0100 	mov.w	r1, #0
 80086de:	f04f 0200 	mov.w	r2, #0
 80086e2:	0122      	lsls	r2, r4, #4
 80086e4:	ea42 7213 	orr.w	r2, r2, r3, lsr #28
 80086e8:	0119      	lsls	r1, r3, #4
 80086ea:	460b      	mov	r3, r1
 80086ec:	4614      	mov	r4, r2
 80086ee:	195b      	adds	r3, r3, r5
 80086f0:	eb44 0406 	adc.w	r4, r4, r6
 80086f4:	f04f 0100 	mov.w	r1, #0
 80086f8:	f04f 0200 	mov.w	r2, #0
 80086fc:	0122      	lsls	r2, r4, #4
 80086fe:	ea42 7213 	orr.w	r2, r2, r3, lsr #28
 8008702:	0119      	lsls	r1, r3, #4
 8008704:	460b      	mov	r3, r1
 8008706:	4614      	mov	r4, r2
 8008708:	4619      	mov	r1, r3
 800870a:	4622      	mov	r2, r4
 800870c:	f240 33e7 	movw	r3, #999	; 0x3e7
 8008710:	f04f 0400 	mov.w	r4, #0
 8008714:	18cd      	adds	r5, r1, r3
 8008716:	eb42 0604 	adc.w	r6, r2, r4
 800871a:	4628      	mov	r0, r5
 800871c:	4631      	mov	r1, r6
 800871e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8008722:	f04f 0300 	mov.w	r3, #0
 8008726:	f7f8 f809 	bl	800073c <__aeabi_uldivmod>
 800872a:	4603      	mov	r3, r0
 800872c:	460c      	mov	r4, r1
 800872e:	4618      	mov	r0, r3
 8008730:	f008 f86e 	bl	8010810 <chThdSleep>
 8008734:	e752      	b.n	80085dc <_ZL7Thread1Pv+0xc>
 8008736:	bf00      	nop
 8008738:	08018d68 	.word	0x08018d68
 800873c:	08018d34 	.word	0x08018d34
 8008740:	40020c00 	.word	0x40020c00
	...

08008750 <_ZL7Thread3Pv>:

/*=============================================================================
 * LED blinker heartbeat thread, times are in milliseconds.
 =============================================================================*/
static THD_WORKING_AREA(waThread3, 128);
static THD_FUNCTION(Thread3, arg) {
 8008750:	b500      	push	{lr}
 8008752:	b083      	sub	sp, #12
 8008754:	9001      	str	r0, [sp, #4]
  (void)arg;
  chRegSetThreadName("blinker");
 8008756:	480a      	ldr	r0, [pc, #40]	; (8008780 <_ZL7Thread3Pv+0x30>)
 8008758:	f7ff fe5a 	bl	8008410 <_ZL18chRegSetThreadNamePKc>
  while (true) {
    palClearPad(GPIOD, GPIOD_LED4);
 800875c:	4b09      	ldr	r3, [pc, #36]	; (8008784 <_ZL7Thread3Pv+0x34>)
 800875e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8008762:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(800);
 8008764:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
 8008768:	f008 f852 	bl	8010810 <chThdSleep>
    palSetPad(GPIOD, GPIOD_LED4);
 800876c:	4b05      	ldr	r3, [pc, #20]	; (8008784 <_ZL7Thread3Pv+0x34>)
 800876e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8008772:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(200);
 8008774:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8008778:	f008 f84a 	bl	8010810 <chThdSleep>
 800877c:	e7ee      	b.n	800875c <_ZL7Thread3Pv+0xc>
 800877e:	bf00      	nop
 8008780:	08018d74 	.word	0x08018d74
 8008784:	40020c00 	.word	0x40020c00
	...

08008790 <main>:


/*
 * Application entry point.
 */
int main(void) {
 8008790:	b530      	push	{r4, r5, lr}
 8008792:	b089      	sub	sp, #36	; 0x24
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */

  halInit();
 8008794:	f000 f994 	bl	8008ac0 <halInit>
  //chSysInit();
  System::init();
 8008798:	f7ff fe4a 	bl	8008430 <_ZN10chibios_rt6System4initEv>

  // Initializes a serial-over-USB CDC driver./
  sduObjectInit(&SDU1);
 800879c:	4871      	ldr	r0, [pc, #452]	; (8008964 <main+0x1d4>)
 800879e:	f001 ff67 	bl	800a670 <sduObjectInit>
  sduStart(&SDU1, &serusbcfg);
 80087a2:	4971      	ldr	r1, [pc, #452]	; (8008968 <main+0x1d8>)
 80087a4:	486f      	ldr	r0, [pc, #444]	; (8008964 <main+0x1d4>)
 80087a6:	f001 ffa3 	bl	800a6f0 <sduStart>

  /** Activates the USB driver and then the USB bus pull-up on D+.
       * Note, a delay is inserted in order to not have to disconnect the cable
       * after a reset.
       */
  usbDisconnectBus(serusbcfg.usbp);
 80087aa:	4b6f      	ldr	r3, [pc, #444]	; (8008968 <main+0x1d8>)
 80087ac:	681b      	ldr	r3, [r3, #0]
 80087ae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80087b0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80087b2:	4b6d      	ldr	r3, [pc, #436]	; (8008968 <main+0x1d8>)
 80087b4:	681b      	ldr	r3, [r3, #0]
 80087b6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80087b8:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 80087bc:	639a      	str	r2, [r3, #56]	; 0x38
  chThdSleepMilliseconds(1500);
 80087be:	f643 2098 	movw	r0, #15000	; 0x3a98
 80087c2:	f008 f825 	bl	8010810 <chThdSleep>
  usbStart(serusbcfg.usbp, &usbcfg);
 80087c6:	4b68      	ldr	r3, [pc, #416]	; (8008968 <main+0x1d8>)
 80087c8:	681b      	ldr	r3, [r3, #0]
 80087ca:	4968      	ldr	r1, [pc, #416]	; (800896c <main+0x1dc>)
 80087cc:	4618      	mov	r0, r3
 80087ce:	f002 fddf 	bl	800b390 <usbStart>
  usbConnectBus(serusbcfg.usbp);
 80087d2:	4b65      	ldr	r3, [pc, #404]	; (8008968 <main+0x1d8>)
 80087d4:	681b      	ldr	r3, [r3, #0]
 80087d6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80087d8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80087da:	4b63      	ldr	r3, [pc, #396]	; (8008968 <main+0x1d8>)
 80087dc:	681b      	ldr	r3, [r3, #0]
 80087de:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80087e0:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 80087e4:	639a      	str	r2, [r3, #56]	; 0x38

  // Shell manager initialization.
  shellInit();
 80087e6:	f00c fa23 	bl	8014c30 <shellInit>

  //Initialize pads and AF(Alternate functions) for PWM
  palSetPadMode(GPIOA, 8, PAL_MODE_ALTERNATE(1)); //PWM on PA8(dico) or D7(nucleo/arduino header)
 80087ea:	2282      	movs	r2, #130	; 0x82
 80087ec:	f44f 7180 	mov.w	r1, #256	; 0x100
 80087f0:	485f      	ldr	r0, [pc, #380]	; (8008970 <main+0x1e0>)
 80087f2:	f003 fec5 	bl	800c580 <_pal_lld_setgroupmode>
  //Initialize pads and AF for Serial UART 2 */
  palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));
 80087f6:	f240 3282 	movw	r2, #898	; 0x382
 80087fa:	2104      	movs	r1, #4
 80087fc:	485c      	ldr	r0, [pc, #368]	; (8008970 <main+0x1e0>)
 80087fe:	f003 febf 	bl	800c580 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));
 8008802:	f240 3282 	movw	r2, #898	; 0x382
 8008806:	2108      	movs	r1, #8
 8008808:	4859      	ldr	r0, [pc, #356]	; (8008970 <main+0x1e0>)
 800880a:	f003 feb9 	bl	800c580 <_pal_lld_setgroupmode>
  /*Initialize pads and AF for SPI */
  palSetPadMode(PORT_SPI2_SCK, PIN_SPI2_SCK,PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);    /* New SCK */
 800880e:	f240 229a 	movw	r2, #666	; 0x29a
 8008812:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8008816:	4857      	ldr	r0, [pc, #348]	; (8008974 <main+0x1e4>)
 8008818:	f003 feb2 	bl	800c580 <_pal_lld_setgroupmode>
  palSetPadMode(PORT_SPI2_MISO, PIN_SPI2_MISO,PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);    /* New MISO*/
 800881c:	f240 229a 	movw	r2, #666	; 0x29a
 8008820:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8008824:	4853      	ldr	r0, [pc, #332]	; (8008974 <main+0x1e4>)
 8008826:	f003 feab 	bl	800c580 <_pal_lld_setgroupmode>
  palSetPadMode(PORT_SPI2_MOSI, PIN_SPI2_MOSI, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);    /* New MOSI*/
 800882a:	f240 229a 	movw	r2, #666	; 0x29a
 800882e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8008832:	4850      	ldr	r0, [pc, #320]	; (8008974 <main+0x1e4>)
 8008834:	f003 fea4 	bl	800c580 <_pal_lld_setgroupmode>
  palSetPadMode(PORT_SPI2_CS, PIN_SPI2_CS, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);//PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST); /* New CS*/
 8008838:	2219      	movs	r2, #25
 800883a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800883e:	484d      	ldr	r0, [pc, #308]	; (8008974 <main+0x1e4>)
 8008840:	f003 fe9e 	bl	800c580 <_pal_lld_setgroupmode>

  //Start Serial on UART 2
  sdStart(&SD2, NULL);
 8008844:	2100      	movs	r1, #0
 8008846:	484c      	ldr	r0, [pc, #304]	; (8008978 <main+0x1e8>)
 8008848:	f001 fc92 	bl	800a170 <sdStart>
  //Start PWM
  pwmStart(&PWMD1, &pwmcfg);
 800884c:	494b      	ldr	r1, [pc, #300]	; (800897c <main+0x1ec>)
 800884e:	484c      	ldr	r0, [pc, #304]	; (8008980 <main+0x1f0>)
 8008850:	f001 fa76 	bl	8009d40 <pwmStart>
  //Start SPI
  spiStart(&SPID2, &cs_spicfg); //Power Up the clock signal and start the driver
 8008854:	494b      	ldr	r1, [pc, #300]	; (8008984 <main+0x1f4>)
 8008856:	484c      	ldr	r0, [pc, #304]	; (8008988 <main+0x1f8>)
 8008858:	f002 f9e2 	bl	800ac20 <spiStart>
  //Confirm boot to the computer
  sdWriteTimeout(&SD2, (uint8_t*)"\r\n!System Initialized!\r\n", 25, TIME_MS2I(50));
 800885c:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8008860:	2219      	movs	r2, #25
 8008862:	494a      	ldr	r1, [pc, #296]	; (800898c <main+0x1fc>)
 8008864:	484a      	ldr	r0, [pc, #296]	; (8008990 <main+0x200>)
 8008866:	f001 f9c3 	bl	8009bf0 <oqWriteTimeout>


  //Start PWM
  pwmChangePeriod(&PWMD1, 500);
 800886a:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800886e:	4844      	ldr	r0, [pc, #272]	; (8008980 <main+0x1f0>)
 8008870:	f001 fa9e 	bl	8009db0 <pwmChangePeriod>
  /*always call a pwmEnableChanel after a PeriodChange because according to doc: "If a period is specified that is shorter than the pulse width
    *          programmed in one of the channels then the behavior is not;
    *          guaranteed." */
  pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, 5000));
 8008874:	4b42      	ldr	r3, [pc, #264]	; (8008980 <main+0x1f0>)
 8008876:	689b      	ldr	r3, [r3, #8]
 8008878:	f241 3288 	movw	r2, #5000	; 0x1388
 800887c:	fb02 f303 	mul.w	r3, r2, r3
 8008880:	4a44      	ldr	r2, [pc, #272]	; (8008994 <main+0x204>)
 8008882:	fba2 2303 	umull	r2, r3, r2, r3
 8008886:	0b5b      	lsrs	r3, r3, #13
 8008888:	461a      	mov	r2, r3
 800888a:	2100      	movs	r1, #0
 800888c:	483c      	ldr	r0, [pc, #240]	; (8008980 <main+0x1f0>)
 800888e:	f001 fab7 	bl	8009e00 <pwmEnableChannel>

  // Creates the usb status blinker thread.
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8008892:	2300      	movs	r3, #0
 8008894:	9300      	str	r3, [sp, #0]
 8008896:	4b40      	ldr	r3, [pc, #256]	; (8008998 <main+0x208>)
 8008898:	2280      	movs	r2, #128	; 0x80
 800889a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800889e:	483f      	ldr	r0, [pc, #252]	; (800899c <main+0x20c>)
 80088a0:	f007 fe1e 	bl	80104e0 <chThdCreateStatic>
  // Creates the shell spawning thread.
  chThdCreateStatic(waThread2, sizeof(waThread2), LOWPRIO, Thread2, NULL);
 80088a4:	2300      	movs	r3, #0
 80088a6:	9300      	str	r3, [sp, #0]
 80088a8:	4b3d      	ldr	r3, [pc, #244]	; (80089a0 <main+0x210>)
 80088aa:	2202      	movs	r2, #2
 80088ac:	f640 01c8 	movw	r1, #2248	; 0x8c8
 80088b0:	483c      	ldr	r0, [pc, #240]	; (80089a4 <main+0x214>)
 80088b2:	f007 fe15 	bl	80104e0 <chThdCreateStatic>
  //Create the heartbeat thread
  chThdCreateStatic(waThread3, sizeof(waThread3), NORMALPRIO, Thread3, NULL);
 80088b6:	2300      	movs	r3, #0
 80088b8:	9300      	str	r3, [sp, #0]
 80088ba:	4b3b      	ldr	r3, [pc, #236]	; (80089a8 <main+0x218>)
 80088bc:	2280      	movs	r2, #128	; 0x80
 80088be:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80088c2:	483a      	ldr	r0, [pc, #232]	; (80089ac <main+0x21c>)
 80088c4:	f007 fe0c 	bl	80104e0 <chThdCreateStatic>

  ///Init encoder;
  encoder.csFunctionAttach(ChangeCS);
 80088c8:	4939      	ldr	r1, [pc, #228]	; (80089b0 <main+0x220>)
 80088ca:	483a      	ldr	r0, [pc, #232]	; (80089b4 <main+0x224>)
 80088cc:	f7ff f9b8 	bl	8007c40 <_ZN8IcHausMu16csFunctionAttachEPFvbE>
  encoder.streamFunctionAttach(TransferIcMU);
 80088d0:	4939      	ldr	r1, [pc, #228]	; (80089b8 <main+0x228>)
 80088d2:	4838      	ldr	r0, [pc, #224]	; (80089b4 <main+0x224>)
 80088d4:	f7ff f9c4 	bl	8007c60 <_ZN8IcHausMu20streamFunctionAttachEPFvPhS0_jE>



  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON)) {
 80088d8:	4b25      	ldr	r3, [pc, #148]	; (8008970 <main+0x1e0>)
 80088da:	691b      	ldr	r3, [r3, #16]
 80088dc:	f003 0301 	and.w	r3, r3, #1
 80088e0:	2b00      	cmp	r3, #0
 80088e2:	bf14      	ite	ne
 80088e4:	2301      	movne	r3, #1
 80088e6:	2300      	moveq	r3, #0
 80088e8:	b2db      	uxtb	r3, r3
 80088ea:	2b00      	cmp	r3, #0
 80088ec:	d034      	beq.n	8008958 <main+0x1c8>
        fctStatus init_encoder = encoder.init();
 80088ee:	4831      	ldr	r0, [pc, #196]	; (80089b4 <main+0x224>)
 80088f0:	f7ff fb8e 	bl	8008010 <_ZN8IcHausMu4initEv>
 80088f4:	4603      	mov	r3, r0
 80088f6:	f88d 301f 	strb.w	r3, [sp, #31]
        encoder.setAutomaticGain(true);
 80088fa:	2101      	movs	r1, #1
 80088fc:	482d      	ldr	r0, [pc, #180]	; (80089b4 <main+0x224>)
 80088fe:	f7ff fbcf 	bl	80080a0 <_ZN8IcHausMu16setAutomaticGainEh>

        sdWriteTimeout(&SD2, (uint8_t*)"Enc status:\r\n", 13, TIME_MS2I(50)); //Example to write a frame on UART 2
 8008902:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8008906:	220d      	movs	r2, #13
 8008908:	492c      	ldr	r1, [pc, #176]	; (80089bc <main+0x22c>)
 800890a:	4821      	ldr	r0, [pc, #132]	; (8008990 <main+0x200>)
 800890c:	f001 f970 	bl	8009bf0 <oqWriteTimeout>
        sdPutTimeout(&SD2, (int8_t)init_encoder,TIME_MS2I(50)); //Example to write a single byte on UART 2
 8008910:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8008914:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8008918:	4619      	mov	r1, r3
 800891a:	481d      	ldr	r0, [pc, #116]	; (8008990 <main+0x200>)
 800891c:	f001 f8e0 	bl	8009ae0 <oqPutTimeout>
        sdPutTimeout(&SD2, (int8_t)'\n',TIME_MS2I(50));
 8008920:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8008924:	210a      	movs	r1, #10
 8008926:	481a      	ldr	r0, [pc, #104]	; (8008990 <main+0x200>)
 8008928:	f001 f8da 	bl	8009ae0 <oqPutTimeout>

        basicSpiComTest(); //example to call a function of a C++ library
 800892c:	f7ff fda0 	bl	8008470 <basicSpiComTest>
        sdPutTimeout(&SD2, (int8_t)'t',TIME_MS2I(50));
 8008930:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8008934:	2174      	movs	r1, #116	; 0x74
 8008936:	4816      	ldr	r0, [pc, #88]	; (8008990 <main+0x200>)
 8008938:	f001 f8d2 	bl	8009ae0 <oqPutTimeout>
        uint8_t msg[] = "\r\nD: SPI frame sent";
 800893c:	4b20      	ldr	r3, [pc, #128]	; (80089c0 <main+0x230>)
 800893e:	ac02      	add	r4, sp, #8
 8008940:	461d      	mov	r5, r3
 8008942:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8008944:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8008946:	682b      	ldr	r3, [r5, #0]
 8008948:	6023      	str	r3, [r4, #0]
        chnWrite(&SDU1, msg, sizeof msg); //Example to send Debug Message on the VCP (Virtual Com Port
 800894a:	4b06      	ldr	r3, [pc, #24]	; (8008964 <main+0x1d4>)
 800894c:	681b      	ldr	r3, [r3, #0]
 800894e:	685b      	ldr	r3, [r3, #4]
 8008950:	a902      	add	r1, sp, #8
 8008952:	2214      	movs	r2, #20
 8008954:	4803      	ldr	r0, [pc, #12]	; (8008964 <main+0x1d4>)
 8008956:	4798      	blx	r3
    }

    BaseThread::sleep(TIME_MS2I(200)); //chThdSleepMilliseconds(200) in C;
 8008958:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 800895c:	f7ff fd70 	bl	8008440 <_ZN10chibios_rt10BaseThread5sleepEm>
 8008960:	e7ba      	b.n	80088d8 <main+0x148>
 8008962:	bf00      	nop
 8008964:	20002178 	.word	0x20002178
 8008968:	08018d34 	.word	0x08018d34
 800896c:	08018d24 	.word	0x08018d24
 8008970:	40020000 	.word	0x40020000
 8008974:	40020400 	.word	0x40020400
 8008978:	20000f38 	.word	0x20000f38
 800897c:	20000d28 	.word	0x20000d28
 8008980:	20000f1c 	.word	0x20000f1c
 8008984:	08018d3c 	.word	0x08018d3c
 8008988:	20000eec 	.word	0x20000eec
 800898c:	08018d7c 	.word	0x08018d7c
 8008990:	20000f68 	.word	0x20000f68
 8008994:	d1b71759 	.word	0xd1b71759
 8008998:	080085d1 	.word	0x080085d1
 800899c:	20003038 	.word	0x20003038
 80089a0:	08008561 	.word	0x08008561
 80089a4:	20002770 	.word	0x20002770
 80089a8:	08008751 	.word	0x08008751
 80089ac:	20003180 	.word	0x20003180
 80089b0:	08008511 	.word	0x08008511
 80089b4:	20002638 	.word	0x20002638
 80089b8:	08008541 	.word	0x08008541
 80089bc:	08018d98 	.word	0x08018d98
 80089c0:	08018da8 	.word	0x08018da8
	...

080089d0 <_Z41__static_initialization_and_destruction_0ii>:
  }

  return 0;
}
 80089d0:	b500      	push	{lr}
 80089d2:	b083      	sub	sp, #12
 80089d4:	9001      	str	r0, [sp, #4]
 80089d6:	9100      	str	r1, [sp, #0]
 80089d8:	9b01      	ldr	r3, [sp, #4]
 80089da:	2b01      	cmp	r3, #1
 80089dc:	d108      	bne.n	80089f0 <_Z41__static_initialization_and_destruction_0ii+0x20>
 80089de:	9b00      	ldr	r3, [sp, #0]
 80089e0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80089e4:	4293      	cmp	r3, r2
 80089e6:	d103      	bne.n	80089f0 <_Z41__static_initialization_and_destruction_0ii+0x20>
 IcHausMu encoder(0x07);//Instanciate icMU
 80089e8:	2107      	movs	r1, #7
 80089ea:	4803      	ldr	r0, [pc, #12]	; (80089f8 <_Z41__static_initialization_and_destruction_0ii+0x28>)
 80089ec:	f7ff f8d8 	bl	8007ba0 <_ZN8IcHausMuC1Eh>
 80089f0:	b003      	add	sp, #12
 80089f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80089f6:	bf00      	nop
 80089f8:	20002638 	.word	0x20002638
 80089fc:	00000000 	.word	0x00000000

08008a00 <_GLOBAL__sub_I_test>:
 8008a00:	b508      	push	{r3, lr}
 8008a02:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8008a06:	2001      	movs	r0, #1
 8008a08:	f7ff ffe2 	bl	80089d0 <_Z41__static_initialization_and_destruction_0ii>
 8008a0c:	bd08      	pop	{r3, pc}
 8008a0e:	bf00      	nop

08008a10 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8008a10:	4770      	bx	lr
 8008a12:	bf00      	nop
	...

08008a20 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8008a20:	4770      	bx	lr
 8008a22:	bf00      	nop
	...

08008a30 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8008a30:	e7fe      	b.n	8008a30 <__default_exit>
 8008a32:	bf00      	nop
	...

08008a40 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8008a40:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8008a42:	4b16      	ldr	r3, [pc, #88]	; (8008a9c <__init_ram_areas+0x5c>)
 8008a44:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8008a46:	9b03      	ldr	r3, [sp, #12]
 8008a48:	681b      	ldr	r3, [r3, #0]
 8008a4a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 8008a4c:	9b03      	ldr	r3, [sp, #12]
 8008a4e:	685b      	ldr	r3, [r3, #4]
 8008a50:	9301      	str	r3, [sp, #4]
 8008a52:	e009      	b.n	8008a68 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8008a54:	9b02      	ldr	r3, [sp, #8]
 8008a56:	681a      	ldr	r2, [r3, #0]
 8008a58:	9b01      	ldr	r3, [sp, #4]
 8008a5a:	601a      	str	r2, [r3, #0]
      p++;
 8008a5c:	9b01      	ldr	r3, [sp, #4]
 8008a5e:	3304      	adds	r3, #4
 8008a60:	9301      	str	r3, [sp, #4]
      tp++;
 8008a62:	9b02      	ldr	r3, [sp, #8]
 8008a64:	3304      	adds	r3, #4
 8008a66:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8008a68:	9b03      	ldr	r3, [sp, #12]
 8008a6a:	689b      	ldr	r3, [r3, #8]
 8008a6c:	9a01      	ldr	r2, [sp, #4]
 8008a6e:	429a      	cmp	r2, r3
 8008a70:	d3f0      	bcc.n	8008a54 <__init_ram_areas+0x14>
 8008a72:	e005      	b.n	8008a80 <__init_ram_areas+0x40>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8008a74:	9b01      	ldr	r3, [sp, #4]
 8008a76:	2200      	movs	r2, #0
 8008a78:	601a      	str	r2, [r3, #0]
      p++;
 8008a7a:	9b01      	ldr	r3, [sp, #4]
 8008a7c:	3304      	adds	r3, #4
 8008a7e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8008a80:	9b03      	ldr	r3, [sp, #12]
 8008a82:	68db      	ldr	r3, [r3, #12]
 8008a84:	9a01      	ldr	r2, [sp, #4]
 8008a86:	429a      	cmp	r2, r3
 8008a88:	d3f4      	bcc.n	8008a74 <__init_ram_areas+0x34>
    }
    rap++;
 8008a8a:	9b03      	ldr	r3, [sp, #12]
 8008a8c:	3310      	adds	r3, #16
 8008a8e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8008a90:	9b03      	ldr	r3, [sp, #12]
 8008a92:	4a03      	ldr	r2, [pc, #12]	; (8008aa0 <__init_ram_areas+0x60>)
 8008a94:	4293      	cmp	r3, r2
 8008a96:	d3d6      	bcc.n	8008a46 <__init_ram_areas+0x6>
#endif
}
 8008a98:	b004      	add	sp, #16
 8008a9a:	4770      	bx	lr
 8008a9c:	08015ad0 	.word	0x08015ad0
 8008aa0:	08015b50 	.word	0x08015b50
	...

08008ab0 <osalInit>:
}
 8008ab0:	4770      	bx	lr
 8008ab2:	bf00      	nop
	...

08008ac0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8008ac0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8008ac2:	f7ff fff5 	bl	8008ab0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8008ac6:	f003 f88b 	bl	800bbe0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 8008aca:	f003 fd51 	bl	800c570 <_pal_lld_init>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8008ace:	f001 f91f 	bl	8009d10 <pwmInit>
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8008ad2:	f001 fb15 	bl	800a100 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 8008ad6:	f002 f883 	bl	800abe0 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8008ada:	f002 fc29 	bl	800b330 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 8008ade:	f001 fdbf 	bl	800a660 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8008ae2:	f006 f825 	bl	800eb30 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8008ae6:	f000 f833 	bl	8008b50 <stInit>
#endif
}
 8008aea:	bd08      	pop	{r3, pc}
 8008aec:	0000      	movs	r0, r0
	...

08008af0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8008af0:	b082      	sub	sp, #8
 8008af2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8008af4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8008af8:	9b01      	ldr	r3, [sp, #4]
 8008afa:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8008afc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008b00:	2200      	movs	r2, #0
 8008b02:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8008b04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008b08:	2202      	movs	r2, #2
 8008b0a:	60da      	str	r2, [r3, #12]
}
 8008b0c:	b002      	add	sp, #8
 8008b0e:	4770      	bx	lr

08008b10 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8008b10:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008b14:	2200      	movs	r2, #0
 8008b16:	60da      	str	r2, [r3, #12]
}
 8008b18:	4770      	bx	lr
 8008b1a:	bf00      	nop
 8008b1c:	0000      	movs	r0, r0
	...

08008b20 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8008b20:	b082      	sub	sp, #8
 8008b22:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8008b24:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8008b28:	9b01      	ldr	r3, [sp, #4]
 8008b2a:	6353      	str	r3, [r2, #52]	; 0x34
}
 8008b2c:	b002      	add	sp, #8
 8008b2e:	4770      	bx	lr

08008b30 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8008b30:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008b34:	68db      	ldr	r3, [r3, #12]
 8008b36:	f003 0302 	and.w	r3, r3, #2
 8008b3a:	2b00      	cmp	r3, #0
 8008b3c:	bf14      	ite	ne
 8008b3e:	2301      	movne	r3, #1
 8008b40:	2300      	moveq	r3, #0
 8008b42:	b2db      	uxtb	r3, r3
}
 8008b44:	4618      	mov	r0, r3
 8008b46:	4770      	bx	lr
	...

08008b50 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8008b50:	b508      	push	{r3, lr}

  st_lld_init();
 8008b52:	f005 fb45 	bl	800e1e0 <st_lld_init>
}
 8008b56:	bd08      	pop	{r3, pc}
	...

08008b60 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8008b60:	b500      	push	{lr}
 8008b62:	b083      	sub	sp, #12
 8008b64:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8008b66:	f7ff ffe3 	bl	8008b30 <st_lld_is_alarm_active>
 8008b6a:	4603      	mov	r3, r0
 8008b6c:	2b00      	cmp	r3, #0
 8008b6e:	d002      	beq.n	8008b76 <stStartAlarm+0x16>
 8008b70:	4804      	ldr	r0, [pc, #16]	; (8008b84 <stStartAlarm+0x24>)
 8008b72:	f006 fa35 	bl	800efe0 <chSysHalt>

  st_lld_start_alarm(abstime);
 8008b76:	9801      	ldr	r0, [sp, #4]
 8008b78:	f7ff ffba 	bl	8008af0 <st_lld_start_alarm>
}
 8008b7c:	b003      	add	sp, #12
 8008b7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008b82:	bf00      	nop
 8008b84:	08015b50 	.word	0x08015b50
	...

08008b90 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8008b90:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8008b92:	f7ff ffbd 	bl	8008b10 <st_lld_stop_alarm>
}
 8008b96:	bd08      	pop	{r3, pc}
	...

08008ba0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8008ba0:	b500      	push	{lr}
 8008ba2:	b083      	sub	sp, #12
 8008ba4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8008ba6:	f7ff ffc3 	bl	8008b30 <st_lld_is_alarm_active>
 8008baa:	4603      	mov	r3, r0
 8008bac:	f083 0301 	eor.w	r3, r3, #1
 8008bb0:	b2db      	uxtb	r3, r3
 8008bb2:	2b00      	cmp	r3, #0
 8008bb4:	d002      	beq.n	8008bbc <stSetAlarm+0x1c>
 8008bb6:	4804      	ldr	r0, [pc, #16]	; (8008bc8 <stSetAlarm+0x28>)
 8008bb8:	f006 fa12 	bl	800efe0 <chSysHalt>

  st_lld_set_alarm(abstime);
 8008bbc:	9801      	ldr	r0, [sp, #4]
 8008bbe:	f7ff ffaf 	bl	8008b20 <st_lld_set_alarm>
}
 8008bc2:	b003      	add	sp, #12
 8008bc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8008bc8:	08015b60 	.word	0x08015b60
 8008bcc:	00000000 	.word	0x00000000

08008bd0 <port_lock.lto_priv.381>:
static inline void port_lock(void) {
 8008bd0:	b082      	sub	sp, #8
 8008bd2:	2320      	movs	r3, #32
 8008bd4:	9301      	str	r3, [sp, #4]
 8008bd6:	9b01      	ldr	r3, [sp, #4]
 8008bd8:	f383 8811 	msr	BASEPRI, r3
}
 8008bdc:	b002      	add	sp, #8
 8008bde:	4770      	bx	lr

08008be0 <port_unlock.lto_priv.350>:
static inline void port_unlock(void) {
 8008be0:	b082      	sub	sp, #8
 8008be2:	2300      	movs	r3, #0
 8008be4:	9301      	str	r3, [sp, #4]
 8008be6:	9b01      	ldr	r3, [sp, #4]
 8008be8:	f383 8811 	msr	BASEPRI, r3
}
 8008bec:	b002      	add	sp, #8
 8008bee:	4770      	bx	lr

08008bf0 <queue_init.lto_priv.460>:
static inline void queue_init(threads_queue_t *tqp) {
 8008bf0:	b082      	sub	sp, #8
 8008bf2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8008bf4:	9b01      	ldr	r3, [sp, #4]
 8008bf6:	9a01      	ldr	r2, [sp, #4]
 8008bf8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8008bfa:	9b01      	ldr	r3, [sp, #4]
 8008bfc:	9a01      	ldr	r2, [sp, #4]
 8008bfe:	605a      	str	r2, [r3, #4]
}
 8008c00:	b002      	add	sp, #8
 8008c02:	4770      	bx	lr
	...

08008c10 <chSysLock.lto_priv.313>:
static inline void chSysLock(void) {
 8008c10:	b508      	push	{r3, lr}
  port_lock();
 8008c12:	f7ff ffdd 	bl	8008bd0 <port_lock.lto_priv.381>
  _dbg_check_lock();
 8008c16:	f006 fb53 	bl	800f2c0 <_dbg_check_lock>
}
 8008c1a:	bd08      	pop	{r3, pc}
 8008c1c:	0000      	movs	r0, r0
	...

08008c20 <chSysUnlock.lto_priv.289>:
static inline void chSysUnlock(void) {
 8008c20:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8008c22:	f006 fb65 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008c26:	4b09      	ldr	r3, [pc, #36]	; (8008c4c <chSysUnlock.lto_priv.289+0x2c>)
 8008c28:	681b      	ldr	r3, [r3, #0]
 8008c2a:	4a08      	ldr	r2, [pc, #32]	; (8008c4c <chSysUnlock.lto_priv.289+0x2c>)
 8008c2c:	4293      	cmp	r3, r2
 8008c2e:	d00a      	beq.n	8008c46 <chSysUnlock.lto_priv.289+0x26>
 8008c30:	4b06      	ldr	r3, [pc, #24]	; (8008c4c <chSysUnlock.lto_priv.289+0x2c>)
 8008c32:	699b      	ldr	r3, [r3, #24]
 8008c34:	689a      	ldr	r2, [r3, #8]
 8008c36:	4b05      	ldr	r3, [pc, #20]	; (8008c4c <chSysUnlock.lto_priv.289+0x2c>)
 8008c38:	681b      	ldr	r3, [r3, #0]
 8008c3a:	689b      	ldr	r3, [r3, #8]
 8008c3c:	429a      	cmp	r2, r3
 8008c3e:	d202      	bcs.n	8008c46 <chSysUnlock.lto_priv.289+0x26>
 8008c40:	4803      	ldr	r0, [pc, #12]	; (8008c50 <chSysUnlock.lto_priv.289+0x30>)
 8008c42:	f006 f9cd 	bl	800efe0 <chSysHalt>
  port_unlock();
 8008c46:	f7ff ffcb 	bl	8008be0 <port_unlock.lto_priv.350>
}
 8008c4a:	bd08      	pop	{r3, pc}
 8008c4c:	20001090 	.word	0x20001090
 8008c50:	08015b90 	.word	0x08015b90
	...

08008c60 <chThdQueueObjectInit.lto_priv.457>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8008c60:	b500      	push	{lr}
 8008c62:	b083      	sub	sp, #12
 8008c64:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8008c66:	9801      	ldr	r0, [sp, #4]
 8008c68:	f7ff ffc2 	bl	8008bf0 <queue_init.lto_priv.460>
}
 8008c6c:	b003      	add	sp, #12
 8008c6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008c72:	bf00      	nop
	...

08008c80 <osalSysLock.lto_priv.274>:
static inline void osalSysLock(void) {
 8008c80:	b508      	push	{r3, lr}
  chSysLock();
 8008c82:	f7ff ffc5 	bl	8008c10 <chSysLock.lto_priv.313>
}
 8008c86:	bd08      	pop	{r3, pc}
	...

08008c90 <osalSysUnlock.lto_priv.265>:
static inline void osalSysUnlock(void) {
 8008c90:	b508      	push	{r3, lr}
  chSysUnlock();
 8008c92:	f7ff ffc5 	bl	8008c20 <chSysUnlock.lto_priv.289>
}
 8008c96:	bd08      	pop	{r3, pc}
	...

08008ca0 <osalThreadQueueObjectInit.lto_priv.632>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8008ca0:	b500      	push	{lr}
 8008ca2:	b083      	sub	sp, #12
 8008ca4:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8008ca6:	9801      	ldr	r0, [sp, #4]
 8008ca8:	f7ff ffda 	bl	8008c60 <chThdQueueObjectInit.lto_priv.457>
}
 8008cac:	b003      	add	sp, #12
 8008cae:	f85d fb04 	ldr.w	pc, [sp], #4
 8008cb2:	bf00      	nop
	...

08008cc0 <osalThreadEnqueueTimeoutS.lto_priv.630>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {
 8008cc0:	b500      	push	{lr}
 8008cc2:	b083      	sub	sp, #12
 8008cc4:	9001      	str	r0, [sp, #4]
 8008cc6:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, timeout);
 8008cc8:	9900      	ldr	r1, [sp, #0]
 8008cca:	9801      	ldr	r0, [sp, #4]
 8008ccc:	f007 fe50 	bl	8010970 <chThdEnqueueTimeoutS>
 8008cd0:	4603      	mov	r3, r0
}
 8008cd2:	4618      	mov	r0, r3
 8008cd4:	b003      	add	sp, #12
 8008cd6:	f85d fb04 	ldr.w	pc, [sp], #4
 8008cda:	bf00      	nop
 8008cdc:	0000      	movs	r0, r0
	...

08008ce0 <osalThreadDequeueNextI.lto_priv.628>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8008ce0:	b500      	push	{lr}
 8008ce2:	b083      	sub	sp, #12
 8008ce4:	9001      	str	r0, [sp, #4]
 8008ce6:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8008ce8:	9900      	ldr	r1, [sp, #0]
 8008cea:	9801      	ldr	r0, [sp, #4]
 8008cec:	f007 fe60 	bl	80109b0 <chThdDequeueNextI>
}
 8008cf0:	b003      	add	sp, #12
 8008cf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8008cf6:	bf00      	nop
	...

08008d00 <osalThreadDequeueAllI.lto_priv.614>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8008d00:	b500      	push	{lr}
 8008d02:	b083      	sub	sp, #12
 8008d04:	9001      	str	r0, [sp, #4]
 8008d06:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 8008d08:	9900      	ldr	r1, [sp, #0]
 8008d0a:	9801      	ldr	r0, [sp, #4]
 8008d0c:	f007 fe68 	bl	80109e0 <chThdDequeueAllI>
}
 8008d10:	b003      	add	sp, #12
 8008d12:	f85d fb04 	ldr.w	pc, [sp], #4
 8008d16:	bf00      	nop
	...

08008d20 <ibqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, bool suspended, uint8_t *bp,
                   size_t size, size_t n, bqnotify_t infy, void *link) {
 8008d20:	b500      	push	{lr}
 8008d22:	b085      	sub	sp, #20
 8008d24:	9003      	str	r0, [sp, #12]
 8008d26:	9201      	str	r2, [sp, #4]
 8008d28:	9300      	str	r3, [sp, #0]
 8008d2a:	460b      	mov	r3, r1
 8008d2c:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));
 8008d30:	9b03      	ldr	r3, [sp, #12]
 8008d32:	2b00      	cmp	r3, #0
 8008d34:	d005      	beq.n	8008d42 <ibqObjectInit+0x22>
 8008d36:	9b01      	ldr	r3, [sp, #4]
 8008d38:	2b00      	cmp	r3, #0
 8008d3a:	d002      	beq.n	8008d42 <ibqObjectInit+0x22>
 8008d3c:	9b00      	ldr	r3, [sp, #0]
 8008d3e:	2b01      	cmp	r3, #1
 8008d40:	d802      	bhi.n	8008d48 <ibqObjectInit+0x28>
 8008d42:	481b      	ldr	r0, [pc, #108]	; (8008db0 <ibqObjectInit+0x90>)
 8008d44:	f006 f94c 	bl	800efe0 <chSysHalt>

  osalThreadQueueObjectInit(&ibqp->waiting);
 8008d48:	9b03      	ldr	r3, [sp, #12]
 8008d4a:	4618      	mov	r0, r3
 8008d4c:	f7ff ffa8 	bl	8008ca0 <osalThreadQueueObjectInit.lto_priv.632>
  ibqp->suspended = suspended;
 8008d50:	9b03      	ldr	r3, [sp, #12]
 8008d52:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8008d56:	721a      	strb	r2, [r3, #8]
  ibqp->bcounter  = 0;
 8008d58:	9b03      	ldr	r3, [sp, #12]
 8008d5a:	2200      	movs	r2, #0
 8008d5c:	60da      	str	r2, [r3, #12]
  ibqp->brdptr    = bp;
 8008d5e:	9b03      	ldr	r3, [sp, #12]
 8008d60:	9a01      	ldr	r2, [sp, #4]
 8008d62:	615a      	str	r2, [r3, #20]
  ibqp->bwrptr    = bp;
 8008d64:	9b03      	ldr	r3, [sp, #12]
 8008d66:	9a01      	ldr	r2, [sp, #4]
 8008d68:	611a      	str	r2, [r3, #16]
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8008d6a:	9b00      	ldr	r3, [sp, #0]
 8008d6c:	3304      	adds	r3, #4
 8008d6e:	9a06      	ldr	r2, [sp, #24]
 8008d70:	fb02 f303 	mul.w	r3, r2, r3
 8008d74:	9a01      	ldr	r2, [sp, #4]
 8008d76:	441a      	add	r2, r3
 8008d78:	9b03      	ldr	r3, [sp, #12]
 8008d7a:	619a      	str	r2, [r3, #24]
  ibqp->bsize     = size + sizeof (size_t);
 8008d7c:	9b00      	ldr	r3, [sp, #0]
 8008d7e:	1d1a      	adds	r2, r3, #4
 8008d80:	9b03      	ldr	r3, [sp, #12]
 8008d82:	61da      	str	r2, [r3, #28]
  ibqp->bn        = n;
 8008d84:	9b03      	ldr	r3, [sp, #12]
 8008d86:	9a06      	ldr	r2, [sp, #24]
 8008d88:	621a      	str	r2, [r3, #32]
  ibqp->buffers   = bp;
 8008d8a:	9b03      	ldr	r3, [sp, #12]
 8008d8c:	9a01      	ldr	r2, [sp, #4]
 8008d8e:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->ptr       = NULL;
 8008d90:	9b03      	ldr	r3, [sp, #12]
 8008d92:	2200      	movs	r2, #0
 8008d94:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->top       = NULL;
 8008d96:	9b03      	ldr	r3, [sp, #12]
 8008d98:	2200      	movs	r2, #0
 8008d9a:	62da      	str	r2, [r3, #44]	; 0x2c
  ibqp->notify    = infy;
 8008d9c:	9b03      	ldr	r3, [sp, #12]
 8008d9e:	9a07      	ldr	r2, [sp, #28]
 8008da0:	631a      	str	r2, [r3, #48]	; 0x30
  ibqp->link      = link;
 8008da2:	9b03      	ldr	r3, [sp, #12]
 8008da4:	9a08      	ldr	r2, [sp, #32]
 8008da6:	635a      	str	r2, [r3, #52]	; 0x34
}
 8008da8:	b005      	add	sp, #20
 8008daa:	f85d fb04 	ldr.w	pc, [sp], #4
 8008dae:	bf00      	nop
 8008db0:	08015b6c 	.word	0x08015b6c
	...

08008dc0 <ibqResetI>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {
 8008dc0:	b500      	push	{lr}
 8008dc2:	b083      	sub	sp, #12
 8008dc4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8008dc6:	f006 fb1b 	bl	800f400 <chDbgCheckClassI>

  ibqp->bcounter  = 0;
 8008dca:	9b01      	ldr	r3, [sp, #4]
 8008dcc:	2200      	movs	r2, #0
 8008dce:	60da      	str	r2, [r3, #12]
  ibqp->brdptr    = ibqp->buffers;
 8008dd0:	9b01      	ldr	r3, [sp, #4]
 8008dd2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008dd4:	9b01      	ldr	r3, [sp, #4]
 8008dd6:	615a      	str	r2, [r3, #20]
  ibqp->bwrptr    = ibqp->buffers;
 8008dd8:	9b01      	ldr	r3, [sp, #4]
 8008dda:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008ddc:	9b01      	ldr	r3, [sp, #4]
 8008dde:	611a      	str	r2, [r3, #16]
  ibqp->ptr       = NULL;
 8008de0:	9b01      	ldr	r3, [sp, #4]
 8008de2:	2200      	movs	r2, #0
 8008de4:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->top       = NULL;
 8008de6:	9b01      	ldr	r3, [sp, #4]
 8008de8:	2200      	movs	r2, #0
 8008dea:	62da      	str	r2, [r3, #44]	; 0x2c
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 8008dec:	9b01      	ldr	r3, [sp, #4]
 8008dee:	f06f 0101 	mvn.w	r1, #1
 8008df2:	4618      	mov	r0, r3
 8008df4:	f7ff ff84 	bl	8008d00 <osalThreadDequeueAllI.lto_priv.614>
}
 8008df8:	b003      	add	sp, #12
 8008dfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8008dfe:	bf00      	nop

08008e00 <ibqGetEmptyBufferI>:
 * @return              A pointer to the next buffer to be filled.
 * @retval NULL         if the queue is full.
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {
 8008e00:	b500      	push	{lr}
 8008e02:	b083      	sub	sp, #12
 8008e04:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8008e06:	f006 fafb 	bl	800f400 <chDbgCheckClassI>

  if (ibqIsFullI(ibqp)) {
 8008e0a:	9b01      	ldr	r3, [sp, #4]
 8008e0c:	691a      	ldr	r2, [r3, #16]
 8008e0e:	9b01      	ldr	r3, [sp, #4]
 8008e10:	695b      	ldr	r3, [r3, #20]
 8008e12:	429a      	cmp	r2, r3
 8008e14:	d105      	bne.n	8008e22 <ibqGetEmptyBufferI+0x22>
 8008e16:	9b01      	ldr	r3, [sp, #4]
 8008e18:	68db      	ldr	r3, [r3, #12]
 8008e1a:	2b00      	cmp	r3, #0
 8008e1c:	d001      	beq.n	8008e22 <ibqGetEmptyBufferI+0x22>
 8008e1e:	2301      	movs	r3, #1
 8008e20:	e000      	b.n	8008e24 <ibqGetEmptyBufferI+0x24>
 8008e22:	2300      	movs	r3, #0
 8008e24:	f003 0301 	and.w	r3, r3, #1
 8008e28:	b2db      	uxtb	r3, r3
 8008e2a:	2b00      	cmp	r3, #0
 8008e2c:	d001      	beq.n	8008e32 <ibqGetEmptyBufferI+0x32>
    return NULL;
 8008e2e:	2300      	movs	r3, #0
 8008e30:	e002      	b.n	8008e38 <ibqGetEmptyBufferI+0x38>
  }

  return ibqp->bwrptr + sizeof (size_t);
 8008e32:	9b01      	ldr	r3, [sp, #4]
 8008e34:	691b      	ldr	r3, [r3, #16]
 8008e36:	3304      	adds	r3, #4
}
 8008e38:	4618      	mov	r0, r3
 8008e3a:	b003      	add	sp, #12
 8008e3c:	f85d fb04 	ldr.w	pc, [sp], #4

08008e40 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 8008e40:	b500      	push	{lr}
 8008e42:	b083      	sub	sp, #12
 8008e44:	9001      	str	r0, [sp, #4]
 8008e46:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 8008e48:	f006 fada 	bl	800f400 <chDbgCheckClassI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 8008e4c:	9b00      	ldr	r3, [sp, #0]
 8008e4e:	2b00      	cmp	r3, #0
 8008e50:	d005      	beq.n	8008e5e <ibqPostFullBufferI+0x1e>
 8008e52:	9b01      	ldr	r3, [sp, #4]
 8008e54:	69db      	ldr	r3, [r3, #28]
 8008e56:	3b04      	subs	r3, #4
 8008e58:	9a00      	ldr	r2, [sp, #0]
 8008e5a:	429a      	cmp	r2, r3
 8008e5c:	d902      	bls.n	8008e64 <ibqPostFullBufferI+0x24>
 8008e5e:	481d      	ldr	r0, [pc, #116]	; (8008ed4 <ibqPostFullBufferI+0x94>)
 8008e60:	f006 f8be 	bl	800efe0 <chSysHalt>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 8008e64:	9b01      	ldr	r3, [sp, #4]
 8008e66:	691a      	ldr	r2, [r3, #16]
 8008e68:	9b01      	ldr	r3, [sp, #4]
 8008e6a:	695b      	ldr	r3, [r3, #20]
 8008e6c:	429a      	cmp	r2, r3
 8008e6e:	d105      	bne.n	8008e7c <ibqPostFullBufferI+0x3c>
 8008e70:	9b01      	ldr	r3, [sp, #4]
 8008e72:	68db      	ldr	r3, [r3, #12]
 8008e74:	2b00      	cmp	r3, #0
 8008e76:	d001      	beq.n	8008e7c <ibqPostFullBufferI+0x3c>
 8008e78:	2301      	movs	r3, #1
 8008e7a:	e000      	b.n	8008e7e <ibqPostFullBufferI+0x3e>
 8008e7c:	2300      	movs	r3, #0
 8008e7e:	f003 0301 	and.w	r3, r3, #1
 8008e82:	b2db      	uxtb	r3, r3
 8008e84:	2b00      	cmp	r3, #0
 8008e86:	d002      	beq.n	8008e8e <ibqPostFullBufferI+0x4e>
 8008e88:	4812      	ldr	r0, [pc, #72]	; (8008ed4 <ibqPostFullBufferI+0x94>)
 8008e8a:	f006 f8a9 	bl	800efe0 <chSysHalt>

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 8008e8e:	9b01      	ldr	r3, [sp, #4]
 8008e90:	691b      	ldr	r3, [r3, #16]
 8008e92:	9a00      	ldr	r2, [sp, #0]
 8008e94:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 8008e96:	9b01      	ldr	r3, [sp, #4]
 8008e98:	68db      	ldr	r3, [r3, #12]
 8008e9a:	1c5a      	adds	r2, r3, #1
 8008e9c:	9b01      	ldr	r3, [sp, #4]
 8008e9e:	60da      	str	r2, [r3, #12]
  ibqp->bwrptr += ibqp->bsize;
 8008ea0:	9b01      	ldr	r3, [sp, #4]
 8008ea2:	691a      	ldr	r2, [r3, #16]
 8008ea4:	9b01      	ldr	r3, [sp, #4]
 8008ea6:	69db      	ldr	r3, [r3, #28]
 8008ea8:	441a      	add	r2, r3
 8008eaa:	9b01      	ldr	r3, [sp, #4]
 8008eac:	611a      	str	r2, [r3, #16]
  if (ibqp->bwrptr >= ibqp->btop) {
 8008eae:	9b01      	ldr	r3, [sp, #4]
 8008eb0:	691a      	ldr	r2, [r3, #16]
 8008eb2:	9b01      	ldr	r3, [sp, #4]
 8008eb4:	699b      	ldr	r3, [r3, #24]
 8008eb6:	429a      	cmp	r2, r3
 8008eb8:	d303      	bcc.n	8008ec2 <ibqPostFullBufferI+0x82>
    ibqp->bwrptr = ibqp->buffers;
 8008eba:	9b01      	ldr	r3, [sp, #4]
 8008ebc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008ebe:	9b01      	ldr	r3, [sp, #4]
 8008ec0:	611a      	str	r2, [r3, #16]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 8008ec2:	9b01      	ldr	r3, [sp, #4]
 8008ec4:	2100      	movs	r1, #0
 8008ec6:	4618      	mov	r0, r3
 8008ec8:	f7ff ff0a 	bl	8008ce0 <osalThreadDequeueNextI.lto_priv.628>
}
 8008ecc:	b003      	add	sp, #12
 8008ece:	f85d fb04 	ldr.w	pc, [sp], #4
 8008ed2:	bf00      	nop
 8008ed4:	08015b7c 	.word	0x08015b7c
	...

08008ee0 <ibqGetFullBufferTimeoutS>:
   *                      suspended state.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 sysinterval_t timeout) {
 8008ee0:	b500      	push	{lr}
 8008ee2:	b085      	sub	sp, #20
 8008ee4:	9001      	str	r0, [sp, #4]
 8008ee6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 8008ee8:	f006 faa2 	bl	800f430 <chDbgCheckClassS>
 8008eec:	e011      	b.n	8008f12 <ibqGetFullBufferTimeoutS+0x32>

  while (ibqIsEmptyI(ibqp)) {
    if (ibqp->suspended) {
 8008eee:	9b01      	ldr	r3, [sp, #4]
 8008ef0:	7a1b      	ldrb	r3, [r3, #8]
 8008ef2:	2b00      	cmp	r3, #0
 8008ef4:	d002      	beq.n	8008efc <ibqGetFullBufferTimeoutS+0x1c>
      return MSG_RESET;
 8008ef6:	f06f 0301 	mvn.w	r3, #1
 8008efa:	e023      	b.n	8008f44 <ibqGetFullBufferTimeoutS+0x64>
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 8008efc:	9b01      	ldr	r3, [sp, #4]
 8008efe:	9900      	ldr	r1, [sp, #0]
 8008f00:	4618      	mov	r0, r3
 8008f02:	f7ff fedd 	bl	8008cc0 <osalThreadEnqueueTimeoutS.lto_priv.630>
 8008f06:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8008f08:	9b03      	ldr	r3, [sp, #12]
 8008f0a:	2b00      	cmp	r3, #0
 8008f0c:	da01      	bge.n	8008f12 <ibqGetFullBufferTimeoutS+0x32>
       return msg;
 8008f0e:	9b03      	ldr	r3, [sp, #12]
 8008f10:	e018      	b.n	8008f44 <ibqGetFullBufferTimeoutS+0x64>
  while (ibqIsEmptyI(ibqp)) {
 8008f12:	9b01      	ldr	r3, [sp, #4]
 8008f14:	68db      	ldr	r3, [r3, #12]
 8008f16:	2b00      	cmp	r3, #0
 8008f18:	d0e9      	beq.n	8008eee <ibqGetFullBufferTimeoutS+0xe>
    }
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 8008f1a:	9b01      	ldr	r3, [sp, #4]
 8008f1c:	68db      	ldr	r3, [r3, #12]
 8008f1e:	2b00      	cmp	r3, #0
 8008f20:	d102      	bne.n	8008f28 <ibqGetFullBufferTimeoutS+0x48>
 8008f22:	480a      	ldr	r0, [pc, #40]	; (8008f4c <ibqGetFullBufferTimeoutS+0x6c>)
 8008f24:	f006 f85c 	bl	800efe0 <chSysHalt>

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8008f28:	9b01      	ldr	r3, [sp, #4]
 8008f2a:	695b      	ldr	r3, [r3, #20]
 8008f2c:	1d1a      	adds	r2, r3, #4
 8008f2e:	9b01      	ldr	r3, [sp, #4]
 8008f30:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8008f32:	9b01      	ldr	r3, [sp, #4]
 8008f34:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8008f36:	9b01      	ldr	r3, [sp, #4]
 8008f38:	695b      	ldr	r3, [r3, #20]
 8008f3a:	681b      	ldr	r3, [r3, #0]
 8008f3c:	441a      	add	r2, r3
 8008f3e:	9b01      	ldr	r3, [sp, #4]
 8008f40:	62da      	str	r2, [r3, #44]	; 0x2c

  return MSG_OK;
 8008f42:	2300      	movs	r3, #0
}
 8008f44:	4618      	mov	r0, r3
 8008f46:	b005      	add	sp, #20
 8008f48:	f85d fb04 	ldr.w	pc, [sp], #4
 8008f4c:	08015b9c 	.word	0x08015b9c

08008f50 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8008f50:	b500      	push	{lr}
 8008f52:	b083      	sub	sp, #12
 8008f54:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassS();
 8008f56:	f006 fa6b 	bl	800f430 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8008f5a:	9b01      	ldr	r3, [sp, #4]
 8008f5c:	68db      	ldr	r3, [r3, #12]
 8008f5e:	2b00      	cmp	r3, #0
 8008f60:	d102      	bne.n	8008f68 <ibqReleaseEmptyBufferS+0x18>
 8008f62:	4813      	ldr	r0, [pc, #76]	; (8008fb0 <ibqReleaseEmptyBufferS+0x60>)
 8008f64:	f006 f83c 	bl	800efe0 <chSysHalt>

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8008f68:	9b01      	ldr	r3, [sp, #4]
 8008f6a:	68db      	ldr	r3, [r3, #12]
 8008f6c:	1e5a      	subs	r2, r3, #1
 8008f6e:	9b01      	ldr	r3, [sp, #4]
 8008f70:	60da      	str	r2, [r3, #12]
  ibqp->brdptr += ibqp->bsize;
 8008f72:	9b01      	ldr	r3, [sp, #4]
 8008f74:	695a      	ldr	r2, [r3, #20]
 8008f76:	9b01      	ldr	r3, [sp, #4]
 8008f78:	69db      	ldr	r3, [r3, #28]
 8008f7a:	441a      	add	r2, r3
 8008f7c:	9b01      	ldr	r3, [sp, #4]
 8008f7e:	615a      	str	r2, [r3, #20]
  if (ibqp->brdptr >= ibqp->btop) {
 8008f80:	9b01      	ldr	r3, [sp, #4]
 8008f82:	695a      	ldr	r2, [r3, #20]
 8008f84:	9b01      	ldr	r3, [sp, #4]
 8008f86:	699b      	ldr	r3, [r3, #24]
 8008f88:	429a      	cmp	r2, r3
 8008f8a:	d303      	bcc.n	8008f94 <ibqReleaseEmptyBufferS+0x44>
    ibqp->brdptr = ibqp->buffers;
 8008f8c:	9b01      	ldr	r3, [sp, #4]
 8008f8e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008f90:	9b01      	ldr	r3, [sp, #4]
 8008f92:	615a      	str	r2, [r3, #20]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8008f94:	9b01      	ldr	r3, [sp, #4]
 8008f96:	2200      	movs	r2, #0
 8008f98:	629a      	str	r2, [r3, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8008f9a:	9b01      	ldr	r3, [sp, #4]
 8008f9c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008f9e:	2b00      	cmp	r3, #0
 8008fa0:	d003      	beq.n	8008faa <ibqReleaseEmptyBufferS+0x5a>
    ibqp->notify(ibqp);
 8008fa2:	9b01      	ldr	r3, [sp, #4]
 8008fa4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008fa6:	9801      	ldr	r0, [sp, #4]
 8008fa8:	4798      	blx	r3
  }
}
 8008faa:	b003      	add	sp, #12
 8008fac:	f85d fb04 	ldr.w	pc, [sp], #4
 8008fb0:	08015bb8 	.word	0x08015bb8
	...

08008fc0 <ibqGetTimeout>:
 * @retval MSG_RESET    if the queue has been reset or has been put in
 *                      suspended state.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
 8008fc0:	b500      	push	{lr}
 8008fc2:	b085      	sub	sp, #20
 8008fc4:	9001      	str	r0, [sp, #4]
 8008fc6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8008fc8:	f7ff fe5a 	bl	8008c80 <osalSysLock.lto_priv.274>

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 8008fcc:	9b01      	ldr	r3, [sp, #4]
 8008fce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008fd0:	2b00      	cmp	r3, #0
 8008fd2:	d10b      	bne.n	8008fec <ibqGetTimeout+0x2c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8008fd4:	9900      	ldr	r1, [sp, #0]
 8008fd6:	9801      	ldr	r0, [sp, #4]
 8008fd8:	f7ff ff82 	bl	8008ee0 <ibqGetFullBufferTimeoutS>
 8008fdc:	9003      	str	r0, [sp, #12]
    if (msg != MSG_OK) {
 8008fde:	9b03      	ldr	r3, [sp, #12]
 8008fe0:	2b00      	cmp	r3, #0
 8008fe2:	d003      	beq.n	8008fec <ibqGetTimeout+0x2c>
      osalSysUnlock();
 8008fe4:	f7ff fe54 	bl	8008c90 <osalSysUnlock.lto_priv.265>
      return msg;
 8008fe8:	9b03      	ldr	r3, [sp, #12]
 8008fea:	e014      	b.n	8009016 <ibqGetTimeout+0x56>
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 8008fec:	9b01      	ldr	r3, [sp, #4]
 8008fee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008ff0:	781b      	ldrb	r3, [r3, #0]
 8008ff2:	9303      	str	r3, [sp, #12]
  ibqp->ptr++;
 8008ff4:	9b01      	ldr	r3, [sp, #4]
 8008ff6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008ff8:	1c5a      	adds	r2, r3, #1
 8008ffa:	9b01      	ldr	r3, [sp, #4]
 8008ffc:	629a      	str	r2, [r3, #40]	; 0x28

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 8008ffe:	9b01      	ldr	r3, [sp, #4]
 8009000:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009002:	9b01      	ldr	r3, [sp, #4]
 8009004:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009006:	429a      	cmp	r2, r3
 8009008:	d302      	bcc.n	8009010 <ibqGetTimeout+0x50>
    ibqReleaseEmptyBufferS(ibqp);
 800900a:	9801      	ldr	r0, [sp, #4]
 800900c:	f7ff ffa0 	bl	8008f50 <ibqReleaseEmptyBufferS>
  }

  osalSysUnlock();
 8009010:	f7ff fe3e 	bl	8008c90 <osalSysUnlock.lto_priv.265>
  return msg;
 8009014:	9b03      	ldr	r3, [sp, #12]
}
 8009016:	4618      	mov	r0, r3
 8009018:	b005      	add	sp, #20
 800901a:	f85d fb04 	ldr.w	pc, [sp], #4
 800901e:	bf00      	nop

08009020 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8009020:	b500      	push	{lr}
 8009022:	b089      	sub	sp, #36	; 0x24
 8009024:	9003      	str	r0, [sp, #12]
 8009026:	9102      	str	r1, [sp, #8]
 8009028:	9201      	str	r2, [sp, #4]
 800902a:	9300      	str	r3, [sp, #0]
  size_t r = 0;
 800902c:	2300      	movs	r3, #0
 800902e:	9307      	str	r3, [sp, #28]

  osalDbgCheck(n > 0U);
 8009030:	9b01      	ldr	r3, [sp, #4]
 8009032:	2b00      	cmp	r3, #0
 8009034:	d102      	bne.n	800903c <ibqReadTimeout+0x1c>
 8009036:	4835      	ldr	r0, [pc, #212]	; (800910c <ibqReadTimeout+0xec>)
 8009038:	f005 ffd2 	bl	800efe0 <chSysHalt>

  osalSysLock();
 800903c:	f7ff fe20 	bl	8008c80 <osalSysLock.lto_priv.274>

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8009040:	9b03      	ldr	r3, [sp, #12]
 8009042:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009044:	2b00      	cmp	r3, #0
 8009046:	d10b      	bne.n	8009060 <ibqReadTimeout+0x40>
      msg_t msg;

      /* Getting a data buffer using the specified timeout.*/
      msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8009048:	9900      	ldr	r1, [sp, #0]
 800904a:	9803      	ldr	r0, [sp, #12]
 800904c:	f7ff ff48 	bl	8008ee0 <ibqGetFullBufferTimeoutS>
 8009050:	9005      	str	r0, [sp, #20]

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8009052:	9b05      	ldr	r3, [sp, #20]
 8009054:	2b00      	cmp	r3, #0
 8009056:	d003      	beq.n	8009060 <ibqReadTimeout+0x40>
        osalSysUnlock();
 8009058:	f7ff fe1a 	bl	8008c90 <osalSysUnlock.lto_priv.265>
        return r;
 800905c:	9b07      	ldr	r3, [sp, #28]
 800905e:	e050      	b.n	8009102 <ibqReadTimeout+0xe2>
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8009060:	9b03      	ldr	r3, [sp, #12]
 8009062:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009064:	461a      	mov	r2, r3
 8009066:	9b03      	ldr	r3, [sp, #12]
 8009068:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800906a:	1ad3      	subs	r3, r2, r3
 800906c:	9306      	str	r3, [sp, #24]
    if (size > (n - r)) {
 800906e:	9a01      	ldr	r2, [sp, #4]
 8009070:	9b07      	ldr	r3, [sp, #28]
 8009072:	1ad3      	subs	r3, r2, r3
 8009074:	9a06      	ldr	r2, [sp, #24]
 8009076:	429a      	cmp	r2, r3
 8009078:	d903      	bls.n	8009082 <ibqReadTimeout+0x62>
      size = n - r;
 800907a:	9a01      	ldr	r2, [sp, #4]
 800907c:	9b07      	ldr	r3, [sp, #28]
 800907e:	1ad3      	subs	r3, r2, r3
 8009080:	9306      	str	r3, [sp, #24]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8009082:	9b06      	ldr	r3, [sp, #24]
 8009084:	2b40      	cmp	r3, #64	; 0x40
 8009086:	d913      	bls.n	80090b0 <ibqReadTimeout+0x90>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
 8009088:	9b03      	ldr	r3, [sp, #12]
 800908a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800908c:	2240      	movs	r2, #64	; 0x40
 800908e:	4619      	mov	r1, r3
 8009090:	9802      	ldr	r0, [sp, #8]
 8009092:	f7f7 f93f 	bl	8000314 <memcpy>
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 8009096:	9b02      	ldr	r3, [sp, #8]
 8009098:	3340      	adds	r3, #64	; 0x40
 800909a:	9302      	str	r3, [sp, #8]
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 800909c:	9b03      	ldr	r3, [sp, #12]
 800909e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80090a0:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80090a4:	9b03      	ldr	r3, [sp, #12]
 80090a6:	629a      	str	r2, [r3, #40]	; 0x28
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
 80090a8:	9b07      	ldr	r3, [sp, #28]
 80090aa:	3340      	adds	r3, #64	; 0x40
 80090ac:	9307      	str	r3, [sp, #28]
 80090ae:	e014      	b.n	80090da <ibqReadTimeout+0xba>
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 80090b0:	9b03      	ldr	r3, [sp, #12]
 80090b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80090b4:	9a06      	ldr	r2, [sp, #24]
 80090b6:	4619      	mov	r1, r3
 80090b8:	9802      	ldr	r0, [sp, #8]
 80090ba:	f7f7 f92b 	bl	8000314 <memcpy>
      bp        += size;
 80090be:	9a02      	ldr	r2, [sp, #8]
 80090c0:	9b06      	ldr	r3, [sp, #24]
 80090c2:	4413      	add	r3, r2
 80090c4:	9302      	str	r3, [sp, #8]
      ibqp->ptr += size;
 80090c6:	9b03      	ldr	r3, [sp, #12]
 80090c8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80090ca:	9b06      	ldr	r3, [sp, #24]
 80090cc:	441a      	add	r2, r3
 80090ce:	9b03      	ldr	r3, [sp, #12]
 80090d0:	629a      	str	r2, [r3, #40]	; 0x28
      r         += size;
 80090d2:	9a07      	ldr	r2, [sp, #28]
 80090d4:	9b06      	ldr	r3, [sp, #24]
 80090d6:	4413      	add	r3, r2
 80090d8:	9307      	str	r3, [sp, #28]
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 80090da:	9b03      	ldr	r3, [sp, #12]
 80090dc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80090de:	9b03      	ldr	r3, [sp, #12]
 80090e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80090e2:	429a      	cmp	r2, r3
 80090e4:	d302      	bcc.n	80090ec <ibqReadTimeout+0xcc>
      ibqReleaseEmptyBufferS(ibqp);
 80090e6:	9803      	ldr	r0, [sp, #12]
 80090e8:	f7ff ff32 	bl	8008f50 <ibqReleaseEmptyBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 80090ec:	f7ff fdd0 	bl	8008c90 <osalSysUnlock.lto_priv.265>
    if (r >= n) {
 80090f0:	9a07      	ldr	r2, [sp, #28]
 80090f2:	9b01      	ldr	r3, [sp, #4]
 80090f4:	429a      	cmp	r2, r3
 80090f6:	d301      	bcc.n	80090fc <ibqReadTimeout+0xdc>
      return r;
 80090f8:	9b07      	ldr	r3, [sp, #28]
 80090fa:	e002      	b.n	8009102 <ibqReadTimeout+0xe2>
    }
    osalSysLock();
 80090fc:	f7ff fdc0 	bl	8008c80 <osalSysLock.lto_priv.274>
 8009100:	e79e      	b.n	8009040 <ibqReadTimeout+0x20>
  }
}
 8009102:	4618      	mov	r0, r3
 8009104:	b009      	add	sp, #36	; 0x24
 8009106:	f85d fb04 	ldr.w	pc, [sp], #4
 800910a:	bf00      	nop
 800910c:	08015bd0 	.word	0x08015bd0

08009110 <obqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, bool suspended, uint8_t *bp,
                   size_t size, size_t n, bqnotify_t onfy, void *link) {
 8009110:	b500      	push	{lr}
 8009112:	b085      	sub	sp, #20
 8009114:	9003      	str	r0, [sp, #12]
 8009116:	9201      	str	r2, [sp, #4]
 8009118:	9300      	str	r3, [sp, #0]
 800911a:	460b      	mov	r3, r1
 800911c:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));
 8009120:	9b03      	ldr	r3, [sp, #12]
 8009122:	2b00      	cmp	r3, #0
 8009124:	d005      	beq.n	8009132 <obqObjectInit+0x22>
 8009126:	9b01      	ldr	r3, [sp, #4]
 8009128:	2b00      	cmp	r3, #0
 800912a:	d002      	beq.n	8009132 <obqObjectInit+0x22>
 800912c:	9b00      	ldr	r3, [sp, #0]
 800912e:	2b01      	cmp	r3, #1
 8009130:	d802      	bhi.n	8009138 <obqObjectInit+0x28>
 8009132:	481b      	ldr	r0, [pc, #108]	; (80091a0 <obqObjectInit+0x90>)
 8009134:	f005 ff54 	bl	800efe0 <chSysHalt>

  osalThreadQueueObjectInit(&obqp->waiting);
 8009138:	9b03      	ldr	r3, [sp, #12]
 800913a:	4618      	mov	r0, r3
 800913c:	f7ff fdb0 	bl	8008ca0 <osalThreadQueueObjectInit.lto_priv.632>
  obqp->suspended = suspended;
 8009140:	9b03      	ldr	r3, [sp, #12]
 8009142:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8009146:	721a      	strb	r2, [r3, #8]
  obqp->bcounter  = n;
 8009148:	9b03      	ldr	r3, [sp, #12]
 800914a:	9a06      	ldr	r2, [sp, #24]
 800914c:	60da      	str	r2, [r3, #12]
  obqp->brdptr    = bp;
 800914e:	9b03      	ldr	r3, [sp, #12]
 8009150:	9a01      	ldr	r2, [sp, #4]
 8009152:	615a      	str	r2, [r3, #20]
  obqp->bwrptr    = bp;
 8009154:	9b03      	ldr	r3, [sp, #12]
 8009156:	9a01      	ldr	r2, [sp, #4]
 8009158:	611a      	str	r2, [r3, #16]
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800915a:	9b00      	ldr	r3, [sp, #0]
 800915c:	3304      	adds	r3, #4
 800915e:	9a06      	ldr	r2, [sp, #24]
 8009160:	fb02 f303 	mul.w	r3, r2, r3
 8009164:	9a01      	ldr	r2, [sp, #4]
 8009166:	441a      	add	r2, r3
 8009168:	9b03      	ldr	r3, [sp, #12]
 800916a:	619a      	str	r2, [r3, #24]
  obqp->bsize     = size + sizeof (size_t);
 800916c:	9b00      	ldr	r3, [sp, #0]
 800916e:	1d1a      	adds	r2, r3, #4
 8009170:	9b03      	ldr	r3, [sp, #12]
 8009172:	61da      	str	r2, [r3, #28]
  obqp->bn        = n;
 8009174:	9b03      	ldr	r3, [sp, #12]
 8009176:	9a06      	ldr	r2, [sp, #24]
 8009178:	621a      	str	r2, [r3, #32]
  obqp->buffers   = bp;
 800917a:	9b03      	ldr	r3, [sp, #12]
 800917c:	9a01      	ldr	r2, [sp, #4]
 800917e:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->ptr       = NULL;
 8009180:	9b03      	ldr	r3, [sp, #12]
 8009182:	2200      	movs	r2, #0
 8009184:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->top       = NULL;
 8009186:	9b03      	ldr	r3, [sp, #12]
 8009188:	2200      	movs	r2, #0
 800918a:	62da      	str	r2, [r3, #44]	; 0x2c
  obqp->notify    = onfy;
 800918c:	9b03      	ldr	r3, [sp, #12]
 800918e:	9a07      	ldr	r2, [sp, #28]
 8009190:	631a      	str	r2, [r3, #48]	; 0x30
  obqp->link      = link;
 8009192:	9b03      	ldr	r3, [sp, #12]
 8009194:	9a08      	ldr	r2, [sp, #32]
 8009196:	635a      	str	r2, [r3, #52]	; 0x34
}
 8009198:	b005      	add	sp, #20
 800919a:	f85d fb04 	ldr.w	pc, [sp], #4
 800919e:	bf00      	nop
 80091a0:	08015be0 	.word	0x08015be0
	...

080091b0 <obqResetI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 80091b0:	b500      	push	{lr}
 80091b2:	b083      	sub	sp, #12
 80091b4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 80091b6:	f006 f923 	bl	800f400 <chDbgCheckClassI>

  obqp->bcounter  = bqSizeX(obqp);
 80091ba:	9b01      	ldr	r3, [sp, #4]
 80091bc:	6a1a      	ldr	r2, [r3, #32]
 80091be:	9b01      	ldr	r3, [sp, #4]
 80091c0:	60da      	str	r2, [r3, #12]
  obqp->brdptr    = obqp->buffers;
 80091c2:	9b01      	ldr	r3, [sp, #4]
 80091c4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80091c6:	9b01      	ldr	r3, [sp, #4]
 80091c8:	615a      	str	r2, [r3, #20]
  obqp->bwrptr    = obqp->buffers;
 80091ca:	9b01      	ldr	r3, [sp, #4]
 80091cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80091ce:	9b01      	ldr	r3, [sp, #4]
 80091d0:	611a      	str	r2, [r3, #16]
  obqp->ptr       = NULL;
 80091d2:	9b01      	ldr	r3, [sp, #4]
 80091d4:	2200      	movs	r2, #0
 80091d6:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->top       = NULL;
 80091d8:	9b01      	ldr	r3, [sp, #4]
 80091da:	2200      	movs	r2, #0
 80091dc:	62da      	str	r2, [r3, #44]	; 0x2c
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 80091de:	9b01      	ldr	r3, [sp, #4]
 80091e0:	f06f 0101 	mvn.w	r1, #1
 80091e4:	4618      	mov	r0, r3
 80091e6:	f7ff fd8b 	bl	8008d00 <osalThreadDequeueAllI.lto_priv.614>
}
 80091ea:	b003      	add	sp, #12
 80091ec:	f85d fb04 	ldr.w	pc, [sp], #4

080091f0 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 80091f0:	b500      	push	{lr}
 80091f2:	b083      	sub	sp, #12
 80091f4:	9001      	str	r0, [sp, #4]
 80091f6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 80091f8:	f006 f902 	bl	800f400 <chDbgCheckClassI>

  if (obqIsEmptyI(obqp)) {
 80091fc:	9b01      	ldr	r3, [sp, #4]
 80091fe:	691a      	ldr	r2, [r3, #16]
 8009200:	9b01      	ldr	r3, [sp, #4]
 8009202:	695b      	ldr	r3, [r3, #20]
 8009204:	429a      	cmp	r2, r3
 8009206:	d105      	bne.n	8009214 <obqGetFullBufferI+0x24>
 8009208:	9b01      	ldr	r3, [sp, #4]
 800920a:	68db      	ldr	r3, [r3, #12]
 800920c:	2b00      	cmp	r3, #0
 800920e:	d001      	beq.n	8009214 <obqGetFullBufferI+0x24>
 8009210:	2301      	movs	r3, #1
 8009212:	e000      	b.n	8009216 <obqGetFullBufferI+0x26>
 8009214:	2300      	movs	r3, #0
 8009216:	f003 0301 	and.w	r3, r3, #1
 800921a:	b2db      	uxtb	r3, r3
 800921c:	2b00      	cmp	r3, #0
 800921e:	d001      	beq.n	8009224 <obqGetFullBufferI+0x34>
    return NULL;
 8009220:	2300      	movs	r3, #0
 8009222:	e007      	b.n	8009234 <obqGetFullBufferI+0x44>
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 8009224:	9b01      	ldr	r3, [sp, #4]
 8009226:	695b      	ldr	r3, [r3, #20]
 8009228:	681a      	ldr	r2, [r3, #0]
 800922a:	9b00      	ldr	r3, [sp, #0]
 800922c:	601a      	str	r2, [r3, #0]

  return obqp->brdptr + sizeof (size_t);
 800922e:	9b01      	ldr	r3, [sp, #4]
 8009230:	695b      	ldr	r3, [r3, #20]
 8009232:	3304      	adds	r3, #4
}
 8009234:	4618      	mov	r0, r3
 8009236:	b003      	add	sp, #12
 8009238:	f85d fb04 	ldr.w	pc, [sp], #4
 800923c:	0000      	movs	r0, r0
	...

08009240 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 8009240:	b500      	push	{lr}
 8009242:	b083      	sub	sp, #12
 8009244:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8009246:	f006 f8db 	bl	800f400 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 800924a:	9b01      	ldr	r3, [sp, #4]
 800924c:	691a      	ldr	r2, [r3, #16]
 800924e:	9b01      	ldr	r3, [sp, #4]
 8009250:	695b      	ldr	r3, [r3, #20]
 8009252:	429a      	cmp	r2, r3
 8009254:	d105      	bne.n	8009262 <obqReleaseEmptyBufferI+0x22>
 8009256:	9b01      	ldr	r3, [sp, #4]
 8009258:	68db      	ldr	r3, [r3, #12]
 800925a:	2b00      	cmp	r3, #0
 800925c:	d001      	beq.n	8009262 <obqReleaseEmptyBufferI+0x22>
 800925e:	2301      	movs	r3, #1
 8009260:	e000      	b.n	8009264 <obqReleaseEmptyBufferI+0x24>
 8009262:	2300      	movs	r3, #0
 8009264:	f003 0301 	and.w	r3, r3, #1
 8009268:	b2db      	uxtb	r3, r3
 800926a:	2b00      	cmp	r3, #0
 800926c:	d002      	beq.n	8009274 <obqReleaseEmptyBufferI+0x34>
 800926e:	4810      	ldr	r0, [pc, #64]	; (80092b0 <obqReleaseEmptyBufferI+0x70>)
 8009270:	f005 feb6 	bl	800efe0 <chSysHalt>

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 8009274:	9b01      	ldr	r3, [sp, #4]
 8009276:	68db      	ldr	r3, [r3, #12]
 8009278:	1c5a      	adds	r2, r3, #1
 800927a:	9b01      	ldr	r3, [sp, #4]
 800927c:	60da      	str	r2, [r3, #12]
  obqp->brdptr += obqp->bsize;
 800927e:	9b01      	ldr	r3, [sp, #4]
 8009280:	695a      	ldr	r2, [r3, #20]
 8009282:	9b01      	ldr	r3, [sp, #4]
 8009284:	69db      	ldr	r3, [r3, #28]
 8009286:	441a      	add	r2, r3
 8009288:	9b01      	ldr	r3, [sp, #4]
 800928a:	615a      	str	r2, [r3, #20]
  if (obqp->brdptr >= obqp->btop) {
 800928c:	9b01      	ldr	r3, [sp, #4]
 800928e:	695a      	ldr	r2, [r3, #20]
 8009290:	9b01      	ldr	r3, [sp, #4]
 8009292:	699b      	ldr	r3, [r3, #24]
 8009294:	429a      	cmp	r2, r3
 8009296:	d303      	bcc.n	80092a0 <obqReleaseEmptyBufferI+0x60>
    obqp->brdptr = obqp->buffers;
 8009298:	9b01      	ldr	r3, [sp, #4]
 800929a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800929c:	9b01      	ldr	r3, [sp, #4]
 800929e:	615a      	str	r2, [r3, #20]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 80092a0:	9b01      	ldr	r3, [sp, #4]
 80092a2:	2100      	movs	r1, #0
 80092a4:	4618      	mov	r0, r3
 80092a6:	f7ff fd1b 	bl	8008ce0 <osalThreadDequeueNextI.lto_priv.628>
}
 80092aa:	b003      	add	sp, #12
 80092ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80092b0:	08015bf0 	.word	0x08015bf0
	...

080092c0 <obqGetEmptyBufferTimeoutS>:
 *                      suspended state.
 *
 * @sclass
 */
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                sysinterval_t timeout) {
 80092c0:	b500      	push	{lr}
 80092c2:	b085      	sub	sp, #20
 80092c4:	9001      	str	r0, [sp, #4]
 80092c6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 80092c8:	f006 f8b2 	bl	800f430 <chDbgCheckClassS>
 80092cc:	e011      	b.n	80092f2 <obqGetEmptyBufferTimeoutS+0x32>

  while (obqIsFullI(obqp)) {
    if (obqp->suspended) {
 80092ce:	9b01      	ldr	r3, [sp, #4]
 80092d0:	7a1b      	ldrb	r3, [r3, #8]
 80092d2:	2b00      	cmp	r3, #0
 80092d4:	d002      	beq.n	80092dc <obqGetEmptyBufferTimeoutS+0x1c>
      return MSG_RESET;
 80092d6:	f06f 0301 	mvn.w	r3, #1
 80092da:	e022      	b.n	8009322 <obqGetEmptyBufferTimeoutS+0x62>
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 80092dc:	9b01      	ldr	r3, [sp, #4]
 80092de:	9900      	ldr	r1, [sp, #0]
 80092e0:	4618      	mov	r0, r3
 80092e2:	f7ff fced 	bl	8008cc0 <osalThreadEnqueueTimeoutS.lto_priv.630>
 80092e6:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 80092e8:	9b03      	ldr	r3, [sp, #12]
 80092ea:	2b00      	cmp	r3, #0
 80092ec:	da01      	bge.n	80092f2 <obqGetEmptyBufferTimeoutS+0x32>
      return msg;
 80092ee:	9b03      	ldr	r3, [sp, #12]
 80092f0:	e017      	b.n	8009322 <obqGetEmptyBufferTimeoutS+0x62>
  while (obqIsFullI(obqp)) {
 80092f2:	9b01      	ldr	r3, [sp, #4]
 80092f4:	68db      	ldr	r3, [r3, #12]
 80092f6:	2b00      	cmp	r3, #0
 80092f8:	d0e9      	beq.n	80092ce <obqGetEmptyBufferTimeoutS+0xe>
    }
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");
 80092fa:	9b01      	ldr	r3, [sp, #4]
 80092fc:	68db      	ldr	r3, [r3, #12]
 80092fe:	2b00      	cmp	r3, #0
 8009300:	d102      	bne.n	8009308 <obqGetEmptyBufferTimeoutS+0x48>
 8009302:	480a      	ldr	r0, [pc, #40]	; (800932c <obqGetEmptyBufferTimeoutS+0x6c>)
 8009304:	f005 fe6c 	bl	800efe0 <chSysHalt>

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8009308:	9b01      	ldr	r3, [sp, #4]
 800930a:	691b      	ldr	r3, [r3, #16]
 800930c:	1d1a      	adds	r2, r3, #4
 800930e:	9b01      	ldr	r3, [sp, #4]
 8009310:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
 8009312:	9b01      	ldr	r3, [sp, #4]
 8009314:	691a      	ldr	r2, [r3, #16]
 8009316:	9b01      	ldr	r3, [sp, #4]
 8009318:	69db      	ldr	r3, [r3, #28]
 800931a:	441a      	add	r2, r3
 800931c:	9b01      	ldr	r3, [sp, #4]
 800931e:	62da      	str	r2, [r3, #44]	; 0x2c

  return MSG_OK;
 8009320:	2300      	movs	r3, #0
}
 8009322:	4618      	mov	r0, r3
 8009324:	b005      	add	sp, #20
 8009326:	f85d fb04 	ldr.w	pc, [sp], #4
 800932a:	bf00      	nop
 800932c:	08015c08 	.word	0x08015c08

08009330 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8009330:	b500      	push	{lr}
 8009332:	b083      	sub	sp, #12
 8009334:	9001      	str	r0, [sp, #4]
 8009336:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 8009338:	f006 f87a 	bl	800f430 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 800933c:	9b00      	ldr	r3, [sp, #0]
 800933e:	2b00      	cmp	r3, #0
 8009340:	d005      	beq.n	800934e <obqPostFullBufferS+0x1e>
 8009342:	9b01      	ldr	r3, [sp, #4]
 8009344:	69db      	ldr	r3, [r3, #28]
 8009346:	3b04      	subs	r3, #4
 8009348:	9a00      	ldr	r2, [sp, #0]
 800934a:	429a      	cmp	r2, r3
 800934c:	d902      	bls.n	8009354 <obqPostFullBufferS+0x24>
 800934e:	4819      	ldr	r0, [pc, #100]	; (80093b4 <obqPostFullBufferS+0x84>)
 8009350:	f005 fe46 	bl	800efe0 <chSysHalt>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8009354:	9b01      	ldr	r3, [sp, #4]
 8009356:	68db      	ldr	r3, [r3, #12]
 8009358:	2b00      	cmp	r3, #0
 800935a:	d102      	bne.n	8009362 <obqPostFullBufferS+0x32>
 800935c:	4815      	ldr	r0, [pc, #84]	; (80093b4 <obqPostFullBufferS+0x84>)
 800935e:	f005 fe3f 	bl	800efe0 <chSysHalt>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8009362:	9b01      	ldr	r3, [sp, #4]
 8009364:	691b      	ldr	r3, [r3, #16]
 8009366:	9a00      	ldr	r2, [sp, #0]
 8009368:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 800936a:	9b01      	ldr	r3, [sp, #4]
 800936c:	68db      	ldr	r3, [r3, #12]
 800936e:	1e5a      	subs	r2, r3, #1
 8009370:	9b01      	ldr	r3, [sp, #4]
 8009372:	60da      	str	r2, [r3, #12]
  obqp->bwrptr += obqp->bsize;
 8009374:	9b01      	ldr	r3, [sp, #4]
 8009376:	691a      	ldr	r2, [r3, #16]
 8009378:	9b01      	ldr	r3, [sp, #4]
 800937a:	69db      	ldr	r3, [r3, #28]
 800937c:	441a      	add	r2, r3
 800937e:	9b01      	ldr	r3, [sp, #4]
 8009380:	611a      	str	r2, [r3, #16]
  if (obqp->bwrptr >= obqp->btop) {
 8009382:	9b01      	ldr	r3, [sp, #4]
 8009384:	691a      	ldr	r2, [r3, #16]
 8009386:	9b01      	ldr	r3, [sp, #4]
 8009388:	699b      	ldr	r3, [r3, #24]
 800938a:	429a      	cmp	r2, r3
 800938c:	d303      	bcc.n	8009396 <obqPostFullBufferS+0x66>
    obqp->bwrptr = obqp->buffers;
 800938e:	9b01      	ldr	r3, [sp, #4]
 8009390:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009392:	9b01      	ldr	r3, [sp, #4]
 8009394:	611a      	str	r2, [r3, #16]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 8009396:	9b01      	ldr	r3, [sp, #4]
 8009398:	2200      	movs	r2, #0
 800939a:	629a      	str	r2, [r3, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 800939c:	9b01      	ldr	r3, [sp, #4]
 800939e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80093a0:	2b00      	cmp	r3, #0
 80093a2:	d003      	beq.n	80093ac <obqPostFullBufferS+0x7c>
    obqp->notify(obqp);
 80093a4:	9b01      	ldr	r3, [sp, #4]
 80093a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80093a8:	9801      	ldr	r0, [sp, #4]
 80093aa:	4798      	blx	r3
  }
}
 80093ac:	b003      	add	sp, #12
 80093ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80093b2:	bf00      	nop
 80093b4:	08015c24 	.word	0x08015c24
	...

080093c0 <obqPutTimeout>:
 *                      suspended state.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    sysinterval_t timeout) {
 80093c0:	b500      	push	{lr}
 80093c2:	b087      	sub	sp, #28
 80093c4:	9003      	str	r0, [sp, #12]
 80093c6:	460b      	mov	r3, r1
 80093c8:	9201      	str	r2, [sp, #4]
 80093ca:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 80093ce:	f7ff fc57 	bl	8008c80 <osalSysLock.lto_priv.274>

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 80093d2:	9b03      	ldr	r3, [sp, #12]
 80093d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80093d6:	2b00      	cmp	r3, #0
 80093d8:	d10b      	bne.n	80093f2 <obqPutTimeout+0x32>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80093da:	9901      	ldr	r1, [sp, #4]
 80093dc:	9803      	ldr	r0, [sp, #12]
 80093de:	f7ff ff6f 	bl	80092c0 <obqGetEmptyBufferTimeoutS>
 80093e2:	9005      	str	r0, [sp, #20]
    if (msg != MSG_OK) {
 80093e4:	9b05      	ldr	r3, [sp, #20]
 80093e6:	2b00      	cmp	r3, #0
 80093e8:	d003      	beq.n	80093f2 <obqPutTimeout+0x32>
      osalSysUnlock();
 80093ea:	f7ff fc51 	bl	8008c90 <osalSysUnlock.lto_priv.265>
      return msg;
 80093ee:	9b05      	ldr	r3, [sp, #20]
 80093f0:	e019      	b.n	8009426 <obqPutTimeout+0x66>
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 80093f2:	9b03      	ldr	r3, [sp, #12]
 80093f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80093f6:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80093fa:	701a      	strb	r2, [r3, #0]
  obqp->ptr++;
 80093fc:	9b03      	ldr	r3, [sp, #12]
 80093fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009400:	1c5a      	adds	r2, r3, #1
 8009402:	9b03      	ldr	r3, [sp, #12]
 8009404:	629a      	str	r2, [r3, #40]	; 0x28

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8009406:	9b03      	ldr	r3, [sp, #12]
 8009408:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800940a:	9b03      	ldr	r3, [sp, #12]
 800940c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800940e:	429a      	cmp	r2, r3
 8009410:	d306      	bcc.n	8009420 <obqPutTimeout+0x60>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8009412:	9b03      	ldr	r3, [sp, #12]
 8009414:	69db      	ldr	r3, [r3, #28]
 8009416:	3b04      	subs	r3, #4
 8009418:	4619      	mov	r1, r3
 800941a:	9803      	ldr	r0, [sp, #12]
 800941c:	f7ff ff88 	bl	8009330 <obqPostFullBufferS>
  }

  osalSysUnlock();
 8009420:	f7ff fc36 	bl	8008c90 <osalSysUnlock.lto_priv.265>
  return MSG_OK;
 8009424:	2300      	movs	r3, #0
}
 8009426:	4618      	mov	r0, r3
 8009428:	b007      	add	sp, #28
 800942a:	f85d fb04 	ldr.w	pc, [sp], #4
 800942e:	bf00      	nop

08009430 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, sysinterval_t timeout) {
 8009430:	b500      	push	{lr}
 8009432:	b089      	sub	sp, #36	; 0x24
 8009434:	9003      	str	r0, [sp, #12]
 8009436:	9102      	str	r1, [sp, #8]
 8009438:	9201      	str	r2, [sp, #4]
 800943a:	9300      	str	r3, [sp, #0]
  size_t w = 0;
 800943c:	2300      	movs	r3, #0
 800943e:	9307      	str	r3, [sp, #28]

  osalDbgCheck(n > 0U);
 8009440:	9b01      	ldr	r3, [sp, #4]
 8009442:	2b00      	cmp	r3, #0
 8009444:	d102      	bne.n	800944c <obqWriteTimeout+0x1c>
 8009446:	4837      	ldr	r0, [pc, #220]	; (8009524 <obqWriteTimeout+0xf4>)
 8009448:	f005 fdca 	bl	800efe0 <chSysHalt>

  osalSysLock();
 800944c:	f7ff fc18 	bl	8008c80 <osalSysLock.lto_priv.274>

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8009450:	9b03      	ldr	r3, [sp, #12]
 8009452:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009454:	2b00      	cmp	r3, #0
 8009456:	d10b      	bne.n	8009470 <obqWriteTimeout+0x40>
      msg_t msg;

      /* Getting an empty buffer using the specified timeout.*/
      msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8009458:	9900      	ldr	r1, [sp, #0]
 800945a:	9803      	ldr	r0, [sp, #12]
 800945c:	f7ff ff30 	bl	80092c0 <obqGetEmptyBufferTimeoutS>
 8009460:	9005      	str	r0, [sp, #20]

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8009462:	9b05      	ldr	r3, [sp, #20]
 8009464:	2b00      	cmp	r3, #0
 8009466:	d003      	beq.n	8009470 <obqWriteTimeout+0x40>
        osalSysUnlock();
 8009468:	f7ff fc12 	bl	8008c90 <osalSysUnlock.lto_priv.265>
        return w;
 800946c:	9b07      	ldr	r3, [sp, #28]
 800946e:	e054      	b.n	800951a <obqWriteTimeout+0xea>
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8009470:	9b03      	ldr	r3, [sp, #12]
 8009472:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009474:	461a      	mov	r2, r3
 8009476:	9b03      	ldr	r3, [sp, #12]
 8009478:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800947a:	1ad3      	subs	r3, r2, r3
 800947c:	9306      	str	r3, [sp, #24]
    if (size > (n - w)) {
 800947e:	9a01      	ldr	r2, [sp, #4]
 8009480:	9b07      	ldr	r3, [sp, #28]
 8009482:	1ad3      	subs	r3, r2, r3
 8009484:	9a06      	ldr	r2, [sp, #24]
 8009486:	429a      	cmp	r2, r3
 8009488:	d903      	bls.n	8009492 <obqWriteTimeout+0x62>
      size = n - w;
 800948a:	9a01      	ldr	r2, [sp, #4]
 800948c:	9b07      	ldr	r3, [sp, #28]
 800948e:	1ad3      	subs	r3, r2, r3
 8009490:	9306      	str	r3, [sp, #24]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8009492:	9b06      	ldr	r3, [sp, #24]
 8009494:	2b40      	cmp	r3, #64	; 0x40
 8009496:	d913      	bls.n	80094c0 <obqWriteTimeout+0x90>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
 8009498:	9b03      	ldr	r3, [sp, #12]
 800949a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800949c:	2240      	movs	r2, #64	; 0x40
 800949e:	9902      	ldr	r1, [sp, #8]
 80094a0:	4618      	mov	r0, r3
 80094a2:	f7f6 ff37 	bl	8000314 <memcpy>
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 80094a6:	9b02      	ldr	r3, [sp, #8]
 80094a8:	3340      	adds	r3, #64	; 0x40
 80094aa:	9302      	str	r3, [sp, #8]
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 80094ac:	9b03      	ldr	r3, [sp, #12]
 80094ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80094b0:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80094b4:	9b03      	ldr	r3, [sp, #12]
 80094b6:	629a      	str	r2, [r3, #40]	; 0x28
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
 80094b8:	9b07      	ldr	r3, [sp, #28]
 80094ba:	3340      	adds	r3, #64	; 0x40
 80094bc:	9307      	str	r3, [sp, #28]
 80094be:	e014      	b.n	80094ea <obqWriteTimeout+0xba>
    }
    else {
      memcpy(obqp->ptr, bp, size);
 80094c0:	9b03      	ldr	r3, [sp, #12]
 80094c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80094c4:	9a06      	ldr	r2, [sp, #24]
 80094c6:	9902      	ldr	r1, [sp, #8]
 80094c8:	4618      	mov	r0, r3
 80094ca:	f7f6 ff23 	bl	8000314 <memcpy>
      bp        += size;
 80094ce:	9a02      	ldr	r2, [sp, #8]
 80094d0:	9b06      	ldr	r3, [sp, #24]
 80094d2:	4413      	add	r3, r2
 80094d4:	9302      	str	r3, [sp, #8]
      obqp->ptr += size;
 80094d6:	9b03      	ldr	r3, [sp, #12]
 80094d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80094da:	9b06      	ldr	r3, [sp, #24]
 80094dc:	441a      	add	r2, r3
 80094de:	9b03      	ldr	r3, [sp, #12]
 80094e0:	629a      	str	r2, [r3, #40]	; 0x28
      w         += size;
 80094e2:	9a07      	ldr	r2, [sp, #28]
 80094e4:	9b06      	ldr	r3, [sp, #24]
 80094e6:	4413      	add	r3, r2
 80094e8:	9307      	str	r3, [sp, #28]
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80094ea:	9b03      	ldr	r3, [sp, #12]
 80094ec:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80094ee:	9b03      	ldr	r3, [sp, #12]
 80094f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80094f2:	429a      	cmp	r2, r3
 80094f4:	d306      	bcc.n	8009504 <obqWriteTimeout+0xd4>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 80094f6:	9b03      	ldr	r3, [sp, #12]
 80094f8:	69db      	ldr	r3, [r3, #28]
 80094fa:	3b04      	subs	r3, #4
 80094fc:	4619      	mov	r1, r3
 80094fe:	9803      	ldr	r0, [sp, #12]
 8009500:	f7ff ff16 	bl	8009330 <obqPostFullBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 8009504:	f7ff fbc4 	bl	8008c90 <osalSysUnlock.lto_priv.265>
    if (w >= n) {
 8009508:	9a07      	ldr	r2, [sp, #28]
 800950a:	9b01      	ldr	r3, [sp, #4]
 800950c:	429a      	cmp	r2, r3
 800950e:	d301      	bcc.n	8009514 <obqWriteTimeout+0xe4>
      return w;
 8009510:	9b07      	ldr	r3, [sp, #28]
 8009512:	e002      	b.n	800951a <obqWriteTimeout+0xea>
    }
    osalSysLock();
 8009514:	f7ff fbb4 	bl	8008c80 <osalSysLock.lto_priv.274>
 8009518:	e79a      	b.n	8009450 <obqWriteTimeout+0x20>
  }
}
 800951a:	4618      	mov	r0, r3
 800951c:	b009      	add	sp, #36	; 0x24
 800951e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009522:	bf00      	nop
 8009524:	08015c38 	.word	0x08015c38
	...

08009530 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 8009530:	b500      	push	{lr}
 8009532:	b085      	sub	sp, #20
 8009534:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8009536:	f005 ff63 	bl	800f400 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 800953a:	9b01      	ldr	r3, [sp, #4]
 800953c:	691a      	ldr	r2, [r3, #16]
 800953e:	9b01      	ldr	r3, [sp, #4]
 8009540:	695b      	ldr	r3, [r3, #20]
 8009542:	429a      	cmp	r2, r3
 8009544:	d105      	bne.n	8009552 <obqTryFlushI+0x22>
 8009546:	9b01      	ldr	r3, [sp, #4]
 8009548:	68db      	ldr	r3, [r3, #12]
 800954a:	2b00      	cmp	r3, #0
 800954c:	d001      	beq.n	8009552 <obqTryFlushI+0x22>
 800954e:	2301      	movs	r3, #1
 8009550:	e000      	b.n	8009554 <obqTryFlushI+0x24>
 8009552:	2300      	movs	r3, #0
 8009554:	f003 0301 	and.w	r3, r3, #1
 8009558:	b2db      	uxtb	r3, r3
 800955a:	2b00      	cmp	r3, #0
 800955c:	d02d      	beq.n	80095ba <obqTryFlushI+0x8a>
 800955e:	9b01      	ldr	r3, [sp, #4]
 8009560:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009562:	2b00      	cmp	r3, #0
 8009564:	d029      	beq.n	80095ba <obqTryFlushI+0x8a>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 8009566:	9b01      	ldr	r3, [sp, #4]
 8009568:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800956a:	461a      	mov	r2, r3
 800956c:	9b01      	ldr	r3, [sp, #4]
 800956e:	691b      	ldr	r3, [r3, #16]
 8009570:	1ad3      	subs	r3, r2, r3
 8009572:	3b04      	subs	r3, #4
 8009574:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 8009576:	9b03      	ldr	r3, [sp, #12]
 8009578:	2b00      	cmp	r3, #0
 800957a:	d01e      	beq.n	80095ba <obqTryFlushI+0x8a>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 800957c:	9b01      	ldr	r3, [sp, #4]
 800957e:	691b      	ldr	r3, [r3, #16]
 8009580:	9a03      	ldr	r2, [sp, #12]
 8009582:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8009584:	9b01      	ldr	r3, [sp, #4]
 8009586:	68db      	ldr	r3, [r3, #12]
 8009588:	1e5a      	subs	r2, r3, #1
 800958a:	9b01      	ldr	r3, [sp, #4]
 800958c:	60da      	str	r2, [r3, #12]
      obqp->bwrptr += obqp->bsize;
 800958e:	9b01      	ldr	r3, [sp, #4]
 8009590:	691a      	ldr	r2, [r3, #16]
 8009592:	9b01      	ldr	r3, [sp, #4]
 8009594:	69db      	ldr	r3, [r3, #28]
 8009596:	441a      	add	r2, r3
 8009598:	9b01      	ldr	r3, [sp, #4]
 800959a:	611a      	str	r2, [r3, #16]
      if (obqp->bwrptr >= obqp->btop) {
 800959c:	9b01      	ldr	r3, [sp, #4]
 800959e:	691a      	ldr	r2, [r3, #16]
 80095a0:	9b01      	ldr	r3, [sp, #4]
 80095a2:	699b      	ldr	r3, [r3, #24]
 80095a4:	429a      	cmp	r2, r3
 80095a6:	d303      	bcc.n	80095b0 <obqTryFlushI+0x80>
        obqp->bwrptr = obqp->buffers;
 80095a8:	9b01      	ldr	r3, [sp, #4]
 80095aa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80095ac:	9b01      	ldr	r3, [sp, #4]
 80095ae:	611a      	str	r2, [r3, #16]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 80095b0:	9b01      	ldr	r3, [sp, #4]
 80095b2:	2200      	movs	r2, #0
 80095b4:	629a      	str	r2, [r3, #40]	; 0x28

      return true;
 80095b6:	2301      	movs	r3, #1
 80095b8:	e000      	b.n	80095bc <obqTryFlushI+0x8c>
    }
  }
  return false;
 80095ba:	2300      	movs	r3, #0
}
 80095bc:	4618      	mov	r0, r3
 80095be:	b005      	add	sp, #20
 80095c0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080095d0 <port_lock.lto_priv.382>:
static inline void port_lock(void) {
 80095d0:	b082      	sub	sp, #8
 80095d2:	2320      	movs	r3, #32
 80095d4:	9301      	str	r3, [sp, #4]
 80095d6:	9b01      	ldr	r3, [sp, #4]
 80095d8:	f383 8811 	msr	BASEPRI, r3
}
 80095dc:	b002      	add	sp, #8
 80095de:	4770      	bx	lr

080095e0 <port_unlock.lto_priv.351>:
static inline void port_unlock(void) {
 80095e0:	b082      	sub	sp, #8
 80095e2:	2300      	movs	r3, #0
 80095e4:	9301      	str	r3, [sp, #4]
 80095e6:	9b01      	ldr	r3, [sp, #4]
 80095e8:	f383 8811 	msr	BASEPRI, r3
}
 80095ec:	b002      	add	sp, #8
 80095ee:	4770      	bx	lr

080095f0 <queue_init.lto_priv.461>:
static inline void queue_init(threads_queue_t *tqp) {
 80095f0:	b082      	sub	sp, #8
 80095f2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80095f4:	9b01      	ldr	r3, [sp, #4]
 80095f6:	9a01      	ldr	r2, [sp, #4]
 80095f8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80095fa:	9b01      	ldr	r3, [sp, #4]
 80095fc:	9a01      	ldr	r2, [sp, #4]
 80095fe:	605a      	str	r2, [r3, #4]
}
 8009600:	b002      	add	sp, #8
 8009602:	4770      	bx	lr
	...

08009610 <chSysLock.lto_priv.314>:
static inline void chSysLock(void) {
 8009610:	b508      	push	{r3, lr}
  port_lock();
 8009612:	f7ff ffdd 	bl	80095d0 <port_lock.lto_priv.382>
  _dbg_check_lock();
 8009616:	f005 fe53 	bl	800f2c0 <_dbg_check_lock>
}
 800961a:	bd08      	pop	{r3, pc}
 800961c:	0000      	movs	r0, r0
	...

08009620 <chSysUnlock.lto_priv.290>:
static inline void chSysUnlock(void) {
 8009620:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8009622:	f005 fe65 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009626:	4b09      	ldr	r3, [pc, #36]	; (800964c <chSysUnlock.lto_priv.290+0x2c>)
 8009628:	681b      	ldr	r3, [r3, #0]
 800962a:	4a08      	ldr	r2, [pc, #32]	; (800964c <chSysUnlock.lto_priv.290+0x2c>)
 800962c:	4293      	cmp	r3, r2
 800962e:	d00a      	beq.n	8009646 <chSysUnlock.lto_priv.290+0x26>
 8009630:	4b06      	ldr	r3, [pc, #24]	; (800964c <chSysUnlock.lto_priv.290+0x2c>)
 8009632:	699b      	ldr	r3, [r3, #24]
 8009634:	689a      	ldr	r2, [r3, #8]
 8009636:	4b05      	ldr	r3, [pc, #20]	; (800964c <chSysUnlock.lto_priv.290+0x2c>)
 8009638:	681b      	ldr	r3, [r3, #0]
 800963a:	689b      	ldr	r3, [r3, #8]
 800963c:	429a      	cmp	r2, r3
 800963e:	d202      	bcs.n	8009646 <chSysUnlock.lto_priv.290+0x26>
 8009640:	4803      	ldr	r0, [pc, #12]	; (8009650 <chSysUnlock.lto_priv.290+0x30>)
 8009642:	f005 fccd 	bl	800efe0 <chSysHalt>
  port_unlock();
 8009646:	f7ff ffcb 	bl	80095e0 <port_unlock.lto_priv.351>
}
 800964a:	bd08      	pop	{r3, pc}
 800964c:	20001090 	.word	0x20001090
 8009650:	08015c5c 	.word	0x08015c5c
	...

08009660 <chThdQueueObjectInit.lto_priv.458>:
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8009660:	b500      	push	{lr}
 8009662:	b083      	sub	sp, #12
 8009664:	9001      	str	r0, [sp, #4]
  queue_init(tqp);
 8009666:	9801      	ldr	r0, [sp, #4]
 8009668:	f7ff ffc2 	bl	80095f0 <queue_init.lto_priv.461>
}
 800966c:	b003      	add	sp, #12
 800966e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009672:	bf00      	nop
	...

08009680 <osalSysLock.lto_priv.275>:
static inline void osalSysLock(void) {
 8009680:	b508      	push	{r3, lr}
  chSysLock();
 8009682:	f7ff ffc5 	bl	8009610 <chSysLock.lto_priv.314>
}
 8009686:	bd08      	pop	{r3, pc}
	...

08009690 <osalSysUnlock.lto_priv.266>:
static inline void osalSysUnlock(void) {
 8009690:	b508      	push	{r3, lr}
  chSysUnlock();
 8009692:	f7ff ffc5 	bl	8009620 <chSysUnlock.lto_priv.290>
}
 8009696:	bd08      	pop	{r3, pc}
	...

080096a0 <osalThreadQueueObjectInit.lto_priv.633>:
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 80096a0:	b500      	push	{lr}
 80096a2:	b083      	sub	sp, #12
 80096a4:	9001      	str	r0, [sp, #4]
  chThdQueueObjectInit(tqp);
 80096a6:	9801      	ldr	r0, [sp, #4]
 80096a8:	f7ff ffda 	bl	8009660 <chThdQueueObjectInit.lto_priv.458>
}
 80096ac:	b003      	add	sp, #12
 80096ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80096b2:	bf00      	nop
	...

080096c0 <osalThreadEnqueueTimeoutS.lto_priv.631>:
                                              sysinterval_t timeout) {
 80096c0:	b500      	push	{lr}
 80096c2:	b083      	sub	sp, #12
 80096c4:	9001      	str	r0, [sp, #4]
 80096c6:	9100      	str	r1, [sp, #0]
  return chThdEnqueueTimeoutS(tqp, timeout);
 80096c8:	9900      	ldr	r1, [sp, #0]
 80096ca:	9801      	ldr	r0, [sp, #4]
 80096cc:	f007 f950 	bl	8010970 <chThdEnqueueTimeoutS>
 80096d0:	4603      	mov	r3, r0
}
 80096d2:	4618      	mov	r0, r3
 80096d4:	b003      	add	sp, #12
 80096d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80096da:	bf00      	nop
 80096dc:	0000      	movs	r0, r0
	...

080096e0 <osalThreadDequeueNextI.lto_priv.629>:
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80096e0:	b500      	push	{lr}
 80096e2:	b083      	sub	sp, #12
 80096e4:	9001      	str	r0, [sp, #4]
 80096e6:	9100      	str	r1, [sp, #0]
  chThdDequeueNextI(tqp, msg);
 80096e8:	9900      	ldr	r1, [sp, #0]
 80096ea:	9801      	ldr	r0, [sp, #4]
 80096ec:	f007 f960 	bl	80109b0 <chThdDequeueNextI>
}
 80096f0:	b003      	add	sp, #12
 80096f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80096f6:	bf00      	nop
	...

08009700 <iq_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8009700:	b500      	push	{lr}
 8009702:	b087      	sub	sp, #28
 8009704:	9003      	str	r0, [sp, #12]
 8009706:	9102      	str	r1, [sp, #8]
 8009708:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);
 800970a:	9b01      	ldr	r3, [sp, #4]
 800970c:	2b00      	cmp	r3, #0
 800970e:	d102      	bne.n	8009716 <iq_read+0x16>
 8009710:	482d      	ldr	r0, [pc, #180]	; (80097c8 <iq_read+0xc8>)
 8009712:	f005 fc65 	bl	800efe0 <chSysHalt>

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
 8009716:	9b03      	ldr	r3, [sp, #12]
 8009718:	689b      	ldr	r3, [r3, #8]
 800971a:	9a01      	ldr	r2, [sp, #4]
 800971c:	429a      	cmp	r2, r3
 800971e:	d902      	bls.n	8009726 <iq_read+0x26>
    n = iqGetFullI(iqp);
 8009720:	9b03      	ldr	r3, [sp, #12]
 8009722:	689b      	ldr	r3, [r3, #8]
 8009724:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8009726:	9b03      	ldr	r3, [sp, #12]
 8009728:	691b      	ldr	r3, [r3, #16]
 800972a:	461a      	mov	r2, r3
 800972c:	9b03      	ldr	r3, [sp, #12]
 800972e:	699b      	ldr	r3, [r3, #24]
 8009730:	1ad3      	subs	r3, r2, r3
 8009732:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
 8009734:	9a01      	ldr	r2, [sp, #4]
 8009736:	9b05      	ldr	r3, [sp, #20]
 8009738:	429a      	cmp	r2, r3
 800973a:	d20d      	bcs.n	8009758 <iq_read+0x58>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800973c:	9b03      	ldr	r3, [sp, #12]
 800973e:	699b      	ldr	r3, [r3, #24]
 8009740:	9a01      	ldr	r2, [sp, #4]
 8009742:	4619      	mov	r1, r3
 8009744:	9802      	ldr	r0, [sp, #8]
 8009746:	f7f6 fde5 	bl	8000314 <memcpy>
    iqp->q_rdptr += n;
 800974a:	9b03      	ldr	r3, [sp, #12]
 800974c:	699a      	ldr	r2, [r3, #24]
 800974e:	9b01      	ldr	r3, [sp, #4]
 8009750:	441a      	add	r2, r3
 8009752:	9b03      	ldr	r3, [sp, #12]
 8009754:	619a      	str	r2, [r3, #24]
 8009756:	e02b      	b.n	80097b0 <iq_read+0xb0>
  }
  else if (n > s1) {
 8009758:	9a01      	ldr	r2, [sp, #4]
 800975a:	9b05      	ldr	r3, [sp, #20]
 800975c:	429a      	cmp	r2, r3
 800975e:	d91c      	bls.n	800979a <iq_read+0x9a>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8009760:	9b03      	ldr	r3, [sp, #12]
 8009762:	699b      	ldr	r3, [r3, #24]
 8009764:	9a05      	ldr	r2, [sp, #20]
 8009766:	4619      	mov	r1, r3
 8009768:	9802      	ldr	r0, [sp, #8]
 800976a:	f7f6 fdd3 	bl	8000314 <memcpy>
    bp += s1;
 800976e:	9a02      	ldr	r2, [sp, #8]
 8009770:	9b05      	ldr	r3, [sp, #20]
 8009772:	4413      	add	r3, r2
 8009774:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 8009776:	9a01      	ldr	r2, [sp, #4]
 8009778:	9b05      	ldr	r3, [sp, #20]
 800977a:	1ad3      	subs	r3, r2, r3
 800977c:	9304      	str	r3, [sp, #16]
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 800977e:	9b03      	ldr	r3, [sp, #12]
 8009780:	68db      	ldr	r3, [r3, #12]
 8009782:	9a04      	ldr	r2, [sp, #16]
 8009784:	4619      	mov	r1, r3
 8009786:	9802      	ldr	r0, [sp, #8]
 8009788:	f7f6 fdc4 	bl	8000314 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 800978c:	9b03      	ldr	r3, [sp, #12]
 800978e:	68da      	ldr	r2, [r3, #12]
 8009790:	9b04      	ldr	r3, [sp, #16]
 8009792:	441a      	add	r2, r3
 8009794:	9b03      	ldr	r3, [sp, #12]
 8009796:	619a      	str	r2, [r3, #24]
 8009798:	e00a      	b.n	80097b0 <iq_read+0xb0>
  }
  else { /* n == s1 */
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800979a:	9b03      	ldr	r3, [sp, #12]
 800979c:	699b      	ldr	r3, [r3, #24]
 800979e:	9a01      	ldr	r2, [sp, #4]
 80097a0:	4619      	mov	r1, r3
 80097a2:	9802      	ldr	r0, [sp, #8]
 80097a4:	f7f6 fdb6 	bl	8000314 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 80097a8:	9b03      	ldr	r3, [sp, #12]
 80097aa:	68da      	ldr	r2, [r3, #12]
 80097ac:	9b03      	ldr	r3, [sp, #12]
 80097ae:	619a      	str	r2, [r3, #24]
  }

  iqp->q_counter -= n;
 80097b0:	9b03      	ldr	r3, [sp, #12]
 80097b2:	689a      	ldr	r2, [r3, #8]
 80097b4:	9b01      	ldr	r3, [sp, #4]
 80097b6:	1ad2      	subs	r2, r2, r3
 80097b8:	9b03      	ldr	r3, [sp, #12]
 80097ba:	609a      	str	r2, [r3, #8]
  return n;
 80097bc:	9b01      	ldr	r3, [sp, #4]
}
 80097be:	4618      	mov	r0, r3
 80097c0:	b007      	add	sp, #28
 80097c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80097c6:	bf00      	nop
 80097c8:	08015c48 	.word	0x08015c48
 80097cc:	00000000 	.word	0x00000000

080097d0 <oq_write>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 80097d0:	b500      	push	{lr}
 80097d2:	b087      	sub	sp, #28
 80097d4:	9003      	str	r0, [sp, #12]
 80097d6:	9102      	str	r1, [sp, #8]
 80097d8:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);
 80097da:	9b01      	ldr	r3, [sp, #4]
 80097dc:	2b00      	cmp	r3, #0
 80097de:	d102      	bne.n	80097e6 <oq_write+0x16>
 80097e0:	482d      	ldr	r0, [pc, #180]	; (8009898 <oq_write+0xc8>)
 80097e2:	f005 fbfd 	bl	800efe0 <chSysHalt>

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
 80097e6:	9b03      	ldr	r3, [sp, #12]
 80097e8:	689b      	ldr	r3, [r3, #8]
 80097ea:	9a01      	ldr	r2, [sp, #4]
 80097ec:	429a      	cmp	r2, r3
 80097ee:	d902      	bls.n	80097f6 <oq_write+0x26>
    n = oqGetEmptyI(oqp);
 80097f0:	9b03      	ldr	r3, [sp, #12]
 80097f2:	689b      	ldr	r3, [r3, #8]
 80097f4:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 80097f6:	9b03      	ldr	r3, [sp, #12]
 80097f8:	691b      	ldr	r3, [r3, #16]
 80097fa:	461a      	mov	r2, r3
 80097fc:	9b03      	ldr	r3, [sp, #12]
 80097fe:	695b      	ldr	r3, [r3, #20]
 8009800:	1ad3      	subs	r3, r2, r3
 8009802:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
 8009804:	9a01      	ldr	r2, [sp, #4]
 8009806:	9b05      	ldr	r3, [sp, #20]
 8009808:	429a      	cmp	r2, r3
 800980a:	d20d      	bcs.n	8009828 <oq_write+0x58>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 800980c:	9b03      	ldr	r3, [sp, #12]
 800980e:	695b      	ldr	r3, [r3, #20]
 8009810:	9a01      	ldr	r2, [sp, #4]
 8009812:	9902      	ldr	r1, [sp, #8]
 8009814:	4618      	mov	r0, r3
 8009816:	f7f6 fd7d 	bl	8000314 <memcpy>
    oqp->q_wrptr += n;
 800981a:	9b03      	ldr	r3, [sp, #12]
 800981c:	695a      	ldr	r2, [r3, #20]
 800981e:	9b01      	ldr	r3, [sp, #4]
 8009820:	441a      	add	r2, r3
 8009822:	9b03      	ldr	r3, [sp, #12]
 8009824:	615a      	str	r2, [r3, #20]
 8009826:	e02b      	b.n	8009880 <oq_write+0xb0>
  }
  else if (n > s1) {
 8009828:	9a01      	ldr	r2, [sp, #4]
 800982a:	9b05      	ldr	r3, [sp, #20]
 800982c:	429a      	cmp	r2, r3
 800982e:	d91c      	bls.n	800986a <oq_write+0x9a>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8009830:	9b03      	ldr	r3, [sp, #12]
 8009832:	695b      	ldr	r3, [r3, #20]
 8009834:	9a05      	ldr	r2, [sp, #20]
 8009836:	9902      	ldr	r1, [sp, #8]
 8009838:	4618      	mov	r0, r3
 800983a:	f7f6 fd6b 	bl	8000314 <memcpy>
    bp += s1;
 800983e:	9a02      	ldr	r2, [sp, #8]
 8009840:	9b05      	ldr	r3, [sp, #20]
 8009842:	4413      	add	r3, r2
 8009844:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 8009846:	9a01      	ldr	r2, [sp, #4]
 8009848:	9b05      	ldr	r3, [sp, #20]
 800984a:	1ad3      	subs	r3, r2, r3
 800984c:	9304      	str	r3, [sp, #16]
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 800984e:	9b03      	ldr	r3, [sp, #12]
 8009850:	68db      	ldr	r3, [r3, #12]
 8009852:	9a04      	ldr	r2, [sp, #16]
 8009854:	9902      	ldr	r1, [sp, #8]
 8009856:	4618      	mov	r0, r3
 8009858:	f7f6 fd5c 	bl	8000314 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 800985c:	9b03      	ldr	r3, [sp, #12]
 800985e:	68da      	ldr	r2, [r3, #12]
 8009860:	9b04      	ldr	r3, [sp, #16]
 8009862:	441a      	add	r2, r3
 8009864:	9b03      	ldr	r3, [sp, #12]
 8009866:	615a      	str	r2, [r3, #20]
 8009868:	e00a      	b.n	8009880 <oq_write+0xb0>
  }
  else { /* n == s1 */
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 800986a:	9b03      	ldr	r3, [sp, #12]
 800986c:	695b      	ldr	r3, [r3, #20]
 800986e:	9a01      	ldr	r2, [sp, #4]
 8009870:	9902      	ldr	r1, [sp, #8]
 8009872:	4618      	mov	r0, r3
 8009874:	f7f6 fd4e 	bl	8000314 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8009878:	9b03      	ldr	r3, [sp, #12]
 800987a:	68da      	ldr	r2, [r3, #12]
 800987c:	9b03      	ldr	r3, [sp, #12]
 800987e:	615a      	str	r2, [r3, #20]
  }

  oqp->q_counter -= n;
 8009880:	9b03      	ldr	r3, [sp, #12]
 8009882:	689a      	ldr	r2, [r3, #8]
 8009884:	9b01      	ldr	r3, [sp, #4]
 8009886:	1ad2      	subs	r2, r2, r3
 8009888:	9b03      	ldr	r3, [sp, #12]
 800988a:	609a      	str	r2, [r3, #8]
  return n;
 800988c:	9b01      	ldr	r3, [sp, #4]
}
 800988e:	4618      	mov	r0, r3
 8009890:	b007      	add	sp, #28
 8009892:	f85d fb04 	ldr.w	pc, [sp], #4
 8009896:	bf00      	nop
 8009898:	08015c50 	.word	0x08015c50
 800989c:	00000000 	.word	0x00000000

080098a0 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 80098a0:	b500      	push	{lr}
 80098a2:	b085      	sub	sp, #20
 80098a4:	9003      	str	r0, [sp, #12]
 80098a6:	9102      	str	r1, [sp, #8]
 80098a8:	9201      	str	r2, [sp, #4]
 80098aa:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 80098ac:	9b03      	ldr	r3, [sp, #12]
 80098ae:	4618      	mov	r0, r3
 80098b0:	f7ff fef6 	bl	80096a0 <osalThreadQueueObjectInit.lto_priv.633>
  iqp->q_counter = 0;
 80098b4:	9b03      	ldr	r3, [sp, #12]
 80098b6:	2200      	movs	r2, #0
 80098b8:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 80098ba:	9b03      	ldr	r3, [sp, #12]
 80098bc:	9a02      	ldr	r2, [sp, #8]
 80098be:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 80098c0:	9b03      	ldr	r3, [sp, #12]
 80098c2:	9a02      	ldr	r2, [sp, #8]
 80098c4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 80098c6:	9b03      	ldr	r3, [sp, #12]
 80098c8:	9a02      	ldr	r2, [sp, #8]
 80098ca:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 80098cc:	9a02      	ldr	r2, [sp, #8]
 80098ce:	9b01      	ldr	r3, [sp, #4]
 80098d0:	441a      	add	r2, r3
 80098d2:	9b03      	ldr	r3, [sp, #12]
 80098d4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 80098d6:	9b03      	ldr	r3, [sp, #12]
 80098d8:	9a00      	ldr	r2, [sp, #0]
 80098da:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 80098dc:	9b03      	ldr	r3, [sp, #12]
 80098de:	9a06      	ldr	r2, [sp, #24]
 80098e0:	621a      	str	r2, [r3, #32]
}
 80098e2:	b005      	add	sp, #20
 80098e4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080098f0 <iqPutI>:
 * @retval MSG_OK       if the operation has been completed with success.
 * @retval MSG_TIMEOUT  if the queue is full.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 80098f0:	b500      	push	{lr}
 80098f2:	b083      	sub	sp, #12
 80098f4:	9001      	str	r0, [sp, #4]
 80098f6:	460b      	mov	r3, r1
 80098f8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
 80098fc:	f005 fd80 	bl	800f400 <chDbgCheckClassI>

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 8009900:	9b01      	ldr	r3, [sp, #4]
 8009902:	695a      	ldr	r2, [r3, #20]
 8009904:	9b01      	ldr	r3, [sp, #4]
 8009906:	699b      	ldr	r3, [r3, #24]
 8009908:	429a      	cmp	r2, r3
 800990a:	d105      	bne.n	8009918 <iqPutI+0x28>
 800990c:	9b01      	ldr	r3, [sp, #4]
 800990e:	689b      	ldr	r3, [r3, #8]
 8009910:	2b00      	cmp	r3, #0
 8009912:	d001      	beq.n	8009918 <iqPutI+0x28>
 8009914:	2301      	movs	r3, #1
 8009916:	e000      	b.n	800991a <iqPutI+0x2a>
 8009918:	2300      	movs	r3, #0
 800991a:	f003 0301 	and.w	r3, r3, #1
 800991e:	b2db      	uxtb	r3, r3
 8009920:	f083 0301 	eor.w	r3, r3, #1
 8009924:	b2db      	uxtb	r3, r3
 8009926:	2b00      	cmp	r3, #0
 8009928:	d01d      	beq.n	8009966 <iqPutI+0x76>
    iqp->q_counter++;
 800992a:	9b01      	ldr	r3, [sp, #4]
 800992c:	689b      	ldr	r3, [r3, #8]
 800992e:	1c5a      	adds	r2, r3, #1
 8009930:	9b01      	ldr	r3, [sp, #4]
 8009932:	609a      	str	r2, [r3, #8]
    *iqp->q_wrptr++ = b;
 8009934:	9b01      	ldr	r3, [sp, #4]
 8009936:	695b      	ldr	r3, [r3, #20]
 8009938:	1c59      	adds	r1, r3, #1
 800993a:	9a01      	ldr	r2, [sp, #4]
 800993c:	6151      	str	r1, [r2, #20]
 800993e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009942:	701a      	strb	r2, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8009944:	9b01      	ldr	r3, [sp, #4]
 8009946:	695a      	ldr	r2, [r3, #20]
 8009948:	9b01      	ldr	r3, [sp, #4]
 800994a:	691b      	ldr	r3, [r3, #16]
 800994c:	429a      	cmp	r2, r3
 800994e:	d303      	bcc.n	8009958 <iqPutI+0x68>
      iqp->q_wrptr = iqp->q_buffer;
 8009950:	9b01      	ldr	r3, [sp, #4]
 8009952:	68da      	ldr	r2, [r3, #12]
 8009954:	9b01      	ldr	r3, [sp, #4]
 8009956:	615a      	str	r2, [r3, #20]
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8009958:	9b01      	ldr	r3, [sp, #4]
 800995a:	2100      	movs	r1, #0
 800995c:	4618      	mov	r0, r3
 800995e:	f7ff febf 	bl	80096e0 <osalThreadDequeueNextI.lto_priv.629>

    return MSG_OK;
 8009962:	2300      	movs	r3, #0
 8009964:	e001      	b.n	800996a <iqPutI+0x7a>
  }

  return MSG_TIMEOUT;
 8009966:	f04f 33ff 	mov.w	r3, #4294967295
}
 800996a:	4618      	mov	r0, r3
 800996c:	b003      	add	sp, #12
 800996e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009972:	bf00      	nop
	...

08009980 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8009980:	b500      	push	{lr}
 8009982:	b085      	sub	sp, #20
 8009984:	9001      	str	r0, [sp, #4]
 8009986:	9100      	str	r1, [sp, #0]
  uint8_t b;

  osalSysLock();
 8009988:	f7ff fe7a 	bl	8009680 <osalSysLock.lto_priv.275>
 800998c:	e00c      	b.n	80099a8 <iqGetTimeout+0x28>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800998e:	9b01      	ldr	r3, [sp, #4]
 8009990:	9900      	ldr	r1, [sp, #0]
 8009992:	4618      	mov	r0, r3
 8009994:	f7ff fe94 	bl	80096c0 <osalThreadEnqueueTimeoutS.lto_priv.631>
 8009998:	9002      	str	r0, [sp, #8]
    if (msg < MSG_OK) {
 800999a:	9b02      	ldr	r3, [sp, #8]
 800999c:	2b00      	cmp	r3, #0
 800999e:	da03      	bge.n	80099a8 <iqGetTimeout+0x28>
      osalSysUnlock();
 80099a0:	f7ff fe76 	bl	8009690 <osalSysUnlock.lto_priv.266>
      return msg;
 80099a4:	9b02      	ldr	r3, [sp, #8]
 80099a6:	e026      	b.n	80099f6 <iqGetTimeout+0x76>
  while (iqIsEmptyI(iqp)) {
 80099a8:	9b01      	ldr	r3, [sp, #4]
 80099aa:	689b      	ldr	r3, [r3, #8]
 80099ac:	2b00      	cmp	r3, #0
 80099ae:	d0ee      	beq.n	800998e <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 80099b0:	9b01      	ldr	r3, [sp, #4]
 80099b2:	689b      	ldr	r3, [r3, #8]
 80099b4:	1e5a      	subs	r2, r3, #1
 80099b6:	9b01      	ldr	r3, [sp, #4]
 80099b8:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 80099ba:	9b01      	ldr	r3, [sp, #4]
 80099bc:	699b      	ldr	r3, [r3, #24]
 80099be:	1c59      	adds	r1, r3, #1
 80099c0:	9a01      	ldr	r2, [sp, #4]
 80099c2:	6191      	str	r1, [r2, #24]
 80099c4:	781b      	ldrb	r3, [r3, #0]
 80099c6:	f88d 300f 	strb.w	r3, [sp, #15]
  if (iqp->q_rdptr >= iqp->q_top) {
 80099ca:	9b01      	ldr	r3, [sp, #4]
 80099cc:	699a      	ldr	r2, [r3, #24]
 80099ce:	9b01      	ldr	r3, [sp, #4]
 80099d0:	691b      	ldr	r3, [r3, #16]
 80099d2:	429a      	cmp	r2, r3
 80099d4:	d303      	bcc.n	80099de <iqGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
 80099d6:	9b01      	ldr	r3, [sp, #4]
 80099d8:	68da      	ldr	r2, [r3, #12]
 80099da:	9b01      	ldr	r3, [sp, #4]
 80099dc:	619a      	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 80099de:	9b01      	ldr	r3, [sp, #4]
 80099e0:	69db      	ldr	r3, [r3, #28]
 80099e2:	2b00      	cmp	r3, #0
 80099e4:	d003      	beq.n	80099ee <iqGetTimeout+0x6e>
    iqp->q_notify(iqp);
 80099e6:	9b01      	ldr	r3, [sp, #4]
 80099e8:	69db      	ldr	r3, [r3, #28]
 80099ea:	9801      	ldr	r0, [sp, #4]
 80099ec:	4798      	blx	r3
  }

  osalSysUnlock();
 80099ee:	f7ff fe4f 	bl	8009690 <osalSysUnlock.lto_priv.266>

  return (msg_t)b;
 80099f2:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 80099f6:	4618      	mov	r0, r3
 80099f8:	b005      	add	sp, #20
 80099fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80099fe:	bf00      	nop

08009a00 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
 8009a00:	b500      	push	{lr}
 8009a02:	b089      	sub	sp, #36	; 0x24
 8009a04:	9003      	str	r0, [sp, #12]
 8009a06:	9102      	str	r1, [sp, #8]
 8009a08:	9201      	str	r2, [sp, #4]
 8009a0a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 8009a0c:	9b03      	ldr	r3, [sp, #12]
 8009a0e:	69db      	ldr	r3, [r3, #28]
 8009a10:	9307      	str	r3, [sp, #28]
  size_t max = n;
 8009a12:	9b01      	ldr	r3, [sp, #4]
 8009a14:	9306      	str	r3, [sp, #24]

  osalDbgCheck(n > 0U);
 8009a16:	9b01      	ldr	r3, [sp, #4]
 8009a18:	2b00      	cmp	r3, #0
 8009a1a:	d102      	bne.n	8009a22 <iqReadTimeout+0x22>
 8009a1c:	481b      	ldr	r0, [pc, #108]	; (8009a8c <iqReadTimeout+0x8c>)
 8009a1e:	f005 fadf 	bl	800efe0 <chSysHalt>

  osalSysLock();
 8009a22:	f7ff fe2d 	bl	8009680 <osalSysLock.lto_priv.275>
 8009a26:	e024      	b.n	8009a72 <iqReadTimeout+0x72>

  while (n > 0U) {
    size_t done;

    done = iq_read(iqp, bp, n);
 8009a28:	9a01      	ldr	r2, [sp, #4]
 8009a2a:	9902      	ldr	r1, [sp, #8]
 8009a2c:	9803      	ldr	r0, [sp, #12]
 8009a2e:	f7ff fe67 	bl	8009700 <iq_read>
 8009a32:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
 8009a34:	9b05      	ldr	r3, [sp, #20]
 8009a36:	2b00      	cmp	r3, #0
 8009a38:	d109      	bne.n	8009a4e <iqReadTimeout+0x4e>
      msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8009a3a:	9b03      	ldr	r3, [sp, #12]
 8009a3c:	9900      	ldr	r1, [sp, #0]
 8009a3e:	4618      	mov	r0, r3
 8009a40:	f7ff fe3e 	bl	80096c0 <osalThreadEnqueueTimeoutS.lto_priv.631>
 8009a44:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8009a46:	9b04      	ldr	r3, [sp, #16]
 8009a48:	2b00      	cmp	r3, #0
 8009a4a:	d115      	bne.n	8009a78 <iqReadTimeout+0x78>
 8009a4c:	e011      	b.n	8009a72 <iqReadTimeout+0x72>
      }
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
 8009a4e:	9b07      	ldr	r3, [sp, #28]
 8009a50:	2b00      	cmp	r3, #0
 8009a52:	d002      	beq.n	8009a5a <iqReadTimeout+0x5a>
        nfy(iqp);
 8009a54:	9b07      	ldr	r3, [sp, #28]
 8009a56:	9803      	ldr	r0, [sp, #12]
 8009a58:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
 8009a5a:	f7ff fe19 	bl	8009690 <osalSysUnlock.lto_priv.266>

      n  -= done;
 8009a5e:	9a01      	ldr	r2, [sp, #4]
 8009a60:	9b05      	ldr	r3, [sp, #20]
 8009a62:	1ad3      	subs	r3, r2, r3
 8009a64:	9301      	str	r3, [sp, #4]
      bp += done;
 8009a66:	9a02      	ldr	r2, [sp, #8]
 8009a68:	9b05      	ldr	r3, [sp, #20]
 8009a6a:	4413      	add	r3, r2
 8009a6c:	9302      	str	r3, [sp, #8]

      osalSysLock();
 8009a6e:	f7ff fe07 	bl	8009680 <osalSysLock.lto_priv.275>
  while (n > 0U) {
 8009a72:	9b01      	ldr	r3, [sp, #4]
 8009a74:	2b00      	cmp	r3, #0
 8009a76:	d1d7      	bne.n	8009a28 <iqReadTimeout+0x28>
    }
  }

  osalSysUnlock();
 8009a78:	f7ff fe0a 	bl	8009690 <osalSysUnlock.lto_priv.266>
  return max - n;
 8009a7c:	9a06      	ldr	r2, [sp, #24]
 8009a7e:	9b01      	ldr	r3, [sp, #4]
 8009a80:	1ad3      	subs	r3, r2, r3
}
 8009a82:	4618      	mov	r0, r3
 8009a84:	b009      	add	sp, #36	; 0x24
 8009a86:	f85d fb04 	ldr.w	pc, [sp], #4
 8009a8a:	bf00      	nop
 8009a8c:	08015c68 	.word	0x08015c68

08009a90 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8009a90:	b500      	push	{lr}
 8009a92:	b085      	sub	sp, #20
 8009a94:	9003      	str	r0, [sp, #12]
 8009a96:	9102      	str	r1, [sp, #8]
 8009a98:	9201      	str	r2, [sp, #4]
 8009a9a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 8009a9c:	9b03      	ldr	r3, [sp, #12]
 8009a9e:	4618      	mov	r0, r3
 8009aa0:	f7ff fdfe 	bl	80096a0 <osalThreadQueueObjectInit.lto_priv.633>
  oqp->q_counter = size;
 8009aa4:	9b03      	ldr	r3, [sp, #12]
 8009aa6:	9a01      	ldr	r2, [sp, #4]
 8009aa8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 8009aaa:	9b03      	ldr	r3, [sp, #12]
 8009aac:	9a02      	ldr	r2, [sp, #8]
 8009aae:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8009ab0:	9b03      	ldr	r3, [sp, #12]
 8009ab2:	9a02      	ldr	r2, [sp, #8]
 8009ab4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8009ab6:	9b03      	ldr	r3, [sp, #12]
 8009ab8:	9a02      	ldr	r2, [sp, #8]
 8009aba:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 8009abc:	9a02      	ldr	r2, [sp, #8]
 8009abe:	9b01      	ldr	r3, [sp, #4]
 8009ac0:	441a      	add	r2, r3
 8009ac2:	9b03      	ldr	r3, [sp, #12]
 8009ac4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8009ac6:	9b03      	ldr	r3, [sp, #12]
 8009ac8:	9a00      	ldr	r2, [sp, #0]
 8009aca:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 8009acc:	9b03      	ldr	r3, [sp, #12]
 8009ace:	9a06      	ldr	r2, [sp, #24]
 8009ad0:	621a      	str	r2, [r3, #32]
}
 8009ad2:	b005      	add	sp, #20
 8009ad4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08009ae0 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8009ae0:	b500      	push	{lr}
 8009ae2:	b087      	sub	sp, #28
 8009ae4:	9003      	str	r0, [sp, #12]
 8009ae6:	460b      	mov	r3, r1
 8009ae8:	9201      	str	r2, [sp, #4]
 8009aea:	f88d 300b 	strb.w	r3, [sp, #11]

  osalSysLock();
 8009aee:	f7ff fdc7 	bl	8009680 <osalSysLock.lto_priv.275>
 8009af2:	e00c      	b.n	8009b0e <oqPutTimeout+0x2e>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8009af4:	9b03      	ldr	r3, [sp, #12]
 8009af6:	9901      	ldr	r1, [sp, #4]
 8009af8:	4618      	mov	r0, r3
 8009afa:	f7ff fde1 	bl	80096c0 <osalThreadEnqueueTimeoutS.lto_priv.631>
 8009afe:	9005      	str	r0, [sp, #20]
    if (msg < MSG_OK) {
 8009b00:	9b05      	ldr	r3, [sp, #20]
 8009b02:	2b00      	cmp	r3, #0
 8009b04:	da03      	bge.n	8009b0e <oqPutTimeout+0x2e>
      osalSysUnlock();
 8009b06:	f7ff fdc3 	bl	8009690 <osalSysUnlock.lto_priv.266>
      return msg;
 8009b0a:	9b05      	ldr	r3, [sp, #20]
 8009b0c:	e025      	b.n	8009b5a <oqPutTimeout+0x7a>
  while (oqIsFullI(oqp)) {
 8009b0e:	9b03      	ldr	r3, [sp, #12]
 8009b10:	689b      	ldr	r3, [r3, #8]
 8009b12:	2b00      	cmp	r3, #0
 8009b14:	d0ee      	beq.n	8009af4 <oqPutTimeout+0x14>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8009b16:	9b03      	ldr	r3, [sp, #12]
 8009b18:	689b      	ldr	r3, [r3, #8]
 8009b1a:	1e5a      	subs	r2, r3, #1
 8009b1c:	9b03      	ldr	r3, [sp, #12]
 8009b1e:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8009b20:	9b03      	ldr	r3, [sp, #12]
 8009b22:	695b      	ldr	r3, [r3, #20]
 8009b24:	1c59      	adds	r1, r3, #1
 8009b26:	9a03      	ldr	r2, [sp, #12]
 8009b28:	6151      	str	r1, [r2, #20]
 8009b2a:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8009b2e:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8009b30:	9b03      	ldr	r3, [sp, #12]
 8009b32:	695a      	ldr	r2, [r3, #20]
 8009b34:	9b03      	ldr	r3, [sp, #12]
 8009b36:	691b      	ldr	r3, [r3, #16]
 8009b38:	429a      	cmp	r2, r3
 8009b3a:	d303      	bcc.n	8009b44 <oqPutTimeout+0x64>
    oqp->q_wrptr = oqp->q_buffer;
 8009b3c:	9b03      	ldr	r3, [sp, #12]
 8009b3e:	68da      	ldr	r2, [r3, #12]
 8009b40:	9b03      	ldr	r3, [sp, #12]
 8009b42:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8009b44:	9b03      	ldr	r3, [sp, #12]
 8009b46:	69db      	ldr	r3, [r3, #28]
 8009b48:	2b00      	cmp	r3, #0
 8009b4a:	d003      	beq.n	8009b54 <oqPutTimeout+0x74>
    oqp->q_notify(oqp);
 8009b4c:	9b03      	ldr	r3, [sp, #12]
 8009b4e:	69db      	ldr	r3, [r3, #28]
 8009b50:	9803      	ldr	r0, [sp, #12]
 8009b52:	4798      	blx	r3
  }

  osalSysUnlock();
 8009b54:	f7ff fd9c 	bl	8009690 <osalSysUnlock.lto_priv.266>

  return MSG_OK;
 8009b58:	2300      	movs	r3, #0
}
 8009b5a:	4618      	mov	r0, r3
 8009b5c:	b007      	add	sp, #28
 8009b5e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009b62:	bf00      	nop
	...

08009b70 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8009b70:	b500      	push	{lr}
 8009b72:	b085      	sub	sp, #20
 8009b74:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8009b76:	f005 fc43 	bl	800f400 <chDbgCheckClassI>

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8009b7a:	9b01      	ldr	r3, [sp, #4]
 8009b7c:	695a      	ldr	r2, [r3, #20]
 8009b7e:	9b01      	ldr	r3, [sp, #4]
 8009b80:	699b      	ldr	r3, [r3, #24]
 8009b82:	429a      	cmp	r2, r3
 8009b84:	d105      	bne.n	8009b92 <oqGetI+0x22>
 8009b86:	9b01      	ldr	r3, [sp, #4]
 8009b88:	689b      	ldr	r3, [r3, #8]
 8009b8a:	2b00      	cmp	r3, #0
 8009b8c:	d001      	beq.n	8009b92 <oqGetI+0x22>
 8009b8e:	2301      	movs	r3, #1
 8009b90:	e000      	b.n	8009b94 <oqGetI+0x24>
 8009b92:	2300      	movs	r3, #0
 8009b94:	f003 0301 	and.w	r3, r3, #1
 8009b98:	b2db      	uxtb	r3, r3
 8009b9a:	f083 0301 	eor.w	r3, r3, #1
 8009b9e:	b2db      	uxtb	r3, r3
 8009ba0:	2b00      	cmp	r3, #0
 8009ba2:	d01e      	beq.n	8009be2 <oqGetI+0x72>
    uint8_t b;

    oqp->q_counter++;
 8009ba4:	9b01      	ldr	r3, [sp, #4]
 8009ba6:	689b      	ldr	r3, [r3, #8]
 8009ba8:	1c5a      	adds	r2, r3, #1
 8009baa:	9b01      	ldr	r3, [sp, #4]
 8009bac:	609a      	str	r2, [r3, #8]
    b = *oqp->q_rdptr++;
 8009bae:	9b01      	ldr	r3, [sp, #4]
 8009bb0:	699b      	ldr	r3, [r3, #24]
 8009bb2:	1c59      	adds	r1, r3, #1
 8009bb4:	9a01      	ldr	r2, [sp, #4]
 8009bb6:	6191      	str	r1, [r2, #24]
 8009bb8:	781b      	ldrb	r3, [r3, #0]
 8009bba:	f88d 300f 	strb.w	r3, [sp, #15]
    if (oqp->q_rdptr >= oqp->q_top) {
 8009bbe:	9b01      	ldr	r3, [sp, #4]
 8009bc0:	699a      	ldr	r2, [r3, #24]
 8009bc2:	9b01      	ldr	r3, [sp, #4]
 8009bc4:	691b      	ldr	r3, [r3, #16]
 8009bc6:	429a      	cmp	r2, r3
 8009bc8:	d303      	bcc.n	8009bd2 <oqGetI+0x62>
      oqp->q_rdptr = oqp->q_buffer;
 8009bca:	9b01      	ldr	r3, [sp, #4]
 8009bcc:	68da      	ldr	r2, [r3, #12]
 8009bce:	9b01      	ldr	r3, [sp, #4]
 8009bd0:	619a      	str	r2, [r3, #24]
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8009bd2:	9b01      	ldr	r3, [sp, #4]
 8009bd4:	2100      	movs	r1, #0
 8009bd6:	4618      	mov	r0, r3
 8009bd8:	f7ff fd82 	bl	80096e0 <osalThreadDequeueNextI.lto_priv.629>

    return (msg_t)b;
 8009bdc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8009be0:	e001      	b.n	8009be6 <oqGetI+0x76>
  }

  return MSG_TIMEOUT;
 8009be2:	f04f 33ff 	mov.w	r3, #4294967295
}
 8009be6:	4618      	mov	r0, r3
 8009be8:	b005      	add	sp, #20
 8009bea:	f85d fb04 	ldr.w	pc, [sp], #4
 8009bee:	bf00      	nop

08009bf0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8009bf0:	b500      	push	{lr}
 8009bf2:	b089      	sub	sp, #36	; 0x24
 8009bf4:	9003      	str	r0, [sp, #12]
 8009bf6:	9102      	str	r1, [sp, #8]
 8009bf8:	9201      	str	r2, [sp, #4]
 8009bfa:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 8009bfc:	9b03      	ldr	r3, [sp, #12]
 8009bfe:	69db      	ldr	r3, [r3, #28]
 8009c00:	9307      	str	r3, [sp, #28]
  size_t max = n;
 8009c02:	9b01      	ldr	r3, [sp, #4]
 8009c04:	9306      	str	r3, [sp, #24]

  osalDbgCheck(n > 0U);
 8009c06:	9b01      	ldr	r3, [sp, #4]
 8009c08:	2b00      	cmp	r3, #0
 8009c0a:	d102      	bne.n	8009c12 <oqWriteTimeout+0x22>
 8009c0c:	481b      	ldr	r0, [pc, #108]	; (8009c7c <oqWriteTimeout+0x8c>)
 8009c0e:	f005 f9e7 	bl	800efe0 <chSysHalt>

  osalSysLock();
 8009c12:	f7ff fd35 	bl	8009680 <osalSysLock.lto_priv.275>
 8009c16:	e024      	b.n	8009c62 <oqWriteTimeout+0x72>

  while (n > 0U) {
    size_t done;

    done = oq_write(oqp, bp, n);
 8009c18:	9a01      	ldr	r2, [sp, #4]
 8009c1a:	9902      	ldr	r1, [sp, #8]
 8009c1c:	9803      	ldr	r0, [sp, #12]
 8009c1e:	f7ff fdd7 	bl	80097d0 <oq_write>
 8009c22:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
 8009c24:	9b05      	ldr	r3, [sp, #20]
 8009c26:	2b00      	cmp	r3, #0
 8009c28:	d109      	bne.n	8009c3e <oqWriteTimeout+0x4e>
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8009c2a:	9b03      	ldr	r3, [sp, #12]
 8009c2c:	9900      	ldr	r1, [sp, #0]
 8009c2e:	4618      	mov	r0, r3
 8009c30:	f7ff fd46 	bl	80096c0 <osalThreadEnqueueTimeoutS.lto_priv.631>
 8009c34:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8009c36:	9b04      	ldr	r3, [sp, #16]
 8009c38:	2b00      	cmp	r3, #0
 8009c3a:	d115      	bne.n	8009c68 <oqWriteTimeout+0x78>
 8009c3c:	e011      	b.n	8009c62 <oqWriteTimeout+0x72>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 8009c3e:	9b07      	ldr	r3, [sp, #28]
 8009c40:	2b00      	cmp	r3, #0
 8009c42:	d002      	beq.n	8009c4a <oqWriteTimeout+0x5a>
        nfy(oqp);
 8009c44:	9b07      	ldr	r3, [sp, #28]
 8009c46:	9803      	ldr	r0, [sp, #12]
 8009c48:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
 8009c4a:	f7ff fd21 	bl	8009690 <osalSysUnlock.lto_priv.266>

      n  -= done;
 8009c4e:	9a01      	ldr	r2, [sp, #4]
 8009c50:	9b05      	ldr	r3, [sp, #20]
 8009c52:	1ad3      	subs	r3, r2, r3
 8009c54:	9301      	str	r3, [sp, #4]
      bp += done;
 8009c56:	9a02      	ldr	r2, [sp, #8]
 8009c58:	9b05      	ldr	r3, [sp, #20]
 8009c5a:	4413      	add	r3, r2
 8009c5c:	9302      	str	r3, [sp, #8]

      osalSysLock();
 8009c5e:	f7ff fd0f 	bl	8009680 <osalSysLock.lto_priv.275>
  while (n > 0U) {
 8009c62:	9b01      	ldr	r3, [sp, #4]
 8009c64:	2b00      	cmp	r3, #0
 8009c66:	d1d7      	bne.n	8009c18 <oqWriteTimeout+0x28>
    }
  }

  osalSysUnlock();
 8009c68:	f7ff fd12 	bl	8009690 <osalSysUnlock.lto_priv.266>
  return max - n;
 8009c6c:	9a06      	ldr	r2, [sp, #24]
 8009c6e:	9b01      	ldr	r3, [sp, #4]
 8009c70:	1ad3      	subs	r3, r2, r3
}
 8009c72:	4618      	mov	r0, r3
 8009c74:	b009      	add	sp, #36	; 0x24
 8009c76:	f85d fb04 	ldr.w	pc, [sp], #4
 8009c7a:	bf00      	nop
 8009c7c:	08015c78 	.word	0x08015c78

08009c80 <port_lock.lto_priv.383>:
static inline void port_lock(void) {
 8009c80:	b082      	sub	sp, #8
 8009c82:	2320      	movs	r3, #32
 8009c84:	9301      	str	r3, [sp, #4]
 8009c86:	9b01      	ldr	r3, [sp, #4]
 8009c88:	f383 8811 	msr	BASEPRI, r3
}
 8009c8c:	b002      	add	sp, #8
 8009c8e:	4770      	bx	lr

08009c90 <port_unlock.lto_priv.352>:
static inline void port_unlock(void) {
 8009c90:	b082      	sub	sp, #8
 8009c92:	2300      	movs	r3, #0
 8009c94:	9301      	str	r3, [sp, #4]
 8009c96:	9b01      	ldr	r3, [sp, #4]
 8009c98:	f383 8811 	msr	BASEPRI, r3
}
 8009c9c:	b002      	add	sp, #8
 8009c9e:	4770      	bx	lr

08009ca0 <chSysLock.lto_priv.315>:
static inline void chSysLock(void) {
 8009ca0:	b508      	push	{r3, lr}
  port_lock();
 8009ca2:	f7ff ffed 	bl	8009c80 <port_lock.lto_priv.383>
  _dbg_check_lock();
 8009ca6:	f005 fb0b 	bl	800f2c0 <_dbg_check_lock>
}
 8009caa:	bd08      	pop	{r3, pc}
 8009cac:	0000      	movs	r0, r0
	...

08009cb0 <chSysUnlock.lto_priv.291>:
static inline void chSysUnlock(void) {
 8009cb0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8009cb2:	f005 fb1d 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009cb6:	4b09      	ldr	r3, [pc, #36]	; (8009cdc <chSysUnlock.lto_priv.291+0x2c>)
 8009cb8:	681b      	ldr	r3, [r3, #0]
 8009cba:	4a08      	ldr	r2, [pc, #32]	; (8009cdc <chSysUnlock.lto_priv.291+0x2c>)
 8009cbc:	4293      	cmp	r3, r2
 8009cbe:	d00a      	beq.n	8009cd6 <chSysUnlock.lto_priv.291+0x26>
 8009cc0:	4b06      	ldr	r3, [pc, #24]	; (8009cdc <chSysUnlock.lto_priv.291+0x2c>)
 8009cc2:	699b      	ldr	r3, [r3, #24]
 8009cc4:	689a      	ldr	r2, [r3, #8]
 8009cc6:	4b05      	ldr	r3, [pc, #20]	; (8009cdc <chSysUnlock.lto_priv.291+0x2c>)
 8009cc8:	681b      	ldr	r3, [r3, #0]
 8009cca:	689b      	ldr	r3, [r3, #8]
 8009ccc:	429a      	cmp	r2, r3
 8009cce:	d202      	bcs.n	8009cd6 <chSysUnlock.lto_priv.291+0x26>
 8009cd0:	4803      	ldr	r0, [pc, #12]	; (8009ce0 <chSysUnlock.lto_priv.291+0x30>)
 8009cd2:	f005 f985 	bl	800efe0 <chSysHalt>
  port_unlock();
 8009cd6:	f7ff ffdb 	bl	8009c90 <port_unlock.lto_priv.352>
}
 8009cda:	bd08      	pop	{r3, pc}
 8009cdc:	20001090 	.word	0x20001090
 8009ce0:	08015c94 	.word	0x08015c94
	...

08009cf0 <osalSysLock.lto_priv.276>:
static inline void osalSysLock(void) {
 8009cf0:	b508      	push	{r3, lr}
  chSysLock();
 8009cf2:	f7ff ffd5 	bl	8009ca0 <chSysLock.lto_priv.315>
}
 8009cf6:	bd08      	pop	{r3, pc}
	...

08009d00 <osalSysUnlock.lto_priv.267>:
static inline void osalSysUnlock(void) {
 8009d00:	b508      	push	{r3, lr}
  chSysUnlock();
 8009d02:	f7ff ffd5 	bl	8009cb0 <chSysUnlock.lto_priv.291>
}
 8009d06:	bd08      	pop	{r3, pc}
	...

08009d10 <pwmInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void pwmInit(void) {
 8009d10:	b508      	push	{r3, lr}

  pwm_lld_init();
 8009d12:	f004 fad5 	bl	800e2c0 <pwm_lld_init>
}
 8009d16:	bd08      	pop	{r3, pc}
	...

08009d20 <pwmObjectInit>:
 *
 * @param[out] pwmp     pointer to a @p PWMDriver object
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {
 8009d20:	b082      	sub	sp, #8
 8009d22:	9001      	str	r0, [sp, #4]

  pwmp->state    = PWM_STOP;
 8009d24:	9b01      	ldr	r3, [sp, #4]
 8009d26:	2201      	movs	r2, #1
 8009d28:	701a      	strb	r2, [r3, #0]
  pwmp->config   = NULL;
 8009d2a:	9b01      	ldr	r3, [sp, #4]
 8009d2c:	2200      	movs	r2, #0
 8009d2e:	605a      	str	r2, [r3, #4]
  pwmp->enabled  = 0;
 8009d30:	9b01      	ldr	r3, [sp, #4]
 8009d32:	2200      	movs	r2, #0
 8009d34:	60da      	str	r2, [r3, #12]
  pwmp->channels = 0;
 8009d36:	9b01      	ldr	r3, [sp, #4]
 8009d38:	2200      	movs	r2, #0
 8009d3a:	741a      	strb	r2, [r3, #16]
#if defined(PWM_DRIVER_EXT_INIT_HOOK)
  PWM_DRIVER_EXT_INIT_HOOK(pwmp);
#endif
}
 8009d3c:	b002      	add	sp, #8
 8009d3e:	4770      	bx	lr

08009d40 <pwmStart>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] config    pointer to a @p PWMConfig object
 *
 * @api
 */
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
 8009d40:	b500      	push	{lr}
 8009d42:	b083      	sub	sp, #12
 8009d44:	9001      	str	r0, [sp, #4]
 8009d46:	9100      	str	r1, [sp, #0]

  osalDbgCheck((pwmp != NULL) && (config != NULL));
 8009d48:	9b01      	ldr	r3, [sp, #4]
 8009d4a:	2b00      	cmp	r3, #0
 8009d4c:	d002      	beq.n	8009d54 <pwmStart+0x14>
 8009d4e:	9b00      	ldr	r3, [sp, #0]
 8009d50:	2b00      	cmp	r3, #0
 8009d52:	d102      	bne.n	8009d5a <pwmStart+0x1a>
 8009d54:	4812      	ldr	r0, [pc, #72]	; (8009da0 <pwmStart+0x60>)
 8009d56:	f005 f943 	bl	800efe0 <chSysHalt>

  osalSysLock();
 8009d5a:	f7ff ffc9 	bl	8009cf0 <osalSysLock.lto_priv.276>
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 8009d5e:	9b01      	ldr	r3, [sp, #4]
 8009d60:	781b      	ldrb	r3, [r3, #0]
 8009d62:	2b01      	cmp	r3, #1
 8009d64:	d006      	beq.n	8009d74 <pwmStart+0x34>
 8009d66:	9b01      	ldr	r3, [sp, #4]
 8009d68:	781b      	ldrb	r3, [r3, #0]
 8009d6a:	2b02      	cmp	r3, #2
 8009d6c:	d002      	beq.n	8009d74 <pwmStart+0x34>
 8009d6e:	480c      	ldr	r0, [pc, #48]	; (8009da0 <pwmStart+0x60>)
 8009d70:	f005 f936 	bl	800efe0 <chSysHalt>
                "invalid state");
  pwmp->config = config;
 8009d74:	9b01      	ldr	r3, [sp, #4]
 8009d76:	9a00      	ldr	r2, [sp, #0]
 8009d78:	605a      	str	r2, [r3, #4]
  pwmp->period = config->period;
 8009d7a:	9b00      	ldr	r3, [sp, #0]
 8009d7c:	685a      	ldr	r2, [r3, #4]
 8009d7e:	9b01      	ldr	r3, [sp, #4]
 8009d80:	609a      	str	r2, [r3, #8]
  pwm_lld_start(pwmp);
 8009d82:	9801      	ldr	r0, [sp, #4]
 8009d84:	f004 faac 	bl	800e2e0 <pwm_lld_start>
  pwmp->enabled = 0;
 8009d88:	9b01      	ldr	r3, [sp, #4]
 8009d8a:	2200      	movs	r2, #0
 8009d8c:	60da      	str	r2, [r3, #12]
  pwmp->state = PWM_READY;
 8009d8e:	9b01      	ldr	r3, [sp, #4]
 8009d90:	2202      	movs	r2, #2
 8009d92:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8009d94:	f7ff ffb4 	bl	8009d00 <osalSysUnlock.lto_priv.267>
}
 8009d98:	b003      	add	sp, #12
 8009d9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8009d9e:	bf00      	nop
 8009da0:	08015c88 	.word	0x08015c88
	...

08009db0 <pwmChangePeriod>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] period    new cycle time in ticks
 *
 * @api
 */
void pwmChangePeriod(PWMDriver *pwmp, pwmcnt_t period) {
 8009db0:	b500      	push	{lr}
 8009db2:	b083      	sub	sp, #12
 8009db4:	9001      	str	r0, [sp, #4]
 8009db6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(pwmp != NULL);
 8009db8:	9b01      	ldr	r3, [sp, #4]
 8009dba:	2b00      	cmp	r3, #0
 8009dbc:	d102      	bne.n	8009dc4 <pwmChangePeriod+0x14>
 8009dbe:	480c      	ldr	r0, [pc, #48]	; (8009df0 <pwmChangePeriod+0x40>)
 8009dc0:	f005 f90e 	bl	800efe0 <chSysHalt>

  osalSysLock();
 8009dc4:	f7ff ff94 	bl	8009cf0 <osalSysLock.lto_priv.276>
  osalDbgAssert(pwmp->state == PWM_READY, "invalid state");
 8009dc8:	9b01      	ldr	r3, [sp, #4]
 8009dca:	781b      	ldrb	r3, [r3, #0]
 8009dcc:	2b02      	cmp	r3, #2
 8009dce:	d002      	beq.n	8009dd6 <pwmChangePeriod+0x26>
 8009dd0:	4807      	ldr	r0, [pc, #28]	; (8009df0 <pwmChangePeriod+0x40>)
 8009dd2:	f005 f905 	bl	800efe0 <chSysHalt>
  pwmChangePeriodI(pwmp, period);
 8009dd6:	9b01      	ldr	r3, [sp, #4]
 8009dd8:	9a00      	ldr	r2, [sp, #0]
 8009dda:	609a      	str	r2, [r3, #8]
 8009ddc:	9b01      	ldr	r3, [sp, #4]
 8009dde:	699b      	ldr	r3, [r3, #24]
 8009de0:	9a00      	ldr	r2, [sp, #0]
 8009de2:	3a01      	subs	r2, #1
 8009de4:	62da      	str	r2, [r3, #44]	; 0x2c
  osalSysUnlock();
 8009de6:	f7ff ff8b 	bl	8009d00 <osalSysUnlock.lto_priv.267>
}
 8009dea:	b003      	add	sp, #12
 8009dec:	f85d fb04 	ldr.w	pc, [sp], #4
 8009df0:	08015ca0 	.word	0x08015ca0
	...

08009e00 <pwmEnableChannel>:
 *
 * @api
 */
void pwmEnableChannel(PWMDriver *pwmp,
                      pwmchannel_t channel,
                      pwmcnt_t width) {
 8009e00:	b500      	push	{lr}
 8009e02:	b085      	sub	sp, #20
 8009e04:	9003      	str	r0, [sp, #12]
 8009e06:	460b      	mov	r3, r1
 8009e08:	9201      	str	r2, [sp, #4]
 8009e0a:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 8009e0e:	9b03      	ldr	r3, [sp, #12]
 8009e10:	2b00      	cmp	r3, #0
 8009e12:	d005      	beq.n	8009e20 <pwmEnableChannel+0x20>
 8009e14:	9b03      	ldr	r3, [sp, #12]
 8009e16:	7c1b      	ldrb	r3, [r3, #16]
 8009e18:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8009e1c:	429a      	cmp	r2, r3
 8009e1e:	d302      	bcc.n	8009e26 <pwmEnableChannel+0x26>
 8009e20:	4810      	ldr	r0, [pc, #64]	; (8009e64 <pwmEnableChannel+0x64>)
 8009e22:	f005 f8dd 	bl	800efe0 <chSysHalt>

  osalSysLock();
 8009e26:	f7ff ff63 	bl	8009cf0 <osalSysLock.lto_priv.276>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8009e2a:	9b03      	ldr	r3, [sp, #12]
 8009e2c:	781b      	ldrb	r3, [r3, #0]
 8009e2e:	2b02      	cmp	r3, #2
 8009e30:	d002      	beq.n	8009e38 <pwmEnableChannel+0x38>
 8009e32:	480c      	ldr	r0, [pc, #48]	; (8009e64 <pwmEnableChannel+0x64>)
 8009e34:	f005 f8d4 	bl	800efe0 <chSysHalt>

  pwmEnableChannelI(pwmp, channel, width);
 8009e38:	9b03      	ldr	r3, [sp, #12]
 8009e3a:	68da      	ldr	r2, [r3, #12]
 8009e3c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8009e40:	2101      	movs	r1, #1
 8009e42:	fa01 f303 	lsl.w	r3, r1, r3
 8009e46:	431a      	orrs	r2, r3
 8009e48:	9b03      	ldr	r3, [sp, #12]
 8009e4a:	60da      	str	r2, [r3, #12]
 8009e4c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8009e50:	9a01      	ldr	r2, [sp, #4]
 8009e52:	4619      	mov	r1, r3
 8009e54:	9803      	ldr	r0, [sp, #12]
 8009e56:	f004 fb33 	bl	800e4c0 <pwm_lld_enable_channel>

  osalSysUnlock();
 8009e5a:	f7ff ff51 	bl	8009d00 <osalSysUnlock.lto_priv.267>
}
 8009e5e:	b005      	add	sp, #20
 8009e60:	f85d fb04 	ldr.w	pc, [sp], #4
 8009e64:	08015cb0 	.word	0x08015cb0
	...

08009e70 <port_lock.lto_priv.384>:
static inline void port_lock(void) {
 8009e70:	b082      	sub	sp, #8
 8009e72:	2320      	movs	r3, #32
 8009e74:	9301      	str	r3, [sp, #4]
 8009e76:	9b01      	ldr	r3, [sp, #4]
 8009e78:	f383 8811 	msr	BASEPRI, r3
}
 8009e7c:	b002      	add	sp, #8
 8009e7e:	4770      	bx	lr

08009e80 <port_unlock.lto_priv.353>:
static inline void port_unlock(void) {
 8009e80:	b082      	sub	sp, #8
 8009e82:	2300      	movs	r3, #0
 8009e84:	9301      	str	r3, [sp, #4]
 8009e86:	9b01      	ldr	r3, [sp, #4]
 8009e88:	f383 8811 	msr	BASEPRI, r3
}
 8009e8c:	b002      	add	sp, #8
 8009e8e:	4770      	bx	lr

08009e90 <chSysLock.lto_priv.316>:
static inline void chSysLock(void) {
 8009e90:	b508      	push	{r3, lr}
  port_lock();
 8009e92:	f7ff ffed 	bl	8009e70 <port_lock.lto_priv.384>
  _dbg_check_lock();
 8009e96:	f005 fa13 	bl	800f2c0 <_dbg_check_lock>
}
 8009e9a:	bd08      	pop	{r3, pc}
 8009e9c:	0000      	movs	r0, r0
	...

08009ea0 <chSysUnlock.lto_priv.292>:
static inline void chSysUnlock(void) {
 8009ea0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8009ea2:	f005 fa25 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009ea6:	4b09      	ldr	r3, [pc, #36]	; (8009ecc <chSysUnlock.lto_priv.292+0x2c>)
 8009ea8:	681b      	ldr	r3, [r3, #0]
 8009eaa:	4a08      	ldr	r2, [pc, #32]	; (8009ecc <chSysUnlock.lto_priv.292+0x2c>)
 8009eac:	4293      	cmp	r3, r2
 8009eae:	d00a      	beq.n	8009ec6 <chSysUnlock.lto_priv.292+0x26>
 8009eb0:	4b06      	ldr	r3, [pc, #24]	; (8009ecc <chSysUnlock.lto_priv.292+0x2c>)
 8009eb2:	699b      	ldr	r3, [r3, #24]
 8009eb4:	689a      	ldr	r2, [r3, #8]
 8009eb6:	4b05      	ldr	r3, [pc, #20]	; (8009ecc <chSysUnlock.lto_priv.292+0x2c>)
 8009eb8:	681b      	ldr	r3, [r3, #0]
 8009eba:	689b      	ldr	r3, [r3, #8]
 8009ebc:	429a      	cmp	r2, r3
 8009ebe:	d202      	bcs.n	8009ec6 <chSysUnlock.lto_priv.292+0x26>
 8009ec0:	4803      	ldr	r0, [pc, #12]	; (8009ed0 <chSysUnlock.lto_priv.292+0x30>)
 8009ec2:	f005 f88d 	bl	800efe0 <chSysHalt>
  port_unlock();
 8009ec6:	f7ff ffdb 	bl	8009e80 <port_unlock.lto_priv.353>
}
 8009eca:	bd08      	pop	{r3, pc}
 8009ecc:	20001090 	.word	0x20001090
 8009ed0:	08015cfc 	.word	0x08015cfc
	...

08009ee0 <chEvtObjectInit.lto_priv.420>:
static inline void chEvtObjectInit(event_source_t *esp) {
 8009ee0:	b082      	sub	sp, #8
 8009ee2:	9001      	str	r0, [sp, #4]
  esp->next = (event_listener_t *)esp;
 8009ee4:	9b01      	ldr	r3, [sp, #4]
 8009ee6:	9a01      	ldr	r2, [sp, #4]
 8009ee8:	601a      	str	r2, [r3, #0]
}
 8009eea:	b002      	add	sp, #8
 8009eec:	4770      	bx	lr
 8009eee:	bf00      	nop

08009ef0 <osalSysLock.lto_priv.277>:
static inline void osalSysLock(void) {
 8009ef0:	b508      	push	{r3, lr}
  chSysLock();
 8009ef2:	f7ff ffcd 	bl	8009e90 <chSysLock.lto_priv.316>
}
 8009ef6:	bd08      	pop	{r3, pc}
	...

08009f00 <osalSysUnlock.lto_priv.268>:
static inline void osalSysUnlock(void) {
 8009f00:	b508      	push	{r3, lr}
  chSysUnlock();
 8009f02:	f7ff ffcd 	bl	8009ea0 <chSysUnlock.lto_priv.292>
}
 8009f06:	bd08      	pop	{r3, pc}
	...

08009f10 <osalEventObjectInit.lto_priv.612>:
 *
 * @param[out] esp      pointer to the event source object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8009f10:	b500      	push	{lr}
 8009f12:	b083      	sub	sp, #12
 8009f14:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8009f16:	9801      	ldr	r0, [sp, #4]
 8009f18:	f7ff ffe2 	bl	8009ee0 <chEvtObjectInit.lto_priv.420>
}
 8009f1c:	b003      	add	sp, #12
 8009f1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009f22:	bf00      	nop
	...

08009f30 <osalEventBroadcastFlagsI.lto_priv.546>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8009f30:	b500      	push	{lr}
 8009f32:	b083      	sub	sp, #12
 8009f34:	9001      	str	r0, [sp, #4]
 8009f36:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8009f38:	9900      	ldr	r1, [sp, #0]
 8009f3a:	9801      	ldr	r0, [sp, #4]
 8009f3c:	f007 ffd0 	bl	8011ee0 <chEvtBroadcastFlagsI>
}
 8009f40:	b003      	add	sp, #12
 8009f42:	f85d fb04 	ldr.w	pc, [sp], #4
 8009f46:	bf00      	nop
	...

08009f50 <_write.lto_priv.241>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8009f50:	b500      	push	{lr}
 8009f52:	b085      	sub	sp, #20
 8009f54:	9003      	str	r0, [sp, #12]
 8009f56:	9102      	str	r1, [sp, #8]
 8009f58:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8009f5a:	9b03      	ldr	r3, [sp, #12]
 8009f5c:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8009f60:	f04f 33ff 	mov.w	r3, #4294967295
 8009f64:	9a01      	ldr	r2, [sp, #4]
 8009f66:	9902      	ldr	r1, [sp, #8]
 8009f68:	f7ff fe42 	bl	8009bf0 <oqWriteTimeout>
 8009f6c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 8009f6e:	4618      	mov	r0, r3
 8009f70:	b005      	add	sp, #20
 8009f72:	f85d fb04 	ldr.w	pc, [sp], #4
 8009f76:	bf00      	nop
	...

08009f80 <_read.lto_priv.243>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8009f80:	b500      	push	{lr}
 8009f82:	b085      	sub	sp, #20
 8009f84:	9003      	str	r0, [sp, #12]
 8009f86:	9102      	str	r1, [sp, #8]
 8009f88:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8009f8a:	9b03      	ldr	r3, [sp, #12]
 8009f8c:	f103 000c 	add.w	r0, r3, #12
 8009f90:	f04f 33ff 	mov.w	r3, #4294967295
 8009f94:	9a01      	ldr	r2, [sp, #4]
 8009f96:	9902      	ldr	r1, [sp, #8]
 8009f98:	f7ff fd32 	bl	8009a00 <iqReadTimeout>
 8009f9c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 8009f9e:	4618      	mov	r0, r3
 8009fa0:	b005      	add	sp, #20
 8009fa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8009fa6:	bf00      	nop
	...

08009fb0 <_put.lto_priv.153>:

static msg_t _put(void *ip, uint8_t b) {
 8009fb0:	b500      	push	{lr}
 8009fb2:	b083      	sub	sp, #12
 8009fb4:	9001      	str	r0, [sp, #4]
 8009fb6:	460b      	mov	r3, r1
 8009fb8:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8009fbc:	9b01      	ldr	r3, [sp, #4]
 8009fbe:	3330      	adds	r3, #48	; 0x30
 8009fc0:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8009fc4:	f04f 32ff 	mov.w	r2, #4294967295
 8009fc8:	4618      	mov	r0, r3
 8009fca:	f7ff fd89 	bl	8009ae0 <oqPutTimeout>
 8009fce:	4603      	mov	r3, r0
}
 8009fd0:	4618      	mov	r0, r3
 8009fd2:	b003      	add	sp, #12
 8009fd4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08009fe0 <_get.lto_priv.156>:

static msg_t _get(void *ip) {
 8009fe0:	b500      	push	{lr}
 8009fe2:	b083      	sub	sp, #12
 8009fe4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8009fe6:	9b01      	ldr	r3, [sp, #4]
 8009fe8:	330c      	adds	r3, #12
 8009fea:	f04f 31ff 	mov.w	r1, #4294967295
 8009fee:	4618      	mov	r0, r3
 8009ff0:	f7ff fcc6 	bl	8009980 <iqGetTimeout>
 8009ff4:	4603      	mov	r3, r0
}
 8009ff6:	4618      	mov	r0, r3
 8009ff8:	b003      	add	sp, #12
 8009ffa:	f85d fb04 	ldr.w	pc, [sp], #4
 8009ffe:	bf00      	nop

0800a000 <_putt.lto_priv.245>:

static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 800a000:	b500      	push	{lr}
 800a002:	b085      	sub	sp, #20
 800a004:	9003      	str	r0, [sp, #12]
 800a006:	460b      	mov	r3, r1
 800a008:	9201      	str	r2, [sp, #4]
 800a00a:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 800a00e:	9b03      	ldr	r3, [sp, #12]
 800a010:	3330      	adds	r3, #48	; 0x30
 800a012:	f89d 100b 	ldrb.w	r1, [sp, #11]
 800a016:	9a01      	ldr	r2, [sp, #4]
 800a018:	4618      	mov	r0, r3
 800a01a:	f7ff fd61 	bl	8009ae0 <oqPutTimeout>
 800a01e:	4603      	mov	r3, r0
}
 800a020:	4618      	mov	r0, r3
 800a022:	b005      	add	sp, #20
 800a024:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a030 <_gett.lto_priv.247>:

static msg_t _gett(void *ip, sysinterval_t timeout) {
 800a030:	b500      	push	{lr}
 800a032:	b083      	sub	sp, #12
 800a034:	9001      	str	r0, [sp, #4]
 800a036:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 800a038:	9b01      	ldr	r3, [sp, #4]
 800a03a:	330c      	adds	r3, #12
 800a03c:	9900      	ldr	r1, [sp, #0]
 800a03e:	4618      	mov	r0, r3
 800a040:	f7ff fc9e 	bl	8009980 <iqGetTimeout>
 800a044:	4603      	mov	r3, r0
}
 800a046:	4618      	mov	r0, r3
 800a048:	b003      	add	sp, #12
 800a04a:	f85d fb04 	ldr.w	pc, [sp], #4
 800a04e:	bf00      	nop

0800a050 <_writet.lto_priv.249>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n,
                      sysinterval_t timeout) {
 800a050:	b500      	push	{lr}
 800a052:	b085      	sub	sp, #20
 800a054:	9003      	str	r0, [sp, #12]
 800a056:	9102      	str	r1, [sp, #8]
 800a058:	9201      	str	r2, [sp, #4]
 800a05a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800a05c:	9b03      	ldr	r3, [sp, #12]
 800a05e:	f103 0030 	add.w	r0, r3, #48	; 0x30
 800a062:	9b00      	ldr	r3, [sp, #0]
 800a064:	9a01      	ldr	r2, [sp, #4]
 800a066:	9902      	ldr	r1, [sp, #8]
 800a068:	f7ff fdc2 	bl	8009bf0 <oqWriteTimeout>
 800a06c:	4603      	mov	r3, r0
}
 800a06e:	4618      	mov	r0, r3
 800a070:	b005      	add	sp, #20
 800a072:	f85d fb04 	ldr.w	pc, [sp], #4
 800a076:	bf00      	nop
	...

0800a080 <_readt.lto_priv.251>:

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {
 800a080:	b500      	push	{lr}
 800a082:	b085      	sub	sp, #20
 800a084:	9003      	str	r0, [sp, #12]
 800a086:	9102      	str	r1, [sp, #8]
 800a088:	9201      	str	r2, [sp, #4]
 800a08a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800a08c:	9b03      	ldr	r3, [sp, #12]
 800a08e:	f103 000c 	add.w	r0, r3, #12
 800a092:	9b00      	ldr	r3, [sp, #0]
 800a094:	9a01      	ldr	r2, [sp, #4]
 800a096:	9902      	ldr	r1, [sp, #8]
 800a098:	f7ff fcb2 	bl	8009a00 <iqReadTimeout>
 800a09c:	4603      	mov	r3, r0
}
 800a09e:	4618      	mov	r0, r3
 800a0a0:	b005      	add	sp, #20
 800a0a2:	f85d fb04 	ldr.w	pc, [sp], #4
 800a0a6:	bf00      	nop
	...

0800a0b0 <_ctl.lto_priv.253>:

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 800a0b0:	b500      	push	{lr}
 800a0b2:	b087      	sub	sp, #28
 800a0b4:	9003      	str	r0, [sp, #12]
 800a0b6:	9102      	str	r1, [sp, #8]
 800a0b8:	9201      	str	r2, [sp, #4]
  SerialDriver *sdp = (SerialDriver *)ip;
 800a0ba:	9b03      	ldr	r3, [sp, #12]
 800a0bc:	9305      	str	r3, [sp, #20]

  osalDbgCheck(sdp != NULL);
 800a0be:	9b05      	ldr	r3, [sp, #20]
 800a0c0:	2b00      	cmp	r3, #0
 800a0c2:	d102      	bne.n	800a0ca <_ctl.lto_priv.253+0x1a>
 800a0c4:	480b      	ldr	r0, [pc, #44]	; (800a0f4 <_ctl.lto_priv.253+0x44>)
 800a0c6:	f004 ff8b 	bl	800efe0 <chSysHalt>

  switch (operation) {
 800a0ca:	9b02      	ldr	r3, [sp, #8]
 800a0cc:	2b00      	cmp	r3, #0
 800a0ce:	d008      	beq.n	800a0e2 <_ctl.lto_priv.253+0x32>
 800a0d0:	2b01      	cmp	r3, #1
 800a0d2:	d109      	bne.n	800a0e8 <_ctl.lto_priv.253+0x38>
  case CHN_CTL_NOP:
    osalDbgCheck(arg == NULL);
 800a0d4:	9b01      	ldr	r3, [sp, #4]
 800a0d6:	2b00      	cmp	r3, #0
 800a0d8:	d006      	beq.n	800a0e8 <_ctl.lto_priv.253+0x38>
 800a0da:	4806      	ldr	r0, [pc, #24]	; (800a0f4 <_ctl.lto_priv.253+0x44>)
 800a0dc:	f004 ff80 	bl	800efe0 <chSysHalt>
 800a0e0:	e002      	b.n	800a0e8 <_ctl.lto_priv.253+0x38>
    break;
  case CHN_CTL_INVALID:
    osalDbgAssert(false, "invalid CTL operation");
 800a0e2:	4804      	ldr	r0, [pc, #16]	; (800a0f4 <_ctl.lto_priv.253+0x44>)
 800a0e4:	f004 ff7c 	bl	800efe0 <chSysHalt>
    return sd_lld_control(sdp, operation, arg);
#else
    break;
#endif
  }
  return MSG_OK;
 800a0e8:	2300      	movs	r3, #0
}
 800a0ea:	4618      	mov	r0, r3
 800a0ec:	b007      	add	sp, #28
 800a0ee:	f85d fb04 	ldr.w	pc, [sp], #4
 800a0f2:	bf00      	nop
 800a0f4:	08015cec 	.word	0x08015cec
	...

0800a100 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 800a100:	b508      	push	{r3, lr}

  sd_lld_init();
 800a102:	f004 fc35 	bl	800e970 <sd_lld_init>
}
 800a106:	bd08      	pop	{r3, pc}
	...

0800a110 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 800a110:	b500      	push	{lr}
 800a112:	b087      	sub	sp, #28
 800a114:	9005      	str	r0, [sp, #20]
 800a116:	9104      	str	r1, [sp, #16]
 800a118:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 800a11a:	9b05      	ldr	r3, [sp, #20]
 800a11c:	4a12      	ldr	r2, [pc, #72]	; (800a168 <sdObjectInit+0x58>)
 800a11e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 800a120:	9b05      	ldr	r3, [sp, #20]
 800a122:	3304      	adds	r3, #4
 800a124:	4618      	mov	r0, r3
 800a126:	f7ff fef3 	bl	8009f10 <osalEventObjectInit.lto_priv.612>
  sdp->state = SD_STOP;
 800a12a:	9b05      	ldr	r3, [sp, #20]
 800a12c:	2201      	movs	r2, #1
 800a12e:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 800a130:	9b05      	ldr	r3, [sp, #20]
 800a132:	f103 000c 	add.w	r0, r3, #12
 800a136:	9b05      	ldr	r3, [sp, #20]
 800a138:	f103 0154 	add.w	r1, r3, #84	; 0x54
 800a13c:	9b05      	ldr	r3, [sp, #20]
 800a13e:	9300      	str	r3, [sp, #0]
 800a140:	9b04      	ldr	r3, [sp, #16]
 800a142:	2210      	movs	r2, #16
 800a144:	f7ff fbac 	bl	80098a0 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 800a148:	9b05      	ldr	r3, [sp, #20]
 800a14a:	f103 0030 	add.w	r0, r3, #48	; 0x30
 800a14e:	9b05      	ldr	r3, [sp, #20]
 800a150:	f103 0164 	add.w	r1, r3, #100	; 0x64
 800a154:	9b05      	ldr	r3, [sp, #20]
 800a156:	9300      	str	r3, [sp, #0]
 800a158:	9b03      	ldr	r3, [sp, #12]
 800a15a:	2210      	movs	r2, #16
 800a15c:	f7ff fc98 	bl	8009a90 <oqObjectInit>
}
 800a160:	b007      	add	sp, #28
 800a162:	f85d fb04 	ldr.w	pc, [sp], #4
 800a166:	bf00      	nop
 800a168:	08015cc4 	.word	0x08015cc4
 800a16c:	00000000 	.word	0x00000000

0800a170 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 800a170:	b500      	push	{lr}
 800a172:	b083      	sub	sp, #12
 800a174:	9001      	str	r0, [sp, #4]
 800a176:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);
 800a178:	9b01      	ldr	r3, [sp, #4]
 800a17a:	2b00      	cmp	r3, #0
 800a17c:	d102      	bne.n	800a184 <sdStart+0x14>
 800a17e:	480e      	ldr	r0, [pc, #56]	; (800a1b8 <sdStart+0x48>)
 800a180:	f004 ff2e 	bl	800efe0 <chSysHalt>

  osalSysLock();
 800a184:	f7ff feb4 	bl	8009ef0 <osalSysLock.lto_priv.277>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 800a188:	9b01      	ldr	r3, [sp, #4]
 800a18a:	7a1b      	ldrb	r3, [r3, #8]
 800a18c:	2b01      	cmp	r3, #1
 800a18e:	d006      	beq.n	800a19e <sdStart+0x2e>
 800a190:	9b01      	ldr	r3, [sp, #4]
 800a192:	7a1b      	ldrb	r3, [r3, #8]
 800a194:	2b02      	cmp	r3, #2
 800a196:	d002      	beq.n	800a19e <sdStart+0x2e>
 800a198:	4807      	ldr	r0, [pc, #28]	; (800a1b8 <sdStart+0x48>)
 800a19a:	f004 ff21 	bl	800efe0 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
 800a19e:	9900      	ldr	r1, [sp, #0]
 800a1a0:	9801      	ldr	r0, [sp, #4]
 800a1a2:	f004 fbf5 	bl	800e990 <sd_lld_start>
  sdp->state = SD_READY;
 800a1a6:	9b01      	ldr	r3, [sp, #4]
 800a1a8:	2202      	movs	r2, #2
 800a1aa:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800a1ac:	f7ff fea8 	bl	8009f00 <osalSysUnlock.lto_priv.268>
}
 800a1b0:	b003      	add	sp, #12
 800a1b2:	f85d fb04 	ldr.w	pc, [sp], #4
 800a1b6:	bf00      	nop
 800a1b8:	08015cf4 	.word	0x08015cf4
 800a1bc:	00000000 	.word	0x00000000

0800a1c0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 800a1c0:	b500      	push	{lr}
 800a1c2:	b083      	sub	sp, #12
 800a1c4:	9001      	str	r0, [sp, #4]
 800a1c6:	460b      	mov	r3, r1
 800a1c8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
 800a1cc:	f005 f918 	bl	800f400 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 800a1d0:	9b01      	ldr	r3, [sp, #4]
 800a1d2:	2b00      	cmp	r3, #0
 800a1d4:	d102      	bne.n	800a1dc <sdIncomingDataI+0x1c>
 800a1d6:	4811      	ldr	r0, [pc, #68]	; (800a21c <sdIncomingDataI+0x5c>)
 800a1d8:	f004 ff02 	bl	800efe0 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
 800a1dc:	9b01      	ldr	r3, [sp, #4]
 800a1de:	695b      	ldr	r3, [r3, #20]
 800a1e0:	2b00      	cmp	r3, #0
 800a1e2:	d105      	bne.n	800a1f0 <sdIncomingDataI+0x30>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800a1e4:	9b01      	ldr	r3, [sp, #4]
 800a1e6:	3304      	adds	r3, #4
 800a1e8:	2104      	movs	r1, #4
 800a1ea:	4618      	mov	r0, r3
 800a1ec:	f7ff fea0 	bl	8009f30 <osalEventBroadcastFlagsI.lto_priv.546>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 800a1f0:	9b01      	ldr	r3, [sp, #4]
 800a1f2:	330c      	adds	r3, #12
 800a1f4:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800a1f8:	4611      	mov	r1, r2
 800a1fa:	4618      	mov	r0, r3
 800a1fc:	f7ff fb78 	bl	80098f0 <iqPutI>
 800a200:	4603      	mov	r3, r0
 800a202:	2b00      	cmp	r3, #0
 800a204:	da06      	bge.n	800a214 <sdIncomingDataI+0x54>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 800a206:	9b01      	ldr	r3, [sp, #4]
 800a208:	3304      	adds	r3, #4
 800a20a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800a20e:	4618      	mov	r0, r3
 800a210:	f7ff fe8e 	bl	8009f30 <osalEventBroadcastFlagsI.lto_priv.546>
}
 800a214:	b003      	add	sp, #12
 800a216:	f85d fb04 	ldr.w	pc, [sp], #4
 800a21a:	bf00      	nop
 800a21c:	08015d08 	.word	0x08015d08

0800a220 <port_lock.lto_priv.385>:
static inline void port_lock(void) {
 800a220:	b082      	sub	sp, #8
 800a222:	2320      	movs	r3, #32
 800a224:	9301      	str	r3, [sp, #4]
 800a226:	9b01      	ldr	r3, [sp, #4]
 800a228:	f383 8811 	msr	BASEPRI, r3
}
 800a22c:	b002      	add	sp, #8
 800a22e:	4770      	bx	lr

0800a230 <port_unlock.lto_priv.354>:
static inline void port_unlock(void) {
 800a230:	b082      	sub	sp, #8
 800a232:	2300      	movs	r3, #0
 800a234:	9301      	str	r3, [sp, #4]
 800a236:	9b01      	ldr	r3, [sp, #4]
 800a238:	f383 8811 	msr	BASEPRI, r3
}
 800a23c:	b002      	add	sp, #8
 800a23e:	4770      	bx	lr

0800a240 <port_lock_from_isr.lto_priv.434>:
static inline void port_lock_from_isr(void) {
 800a240:	b508      	push	{r3, lr}
  port_lock();
 800a242:	f7ff ffed 	bl	800a220 <port_lock.lto_priv.385>
}
 800a246:	bd08      	pop	{r3, pc}
	...

0800a250 <port_unlock_from_isr.lto_priv.423>:
static inline void port_unlock_from_isr(void) {
 800a250:	b508      	push	{r3, lr}
  port_unlock();
 800a252:	f7ff ffed 	bl	800a230 <port_unlock.lto_priv.354>
}
 800a256:	bd08      	pop	{r3, pc}
	...

0800a260 <chSysLock.lto_priv.317>:
static inline void chSysLock(void) {
 800a260:	b508      	push	{r3, lr}
  port_lock();
 800a262:	f7ff ffdd 	bl	800a220 <port_lock.lto_priv.385>
  _dbg_check_lock();
 800a266:	f005 f82b 	bl	800f2c0 <_dbg_check_lock>
}
 800a26a:	bd08      	pop	{r3, pc}
 800a26c:	0000      	movs	r0, r0
	...

0800a270 <chSysUnlock.lto_priv.293>:
static inline void chSysUnlock(void) {
 800a270:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 800a272:	f005 f83d 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a276:	4b09      	ldr	r3, [pc, #36]	; (800a29c <chSysUnlock.lto_priv.293+0x2c>)
 800a278:	681b      	ldr	r3, [r3, #0]
 800a27a:	4a08      	ldr	r2, [pc, #32]	; (800a29c <chSysUnlock.lto_priv.293+0x2c>)
 800a27c:	4293      	cmp	r3, r2
 800a27e:	d00a      	beq.n	800a296 <chSysUnlock.lto_priv.293+0x26>
 800a280:	4b06      	ldr	r3, [pc, #24]	; (800a29c <chSysUnlock.lto_priv.293+0x2c>)
 800a282:	699b      	ldr	r3, [r3, #24]
 800a284:	689a      	ldr	r2, [r3, #8]
 800a286:	4b05      	ldr	r3, [pc, #20]	; (800a29c <chSysUnlock.lto_priv.293+0x2c>)
 800a288:	681b      	ldr	r3, [r3, #0]
 800a28a:	689b      	ldr	r3, [r3, #8]
 800a28c:	429a      	cmp	r2, r3
 800a28e:	d202      	bcs.n	800a296 <chSysUnlock.lto_priv.293+0x26>
 800a290:	4803      	ldr	r0, [pc, #12]	; (800a2a0 <chSysUnlock.lto_priv.293+0x30>)
 800a292:	f004 fea5 	bl	800efe0 <chSysHalt>
  port_unlock();
 800a296:	f7ff ffcb 	bl	800a230 <port_unlock.lto_priv.354>
}
 800a29a:	bd08      	pop	{r3, pc}
 800a29c:	20001090 	.word	0x20001090
 800a2a0:	08015d60 	.word	0x08015d60
	...

0800a2b0 <chSysLockFromISR.lto_priv.527>:
static inline void chSysLockFromISR(void) {
 800a2b0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 800a2b2:	f7ff ffc5 	bl	800a240 <port_lock_from_isr.lto_priv.434>
  _dbg_check_lock_from_isr();
 800a2b6:	f005 f833 	bl	800f320 <_dbg_check_lock_from_isr>
}
 800a2ba:	bd08      	pop	{r3, pc}
 800a2bc:	0000      	movs	r0, r0
	...

0800a2c0 <chSysUnlockFromISR.lto_priv.519>:
static inline void chSysUnlockFromISR(void) {
 800a2c0:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 800a2c2:	f005 f845 	bl	800f350 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 800a2c6:	f7ff ffc3 	bl	800a250 <port_unlock_from_isr.lto_priv.423>
}
 800a2ca:	bd08      	pop	{r3, pc}
 800a2cc:	0000      	movs	r0, r0
	...

0800a2d0 <chEvtObjectInit.lto_priv.421>:
static inline void chEvtObjectInit(event_source_t *esp) {
 800a2d0:	b082      	sub	sp, #8
 800a2d2:	9001      	str	r0, [sp, #4]
  esp->next = (event_listener_t *)esp;
 800a2d4:	9b01      	ldr	r3, [sp, #4]
 800a2d6:	9a01      	ldr	r2, [sp, #4]
 800a2d8:	601a      	str	r2, [r3, #0]
}
 800a2da:	b002      	add	sp, #8
 800a2dc:	4770      	bx	lr
 800a2de:	bf00      	nop

0800a2e0 <osalSysLock.lto_priv.278>:
static inline void osalSysLock(void) {
 800a2e0:	b508      	push	{r3, lr}
  chSysLock();
 800a2e2:	f7ff ffbd 	bl	800a260 <chSysLock.lto_priv.317>
}
 800a2e6:	bd08      	pop	{r3, pc}
	...

0800a2f0 <osalSysUnlock.lto_priv.269>:
static inline void osalSysUnlock(void) {
 800a2f0:	b508      	push	{r3, lr}
  chSysUnlock();
 800a2f2:	f7ff ffbd 	bl	800a270 <chSysUnlock.lto_priv.293>
}
 800a2f6:	bd08      	pop	{r3, pc}
	...

0800a300 <osalSysLockFromISR.lto_priv.555>:
static inline void osalSysLockFromISR(void) {
 800a300:	b508      	push	{r3, lr}
  chSysLockFromISR();
 800a302:	f7ff ffd5 	bl	800a2b0 <chSysLockFromISR.lto_priv.527>
}
 800a306:	bd08      	pop	{r3, pc}
	...

0800a310 <osalSysUnlockFromISR.lto_priv.549>:
static inline void osalSysUnlockFromISR(void) {
 800a310:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 800a312:	f7ff ffd5 	bl	800a2c0 <chSysUnlockFromISR.lto_priv.519>
}
 800a316:	bd08      	pop	{r3, pc}
	...

0800a320 <osalThreadDequeueAllI.lto_priv.616>:
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 800a320:	b500      	push	{lr}
 800a322:	b083      	sub	sp, #12
 800a324:	9001      	str	r0, [sp, #4]
 800a326:	9100      	str	r1, [sp, #0]
  chThdDequeueAllI(tqp, msg);
 800a328:	9900      	ldr	r1, [sp, #0]
 800a32a:	9801      	ldr	r0, [sp, #4]
 800a32c:	f006 fb58 	bl	80109e0 <chThdDequeueAllI>
}
 800a330:	b003      	add	sp, #12
 800a332:	f85d fb04 	ldr.w	pc, [sp], #4
 800a336:	bf00      	nop
	...

0800a340 <osalEventObjectInit.lto_priv.613>:
static inline void osalEventObjectInit(event_source_t *esp) {
 800a340:	b500      	push	{lr}
 800a342:	b083      	sub	sp, #12
 800a344:	9001      	str	r0, [sp, #4]
  chEvtObjectInit(esp);
 800a346:	9801      	ldr	r0, [sp, #4]
 800a348:	f7ff ffc2 	bl	800a2d0 <chEvtObjectInit.lto_priv.421>
}
 800a34c:	b003      	add	sp, #12
 800a34e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a352:	bf00      	nop
	...

0800a360 <osalEventBroadcastFlagsI.lto_priv.547>:
                                            eventflags_t flags) {
 800a360:	b500      	push	{lr}
 800a362:	b083      	sub	sp, #12
 800a364:	9001      	str	r0, [sp, #4]
 800a366:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 800a368:	9900      	ldr	r1, [sp, #0]
 800a36a:	9801      	ldr	r0, [sp, #4]
 800a36c:	f007 fdb8 	bl	8011ee0 <chEvtBroadcastFlagsI>
}
 800a370:	b003      	add	sp, #12
 800a372:	f85d fb04 	ldr.w	pc, [sp], #4
 800a376:	bf00      	nop
	...

0800a380 <sdu_start_receive>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static bool sdu_start_receive(SerialUSBDriver *sdup) {
 800a380:	b500      	push	{lr}
 800a382:	b085      	sub	sp, #20
 800a384:	9001      	str	r0, [sp, #4]
  uint8_t *buf;

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a386:	9b01      	ldr	r3, [sp, #4]
 800a388:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a38c:	681b      	ldr	r3, [r3, #0]
 800a38e:	781b      	ldrb	r3, [r3, #0]
 800a390:	2b04      	cmp	r3, #4
 800a392:	d103      	bne.n	800a39c <sdu_start_receive+0x1c>
      (sdup->state != SDU_READY)) {
 800a394:	9b01      	ldr	r3, [sp, #4]
 800a396:	7a1b      	ldrb	r3, [r3, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a398:	2b02      	cmp	r3, #2
 800a39a:	d001      	beq.n	800a3a0 <sdu_start_receive+0x20>
    return true;
 800a39c:	2301      	movs	r3, #1
 800a39e:	e02b      	b.n	800a3f8 <sdu_start_receive+0x78>
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800a3a0:	9b01      	ldr	r3, [sp, #4]
 800a3a2:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a3a6:	681b      	ldr	r3, [r3, #0]
 800a3a8:	895a      	ldrh	r2, [r3, #10]
 800a3aa:	9b01      	ldr	r3, [sp, #4]
 800a3ac:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a3b0:	791b      	ldrb	r3, [r3, #4]
 800a3b2:	4619      	mov	r1, r3
 800a3b4:	2301      	movs	r3, #1
 800a3b6:	408b      	lsls	r3, r1
 800a3b8:	b29b      	uxth	r3, r3
 800a3ba:	4013      	ands	r3, r2
 800a3bc:	b29b      	uxth	r3, r3
 800a3be:	2b00      	cmp	r3, #0
 800a3c0:	d001      	beq.n	800a3c6 <sdu_start_receive+0x46>
    return true;
 800a3c2:	2301      	movs	r3, #1
 800a3c4:	e018      	b.n	800a3f8 <sdu_start_receive+0x78>
  }

  /* Checking if there is a buffer ready for incoming data.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 800a3c6:	9b01      	ldr	r3, [sp, #4]
 800a3c8:	330c      	adds	r3, #12
 800a3ca:	4618      	mov	r0, r3
 800a3cc:	f7fe fd18 	bl	8008e00 <ibqGetEmptyBufferI>
 800a3d0:	9003      	str	r0, [sp, #12]
  if (buf == NULL) {
 800a3d2:	9b03      	ldr	r3, [sp, #12]
 800a3d4:	2b00      	cmp	r3, #0
 800a3d6:	d101      	bne.n	800a3dc <sdu_start_receive+0x5c>
    return true;
 800a3d8:	2301      	movs	r3, #1
 800a3da:	e00d      	b.n	800a3f8 <sdu_start_receive+0x78>
  }

  /* Buffer found, starting a new transaction.*/
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 800a3dc:	9b01      	ldr	r3, [sp, #4]
 800a3de:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a3e2:	6818      	ldr	r0, [r3, #0]
 800a3e4:	9b01      	ldr	r3, [sp, #4]
 800a3e6:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a3ea:	7959      	ldrb	r1, [r3, #5]
 800a3ec:	f44f 7380 	mov.w	r3, #256	; 0x100
 800a3f0:	9a03      	ldr	r2, [sp, #12]
 800a3f2:	f001 f895 	bl	800b520 <usbStartReceiveI>
                   buf, SERIAL_USB_BUFFERS_SIZE);

  return false;
 800a3f6:	2300      	movs	r3, #0
}
 800a3f8:	4618      	mov	r0, r3
 800a3fa:	b005      	add	sp, #20
 800a3fc:	f85d fb04 	ldr.w	pc, [sp], #4

0800a400 <_write.lto_priv.242>:

/*
 * Interface implementation.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 800a400:	b500      	push	{lr}
 800a402:	b085      	sub	sp, #20
 800a404:	9003      	str	r0, [sp, #12]
 800a406:	9102      	str	r1, [sp, #8]
 800a408:	9201      	str	r2, [sp, #4]

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 800a40a:	9b03      	ldr	r3, [sp, #12]
 800a40c:	f103 0044 	add.w	r0, r3, #68	; 0x44
 800a410:	f04f 33ff 	mov.w	r3, #4294967295
 800a414:	9a01      	ldr	r2, [sp, #4]
 800a416:	9902      	ldr	r1, [sp, #8]
 800a418:	f7ff f80a 	bl	8009430 <obqWriteTimeout>
 800a41c:	4603      	mov	r3, r0
                         n, TIME_INFINITE);
}
 800a41e:	4618      	mov	r0, r3
 800a420:	b005      	add	sp, #20
 800a422:	f85d fb04 	ldr.w	pc, [sp], #4
 800a426:	bf00      	nop
	...

0800a430 <_read.lto_priv.244>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 800a430:	b500      	push	{lr}
 800a432:	b085      	sub	sp, #20
 800a434:	9003      	str	r0, [sp, #12]
 800a436:	9102      	str	r1, [sp, #8]
 800a438:	9201      	str	r2, [sp, #4]

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 800a43a:	9b03      	ldr	r3, [sp, #12]
 800a43c:	f103 000c 	add.w	r0, r3, #12
 800a440:	f04f 33ff 	mov.w	r3, #4294967295
 800a444:	9a01      	ldr	r2, [sp, #4]
 800a446:	9902      	ldr	r1, [sp, #8]
 800a448:	f7fe fdea 	bl	8009020 <ibqReadTimeout>
 800a44c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800a44e:	4618      	mov	r0, r3
 800a450:	b005      	add	sp, #20
 800a452:	f85d fb04 	ldr.w	pc, [sp], #4
 800a456:	bf00      	nop
	...

0800a460 <_put.lto_priv.154>:

static msg_t _put(void *ip, uint8_t b) {
 800a460:	b500      	push	{lr}
 800a462:	b083      	sub	sp, #12
 800a464:	9001      	str	r0, [sp, #4]
 800a466:	460b      	mov	r3, r1
 800a468:	f88d 3003 	strb.w	r3, [sp, #3]

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 800a46c:	9b01      	ldr	r3, [sp, #4]
 800a46e:	3344      	adds	r3, #68	; 0x44
 800a470:	f89d 1003 	ldrb.w	r1, [sp, #3]
 800a474:	f04f 32ff 	mov.w	r2, #4294967295
 800a478:	4618      	mov	r0, r3
 800a47a:	f7fe ffa1 	bl	80093c0 <obqPutTimeout>
 800a47e:	4603      	mov	r3, r0
}
 800a480:	4618      	mov	r0, r3
 800a482:	b003      	add	sp, #12
 800a484:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a490 <_get.lto_priv.157>:

static msg_t _get(void *ip) {
 800a490:	b500      	push	{lr}
 800a492:	b083      	sub	sp, #12
 800a494:	9001      	str	r0, [sp, #4]

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 800a496:	9b01      	ldr	r3, [sp, #4]
 800a498:	330c      	adds	r3, #12
 800a49a:	f04f 31ff 	mov.w	r1, #4294967295
 800a49e:	4618      	mov	r0, r3
 800a4a0:	f7fe fd8e 	bl	8008fc0 <ibqGetTimeout>
 800a4a4:	4603      	mov	r3, r0
}
 800a4a6:	4618      	mov	r0, r3
 800a4a8:	b003      	add	sp, #12
 800a4aa:	f85d fb04 	ldr.w	pc, [sp], #4
 800a4ae:	bf00      	nop

0800a4b0 <_putt.lto_priv.246>:

static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 800a4b0:	b500      	push	{lr}
 800a4b2:	b085      	sub	sp, #20
 800a4b4:	9003      	str	r0, [sp, #12]
 800a4b6:	460b      	mov	r3, r1
 800a4b8:	9201      	str	r2, [sp, #4]
 800a4ba:	f88d 300b 	strb.w	r3, [sp, #11]

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 800a4be:	9b03      	ldr	r3, [sp, #12]
 800a4c0:	3344      	adds	r3, #68	; 0x44
 800a4c2:	f89d 100b 	ldrb.w	r1, [sp, #11]
 800a4c6:	9a01      	ldr	r2, [sp, #4]
 800a4c8:	4618      	mov	r0, r3
 800a4ca:	f7fe ff79 	bl	80093c0 <obqPutTimeout>
 800a4ce:	4603      	mov	r3, r0
}
 800a4d0:	4618      	mov	r0, r3
 800a4d2:	b005      	add	sp, #20
 800a4d4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a4e0 <_gett.lto_priv.248>:

static msg_t _gett(void *ip, sysinterval_t timeout) {
 800a4e0:	b500      	push	{lr}
 800a4e2:	b083      	sub	sp, #12
 800a4e4:	9001      	str	r0, [sp, #4]
 800a4e6:	9100      	str	r1, [sp, #0]

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 800a4e8:	9b01      	ldr	r3, [sp, #4]
 800a4ea:	330c      	adds	r3, #12
 800a4ec:	9900      	ldr	r1, [sp, #0]
 800a4ee:	4618      	mov	r0, r3
 800a4f0:	f7fe fd66 	bl	8008fc0 <ibqGetTimeout>
 800a4f4:	4603      	mov	r3, r0
}
 800a4f6:	4618      	mov	r0, r3
 800a4f8:	b003      	add	sp, #12
 800a4fa:	f85d fb04 	ldr.w	pc, [sp], #4
 800a4fe:	bf00      	nop

0800a500 <_writet.lto_priv.250>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n,
                      sysinterval_t timeout) {
 800a500:	b500      	push	{lr}
 800a502:	b085      	sub	sp, #20
 800a504:	9003      	str	r0, [sp, #12]
 800a506:	9102      	str	r1, [sp, #8]
 800a508:	9201      	str	r2, [sp, #4]
 800a50a:	9300      	str	r3, [sp, #0]

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 800a50c:	9b03      	ldr	r3, [sp, #12]
 800a50e:	f103 0044 	add.w	r0, r3, #68	; 0x44
 800a512:	9b00      	ldr	r3, [sp, #0]
 800a514:	9a01      	ldr	r2, [sp, #4]
 800a516:	9902      	ldr	r1, [sp, #8]
 800a518:	f7fe ff8a 	bl	8009430 <obqWriteTimeout>
 800a51c:	4603      	mov	r3, r0
}
 800a51e:	4618      	mov	r0, r3
 800a520:	b005      	add	sp, #20
 800a522:	f85d fb04 	ldr.w	pc, [sp], #4
 800a526:	bf00      	nop
	...

0800a530 <_readt.lto_priv.252>:

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {
 800a530:	b500      	push	{lr}
 800a532:	b085      	sub	sp, #20
 800a534:	9003      	str	r0, [sp, #12]
 800a536:	9102      	str	r1, [sp, #8]
 800a538:	9201      	str	r2, [sp, #4]
 800a53a:	9300      	str	r3, [sp, #0]

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 800a53c:	9b03      	ldr	r3, [sp, #12]
 800a53e:	f103 000c 	add.w	r0, r3, #12
 800a542:	9b00      	ldr	r3, [sp, #0]
 800a544:	9a01      	ldr	r2, [sp, #4]
 800a546:	9902      	ldr	r1, [sp, #8]
 800a548:	f7fe fd6a 	bl	8009020 <ibqReadTimeout>
 800a54c:	4603      	mov	r3, r0
}
 800a54e:	4618      	mov	r0, r3
 800a550:	b005      	add	sp, #20
 800a552:	f85d fb04 	ldr.w	pc, [sp], #4
 800a556:	bf00      	nop
	...

0800a560 <_ctl.lto_priv.254>:

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 800a560:	b500      	push	{lr}
 800a562:	b087      	sub	sp, #28
 800a564:	9003      	str	r0, [sp, #12]
 800a566:	9102      	str	r1, [sp, #8]
 800a568:	9201      	str	r2, [sp, #4]
  SerialUSBDriver *sdup = (SerialUSBDriver *)ip;
 800a56a:	9b03      	ldr	r3, [sp, #12]
 800a56c:	9305      	str	r3, [sp, #20]

  osalDbgCheck(sdup != NULL);
 800a56e:	9b05      	ldr	r3, [sp, #20]
 800a570:	2b00      	cmp	r3, #0
 800a572:	d102      	bne.n	800a57a <_ctl.lto_priv.254+0x1a>
 800a574:	480b      	ldr	r0, [pc, #44]	; (800a5a4 <_ctl.lto_priv.254+0x44>)
 800a576:	f004 fd33 	bl	800efe0 <chSysHalt>

  switch (operation) {
 800a57a:	9b02      	ldr	r3, [sp, #8]
 800a57c:	2b00      	cmp	r3, #0
 800a57e:	d008      	beq.n	800a592 <_ctl.lto_priv.254+0x32>
 800a580:	2b01      	cmp	r3, #1
 800a582:	d109      	bne.n	800a598 <_ctl.lto_priv.254+0x38>
  case CHN_CTL_NOP:
    osalDbgCheck(arg == NULL);
 800a584:	9b01      	ldr	r3, [sp, #4]
 800a586:	2b00      	cmp	r3, #0
 800a588:	d006      	beq.n	800a598 <_ctl.lto_priv.254+0x38>
 800a58a:	4806      	ldr	r0, [pc, #24]	; (800a5a4 <_ctl.lto_priv.254+0x44>)
 800a58c:	f004 fd28 	bl	800efe0 <chSysHalt>
 800a590:	e002      	b.n	800a598 <_ctl.lto_priv.254+0x38>
    break;
  case CHN_CTL_INVALID:
    osalDbgAssert(false, "invalid CTL operation");
 800a592:	4804      	ldr	r0, [pc, #16]	; (800a5a4 <_ctl.lto_priv.254+0x44>)
 800a594:	f004 fd24 	bl	800efe0 <chSysHalt>
    return sdu_lld_control(sdup, operation, arg);
#else
    break;
#endif
  }
  return MSG_OK;
 800a598:	2300      	movs	r3, #0
}
 800a59a:	4618      	mov	r0, r3
 800a59c:	b007      	add	sp, #28
 800a59e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a5a2:	bf00      	nop
 800a5a4:	08015d40 	.word	0x08015d40
	...

0800a5b0 <ibnotify>:
/**
 * @brief   Notification of empty buffer released into the input buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void ibnotify(io_buffers_queue_t *bqp) {
 800a5b0:	b500      	push	{lr}
 800a5b2:	b085      	sub	sp, #20
 800a5b4:	9001      	str	r0, [sp, #4]
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 800a5b6:	9b01      	ldr	r3, [sp, #4]
 800a5b8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a5ba:	9303      	str	r3, [sp, #12]
  (void) sdu_start_receive(sdup);
 800a5bc:	9803      	ldr	r0, [sp, #12]
 800a5be:	f7ff fedf 	bl	800a380 <sdu_start_receive>
}
 800a5c2:	b005      	add	sp, #20
 800a5c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a5d0 <obnotify>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 800a5d0:	b500      	push	{lr}
 800a5d2:	b087      	sub	sp, #28
 800a5d4:	9001      	str	r0, [sp, #4]
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 800a5d6:	9b01      	ldr	r3, [sp, #4]
 800a5d8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a5da:	9305      	str	r3, [sp, #20]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a5dc:	9b05      	ldr	r3, [sp, #20]
 800a5de:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a5e2:	681b      	ldr	r3, [r3, #0]
 800a5e4:	781b      	ldrb	r3, [r3, #0]
 800a5e6:	2b04      	cmp	r3, #4
 800a5e8:	d12f      	bne.n	800a64a <obnotify+0x7a>
      (sdup->state != SDU_READY)) {
 800a5ea:	9b05      	ldr	r3, [sp, #20]
 800a5ec:	7a1b      	ldrb	r3, [r3, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a5ee:	2b02      	cmp	r3, #2
 800a5f0:	d12b      	bne.n	800a64a <obnotify+0x7a>
    return;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800a5f2:	9b05      	ldr	r3, [sp, #20]
 800a5f4:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a5f8:	681b      	ldr	r3, [r3, #0]
 800a5fa:	891a      	ldrh	r2, [r3, #8]
 800a5fc:	9b05      	ldr	r3, [sp, #20]
 800a5fe:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a602:	791b      	ldrb	r3, [r3, #4]
 800a604:	4619      	mov	r1, r3
 800a606:	2301      	movs	r3, #1
 800a608:	408b      	lsls	r3, r1
 800a60a:	b29b      	uxth	r3, r3
 800a60c:	4013      	ands	r3, r2
 800a60e:	b29b      	uxth	r3, r3
 800a610:	2b00      	cmp	r3, #0
 800a612:	d11b      	bne.n	800a64c <obnotify+0x7c>
    /* Getting a full buffer, a buffer is available for sure because this
       callback is invoked when one has been inserted.*/
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800a614:	9b05      	ldr	r3, [sp, #20]
 800a616:	3344      	adds	r3, #68	; 0x44
 800a618:	aa03      	add	r2, sp, #12
 800a61a:	4611      	mov	r1, r2
 800a61c:	4618      	mov	r0, r3
 800a61e:	f7fe fde7 	bl	80091f0 <obqGetFullBufferI>
 800a622:	9004      	str	r0, [sp, #16]
    osalDbgAssert(buf != NULL, "buffer not found");
 800a624:	9b04      	ldr	r3, [sp, #16]
 800a626:	2b00      	cmp	r3, #0
 800a628:	d102      	bne.n	800a630 <obnotify+0x60>
 800a62a:	480a      	ldr	r0, [pc, #40]	; (800a654 <obnotify+0x84>)
 800a62c:	f004 fcd8 	bl	800efe0 <chSysHalt>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 800a630:	9b05      	ldr	r3, [sp, #20]
 800a632:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a636:	6818      	ldr	r0, [r3, #0]
 800a638:	9b05      	ldr	r3, [sp, #20]
 800a63a:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a63e:	7919      	ldrb	r1, [r3, #4]
 800a640:	9b03      	ldr	r3, [sp, #12]
 800a642:	9a04      	ldr	r2, [sp, #16]
 800a644:	f000 ffbc 	bl	800b5c0 <usbStartTransmitI>
 800a648:	e000      	b.n	800a64c <obnotify+0x7c>
    return;
 800a64a:	bf00      	nop
  }
}
 800a64c:	b007      	add	sp, #28
 800a64e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a652:	bf00      	nop
 800a654:	08015d48 	.word	0x08015d48
	...

0800a660 <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 800a660:	4770      	bx	lr
 800a662:	bf00      	nop
	...

0800a670 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 800a670:	b500      	push	{lr}
 800a672:	b087      	sub	sp, #28
 800a674:	9005      	str	r0, [sp, #20]

  sdup->vmt = &vmt;
 800a676:	9b05      	ldr	r3, [sp, #20]
 800a678:	4a17      	ldr	r2, [pc, #92]	; (800a6d8 <sduObjectInit+0x68>)
 800a67a:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdup->event);
 800a67c:	9b05      	ldr	r3, [sp, #20]
 800a67e:	3304      	adds	r3, #4
 800a680:	4618      	mov	r0, r3
 800a682:	f7ff fe5d 	bl	800a340 <osalEventObjectInit.lto_priv.613>
  sdup->state = SDU_STOP;
 800a686:	9b05      	ldr	r3, [sp, #20]
 800a688:	2201      	movs	r2, #1
 800a68a:	721a      	strb	r2, [r3, #8]
  ibqObjectInit(&sdup->ibqueue, true, sdup->ib,
 800a68c:	9b05      	ldr	r3, [sp, #20]
 800a68e:	f103 000c 	add.w	r0, r3, #12
 800a692:	9b05      	ldr	r3, [sp, #20]
 800a694:	f103 027c 	add.w	r2, r3, #124	; 0x7c
 800a698:	9b05      	ldr	r3, [sp, #20]
 800a69a:	9302      	str	r3, [sp, #8]
 800a69c:	4b0f      	ldr	r3, [pc, #60]	; (800a6dc <sduObjectInit+0x6c>)
 800a69e:	9301      	str	r3, [sp, #4]
 800a6a0:	2302      	movs	r3, #2
 800a6a2:	9300      	str	r3, [sp, #0]
 800a6a4:	f44f 7380 	mov.w	r3, #256	; 0x100
 800a6a8:	2101      	movs	r1, #1
 800a6aa:	f7fe fb39 	bl	8008d20 <ibqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                ibnotify, sdup);
  obqObjectInit(&sdup->obqueue, true, sdup->ob,
 800a6ae:	9b05      	ldr	r3, [sp, #20]
 800a6b0:	f103 0044 	add.w	r0, r3, #68	; 0x44
 800a6b4:	9b05      	ldr	r3, [sp, #20]
 800a6b6:	f503 7221 	add.w	r2, r3, #644	; 0x284
 800a6ba:	9b05      	ldr	r3, [sp, #20]
 800a6bc:	9302      	str	r3, [sp, #8]
 800a6be:	4b08      	ldr	r3, [pc, #32]	; (800a6e0 <sduObjectInit+0x70>)
 800a6c0:	9301      	str	r3, [sp, #4]
 800a6c2:	2302      	movs	r3, #2
 800a6c4:	9300      	str	r3, [sp, #0]
 800a6c6:	f44f 7380 	mov.w	r3, #256	; 0x100
 800a6ca:	2101      	movs	r1, #1
 800a6cc:	f7fe fd20 	bl	8009110 <obqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                obnotify, sdup);
}
 800a6d0:	b007      	add	sp, #28
 800a6d2:	f85d fb04 	ldr.w	pc, [sp], #4
 800a6d6:	bf00      	nop
 800a6d8:	08015d18 	.word	0x08015d18
 800a6dc:	0800a5b1 	.word	0x0800a5b1
 800a6e0:	0800a5d1 	.word	0x0800a5d1
	...

0800a6f0 <sduStart>:
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
 800a6f0:	b500      	push	{lr}
 800a6f2:	b085      	sub	sp, #20
 800a6f4:	9001      	str	r0, [sp, #4]
 800a6f6:	9100      	str	r1, [sp, #0]
  USBDriver *usbp = config->usbp;
 800a6f8:	9b00      	ldr	r3, [sp, #0]
 800a6fa:	681b      	ldr	r3, [r3, #0]
 800a6fc:	9303      	str	r3, [sp, #12]

  osalDbgCheck(sdup != NULL);
 800a6fe:	9b01      	ldr	r3, [sp, #4]
 800a700:	2b00      	cmp	r3, #0
 800a702:	d102      	bne.n	800a70a <sduStart+0x1a>
 800a704:	481c      	ldr	r0, [pc, #112]	; (800a778 <sduStart+0x88>)
 800a706:	f004 fc6b 	bl	800efe0 <chSysHalt>

  osalSysLock();
 800a70a:	f7ff fde9 	bl	800a2e0 <osalSysLock.lto_priv.278>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 800a70e:	9b01      	ldr	r3, [sp, #4]
 800a710:	7a1b      	ldrb	r3, [r3, #8]
 800a712:	2b01      	cmp	r3, #1
 800a714:	d006      	beq.n	800a724 <sduStart+0x34>
 800a716:	9b01      	ldr	r3, [sp, #4]
 800a718:	7a1b      	ldrb	r3, [r3, #8]
 800a71a:	2b02      	cmp	r3, #2
 800a71c:	d002      	beq.n	800a724 <sduStart+0x34>
 800a71e:	4816      	ldr	r0, [pc, #88]	; (800a778 <sduStart+0x88>)
 800a720:	f004 fc5e 	bl	800efe0 <chSysHalt>
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 800a724:	9b00      	ldr	r3, [sp, #0]
 800a726:	791b      	ldrb	r3, [r3, #4]
 800a728:	3b01      	subs	r3, #1
 800a72a:	9a03      	ldr	r2, [sp, #12]
 800a72c:	3308      	adds	r3, #8
 800a72e:	009b      	lsls	r3, r3, #2
 800a730:	4413      	add	r3, r2
 800a732:	9a01      	ldr	r2, [sp, #4]
 800a734:	605a      	str	r2, [r3, #4]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 800a736:	9b00      	ldr	r3, [sp, #0]
 800a738:	795b      	ldrb	r3, [r3, #5]
 800a73a:	1e5a      	subs	r2, r3, #1
 800a73c:	9b03      	ldr	r3, [sp, #12]
 800a73e:	320e      	adds	r2, #14
 800a740:	9901      	ldr	r1, [sp, #4]
 800a742:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 800a746:	9b00      	ldr	r3, [sp, #0]
 800a748:	799b      	ldrb	r3, [r3, #6]
 800a74a:	2b00      	cmp	r3, #0
 800a74c:	d008      	beq.n	800a760 <sduStart+0x70>
    usbp->in_params[config->int_in - 1U]  = sdup;
 800a74e:	9b00      	ldr	r3, [sp, #0]
 800a750:	799b      	ldrb	r3, [r3, #6]
 800a752:	3b01      	subs	r3, #1
 800a754:	9a03      	ldr	r2, [sp, #12]
 800a756:	3308      	adds	r3, #8
 800a758:	009b      	lsls	r3, r3, #2
 800a75a:	4413      	add	r3, r2
 800a75c:	9a01      	ldr	r2, [sp, #4]
 800a75e:	605a      	str	r2, [r3, #4]
  }
  sdup->config = config;
 800a760:	9b01      	ldr	r3, [sp, #4]
 800a762:	9a00      	ldr	r2, [sp, #0]
 800a764:	f8c3 248c 	str.w	r2, [r3, #1164]	; 0x48c
  sdup->state = SDU_READY;
 800a768:	9b01      	ldr	r3, [sp, #4]
 800a76a:	2202      	movs	r2, #2
 800a76c:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800a76e:	f7ff fdbf 	bl	800a2f0 <osalSysUnlock.lto_priv.269>
}
 800a772:	b005      	add	sp, #20
 800a774:	f85d fb04 	ldr.w	pc, [sp], #4
 800a778:	08015d54 	.word	0x08015d54
 800a77c:	00000000 	.word	0x00000000

0800a780 <sduSuspendHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduSuspendHookI(SerialUSBDriver *sdup) {
 800a780:	b500      	push	{lr}
 800a782:	b083      	sub	sp, #12
 800a784:	9001      	str	r0, [sp, #4]

  /* Avoiding events spam.*/
  if(bqIsSuspendedX(&sdup->ibqueue) && bqIsSuspendedX(&sdup->obqueue)) {
 800a786:	9b01      	ldr	r3, [sp, #4]
 800a788:	7d1b      	ldrb	r3, [r3, #20]
 800a78a:	2b00      	cmp	r3, #0
 800a78c:	d004      	beq.n	800a798 <sduSuspendHookI+0x18>
 800a78e:	9b01      	ldr	r3, [sp, #4]
 800a790:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 800a794:	2b00      	cmp	r3, #0
 800a796:	d11a      	bne.n	800a7ce <sduSuspendHookI+0x4e>
    return;
  }
  chnAddFlagsI(sdup, CHN_DISCONNECTED);
 800a798:	9b01      	ldr	r3, [sp, #4]
 800a79a:	3304      	adds	r3, #4
 800a79c:	2102      	movs	r1, #2
 800a79e:	4618      	mov	r0, r3
 800a7a0:	f7ff fdde 	bl	800a360 <osalEventBroadcastFlagsI.lto_priv.547>
  bqSuspendI(&sdup->ibqueue);
 800a7a4:	9b01      	ldr	r3, [sp, #4]
 800a7a6:	2201      	movs	r2, #1
 800a7a8:	751a      	strb	r2, [r3, #20]
 800a7aa:	9b01      	ldr	r3, [sp, #4]
 800a7ac:	330c      	adds	r3, #12
 800a7ae:	f06f 0101 	mvn.w	r1, #1
 800a7b2:	4618      	mov	r0, r3
 800a7b4:	f7ff fdb4 	bl	800a320 <osalThreadDequeueAllI.lto_priv.616>
  bqSuspendI(&sdup->obqueue);
 800a7b8:	9b01      	ldr	r3, [sp, #4]
 800a7ba:	2201      	movs	r2, #1
 800a7bc:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 800a7c0:	9b01      	ldr	r3, [sp, #4]
 800a7c2:	3344      	adds	r3, #68	; 0x44
 800a7c4:	f06f 0101 	mvn.w	r1, #1
 800a7c8:	4618      	mov	r0, r3
 800a7ca:	f7ff fda9 	bl	800a320 <osalThreadDequeueAllI.lto_priv.616>
}
 800a7ce:	b003      	add	sp, #12
 800a7d0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a7e0 <sduWakeupHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduWakeupHookI(SerialUSBDriver *sdup) {
 800a7e0:	b500      	push	{lr}
 800a7e2:	b083      	sub	sp, #12
 800a7e4:	9001      	str	r0, [sp, #4]

  chnAddFlagsI(sdup, CHN_CONNECTED);
 800a7e6:	9b01      	ldr	r3, [sp, #4]
 800a7e8:	3304      	adds	r3, #4
 800a7ea:	2101      	movs	r1, #1
 800a7ec:	4618      	mov	r0, r3
 800a7ee:	f7ff fdb7 	bl	800a360 <osalEventBroadcastFlagsI.lto_priv.547>
  bqResumeX(&sdup->ibqueue);
 800a7f2:	9b01      	ldr	r3, [sp, #4]
 800a7f4:	2200      	movs	r2, #0
 800a7f6:	751a      	strb	r2, [r3, #20]
  bqResumeX(&sdup->obqueue);
 800a7f8:	9b01      	ldr	r3, [sp, #4]
 800a7fa:	2200      	movs	r2, #0
 800a7fc:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
}
 800a800:	b003      	add	sp, #12
 800a802:	f85d fb04 	ldr.w	pc, [sp], #4
 800a806:	bf00      	nop
	...

0800a810 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 800a810:	b500      	push	{lr}
 800a812:	b083      	sub	sp, #12
 800a814:	9001      	str	r0, [sp, #4]

  ibqResetI(&sdup->ibqueue);
 800a816:	9b01      	ldr	r3, [sp, #4]
 800a818:	330c      	adds	r3, #12
 800a81a:	4618      	mov	r0, r3
 800a81c:	f7fe fad0 	bl	8008dc0 <ibqResetI>
  bqResumeX(&sdup->ibqueue);
 800a820:	9b01      	ldr	r3, [sp, #4]
 800a822:	2200      	movs	r2, #0
 800a824:	751a      	strb	r2, [r3, #20]
  obqResetI(&sdup->obqueue);
 800a826:	9b01      	ldr	r3, [sp, #4]
 800a828:	3344      	adds	r3, #68	; 0x44
 800a82a:	4618      	mov	r0, r3
 800a82c:	f7fe fcc0 	bl	80091b0 <obqResetI>
  bqResumeX(&sdup->obqueue);
 800a830:	9b01      	ldr	r3, [sp, #4]
 800a832:	2200      	movs	r2, #0
 800a834:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  chnAddFlagsI(sdup, CHN_CONNECTED);
 800a838:	9b01      	ldr	r3, [sp, #4]
 800a83a:	3304      	adds	r3, #4
 800a83c:	2101      	movs	r1, #1
 800a83e:	4618      	mov	r0, r3
 800a840:	f7ff fd8e 	bl	800a360 <osalEventBroadcastFlagsI.lto_priv.547>
  (void) sdu_start_receive(sdup);
 800a844:	9801      	ldr	r0, [sp, #4]
 800a846:	f7ff fd9b 	bl	800a380 <sdu_start_receive>
}
 800a84a:	b003      	add	sp, #12
 800a84c:	f85d fb04 	ldr.w	pc, [sp], #4

0800a850 <sduRequestsHook>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The hook status.
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {
 800a850:	b082      	sub	sp, #8
 800a852:	9001      	str	r0, [sp, #4]

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 800a854:	9b01      	ldr	r3, [sp, #4]
 800a856:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800a85a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800a85e:	2b20      	cmp	r3, #32
 800a860:	d12c      	bne.n	800a8bc <sduRequestsHook+0x6c>
    switch (usbp->setup[1]) {
 800a862:	9b01      	ldr	r3, [sp, #4]
 800a864:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 800a868:	2b21      	cmp	r3, #33	; 0x21
 800a86a:	d004      	beq.n	800a876 <sduRequestsHook+0x26>
 800a86c:	2b22      	cmp	r3, #34	; 0x22
 800a86e:	d018      	beq.n	800a8a2 <sduRequestsHook+0x52>
 800a870:	2b20      	cmp	r3, #32
 800a872:	d00b      	beq.n	800a88c <sduRequestsHook+0x3c>
 800a874:	e020      	b.n	800a8b8 <sduRequestsHook+0x68>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800a876:	9b01      	ldr	r3, [sp, #4]
 800a878:	4a12      	ldr	r2, [pc, #72]	; (800a8c4 <sduRequestsHook+0x74>)
 800a87a:	651a      	str	r2, [r3, #80]	; 0x50
 800a87c:	9b01      	ldr	r3, [sp, #4]
 800a87e:	2207      	movs	r2, #7
 800a880:	655a      	str	r2, [r3, #84]	; 0x54
 800a882:	9b01      	ldr	r3, [sp, #4]
 800a884:	2200      	movs	r2, #0
 800a886:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800a888:	2301      	movs	r3, #1
 800a88a:	e018      	b.n	800a8be <sduRequestsHook+0x6e>
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800a88c:	9b01      	ldr	r3, [sp, #4]
 800a88e:	4a0d      	ldr	r2, [pc, #52]	; (800a8c4 <sduRequestsHook+0x74>)
 800a890:	651a      	str	r2, [r3, #80]	; 0x50
 800a892:	9b01      	ldr	r3, [sp, #4]
 800a894:	2207      	movs	r2, #7
 800a896:	655a      	str	r2, [r3, #84]	; 0x54
 800a898:	9b01      	ldr	r3, [sp, #4]
 800a89a:	2200      	movs	r2, #0
 800a89c:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800a89e:	2301      	movs	r3, #1
 800a8a0:	e00d      	b.n	800a8be <sduRequestsHook+0x6e>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800a8a2:	9b01      	ldr	r3, [sp, #4]
 800a8a4:	2200      	movs	r2, #0
 800a8a6:	651a      	str	r2, [r3, #80]	; 0x50
 800a8a8:	9b01      	ldr	r3, [sp, #4]
 800a8aa:	2200      	movs	r2, #0
 800a8ac:	655a      	str	r2, [r3, #84]	; 0x54
 800a8ae:	9b01      	ldr	r3, [sp, #4]
 800a8b0:	2200      	movs	r2, #0
 800a8b2:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800a8b4:	2301      	movs	r3, #1
 800a8b6:	e002      	b.n	800a8be <sduRequestsHook+0x6e>
    default:
      return false;
 800a8b8:	2300      	movs	r3, #0
 800a8ba:	e000      	b.n	800a8be <sduRequestsHook+0x6e>
    }
  }
  return false;
 800a8bc:	2300      	movs	r3, #0
}
 800a8be:	4618      	mov	r0, r3
 800a8c0:	b002      	add	sp, #8
 800a8c2:	4770      	bx	lr
 800a8c4:	20000800 	.word	0x20000800
	...

0800a8d0 <sduSOFHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduSOFHookI(SerialUSBDriver *sdup) {
 800a8d0:	b500      	push	{lr}
 800a8d2:	b085      	sub	sp, #20
 800a8d4:	9001      	str	r0, [sp, #4]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a8d6:	9b01      	ldr	r3, [sp, #4]
 800a8d8:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a8dc:	681b      	ldr	r3, [r3, #0]
 800a8de:	781b      	ldrb	r3, [r3, #0]
 800a8e0:	2b04      	cmp	r3, #4
 800a8e2:	d136      	bne.n	800a952 <sduSOFHookI+0x82>
      (sdup->state != SDU_READY)) {
 800a8e4:	9b01      	ldr	r3, [sp, #4]
 800a8e6:	7a1b      	ldrb	r3, [r3, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a8e8:	2b02      	cmp	r3, #2
 800a8ea:	d132      	bne.n	800a952 <sduSOFHookI+0x82>
    return;
  }

  /* If there is already a transaction ongoing then another one cannot be
     started.*/
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800a8ec:	9b01      	ldr	r3, [sp, #4]
 800a8ee:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a8f2:	681b      	ldr	r3, [r3, #0]
 800a8f4:	891a      	ldrh	r2, [r3, #8]
 800a8f6:	9b01      	ldr	r3, [sp, #4]
 800a8f8:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a8fc:	791b      	ldrb	r3, [r3, #4]
 800a8fe:	4619      	mov	r1, r3
 800a900:	2301      	movs	r3, #1
 800a902:	408b      	lsls	r3, r1
 800a904:	b29b      	uxth	r3, r3
 800a906:	4013      	ands	r3, r2
 800a908:	b29b      	uxth	r3, r3
 800a90a:	2b00      	cmp	r3, #0
 800a90c:	d121      	bne.n	800a952 <sduSOFHookI+0x82>
    return;
  }

  /* Checking if there only a buffer partially filled, if so then it is
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
 800a90e:	9b01      	ldr	r3, [sp, #4]
 800a910:	3344      	adds	r3, #68	; 0x44
 800a912:	4618      	mov	r0, r3
 800a914:	f7fe fe0c 	bl	8009530 <obqTryFlushI>
 800a918:	4603      	mov	r3, r0
 800a91a:	2b00      	cmp	r3, #0
 800a91c:	d019      	beq.n	800a952 <sduSOFHookI+0x82>
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800a91e:	9b01      	ldr	r3, [sp, #4]
 800a920:	3344      	adds	r3, #68	; 0x44
 800a922:	aa02      	add	r2, sp, #8
 800a924:	4611      	mov	r1, r2
 800a926:	4618      	mov	r0, r3
 800a928:	f7fe fc62 	bl	80091f0 <obqGetFullBufferI>
 800a92c:	9003      	str	r0, [sp, #12]

    osalDbgAssert(buf != NULL, "queue is empty");
 800a92e:	9b03      	ldr	r3, [sp, #12]
 800a930:	2b00      	cmp	r3, #0
 800a932:	d102      	bne.n	800a93a <sduSOFHookI+0x6a>
 800a934:	4808      	ldr	r0, [pc, #32]	; (800a958 <sduSOFHookI+0x88>)
 800a936:	f004 fb53 	bl	800efe0 <chSysHalt>

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 800a93a:	9b01      	ldr	r3, [sp, #4]
 800a93c:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a940:	6818      	ldr	r0, [r3, #0]
 800a942:	9b01      	ldr	r3, [sp, #4]
 800a944:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800a948:	7919      	ldrb	r1, [r3, #4]
 800a94a:	9b02      	ldr	r3, [sp, #8]
 800a94c:	9a03      	ldr	r2, [sp, #12]
 800a94e:	f000 fe37 	bl	800b5c0 <usbStartTransmitI>
  }
}
 800a952:	b005      	add	sp, #20
 800a954:	f85d fb04 	ldr.w	pc, [sp], #4
 800a958:	08015d6c 	.word	0x08015d6c
 800a95c:	00000000 	.word	0x00000000

0800a960 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800a960:	b500      	push	{lr}
 800a962:	b087      	sub	sp, #28
 800a964:	9001      	str	r0, [sp, #4]
 800a966:	460b      	mov	r3, r1
 800a968:	f88d 3003 	strb.w	r3, [sp, #3]
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800a96c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a970:	3b01      	subs	r3, #1
 800a972:	9a01      	ldr	r2, [sp, #4]
 800a974:	3308      	adds	r3, #8
 800a976:	009b      	lsls	r3, r3, #2
 800a978:	4413      	add	r3, r2
 800a97a:	685b      	ldr	r3, [r3, #4]
 800a97c:	9305      	str	r3, [sp, #20]

  if (sdup == NULL) {
 800a97e:	9b05      	ldr	r3, [sp, #20]
 800a980:	2b00      	cmp	r3, #0
 800a982:	d056      	beq.n	800aa32 <sduDataTransmitted+0xd2>
    return;
  }

  osalSysLockFromISR();
 800a984:	f7ff fcbc 	bl	800a300 <osalSysLockFromISR.lto_priv.555>

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);
 800a988:	9b05      	ldr	r3, [sp, #20]
 800a98a:	3304      	adds	r3, #4
 800a98c:	2108      	movs	r1, #8
 800a98e:	4618      	mov	r0, r3
 800a990:	f7ff fce6 	bl	800a360 <osalEventBroadcastFlagsI.lto_priv.547>

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 800a994:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a998:	9a01      	ldr	r2, [sp, #4]
 800a99a:	3302      	adds	r3, #2
 800a99c:	009b      	lsls	r3, r3, #2
 800a99e:	4413      	add	r3, r2
 800a9a0:	685b      	ldr	r3, [r3, #4]
 800a9a2:	695b      	ldr	r3, [r3, #20]
 800a9a4:	681b      	ldr	r3, [r3, #0]
 800a9a6:	2b00      	cmp	r3, #0
 800a9a8:	d004      	beq.n	800a9b4 <sduDataTransmitted+0x54>
    obqReleaseEmptyBufferI(&sdup->obqueue);
 800a9aa:	9b05      	ldr	r3, [sp, #20]
 800a9ac:	3344      	adds	r3, #68	; 0x44
 800a9ae:	4618      	mov	r0, r3
 800a9b0:	f7fe fc46 	bl	8009240 <obqReleaseEmptyBufferI>
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800a9b4:	9b05      	ldr	r3, [sp, #20]
 800a9b6:	3344      	adds	r3, #68	; 0x44
 800a9b8:	aa03      	add	r2, sp, #12
 800a9ba:	4611      	mov	r1, r2
 800a9bc:	4618      	mov	r0, r3
 800a9be:	f7fe fc17 	bl	80091f0 <obqGetFullBufferI>
 800a9c2:	9004      	str	r0, [sp, #16]

  if (buf != NULL) {
 800a9c4:	9b04      	ldr	r3, [sp, #16]
 800a9c6:	2b00      	cmp	r3, #0
 800a9c8:	d007      	beq.n	800a9da <sduDataTransmitted+0x7a>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 800a9ca:	9b03      	ldr	r3, [sp, #12]
 800a9cc:	f89d 1003 	ldrb.w	r1, [sp, #3]
 800a9d0:	9a04      	ldr	r2, [sp, #16]
 800a9d2:	9801      	ldr	r0, [sp, #4]
 800a9d4:	f000 fdf4 	bl	800b5c0 <usbStartTransmitI>
 800a9d8:	e028      	b.n	800aa2c <sduDataTransmitted+0xcc>
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800a9da:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a9de:	9a01      	ldr	r2, [sp, #4]
 800a9e0:	3302      	adds	r3, #2
 800a9e2:	009b      	lsls	r3, r3, #2
 800a9e4:	4413      	add	r3, r2
 800a9e6:	685b      	ldr	r3, [r3, #4]
 800a9e8:	695b      	ldr	r3, [r3, #20]
 800a9ea:	681b      	ldr	r3, [r3, #0]
 800a9ec:	2b00      	cmp	r3, #0
 800a9ee:	d01d      	beq.n	800aa2c <sduDataTransmitted+0xcc>
           ((usbp->epc[ep]->in_state->txsize &
 800a9f0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a9f4:	9a01      	ldr	r2, [sp, #4]
 800a9f6:	3302      	adds	r3, #2
 800a9f8:	009b      	lsls	r3, r3, #2
 800a9fa:	4413      	add	r3, r2
 800a9fc:	685b      	ldr	r3, [r3, #4]
 800a9fe:	695b      	ldr	r3, [r3, #20]
 800aa00:	681a      	ldr	r2, [r3, #0]
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 800aa02:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800aa06:	9901      	ldr	r1, [sp, #4]
 800aa08:	3302      	adds	r3, #2
 800aa0a:	009b      	lsls	r3, r3, #2
 800aa0c:	440b      	add	r3, r1
 800aa0e:	685b      	ldr	r3, [r3, #4]
 800aa10:	8a1b      	ldrh	r3, [r3, #16]
 800aa12:	3b01      	subs	r3, #1
           ((usbp->epc[ep]->in_state->txsize &
 800aa14:	4013      	ands	r3, r2
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800aa16:	2b00      	cmp	r3, #0
 800aa18:	d108      	bne.n	800aa2c <sduDataTransmitted+0xcc>
    /* Transmit zero sized packet in case the last one has maximum allowed
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 800aa1a:	9b01      	ldr	r3, [sp, #4]
 800aa1c:	f103 025c 	add.w	r2, r3, #92	; 0x5c
 800aa20:	f89d 1003 	ldrb.w	r1, [sp, #3]
 800aa24:	2300      	movs	r3, #0
 800aa26:	9801      	ldr	r0, [sp, #4]
 800aa28:	f000 fdca 	bl	800b5c0 <usbStartTransmitI>
  }
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
 800aa2c:	f7ff fc70 	bl	800a310 <osalSysUnlockFromISR.lto_priv.549>
 800aa30:	e000      	b.n	800aa34 <sduDataTransmitted+0xd4>
    return;
 800aa32:	bf00      	nop
}
 800aa34:	b007      	add	sp, #28
 800aa36:	f85d fb04 	ldr.w	pc, [sp], #4
 800aa3a:	bf00      	nop
 800aa3c:	0000      	movs	r0, r0
	...

0800aa40 <sduDataReceived>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 800aa40:	b500      	push	{lr}
 800aa42:	b085      	sub	sp, #20
 800aa44:	9001      	str	r0, [sp, #4]
 800aa46:	460b      	mov	r3, r1
 800aa48:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t size;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 800aa4c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800aa50:	1e5a      	subs	r2, r3, #1
 800aa52:	9b01      	ldr	r3, [sp, #4]
 800aa54:	320e      	adds	r2, #14
 800aa56:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800aa5a:	9303      	str	r3, [sp, #12]

  if (sdup == NULL) {
 800aa5c:	9b03      	ldr	r3, [sp, #12]
 800aa5e:	2b00      	cmp	r3, #0
 800aa60:	d024      	beq.n	800aaac <sduDataReceived+0x6c>
    return;
  }

  osalSysLockFromISR();
 800aa62:	f7ff fc4d 	bl	800a300 <osalSysLockFromISR.lto_priv.555>

  /* Checking for zero-size transactions.*/
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 800aa66:	9b03      	ldr	r3, [sp, #12]
 800aa68:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800aa6c:	681a      	ldr	r2, [r3, #0]
 800aa6e:	9b03      	ldr	r3, [sp, #12]
 800aa70:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800aa74:	795b      	ldrb	r3, [r3, #5]
 800aa76:	3302      	adds	r3, #2
 800aa78:	009b      	lsls	r3, r3, #2
 800aa7a:	4413      	add	r3, r2
 800aa7c:	685b      	ldr	r3, [r3, #4]
 800aa7e:	699b      	ldr	r3, [r3, #24]
 800aa80:	685b      	ldr	r3, [r3, #4]
 800aa82:	9302      	str	r3, [sp, #8]
                                       sdup->config->bulk_out);
  if (size > (size_t)0) {
 800aa84:	9b02      	ldr	r3, [sp, #8]
 800aa86:	2b00      	cmp	r3, #0
 800aa88:	d00b      	beq.n	800aaa2 <sduDataReceived+0x62>
    /* Signaling that data is available in the input queue.*/
    chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
 800aa8a:	9b03      	ldr	r3, [sp, #12]
 800aa8c:	3304      	adds	r3, #4
 800aa8e:	2104      	movs	r1, #4
 800aa90:	4618      	mov	r0, r3
 800aa92:	f7ff fc65 	bl	800a360 <osalEventBroadcastFlagsI.lto_priv.547>

    /* Posting the filled buffer in the queue.*/
    ibqPostFullBufferI(&sdup->ibqueue, size);
 800aa96:	9b03      	ldr	r3, [sp, #12]
 800aa98:	330c      	adds	r3, #12
 800aa9a:	9902      	ldr	r1, [sp, #8]
 800aa9c:	4618      	mov	r0, r3
 800aa9e:	f7fe f9cf 	bl	8008e40 <ibqPostFullBufferI>
  }

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  (void) sdu_start_receive(sdup);
 800aaa2:	9803      	ldr	r0, [sp, #12]
 800aaa4:	f7ff fc6c 	bl	800a380 <sdu_start_receive>

  osalSysUnlockFromISR();
 800aaa8:	f7ff fc32 	bl	800a310 <osalSysUnlockFromISR.lto_priv.549>
}
 800aaac:	b005      	add	sp, #20
 800aaae:	f85d fb04 	ldr.w	pc, [sp], #4
 800aab2:	bf00      	nop
	...

0800aac0 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 800aac0:	b082      	sub	sp, #8
 800aac2:	9001      	str	r0, [sp, #4]
 800aac4:	460b      	mov	r3, r1
 800aac6:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)usbp;
  (void)ep;
}
 800aaca:	b002      	add	sp, #8
 800aacc:	4770      	bx	lr
 800aace:	bf00      	nop

0800aad0 <port_lock.lto_priv.386>:
static inline void port_lock(void) {
 800aad0:	b082      	sub	sp, #8
 800aad2:	2320      	movs	r3, #32
 800aad4:	9301      	str	r3, [sp, #4]
 800aad6:	9b01      	ldr	r3, [sp, #4]
 800aad8:	f383 8811 	msr	BASEPRI, r3
}
 800aadc:	b002      	add	sp, #8
 800aade:	4770      	bx	lr

0800aae0 <port_unlock.lto_priv.355>:
static inline void port_unlock(void) {
 800aae0:	b082      	sub	sp, #8
 800aae2:	2300      	movs	r3, #0
 800aae4:	9301      	str	r3, [sp, #4]
 800aae6:	9b01      	ldr	r3, [sp, #4]
 800aae8:	f383 8811 	msr	BASEPRI, r3
}
 800aaec:	b002      	add	sp, #8
 800aaee:	4770      	bx	lr

0800aaf0 <chSysLock.lto_priv.318>:
static inline void chSysLock(void) {
 800aaf0:	b508      	push	{r3, lr}
  port_lock();
 800aaf2:	f7ff ffed 	bl	800aad0 <port_lock.lto_priv.386>
  _dbg_check_lock();
 800aaf6:	f004 fbe3 	bl	800f2c0 <_dbg_check_lock>
}
 800aafa:	bd08      	pop	{r3, pc}
 800aafc:	0000      	movs	r0, r0
	...

0800ab00 <chSysUnlock.lto_priv.294>:
static inline void chSysUnlock(void) {
 800ab00:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 800ab02:	f004 fbf5 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ab06:	4b09      	ldr	r3, [pc, #36]	; (800ab2c <chSysUnlock.lto_priv.294+0x2c>)
 800ab08:	681b      	ldr	r3, [r3, #0]
 800ab0a:	4a08      	ldr	r2, [pc, #32]	; (800ab2c <chSysUnlock.lto_priv.294+0x2c>)
 800ab0c:	4293      	cmp	r3, r2
 800ab0e:	d00a      	beq.n	800ab26 <chSysUnlock.lto_priv.294+0x26>
 800ab10:	4b06      	ldr	r3, [pc, #24]	; (800ab2c <chSysUnlock.lto_priv.294+0x2c>)
 800ab12:	699b      	ldr	r3, [r3, #24]
 800ab14:	689a      	ldr	r2, [r3, #8]
 800ab16:	4b05      	ldr	r3, [pc, #20]	; (800ab2c <chSysUnlock.lto_priv.294+0x2c>)
 800ab18:	681b      	ldr	r3, [r3, #0]
 800ab1a:	689b      	ldr	r3, [r3, #8]
 800ab1c:	429a      	cmp	r2, r3
 800ab1e:	d202      	bcs.n	800ab26 <chSysUnlock.lto_priv.294+0x26>
 800ab20:	4803      	ldr	r0, [pc, #12]	; (800ab30 <chSysUnlock.lto_priv.294+0x30>)
 800ab22:	f004 fa5d 	bl	800efe0 <chSysHalt>
  port_unlock();
 800ab26:	f7ff ffdb 	bl	800aae0 <port_unlock.lto_priv.355>
}
 800ab2a:	bd08      	pop	{r3, pc}
 800ab2c:	20001090 	.word	0x20001090
 800ab30:	08015d84 	.word	0x08015d84
	...

0800ab40 <osalSysLock.lto_priv.279>:
static inline void osalSysLock(void) {
 800ab40:	b508      	push	{r3, lr}
  chSysLock();
 800ab42:	f7ff ffd5 	bl	800aaf0 <chSysLock.lto_priv.318>
}
 800ab46:	bd08      	pop	{r3, pc}
	...

0800ab50 <osalSysUnlock.lto_priv.270>:
static inline void osalSysUnlock(void) {
 800ab50:	b508      	push	{r3, lr}
  chSysUnlock();
 800ab52:	f7ff ffd5 	bl	800ab00 <chSysUnlock.lto_priv.294>
}
 800ab56:	bd08      	pop	{r3, pc}
	...

0800ab60 <osalThreadSuspendS>:
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 800ab60:	b500      	push	{lr}
 800ab62:	b083      	sub	sp, #12
 800ab64:	9001      	str	r0, [sp, #4]
  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 800ab66:	f04f 31ff 	mov.w	r1, #4294967295
 800ab6a:	9801      	ldr	r0, [sp, #4]
 800ab6c:	f005 fe80 	bl	8010870 <chThdSuspendTimeoutS>
 800ab70:	4603      	mov	r3, r0
}
 800ab72:	4618      	mov	r0, r3
 800ab74:	b003      	add	sp, #12
 800ab76:	f85d fb04 	ldr.w	pc, [sp], #4
 800ab7a:	bf00      	nop
 800ab7c:	0000      	movs	r0, r0
	...

0800ab80 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 800ab80:	b500      	push	{lr}
 800ab82:	b083      	sub	sp, #12
 800ab84:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 800ab86:	9801      	ldr	r0, [sp, #4]
 800ab88:	f006 fcd2 	bl	8011530 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 800ab8c:	b003      	add	sp, #12
 800ab8e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ab92:	bf00      	nop
	...

0800aba0 <osalMutexLock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
 800aba0:	b500      	push	{lr}
 800aba2:	b083      	sub	sp, #12
 800aba4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800aba6:	9801      	ldr	r0, [sp, #4]
 800aba8:	f006 fcda 	bl	8011560 <chMtxLock>
#elif CH_CFG_USE_SEMAPHORES
  chSemWait((semaphore_t *)mp);
#else
  *mp = 1;
#endif
}
 800abac:	b003      	add	sp, #12
 800abae:	f85d fb04 	ldr.w	pc, [sp], #4
 800abb2:	bf00      	nop
	...

0800abc0 <osalMutexUnlock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
 800abc0:	b500      	push	{lr}
 800abc2:	b083      	sub	sp, #12
 800abc4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 800abc6:	9801      	ldr	r0, [sp, #4]
 800abc8:	f006 fd9a 	bl	8011700 <chMtxUnlock>
#elif CH_CFG_USE_SEMAPHORES
  chSemSignal((semaphore_t *)mp);
#else
  *mp = 0;
#endif
}
 800abcc:	b003      	add	sp, #12
 800abce:	f85d fb04 	ldr.w	pc, [sp], #4
 800abd2:	bf00      	nop
	...

0800abe0 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
 800abe0:	b508      	push	{r3, lr}

  spi_lld_init();
 800abe2:	f003 f95d 	bl	800dea0 <spi_lld_init>
}
 800abe6:	bd08      	pop	{r3, pc}
	...

0800abf0 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
 800abf0:	b500      	push	{lr}
 800abf2:	b083      	sub	sp, #12
 800abf4:	9001      	str	r0, [sp, #4]

  spip->state = SPI_STOP;
 800abf6:	9b01      	ldr	r3, [sp, #4]
 800abf8:	2201      	movs	r2, #1
 800abfa:	701a      	strb	r2, [r3, #0]
  spip->config = NULL;
 800abfc:	9b01      	ldr	r3, [sp, #4]
 800abfe:	2200      	movs	r2, #0
 800ac00:	605a      	str	r2, [r3, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 800ac02:	9b01      	ldr	r3, [sp, #4]
 800ac04:	2200      	movs	r2, #0
 800ac06:	609a      	str	r2, [r3, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
 800ac08:	9b01      	ldr	r3, [sp, #4]
 800ac0a:	330c      	adds	r3, #12
 800ac0c:	4618      	mov	r0, r3
 800ac0e:	f7ff ffb7 	bl	800ab80 <osalMutexObjectInit>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
 800ac12:	b003      	add	sp, #12
 800ac14:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800ac20 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 800ac20:	b500      	push	{lr}
 800ac22:	b083      	sub	sp, #12
 800ac24:	9001      	str	r0, [sp, #4]
 800ac26:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (config != NULL));
 800ac28:	9b01      	ldr	r3, [sp, #4]
 800ac2a:	2b00      	cmp	r3, #0
 800ac2c:	d002      	beq.n	800ac34 <spiStart+0x14>
 800ac2e:	9b00      	ldr	r3, [sp, #0]
 800ac30:	2b00      	cmp	r3, #0
 800ac32:	d102      	bne.n	800ac3a <spiStart+0x1a>
 800ac34:	480e      	ldr	r0, [pc, #56]	; (800ac70 <spiStart+0x50>)
 800ac36:	f004 f9d3 	bl	800efe0 <chSysHalt>

  osalSysLock();
 800ac3a:	f7ff ff81 	bl	800ab40 <osalSysLock.lto_priv.279>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 800ac3e:	9b01      	ldr	r3, [sp, #4]
 800ac40:	781b      	ldrb	r3, [r3, #0]
 800ac42:	2b01      	cmp	r3, #1
 800ac44:	d006      	beq.n	800ac54 <spiStart+0x34>
 800ac46:	9b01      	ldr	r3, [sp, #4]
 800ac48:	781b      	ldrb	r3, [r3, #0]
 800ac4a:	2b02      	cmp	r3, #2
 800ac4c:	d002      	beq.n	800ac54 <spiStart+0x34>
 800ac4e:	4808      	ldr	r0, [pc, #32]	; (800ac70 <spiStart+0x50>)
 800ac50:	f004 f9c6 	bl	800efe0 <chSysHalt>
                "invalid state");
  spip->config = config;
 800ac54:	9b01      	ldr	r3, [sp, #4]
 800ac56:	9a00      	ldr	r2, [sp, #0]
 800ac58:	605a      	str	r2, [r3, #4]
  spi_lld_start(spip);
 800ac5a:	9801      	ldr	r0, [sp, #4]
 800ac5c:	f003 f940 	bl	800dee0 <spi_lld_start>
  spip->state = SPI_READY;
 800ac60:	9b01      	ldr	r3, [sp, #4]
 800ac62:	2202      	movs	r2, #2
 800ac64:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 800ac66:	f7ff ff73 	bl	800ab50 <osalSysUnlock.lto_priv.270>
}
 800ac6a:	b003      	add	sp, #12
 800ac6c:	f85d fb04 	ldr.w	pc, [sp], #4
 800ac70:	08015d78 	.word	0x08015d78
	...

0800ac80 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 800ac80:	b500      	push	{lr}
 800ac82:	b083      	sub	sp, #12
 800ac84:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);
 800ac86:	9b01      	ldr	r3, [sp, #4]
 800ac88:	2b00      	cmp	r3, #0
 800ac8a:	d102      	bne.n	800ac92 <spiSelect+0x12>
 800ac8c:	480d      	ldr	r0, [pc, #52]	; (800acc4 <spiSelect+0x44>)
 800ac8e:	f004 f9a7 	bl	800efe0 <chSysHalt>

  osalSysLock();
 800ac92:	f7ff ff55 	bl	800ab40 <osalSysLock.lto_priv.279>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800ac96:	9b01      	ldr	r3, [sp, #4]
 800ac98:	781b      	ldrb	r3, [r3, #0]
 800ac9a:	2b02      	cmp	r3, #2
 800ac9c:	d002      	beq.n	800aca4 <spiSelect+0x24>
 800ac9e:	4809      	ldr	r0, [pc, #36]	; (800acc4 <spiSelect+0x44>)
 800aca0:	f004 f99e 	bl	800efe0 <chSysHalt>
  spiSelectI(spip);
 800aca4:	9b01      	ldr	r3, [sp, #4]
 800aca6:	685b      	ldr	r3, [r3, #4]
 800aca8:	68db      	ldr	r3, [r3, #12]
 800acaa:	2201      	movs	r2, #1
 800acac:	409a      	lsls	r2, r3
 800acae:	9b01      	ldr	r3, [sp, #4]
 800acb0:	685b      	ldr	r3, [r3, #4]
 800acb2:	689b      	ldr	r3, [r3, #8]
 800acb4:	b292      	uxth	r2, r2
 800acb6:	835a      	strh	r2, [r3, #26]
  osalSysUnlock();
 800acb8:	f7ff ff4a 	bl	800ab50 <osalSysUnlock.lto_priv.270>
}
 800acbc:	b003      	add	sp, #12
 800acbe:	f85d fb04 	ldr.w	pc, [sp], #4
 800acc2:	bf00      	nop
 800acc4:	08015d90 	.word	0x08015d90
	...

0800acd0 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 800acd0:	b500      	push	{lr}
 800acd2:	b083      	sub	sp, #12
 800acd4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);
 800acd6:	9b01      	ldr	r3, [sp, #4]
 800acd8:	2b00      	cmp	r3, #0
 800acda:	d102      	bne.n	800ace2 <spiUnselect+0x12>
 800acdc:	480d      	ldr	r0, [pc, #52]	; (800ad14 <spiUnselect+0x44>)
 800acde:	f004 f97f 	bl	800efe0 <chSysHalt>

  osalSysLock();
 800ace2:	f7ff ff2d 	bl	800ab40 <osalSysLock.lto_priv.279>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800ace6:	9b01      	ldr	r3, [sp, #4]
 800ace8:	781b      	ldrb	r3, [r3, #0]
 800acea:	2b02      	cmp	r3, #2
 800acec:	d002      	beq.n	800acf4 <spiUnselect+0x24>
 800acee:	4809      	ldr	r0, [pc, #36]	; (800ad14 <spiUnselect+0x44>)
 800acf0:	f004 f976 	bl	800efe0 <chSysHalt>
  spiUnselectI(spip);
 800acf4:	9b01      	ldr	r3, [sp, #4]
 800acf6:	685b      	ldr	r3, [r3, #4]
 800acf8:	68db      	ldr	r3, [r3, #12]
 800acfa:	2201      	movs	r2, #1
 800acfc:	409a      	lsls	r2, r3
 800acfe:	9b01      	ldr	r3, [sp, #4]
 800ad00:	685b      	ldr	r3, [r3, #4]
 800ad02:	689b      	ldr	r3, [r3, #8]
 800ad04:	b292      	uxth	r2, r2
 800ad06:	831a      	strh	r2, [r3, #24]
  osalSysUnlock();
 800ad08:	f7ff ff22 	bl	800ab50 <osalSysUnlock.lto_priv.270>
}
 800ad0c:	b003      	add	sp, #12
 800ad0e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ad12:	bf00      	nop
 800ad14:	08015d9c 	.word	0x08015d9c
	...

0800ad20 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
 800ad20:	b500      	push	{lr}
 800ad22:	b085      	sub	sp, #20
 800ad24:	9003      	str	r0, [sp, #12]
 800ad26:	9102      	str	r1, [sp, #8]
 800ad28:	9201      	str	r2, [sp, #4]
 800ad2a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
 800ad2c:	9b03      	ldr	r3, [sp, #12]
 800ad2e:	2b00      	cmp	r3, #0
 800ad30:	d008      	beq.n	800ad44 <spiExchange+0x24>
 800ad32:	9b02      	ldr	r3, [sp, #8]
 800ad34:	2b00      	cmp	r3, #0
 800ad36:	d005      	beq.n	800ad44 <spiExchange+0x24>
 800ad38:	9b00      	ldr	r3, [sp, #0]
 800ad3a:	2b00      	cmp	r3, #0
 800ad3c:	d002      	beq.n	800ad44 <spiExchange+0x24>
 800ad3e:	9b01      	ldr	r3, [sp, #4]
 800ad40:	2b00      	cmp	r3, #0
 800ad42:	d102      	bne.n	800ad4a <spiExchange+0x2a>
 800ad44:	4815      	ldr	r0, [pc, #84]	; (800ad9c <spiExchange+0x7c>)
 800ad46:	f004 f94b 	bl	800efe0 <chSysHalt>
               (rxbuf != NULL) && (txbuf != NULL));
#if SPI_SUPPORTS_CIRCULAR
  osalDbgCheck((spip->config->circular == false) || ((n & 1U) == 0U));
 800ad4a:	9b03      	ldr	r3, [sp, #12]
 800ad4c:	685b      	ldr	r3, [r3, #4]
 800ad4e:	781b      	ldrb	r3, [r3, #0]
 800ad50:	2b00      	cmp	r3, #0
 800ad52:	d007      	beq.n	800ad64 <spiExchange+0x44>
 800ad54:	9b02      	ldr	r3, [sp, #8]
 800ad56:	f003 0301 	and.w	r3, r3, #1
 800ad5a:	2b00      	cmp	r3, #0
 800ad5c:	d002      	beq.n	800ad64 <spiExchange+0x44>
 800ad5e:	480f      	ldr	r0, [pc, #60]	; (800ad9c <spiExchange+0x7c>)
 800ad60:	f004 f93e 	bl	800efe0 <chSysHalt>
#endif

  osalSysLock();
 800ad64:	f7ff feec 	bl	800ab40 <osalSysLock.lto_priv.279>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800ad68:	9b03      	ldr	r3, [sp, #12]
 800ad6a:	781b      	ldrb	r3, [r3, #0]
 800ad6c:	2b02      	cmp	r3, #2
 800ad6e:	d002      	beq.n	800ad76 <spiExchange+0x56>
 800ad70:	480a      	ldr	r0, [pc, #40]	; (800ad9c <spiExchange+0x7c>)
 800ad72:	f004 f935 	bl	800efe0 <chSysHalt>
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 800ad76:	9b03      	ldr	r3, [sp, #12]
 800ad78:	2203      	movs	r2, #3
 800ad7a:	701a      	strb	r2, [r3, #0]
 800ad7c:	9b00      	ldr	r3, [sp, #0]
 800ad7e:	9a01      	ldr	r2, [sp, #4]
 800ad80:	9902      	ldr	r1, [sp, #8]
 800ad82:	9803      	ldr	r0, [sp, #12]
 800ad84:	f003 f96c 	bl	800e060 <spi_lld_exchange>
  (void) osalThreadSuspendS(&spip->thread);
 800ad88:	9b03      	ldr	r3, [sp, #12]
 800ad8a:	3308      	adds	r3, #8
 800ad8c:	4618      	mov	r0, r3
 800ad8e:	f7ff fee7 	bl	800ab60 <osalThreadSuspendS>
  osalSysUnlock();
 800ad92:	f7ff fedd 	bl	800ab50 <osalSysUnlock.lto_priv.270>
}
 800ad96:	b005      	add	sp, #20
 800ad98:	f85d fb04 	ldr.w	pc, [sp], #4
 800ad9c:	08015da8 	.word	0x08015da8

0800ada0 <spiAcquireBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiAcquireBus(SPIDriver *spip) {
 800ada0:	b500      	push	{lr}
 800ada2:	b083      	sub	sp, #12
 800ada4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);
 800ada6:	9b01      	ldr	r3, [sp, #4]
 800ada8:	2b00      	cmp	r3, #0
 800adaa:	d102      	bne.n	800adb2 <spiAcquireBus+0x12>
 800adac:	4805      	ldr	r0, [pc, #20]	; (800adc4 <spiAcquireBus+0x24>)
 800adae:	f004 f917 	bl	800efe0 <chSysHalt>

  osalMutexLock(&spip->mutex);
 800adb2:	9b01      	ldr	r3, [sp, #4]
 800adb4:	330c      	adds	r3, #12
 800adb6:	4618      	mov	r0, r3
 800adb8:	f7ff fef2 	bl	800aba0 <osalMutexLock>
}
 800adbc:	b003      	add	sp, #12
 800adbe:	f85d fb04 	ldr.w	pc, [sp], #4
 800adc2:	bf00      	nop
 800adc4:	08015db4 	.word	0x08015db4
	...

0800add0 <spiReleaseBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiReleaseBus(SPIDriver *spip) {
 800add0:	b500      	push	{lr}
 800add2:	b083      	sub	sp, #12
 800add4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);
 800add6:	9b01      	ldr	r3, [sp, #4]
 800add8:	2b00      	cmp	r3, #0
 800adda:	d102      	bne.n	800ade2 <spiReleaseBus+0x12>
 800addc:	4805      	ldr	r0, [pc, #20]	; (800adf4 <spiReleaseBus+0x24>)
 800adde:	f004 f8ff 	bl	800efe0 <chSysHalt>

  osalMutexUnlock(&spip->mutex);
 800ade2:	9b01      	ldr	r3, [sp, #4]
 800ade4:	330c      	adds	r3, #12
 800ade6:	4618      	mov	r0, r3
 800ade8:	f7ff feea 	bl	800abc0 <osalMutexUnlock>
}
 800adec:	b003      	add	sp, #12
 800adee:	f85d fb04 	ldr.w	pc, [sp], #4
 800adf2:	bf00      	nop
 800adf4:	08015dc4 	.word	0x08015dc4
	...

0800ae00 <port_lock.lto_priv.387>:
static inline void port_lock(void) {
 800ae00:	b082      	sub	sp, #8
 800ae02:	2320      	movs	r3, #32
 800ae04:	9301      	str	r3, [sp, #4]
 800ae06:	9b01      	ldr	r3, [sp, #4]
 800ae08:	f383 8811 	msr	BASEPRI, r3
}
 800ae0c:	b002      	add	sp, #8
 800ae0e:	4770      	bx	lr

0800ae10 <port_unlock.lto_priv.356>:
static inline void port_unlock(void) {
 800ae10:	b082      	sub	sp, #8
 800ae12:	2300      	movs	r3, #0
 800ae14:	9301      	str	r3, [sp, #4]
 800ae16:	9b01      	ldr	r3, [sp, #4]
 800ae18:	f383 8811 	msr	BASEPRI, r3
}
 800ae1c:	b002      	add	sp, #8
 800ae1e:	4770      	bx	lr

0800ae20 <port_lock_from_isr.lto_priv.435>:
static inline void port_lock_from_isr(void) {
 800ae20:	b508      	push	{r3, lr}
  port_lock();
 800ae22:	f7ff ffed 	bl	800ae00 <port_lock.lto_priv.387>
}
 800ae26:	bd08      	pop	{r3, pc}
	...

0800ae30 <port_unlock_from_isr.lto_priv.424>:
static inline void port_unlock_from_isr(void) {
 800ae30:	b508      	push	{r3, lr}
  port_unlock();
 800ae32:	f7ff ffed 	bl	800ae10 <port_unlock.lto_priv.356>
}
 800ae36:	bd08      	pop	{r3, pc}
	...

0800ae40 <chSysLock.lto_priv.319>:
static inline void chSysLock(void) {
 800ae40:	b508      	push	{r3, lr}
  port_lock();
 800ae42:	f7ff ffdd 	bl	800ae00 <port_lock.lto_priv.387>
  _dbg_check_lock();
 800ae46:	f004 fa3b 	bl	800f2c0 <_dbg_check_lock>
}
 800ae4a:	bd08      	pop	{r3, pc}
 800ae4c:	0000      	movs	r0, r0
	...

0800ae50 <chSysUnlock.lto_priv.295>:
static inline void chSysUnlock(void) {
 800ae50:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 800ae52:	f004 fa4d 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ae56:	4b09      	ldr	r3, [pc, #36]	; (800ae7c <chSysUnlock.lto_priv.295+0x2c>)
 800ae58:	681b      	ldr	r3, [r3, #0]
 800ae5a:	4a08      	ldr	r2, [pc, #32]	; (800ae7c <chSysUnlock.lto_priv.295+0x2c>)
 800ae5c:	4293      	cmp	r3, r2
 800ae5e:	d00a      	beq.n	800ae76 <chSysUnlock.lto_priv.295+0x26>
 800ae60:	4b06      	ldr	r3, [pc, #24]	; (800ae7c <chSysUnlock.lto_priv.295+0x2c>)
 800ae62:	699b      	ldr	r3, [r3, #24]
 800ae64:	689a      	ldr	r2, [r3, #8]
 800ae66:	4b05      	ldr	r3, [pc, #20]	; (800ae7c <chSysUnlock.lto_priv.295+0x2c>)
 800ae68:	681b      	ldr	r3, [r3, #0]
 800ae6a:	689b      	ldr	r3, [r3, #8]
 800ae6c:	429a      	cmp	r2, r3
 800ae6e:	d202      	bcs.n	800ae76 <chSysUnlock.lto_priv.295+0x26>
 800ae70:	4803      	ldr	r0, [pc, #12]	; (800ae80 <chSysUnlock.lto_priv.295+0x30>)
 800ae72:	f004 f8b5 	bl	800efe0 <chSysHalt>
  port_unlock();
 800ae76:	f7ff ffcb 	bl	800ae10 <port_unlock.lto_priv.356>
}
 800ae7a:	bd08      	pop	{r3, pc}
 800ae7c:	20001090 	.word	0x20001090
 800ae80:	08015dec 	.word	0x08015dec
	...

0800ae90 <chSysLockFromISR.lto_priv.528>:
static inline void chSysLockFromISR(void) {
 800ae90:	b508      	push	{r3, lr}
  port_lock_from_isr();
 800ae92:	f7ff ffc5 	bl	800ae20 <port_lock_from_isr.lto_priv.435>
  _dbg_check_lock_from_isr();
 800ae96:	f004 fa43 	bl	800f320 <_dbg_check_lock_from_isr>
}
 800ae9a:	bd08      	pop	{r3, pc}
 800ae9c:	0000      	movs	r0, r0
	...

0800aea0 <chSysUnlockFromISR.lto_priv.520>:
static inline void chSysUnlockFromISR(void) {
 800aea0:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 800aea2:	f004 fa55 	bl	800f350 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 800aea6:	f7ff ffc3 	bl	800ae30 <port_unlock_from_isr.lto_priv.424>
}
 800aeaa:	bd08      	pop	{r3, pc}
 800aeac:	0000      	movs	r0, r0
	...

0800aeb0 <osalSysLock.lto_priv.280>:
static inline void osalSysLock(void) {
 800aeb0:	b508      	push	{r3, lr}
  chSysLock();
 800aeb2:	f7ff ffc5 	bl	800ae40 <chSysLock.lto_priv.319>
}
 800aeb6:	bd08      	pop	{r3, pc}
	...

0800aec0 <osalSysUnlock.lto_priv.271>:
static inline void osalSysUnlock(void) {
 800aec0:	b508      	push	{r3, lr}
  chSysUnlock();
 800aec2:	f7ff ffc5 	bl	800ae50 <chSysUnlock.lto_priv.295>
}
 800aec6:	bd08      	pop	{r3, pc}
	...

0800aed0 <osalSysLockFromISR.lto_priv.556>:
static inline void osalSysLockFromISR(void) {
 800aed0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 800aed2:	f7ff ffdd 	bl	800ae90 <chSysLockFromISR.lto_priv.528>
}
 800aed6:	bd08      	pop	{r3, pc}
	...

0800aee0 <osalSysUnlockFromISR.lto_priv.550>:
static inline void osalSysUnlockFromISR(void) {
 800aee0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 800aee2:	f7ff ffdd 	bl	800aea0 <chSysUnlockFromISR.lto_priv.520>
}
 800aee6:	bd08      	pop	{r3, pc}
	...

0800aef0 <get_hword>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 800aef0:	b084      	sub	sp, #16
 800aef2:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 800aef4:	9b01      	ldr	r3, [sp, #4]
 800aef6:	1c5a      	adds	r2, r3, #1
 800aef8:	9201      	str	r2, [sp, #4]
 800aefa:	781b      	ldrb	r3, [r3, #0]
 800aefc:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 800af00:	9b01      	ldr	r3, [sp, #4]
 800af02:	781b      	ldrb	r3, [r3, #0]
 800af04:	021b      	lsls	r3, r3, #8
 800af06:	b21a      	sxth	r2, r3
 800af08:	f9bd 300e 	ldrsh.w	r3, [sp, #14]
 800af0c:	4313      	orrs	r3, r2
 800af0e:	b21b      	sxth	r3, r3
 800af10:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 800af14:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 800af18:	4618      	mov	r0, r3
 800af1a:	b004      	add	sp, #16
 800af1c:	4770      	bx	lr
 800af1e:	bf00      	nop

0800af20 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 800af20:	b500      	push	{lr}
 800af22:	b083      	sub	sp, #12
 800af24:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 800af26:	9b01      	ldr	r3, [sp, #4]
 800af28:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 800af2c:	9b01      	ldr	r3, [sp, #4]
 800af2e:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usb_lld_set_address(usbp);
 800af32:	9801      	ldr	r0, [sp, #4]
 800af34:	f002 fb24 	bl	800d580 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 800af38:	9b01      	ldr	r3, [sp, #4]
 800af3a:	685b      	ldr	r3, [r3, #4]
 800af3c:	681b      	ldr	r3, [r3, #0]
 800af3e:	2b00      	cmp	r3, #0
 800af40:	d005      	beq.n	800af4e <set_address+0x2e>
 800af42:	9b01      	ldr	r3, [sp, #4]
 800af44:	685b      	ldr	r3, [r3, #4]
 800af46:	681b      	ldr	r3, [r3, #0]
 800af48:	2101      	movs	r1, #1
 800af4a:	9801      	ldr	r0, [sp, #4]
 800af4c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800af4e:	9b01      	ldr	r3, [sp, #4]
 800af50:	2203      	movs	r2, #3
 800af52:	701a      	strb	r2, [r3, #0]
}
 800af54:	b003      	add	sp, #12
 800af56:	f85d fb04 	ldr.w	pc, [sp], #4
 800af5a:	bf00      	nop
 800af5c:	0000      	movs	r0, r0
	...

0800af60 <default_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 800af60:	b570      	push	{r4, r5, r6, lr}
 800af62:	b084      	sub	sp, #16
 800af64:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800af66:	9b01      	ldr	r3, [sp, #4]
 800af68:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800af6c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 800af70:	9b01      	ldr	r3, [sp, #4]
 800af72:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 800af76:	021b      	lsls	r3, r3, #8
                                        USB_RTYPE_TYPE_MASK)) |
 800af78:	4313      	orrs	r3, r2
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800af7a:	f240 3202 	movw	r2, #770	; 0x302
 800af7e:	4293      	cmp	r3, r2
 800af80:	f000 8197 	beq.w	800b2b2 <default_handler+0x352>
 800af84:	f240 3202 	movw	r2, #770	; 0x302
 800af88:	4293      	cmp	r3, r2
 800af8a:	d815      	bhi.n	800afb8 <default_handler+0x58>
 800af8c:	2b02      	cmp	r3, #2
 800af8e:	f000 8106 	beq.w	800b19e <default_handler+0x23e>
 800af92:	2b02      	cmp	r3, #2
 800af94:	d805      	bhi.n	800afa2 <default_handler+0x42>
 800af96:	2b00      	cmp	r3, #0
 800af98:	d027      	beq.n	800afea <default_handler+0x8a>
 800af9a:	2b01      	cmp	r3, #1
 800af9c:	f000 80f4 	beq.w	800b188 <default_handler+0x228>
 800afa0:	e1bb      	b.n	800b31a <default_handler+0x3ba>
 800afa2:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 800afa6:	f000 8150 	beq.w	800b24a <default_handler+0x2ea>
 800afaa:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800afae:	d044      	beq.n	800b03a <default_handler+0xda>
 800afb0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800afb4:	d026      	beq.n	800b004 <default_handler+0xa4>
 800afb6:	e1b0      	b.n	800b31a <default_handler+0x3ba>
 800afb8:	f240 6201 	movw	r2, #1537	; 0x601
 800afbc:	4293      	cmp	r3, r2
 800afbe:	d806      	bhi.n	800afce <default_handler+0x6e>
 800afc0:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 800afc4:	d26c      	bcs.n	800b0a0 <default_handler+0x140>
 800afc6:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800afca:	d051      	beq.n	800b070 <default_handler+0x110>
 800afcc:	e1a5      	b.n	800b31a <default_handler+0x3ba>
 800afce:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 800afd2:	f000 8098 	beq.w	800b106 <default_handler+0x1a6>
 800afd6:	f640 4202 	movw	r2, #3074	; 0xc02
 800afda:	4293      	cmp	r3, r2
 800afdc:	f000 80d4 	beq.w	800b188 <default_handler+0x228>
 800afe0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800afe4:	f000 8082 	beq.w	800b0ec <default_handler+0x18c>
 800afe8:	e197      	b.n	800b31a <default_handler+0x3ba>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 800afea:	9b01      	ldr	r3, [sp, #4]
 800afec:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800aff0:	9b01      	ldr	r3, [sp, #4]
 800aff2:	651a      	str	r2, [r3, #80]	; 0x50
 800aff4:	9b01      	ldr	r3, [sp, #4]
 800aff6:	2202      	movs	r2, #2
 800aff8:	655a      	str	r2, [r3, #84]	; 0x54
 800affa:	9b01      	ldr	r3, [sp, #4]
 800affc:	2200      	movs	r2, #0
 800affe:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800b000:	2301      	movs	r3, #1
 800b002:	e18b      	b.n	800b31c <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800b004:	9b01      	ldr	r3, [sp, #4]
 800b006:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800b00a:	2b01      	cmp	r3, #1
 800b00c:	d113      	bne.n	800b036 <default_handler+0xd6>
      usbp->status &= ~2U;
 800b00e:	9b01      	ldr	r3, [sp, #4]
 800b010:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 800b014:	f023 0302 	bic.w	r3, r3, #2
 800b018:	b29a      	uxth	r2, r3
 800b01a:	9b01      	ldr	r3, [sp, #4]
 800b01c:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800b020:	9b01      	ldr	r3, [sp, #4]
 800b022:	2200      	movs	r2, #0
 800b024:	651a      	str	r2, [r3, #80]	; 0x50
 800b026:	9b01      	ldr	r3, [sp, #4]
 800b028:	2200      	movs	r2, #0
 800b02a:	655a      	str	r2, [r3, #84]	; 0x54
 800b02c:	9b01      	ldr	r3, [sp, #4]
 800b02e:	2200      	movs	r2, #0
 800b030:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800b032:	2301      	movs	r3, #1
 800b034:	e172      	b.n	800b31c <default_handler+0x3bc>
    }
    return false;
 800b036:	2300      	movs	r3, #0
 800b038:	e170      	b.n	800b31c <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800b03a:	9b01      	ldr	r3, [sp, #4]
 800b03c:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800b040:	2b01      	cmp	r3, #1
 800b042:	d113      	bne.n	800b06c <default_handler+0x10c>
      usbp->status |= 2U;
 800b044:	9b01      	ldr	r3, [sp, #4]
 800b046:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 800b04a:	f043 0302 	orr.w	r3, r3, #2
 800b04e:	b29a      	uxth	r2, r3
 800b050:	9b01      	ldr	r3, [sp, #4]
 800b052:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800b056:	9b01      	ldr	r3, [sp, #4]
 800b058:	2200      	movs	r2, #0
 800b05a:	651a      	str	r2, [r3, #80]	; 0x50
 800b05c:	9b01      	ldr	r3, [sp, #4]
 800b05e:	2200      	movs	r2, #0
 800b060:	655a      	str	r2, [r3, #84]	; 0x54
 800b062:	9b01      	ldr	r3, [sp, #4]
 800b064:	2200      	movs	r2, #0
 800b066:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800b068:	2301      	movs	r3, #1
 800b06a:	e157      	b.n	800b31c <default_handler+0x3bc>
    }
    return false;
 800b06c:	2300      	movs	r3, #0
 800b06e:	e155      	b.n	800b31c <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800b070:	9b01      	ldr	r3, [sp, #4]
 800b072:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800b076:	2b00      	cmp	r3, #0
 800b078:	d107      	bne.n	800b08a <default_handler+0x12a>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 800b07a:	9b01      	ldr	r3, [sp, #4]
 800b07c:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800b080:	2b05      	cmp	r3, #5
 800b082:	d102      	bne.n	800b08a <default_handler+0x12a>
      set_address(usbp);
 800b084:	9801      	ldr	r0, [sp, #4]
 800b086:	f7ff ff4b 	bl	800af20 <set_address>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800b08a:	9b01      	ldr	r3, [sp, #4]
 800b08c:	2200      	movs	r2, #0
 800b08e:	651a      	str	r2, [r3, #80]	; 0x50
 800b090:	9b01      	ldr	r3, [sp, #4]
 800b092:	2200      	movs	r2, #0
 800b094:	655a      	str	r2, [r3, #84]	; 0x54
 800b096:	9b01      	ldr	r3, [sp, #4]
 800b098:	2200      	movs	r2, #0
 800b09a:	659a      	str	r2, [r3, #88]	; 0x58
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 800b09c:	2301      	movs	r3, #1
 800b09e:	e13d      	b.n	800b31c <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800b0a0:	9b01      	ldr	r3, [sp, #4]
 800b0a2:	685b      	ldr	r3, [r3, #4]
 800b0a4:	685c      	ldr	r4, [r3, #4]
 800b0a6:	9b01      	ldr	r3, [sp, #4]
 800b0a8:	f893 505f 	ldrb.w	r5, [r3, #95]	; 0x5f
 800b0ac:	9b01      	ldr	r3, [sp, #4]
 800b0ae:	f893 605e 	ldrb.w	r6, [r3, #94]	; 0x5e
 800b0b2:	9b01      	ldr	r3, [sp, #4]
 800b0b4:	3360      	adds	r3, #96	; 0x60
 800b0b6:	4618      	mov	r0, r3
 800b0b8:	f7ff ff1a 	bl	800aef0 <get_hword>
 800b0bc:	4603      	mov	r3, r0
 800b0be:	4632      	mov	r2, r6
 800b0c0:	4629      	mov	r1, r5
 800b0c2:	9801      	ldr	r0, [sp, #4]
 800b0c4:	47a0      	blx	r4
 800b0c6:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 800b0c8:	9b03      	ldr	r3, [sp, #12]
 800b0ca:	2b00      	cmp	r3, #0
 800b0cc:	d101      	bne.n	800b0d2 <default_handler+0x172>
      return false;
 800b0ce:	2300      	movs	r3, #0
 800b0d0:	e124      	b.n	800b31c <default_handler+0x3bc>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800b0d2:	9b03      	ldr	r3, [sp, #12]
 800b0d4:	685a      	ldr	r2, [r3, #4]
 800b0d6:	9b01      	ldr	r3, [sp, #4]
 800b0d8:	651a      	str	r2, [r3, #80]	; 0x50
 800b0da:	9b03      	ldr	r3, [sp, #12]
 800b0dc:	681a      	ldr	r2, [r3, #0]
 800b0de:	9b01      	ldr	r3, [sp, #4]
 800b0e0:	655a      	str	r2, [r3, #84]	; 0x54
 800b0e2:	9b01      	ldr	r3, [sp, #4]
 800b0e4:	2200      	movs	r2, #0
 800b0e6:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 800b0e8:	2301      	movs	r3, #1
 800b0ea:	e117      	b.n	800b31c <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 800b0ec:	9b01      	ldr	r3, [sp, #4]
 800b0ee:	f103 0267 	add.w	r2, r3, #103	; 0x67
 800b0f2:	9b01      	ldr	r3, [sp, #4]
 800b0f4:	651a      	str	r2, [r3, #80]	; 0x50
 800b0f6:	9b01      	ldr	r3, [sp, #4]
 800b0f8:	2201      	movs	r2, #1
 800b0fa:	655a      	str	r2, [r3, #84]	; 0x54
 800b0fc:	9b01      	ldr	r3, [sp, #4]
 800b0fe:	2200      	movs	r2, #0
 800b100:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800b102:	2301      	movs	r3, #1
 800b104:	e10a      	b.n	800b31c <default_handler+0x3bc>
    if (usbp->configuration != usbp->setup[2])
#endif
    {
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 800b106:	9b01      	ldr	r3, [sp, #4]
 800b108:	781b      	ldrb	r3, [r3, #0]
 800b10a:	2b04      	cmp	r3, #4
 800b10c:	d118      	bne.n	800b140 <default_handler+0x1e0>
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
 800b10e:	f7ff fedf 	bl	800aed0 <osalSysLockFromISR.lto_priv.556>
        usbDisableEndpointsI(usbp);
 800b112:	9801      	ldr	r0, [sp, #4]
 800b114:	f000 f9cc 	bl	800b4b0 <usbDisableEndpointsI>
        osalSysUnlockFromISR ();
 800b118:	f7ff fee2 	bl	800aee0 <osalSysUnlockFromISR.lto_priv.550>
        usbp->configuration = 0U;
 800b11c:	9b01      	ldr	r3, [sp, #4]
 800b11e:	2200      	movs	r2, #0
 800b120:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_SELECTED;
 800b124:	9b01      	ldr	r3, [sp, #4]
 800b126:	2203      	movs	r2, #3
 800b128:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 800b12a:	9b01      	ldr	r3, [sp, #4]
 800b12c:	685b      	ldr	r3, [r3, #4]
 800b12e:	681b      	ldr	r3, [r3, #0]
 800b130:	2b00      	cmp	r3, #0
 800b132:	d005      	beq.n	800b140 <default_handler+0x1e0>
 800b134:	9b01      	ldr	r3, [sp, #4]
 800b136:	685b      	ldr	r3, [r3, #4]
 800b138:	681b      	ldr	r3, [r3, #0]
 800b13a:	2103      	movs	r1, #3
 800b13c:	9801      	ldr	r0, [sp, #4]
 800b13e:	4798      	blx	r3
      }
      if (usbp->setup[2] != 0U) {
 800b140:	9b01      	ldr	r3, [sp, #4]
 800b142:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800b146:	2b00      	cmp	r3, #0
 800b148:	d013      	beq.n	800b172 <default_handler+0x212>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 800b14a:	9b01      	ldr	r3, [sp, #4]
 800b14c:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 800b150:	9b01      	ldr	r3, [sp, #4]
 800b152:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_ACTIVE;
 800b156:	9b01      	ldr	r3, [sp, #4]
 800b158:	2204      	movs	r2, #4
 800b15a:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800b15c:	9b01      	ldr	r3, [sp, #4]
 800b15e:	685b      	ldr	r3, [r3, #4]
 800b160:	681b      	ldr	r3, [r3, #0]
 800b162:	2b00      	cmp	r3, #0
 800b164:	d005      	beq.n	800b172 <default_handler+0x212>
 800b166:	9b01      	ldr	r3, [sp, #4]
 800b168:	685b      	ldr	r3, [r3, #4]
 800b16a:	681b      	ldr	r3, [r3, #0]
 800b16c:	2102      	movs	r1, #2
 800b16e:	9801      	ldr	r0, [sp, #4]
 800b170:	4798      	blx	r3
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800b172:	9b01      	ldr	r3, [sp, #4]
 800b174:	2200      	movs	r2, #0
 800b176:	651a      	str	r2, [r3, #80]	; 0x50
 800b178:	9b01      	ldr	r3, [sp, #4]
 800b17a:	2200      	movs	r2, #0
 800b17c:	655a      	str	r2, [r3, #84]	; 0x54
 800b17e:	9b01      	ldr	r3, [sp, #4]
 800b180:	2200      	movs	r2, #0
 800b182:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800b184:	2301      	movs	r3, #1
 800b186:	e0c9      	b.n	800b31c <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 800b188:	9b01      	ldr	r3, [sp, #4]
 800b18a:	4a66      	ldr	r2, [pc, #408]	; (800b324 <default_handler+0x3c4>)
 800b18c:	651a      	str	r2, [r3, #80]	; 0x50
 800b18e:	9b01      	ldr	r3, [sp, #4]
 800b190:	2202      	movs	r2, #2
 800b192:	655a      	str	r2, [r3, #84]	; 0x54
 800b194:	9b01      	ldr	r3, [sp, #4]
 800b196:	2200      	movs	r2, #0
 800b198:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 800b19a:	2301      	movs	r3, #1
 800b19c:	e0be      	b.n	800b31c <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800b19e:	9b01      	ldr	r3, [sp, #4]
 800b1a0:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b1a4:	b25b      	sxtb	r3, r3
 800b1a6:	2b00      	cmp	r3, #0
 800b1a8:	da27      	bge.n	800b1fa <default_handler+0x29a>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800b1aa:	9b01      	ldr	r3, [sp, #4]
 800b1ac:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b1b0:	f003 030f 	and.w	r3, r3, #15
 800b1b4:	b2db      	uxtb	r3, r3
 800b1b6:	4619      	mov	r1, r3
 800b1b8:	9801      	ldr	r0, [sp, #4]
 800b1ba:	f002 fb51 	bl	800d860 <usb_lld_get_status_in>
 800b1be:	4603      	mov	r3, r0
 800b1c0:	2b01      	cmp	r3, #1
 800b1c2:	d002      	beq.n	800b1ca <default_handler+0x26a>
 800b1c4:	2b02      	cmp	r3, #2
 800b1c6:	d00b      	beq.n	800b1e0 <default_handler+0x280>
 800b1c8:	e015      	b.n	800b1f6 <default_handler+0x296>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800b1ca:	9b01      	ldr	r3, [sp, #4]
 800b1cc:	4a56      	ldr	r2, [pc, #344]	; (800b328 <default_handler+0x3c8>)
 800b1ce:	651a      	str	r2, [r3, #80]	; 0x50
 800b1d0:	9b01      	ldr	r3, [sp, #4]
 800b1d2:	2202      	movs	r2, #2
 800b1d4:	655a      	str	r2, [r3, #84]	; 0x54
 800b1d6:	9b01      	ldr	r3, [sp, #4]
 800b1d8:	2200      	movs	r2, #0
 800b1da:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800b1dc:	2301      	movs	r3, #1
 800b1de:	e09d      	b.n	800b31c <default_handler+0x3bc>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 800b1e0:	9b01      	ldr	r3, [sp, #4]
 800b1e2:	4a52      	ldr	r2, [pc, #328]	; (800b32c <default_handler+0x3cc>)
 800b1e4:	651a      	str	r2, [r3, #80]	; 0x50
 800b1e6:	9b01      	ldr	r3, [sp, #4]
 800b1e8:	2202      	movs	r2, #2
 800b1ea:	655a      	str	r2, [r3, #84]	; 0x54
 800b1ec:	9b01      	ldr	r3, [sp, #4]
 800b1ee:	2200      	movs	r2, #0
 800b1f0:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800b1f2:	2301      	movs	r3, #1
 800b1f4:	e092      	b.n	800b31c <default_handler+0x3bc>
      case EP_STATUS_DISABLED:
      default:
        return false;
 800b1f6:	2300      	movs	r3, #0
 800b1f8:	e090      	b.n	800b31c <default_handler+0x3bc>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 800b1fa:	9b01      	ldr	r3, [sp, #4]
 800b1fc:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b200:	f003 030f 	and.w	r3, r3, #15
 800b204:	b2db      	uxtb	r3, r3
 800b206:	4619      	mov	r1, r3
 800b208:	9801      	ldr	r0, [sp, #4]
 800b20a:	f002 fb09 	bl	800d820 <usb_lld_get_status_out>
 800b20e:	4603      	mov	r3, r0
 800b210:	2b01      	cmp	r3, #1
 800b212:	d002      	beq.n	800b21a <default_handler+0x2ba>
 800b214:	2b02      	cmp	r3, #2
 800b216:	d00b      	beq.n	800b230 <default_handler+0x2d0>
 800b218:	e015      	b.n	800b246 <default_handler+0x2e6>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800b21a:	9b01      	ldr	r3, [sp, #4]
 800b21c:	4a42      	ldr	r2, [pc, #264]	; (800b328 <default_handler+0x3c8>)
 800b21e:	651a      	str	r2, [r3, #80]	; 0x50
 800b220:	9b01      	ldr	r3, [sp, #4]
 800b222:	2202      	movs	r2, #2
 800b224:	655a      	str	r2, [r3, #84]	; 0x54
 800b226:	9b01      	ldr	r3, [sp, #4]
 800b228:	2200      	movs	r2, #0
 800b22a:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800b22c:	2301      	movs	r3, #1
 800b22e:	e075      	b.n	800b31c <default_handler+0x3bc>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 800b230:	9b01      	ldr	r3, [sp, #4]
 800b232:	4a3e      	ldr	r2, [pc, #248]	; (800b32c <default_handler+0x3cc>)
 800b234:	651a      	str	r2, [r3, #80]	; 0x50
 800b236:	9b01      	ldr	r3, [sp, #4]
 800b238:	2202      	movs	r2, #2
 800b23a:	655a      	str	r2, [r3, #84]	; 0x54
 800b23c:	9b01      	ldr	r3, [sp, #4]
 800b23e:	2200      	movs	r2, #0
 800b240:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800b242:	2301      	movs	r3, #1
 800b244:	e06a      	b.n	800b31c <default_handler+0x3bc>
      case EP_STATUS_DISABLED:
      default:
        return false;
 800b246:	2300      	movs	r3, #0
 800b248:	e068      	b.n	800b31c <default_handler+0x3bc>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800b24a:	9b01      	ldr	r3, [sp, #4]
 800b24c:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800b250:	2b00      	cmp	r3, #0
 800b252:	d001      	beq.n	800b258 <default_handler+0x2f8>
      return false;
 800b254:	2300      	movs	r3, #0
 800b256:	e061      	b.n	800b31c <default_handler+0x3bc>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800b258:	9b01      	ldr	r3, [sp, #4]
 800b25a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b25e:	f003 030f 	and.w	r3, r3, #15
 800b262:	2b00      	cmp	r3, #0
 800b264:	d01a      	beq.n	800b29c <default_handler+0x33c>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800b266:	9b01      	ldr	r3, [sp, #4]
 800b268:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b26c:	b25b      	sxtb	r3, r3
 800b26e:	2b00      	cmp	r3, #0
 800b270:	da0a      	bge.n	800b288 <default_handler+0x328>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 800b272:	9b01      	ldr	r3, [sp, #4]
 800b274:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b278:	f003 030f 	and.w	r3, r3, #15
 800b27c:	b2db      	uxtb	r3, r3
 800b27e:	4619      	mov	r1, r3
 800b280:	9801      	ldr	r0, [sp, #4]
 800b282:	f002 fcd5 	bl	800dc30 <usb_lld_clear_in>
 800b286:	e009      	b.n	800b29c <default_handler+0x33c>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 800b288:	9b01      	ldr	r3, [sp, #4]
 800b28a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b28e:	f003 030f 	and.w	r3, r3, #15
 800b292:	b2db      	uxtb	r3, r3
 800b294:	4619      	mov	r1, r3
 800b296:	9801      	ldr	r0, [sp, #4]
 800b298:	f002 fcaa 	bl	800dbf0 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800b29c:	9b01      	ldr	r3, [sp, #4]
 800b29e:	2200      	movs	r2, #0
 800b2a0:	651a      	str	r2, [r3, #80]	; 0x50
 800b2a2:	9b01      	ldr	r3, [sp, #4]
 800b2a4:	2200      	movs	r2, #0
 800b2a6:	655a      	str	r2, [r3, #84]	; 0x54
 800b2a8:	9b01      	ldr	r3, [sp, #4]
 800b2aa:	2200      	movs	r2, #0
 800b2ac:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800b2ae:	2301      	movs	r3, #1
 800b2b0:	e034      	b.n	800b31c <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800b2b2:	9b01      	ldr	r3, [sp, #4]
 800b2b4:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800b2b8:	2b00      	cmp	r3, #0
 800b2ba:	d001      	beq.n	800b2c0 <default_handler+0x360>
      return false;
 800b2bc:	2300      	movs	r3, #0
 800b2be:	e02d      	b.n	800b31c <default_handler+0x3bc>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800b2c0:	9b01      	ldr	r3, [sp, #4]
 800b2c2:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b2c6:	f003 030f 	and.w	r3, r3, #15
 800b2ca:	2b00      	cmp	r3, #0
 800b2cc:	d01a      	beq.n	800b304 <default_handler+0x3a4>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800b2ce:	9b01      	ldr	r3, [sp, #4]
 800b2d0:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b2d4:	b25b      	sxtb	r3, r3
 800b2d6:	2b00      	cmp	r3, #0
 800b2d8:	da0a      	bge.n	800b2f0 <default_handler+0x390>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800b2da:	9b01      	ldr	r3, [sp, #4]
 800b2dc:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b2e0:	f003 030f 	and.w	r3, r3, #15
 800b2e4:	b2db      	uxtb	r3, r3
 800b2e6:	4619      	mov	r1, r3
 800b2e8:	9801      	ldr	r0, [sp, #4]
 800b2ea:	f002 fc61 	bl	800dbb0 <usb_lld_stall_in>
 800b2ee:	e009      	b.n	800b304 <default_handler+0x3a4>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 800b2f0:	9b01      	ldr	r3, [sp, #4]
 800b2f2:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800b2f6:	f003 030f 	and.w	r3, r3, #15
 800b2fa:	b2db      	uxtb	r3, r3
 800b2fc:	4619      	mov	r1, r3
 800b2fe:	9801      	ldr	r0, [sp, #4]
 800b300:	f002 fc36 	bl	800db70 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800b304:	9b01      	ldr	r3, [sp, #4]
 800b306:	2200      	movs	r2, #0
 800b308:	651a      	str	r2, [r3, #80]	; 0x50
 800b30a:	9b01      	ldr	r3, [sp, #4]
 800b30c:	2200      	movs	r2, #0
 800b30e:	655a      	str	r2, [r3, #84]	; 0x54
 800b310:	9b01      	ldr	r3, [sp, #4]
 800b312:	2200      	movs	r2, #0
 800b314:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800b316:	2301      	movs	r3, #1
 800b318:	e000      	b.n	800b31c <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 800b31a:	2300      	movs	r3, #0
  }
}
 800b31c:	4618      	mov	r0, r3
 800b31e:	b004      	add	sp, #16
 800b320:	bd70      	pop	{r4, r5, r6, pc}
 800b322:	bf00      	nop
 800b324:	08015dd4 	.word	0x08015dd4
 800b328:	08015ddc 	.word	0x08015ddc
 800b32c:	08015dd8 	.word	0x08015dd8

0800b330 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 800b330:	b508      	push	{r3, lr}

  usb_lld_init();
 800b332:	f001 ffb5 	bl	800d2a0 <usb_lld_init>
}
 800b336:	bd08      	pop	{r3, pc}
	...

0800b340 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 800b340:	b084      	sub	sp, #16
 800b342:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 800b344:	9b01      	ldr	r3, [sp, #4]
 800b346:	2201      	movs	r2, #1
 800b348:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 800b34a:	9b01      	ldr	r3, [sp, #4]
 800b34c:	2200      	movs	r2, #0
 800b34e:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 800b350:	2300      	movs	r3, #0
 800b352:	9303      	str	r3, [sp, #12]
 800b354:	e00f      	b.n	800b376 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 800b356:	9a01      	ldr	r2, [sp, #4]
 800b358:	9b03      	ldr	r3, [sp, #12]
 800b35a:	3308      	adds	r3, #8
 800b35c:	009b      	lsls	r3, r3, #2
 800b35e:	4413      	add	r3, r2
 800b360:	2200      	movs	r2, #0
 800b362:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 800b364:	9b01      	ldr	r3, [sp, #4]
 800b366:	9a03      	ldr	r2, [sp, #12]
 800b368:	320e      	adds	r2, #14
 800b36a:	2100      	movs	r1, #0
 800b36c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 800b370:	9b03      	ldr	r3, [sp, #12]
 800b372:	3301      	adds	r3, #1
 800b374:	9303      	str	r3, [sp, #12]
 800b376:	9b03      	ldr	r3, [sp, #12]
 800b378:	2b04      	cmp	r3, #4
 800b37a:	d9ec      	bls.n	800b356 <usbObjectInit+0x16>
  }
  usbp->transmitting = 0;
 800b37c:	9b01      	ldr	r3, [sp, #4]
 800b37e:	2200      	movs	r2, #0
 800b380:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 800b382:	9b01      	ldr	r3, [sp, #4]
 800b384:	2200      	movs	r2, #0
 800b386:	815a      	strh	r2, [r3, #10]
}
 800b388:	b004      	add	sp, #16
 800b38a:	4770      	bx	lr
 800b38c:	0000      	movs	r0, r0
	...

0800b390 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 800b390:	b500      	push	{lr}
 800b392:	b085      	sub	sp, #20
 800b394:	9001      	str	r0, [sp, #4]
 800b396:	9100      	str	r1, [sp, #0]
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));
 800b398:	9b01      	ldr	r3, [sp, #4]
 800b39a:	2b00      	cmp	r3, #0
 800b39c:	d002      	beq.n	800b3a4 <usbStart+0x14>
 800b39e:	9b00      	ldr	r3, [sp, #0]
 800b3a0:	2b00      	cmp	r3, #0
 800b3a2:	d102      	bne.n	800b3aa <usbStart+0x1a>
 800b3a4:	4816      	ldr	r0, [pc, #88]	; (800b400 <usbStart+0x70>)
 800b3a6:	f003 fe1b 	bl	800efe0 <chSysHalt>

  osalSysLock();
 800b3aa:	f7ff fd81 	bl	800aeb0 <osalSysLock.lto_priv.280>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 800b3ae:	9b01      	ldr	r3, [sp, #4]
 800b3b0:	781b      	ldrb	r3, [r3, #0]
 800b3b2:	2b01      	cmp	r3, #1
 800b3b4:	d006      	beq.n	800b3c4 <usbStart+0x34>
 800b3b6:	9b01      	ldr	r3, [sp, #4]
 800b3b8:	781b      	ldrb	r3, [r3, #0]
 800b3ba:	2b02      	cmp	r3, #2
 800b3bc:	d002      	beq.n	800b3c4 <usbStart+0x34>
 800b3be:	4810      	ldr	r0, [pc, #64]	; (800b400 <usbStart+0x70>)
 800b3c0:	f003 fe0e 	bl	800efe0 <chSysHalt>
                "invalid state");
  usbp->config = config;
 800b3c4:	9b01      	ldr	r3, [sp, #4]
 800b3c6:	9a00      	ldr	r2, [sp, #0]
 800b3c8:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800b3ca:	2300      	movs	r3, #0
 800b3cc:	9303      	str	r3, [sp, #12]
 800b3ce:	e009      	b.n	800b3e4 <usbStart+0x54>
    usbp->epc[i] = NULL;
 800b3d0:	9a01      	ldr	r2, [sp, #4]
 800b3d2:	9b03      	ldr	r3, [sp, #12]
 800b3d4:	3302      	adds	r3, #2
 800b3d6:	009b      	lsls	r3, r3, #2
 800b3d8:	4413      	add	r3, r2
 800b3da:	2200      	movs	r2, #0
 800b3dc:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800b3de:	9b03      	ldr	r3, [sp, #12]
 800b3e0:	3301      	adds	r3, #1
 800b3e2:	9303      	str	r3, [sp, #12]
 800b3e4:	9b03      	ldr	r3, [sp, #12]
 800b3e6:	2b05      	cmp	r3, #5
 800b3e8:	d9f2      	bls.n	800b3d0 <usbStart+0x40>
  }
  usb_lld_start(usbp);
 800b3ea:	9801      	ldr	r0, [sp, #4]
 800b3ec:	f001 ff78 	bl	800d2e0 <usb_lld_start>
  usbp->state = USB_READY;
 800b3f0:	9b01      	ldr	r3, [sp, #4]
 800b3f2:	2202      	movs	r2, #2
 800b3f4:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 800b3f6:	f7ff fd63 	bl	800aec0 <osalSysUnlock.lto_priv.271>
}
 800b3fa:	b005      	add	sp, #20
 800b3fc:	f85d fb04 	ldr.w	pc, [sp], #4
 800b400:	08015de0 	.word	0x08015de0
	...

0800b410 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 800b410:	b500      	push	{lr}
 800b412:	b085      	sub	sp, #20
 800b414:	9003      	str	r0, [sp, #12]
 800b416:	460b      	mov	r3, r1
 800b418:	9201      	str	r2, [sp, #4]
 800b41a:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheckClassI();
 800b41e:	f003 ffef 	bl	800f400 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 800b422:	9b03      	ldr	r3, [sp, #12]
 800b424:	2b00      	cmp	r3, #0
 800b426:	d002      	beq.n	800b42e <usbInitEndpointI+0x1e>
 800b428:	9b01      	ldr	r3, [sp, #4]
 800b42a:	2b00      	cmp	r3, #0
 800b42c:	d102      	bne.n	800b434 <usbInitEndpointI+0x24>
 800b42e:	481e      	ldr	r0, [pc, #120]	; (800b4a8 <usbInitEndpointI+0x98>)
 800b430:	f003 fdd6 	bl	800efe0 <chSysHalt>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 800b434:	9b03      	ldr	r3, [sp, #12]
 800b436:	781b      	ldrb	r3, [r3, #0]
 800b438:	2b04      	cmp	r3, #4
 800b43a:	d002      	beq.n	800b442 <usbInitEndpointI+0x32>
 800b43c:	481a      	ldr	r0, [pc, #104]	; (800b4a8 <usbInitEndpointI+0x98>)
 800b43e:	f003 fdcf 	bl	800efe0 <chSysHalt>
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 800b442:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b446:	9a03      	ldr	r2, [sp, #12]
 800b448:	3302      	adds	r3, #2
 800b44a:	009b      	lsls	r3, r3, #2
 800b44c:	4413      	add	r3, r2
 800b44e:	685b      	ldr	r3, [r3, #4]
 800b450:	2b00      	cmp	r3, #0
 800b452:	d002      	beq.n	800b45a <usbInitEndpointI+0x4a>
 800b454:	4814      	ldr	r0, [pc, #80]	; (800b4a8 <usbInitEndpointI+0x98>)
 800b456:	f003 fdc3 	bl	800efe0 <chSysHalt>

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 800b45a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b45e:	9a03      	ldr	r2, [sp, #12]
 800b460:	3302      	adds	r3, #2
 800b462:	009b      	lsls	r3, r3, #2
 800b464:	4413      	add	r3, r2
 800b466:	9a01      	ldr	r2, [sp, #4]
 800b468:	605a      	str	r2, [r3, #4]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 800b46a:	9b01      	ldr	r3, [sp, #4]
 800b46c:	695b      	ldr	r3, [r3, #20]
 800b46e:	2b00      	cmp	r3, #0
 800b470:	d006      	beq.n	800b480 <usbInitEndpointI+0x70>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 800b472:	9b01      	ldr	r3, [sp, #4]
 800b474:	695b      	ldr	r3, [r3, #20]
 800b476:	2210      	movs	r2, #16
 800b478:	2100      	movs	r1, #0
 800b47a:	4618      	mov	r0, r3
 800b47c:	f00a f930 	bl	80156e0 <memset>
  }
  if (epcp->out_state != NULL) {
 800b480:	9b01      	ldr	r3, [sp, #4]
 800b482:	699b      	ldr	r3, [r3, #24]
 800b484:	2b00      	cmp	r3, #0
 800b486:	d006      	beq.n	800b496 <usbInitEndpointI+0x86>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 800b488:	9b01      	ldr	r3, [sp, #4]
 800b48a:	699b      	ldr	r3, [r3, #24]
 800b48c:	2210      	movs	r2, #16
 800b48e:	2100      	movs	r1, #0
 800b490:	4618      	mov	r0, r3
 800b492:	f00a f925 	bl	80156e0 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 800b496:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b49a:	4619      	mov	r1, r3
 800b49c:	9803      	ldr	r0, [sp, #12]
 800b49e:	f002 f887 	bl	800d5b0 <usb_lld_init_endpoint>
}
 800b4a2:	b005      	add	sp, #20
 800b4a4:	f85d fb04 	ldr.w	pc, [sp], #4
 800b4a8:	08015df8 	.word	0x08015df8
 800b4ac:	00000000 	.word	0x00000000

0800b4b0 <usbDisableEndpointsI>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
 800b4b0:	b500      	push	{lr}
 800b4b2:	b085      	sub	sp, #20
 800b4b4:	9001      	str	r0, [sp, #4]
  unsigned i;

  osalDbgCheckClassI();
 800b4b6:	f003 ffa3 	bl	800f400 <chDbgCheckClassI>
  osalDbgCheck(usbp != NULL);
 800b4ba:	9b01      	ldr	r3, [sp, #4]
 800b4bc:	2b00      	cmp	r3, #0
 800b4be:	d102      	bne.n	800b4c6 <usbDisableEndpointsI+0x16>
 800b4c0:	4816      	ldr	r0, [pc, #88]	; (800b51c <usbDisableEndpointsI+0x6c>)
 800b4c2:	f003 fd8d 	bl	800efe0 <chSysHalt>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 800b4c6:	9b01      	ldr	r3, [sp, #4]
 800b4c8:	781b      	ldrb	r3, [r3, #0]
 800b4ca:	2b04      	cmp	r3, #4
 800b4cc:	d002      	beq.n	800b4d4 <usbDisableEndpointsI+0x24>
 800b4ce:	4813      	ldr	r0, [pc, #76]	; (800b51c <usbDisableEndpointsI+0x6c>)
 800b4d0:	f003 fd86 	bl	800efe0 <chSysHalt>

  usbp->transmitting &= 1U;
 800b4d4:	9b01      	ldr	r3, [sp, #4]
 800b4d6:	891b      	ldrh	r3, [r3, #8]
 800b4d8:	f003 0301 	and.w	r3, r3, #1
 800b4dc:	b29a      	uxth	r2, r3
 800b4de:	9b01      	ldr	r3, [sp, #4]
 800b4e0:	811a      	strh	r2, [r3, #8]
  usbp->receiving    &= 1U;
 800b4e2:	9b01      	ldr	r3, [sp, #4]
 800b4e4:	895b      	ldrh	r3, [r3, #10]
 800b4e6:	f003 0301 	and.w	r3, r3, #1
 800b4ea:	b29a      	uxth	r2, r3
 800b4ec:	9b01      	ldr	r3, [sp, #4]
 800b4ee:	815a      	strh	r2, [r3, #10]

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800b4f0:	2301      	movs	r3, #1
 800b4f2:	9303      	str	r3, [sp, #12]
 800b4f4:	e009      	b.n	800b50a <usbDisableEndpointsI+0x5a>
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 800b4f6:	9a01      	ldr	r2, [sp, #4]
 800b4f8:	9b03      	ldr	r3, [sp, #12]
 800b4fa:	3302      	adds	r3, #2
 800b4fc:	009b      	lsls	r3, r3, #2
 800b4fe:	4413      	add	r3, r2
 800b500:	2200      	movs	r2, #0
 800b502:	605a      	str	r2, [r3, #4]
  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800b504:	9b03      	ldr	r3, [sp, #12]
 800b506:	3301      	adds	r3, #1
 800b508:	9303      	str	r3, [sp, #12]
 800b50a:	9b03      	ldr	r3, [sp, #12]
 800b50c:	2b05      	cmp	r3, #5
 800b50e:	d9f2      	bls.n	800b4f6 <usbDisableEndpointsI+0x46>
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
 800b510:	9801      	ldr	r0, [sp, #4]
 800b512:	f002 f975 	bl	800d800 <usb_lld_disable_endpoints>
}
 800b516:	b005      	add	sp, #20
 800b518:	f85d fb04 	ldr.w	pc, [sp], #4
 800b51c:	08015e0c 	.word	0x08015e0c

0800b520 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 800b520:	b500      	push	{lr}
 800b522:	b087      	sub	sp, #28
 800b524:	9003      	str	r0, [sp, #12]
 800b526:	9201      	str	r2, [sp, #4]
 800b528:	9300      	str	r3, [sp, #0]
 800b52a:	460b      	mov	r3, r1
 800b52c:	f88d 300b 	strb.w	r3, [sp, #11]
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
 800b530:	f003 ff66 	bl	800f400 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 800b534:	9b03      	ldr	r3, [sp, #12]
 800b536:	2b00      	cmp	r3, #0
 800b538:	d003      	beq.n	800b542 <usbStartReceiveI+0x22>
 800b53a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b53e:	2b05      	cmp	r3, #5
 800b540:	d902      	bls.n	800b548 <usbStartReceiveI+0x28>
 800b542:	481c      	ldr	r0, [pc, #112]	; (800b5b4 <usbStartReceiveI+0x94>)
 800b544:	f003 fd4c 	bl	800efe0 <chSysHalt>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 800b548:	9b03      	ldr	r3, [sp, #12]
 800b54a:	895a      	ldrh	r2, [r3, #10]
 800b54c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b550:	2101      	movs	r1, #1
 800b552:	fa01 f303 	lsl.w	r3, r1, r3
 800b556:	b29b      	uxth	r3, r3
 800b558:	4013      	ands	r3, r2
 800b55a:	b29b      	uxth	r3, r3
 800b55c:	2b00      	cmp	r3, #0
 800b55e:	d002      	beq.n	800b566 <usbStartReceiveI+0x46>
 800b560:	4814      	ldr	r0, [pc, #80]	; (800b5b4 <usbStartReceiveI+0x94>)
 800b562:	f003 fd3d 	bl	800efe0 <chSysHalt>

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800b566:	9b03      	ldr	r3, [sp, #12]
 800b568:	895a      	ldrh	r2, [r3, #10]
 800b56a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b56e:	2101      	movs	r1, #1
 800b570:	fa01 f303 	lsl.w	r3, r1, r3
 800b574:	b29b      	uxth	r3, r3
 800b576:	4313      	orrs	r3, r2
 800b578:	b29a      	uxth	r2, r3
 800b57a:	9b03      	ldr	r3, [sp, #12]
 800b57c:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 800b57e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b582:	9a03      	ldr	r2, [sp, #12]
 800b584:	3302      	adds	r3, #2
 800b586:	009b      	lsls	r3, r3, #2
 800b588:	4413      	add	r3, r2
 800b58a:	685b      	ldr	r3, [r3, #4]
 800b58c:	699b      	ldr	r3, [r3, #24]
 800b58e:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 800b590:	9b05      	ldr	r3, [sp, #20]
 800b592:	9a01      	ldr	r2, [sp, #4]
 800b594:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 800b596:	9b05      	ldr	r3, [sp, #20]
 800b598:	9a00      	ldr	r2, [sp, #0]
 800b59a:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 800b59c:	9b05      	ldr	r3, [sp, #20]
 800b59e:	2200      	movs	r2, #0
 800b5a0:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 800b5a2:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b5a6:	4619      	mov	r1, r3
 800b5a8:	9803      	ldr	r0, [sp, #12]
 800b5aa:	f002 f991 	bl	800d8d0 <usb_lld_start_out>
}
 800b5ae:	b007      	add	sp, #28
 800b5b0:	f85d fb04 	ldr.w	pc, [sp], #4
 800b5b4:	08015e24 	.word	0x08015e24
	...

0800b5c0 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 800b5c0:	b500      	push	{lr}
 800b5c2:	b087      	sub	sp, #28
 800b5c4:	9003      	str	r0, [sp, #12]
 800b5c6:	9201      	str	r2, [sp, #4]
 800b5c8:	9300      	str	r3, [sp, #0]
 800b5ca:	460b      	mov	r3, r1
 800b5cc:	f88d 300b 	strb.w	r3, [sp, #11]
  USBInEndpointState *isp;

  osalDbgCheckClassI();
 800b5d0:	f003 ff16 	bl	800f400 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 800b5d4:	9b03      	ldr	r3, [sp, #12]
 800b5d6:	2b00      	cmp	r3, #0
 800b5d8:	d003      	beq.n	800b5e2 <usbStartTransmitI+0x22>
 800b5da:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b5de:	2b05      	cmp	r3, #5
 800b5e0:	d902      	bls.n	800b5e8 <usbStartTransmitI+0x28>
 800b5e2:	481c      	ldr	r0, [pc, #112]	; (800b654 <usbStartTransmitI+0x94>)
 800b5e4:	f003 fcfc 	bl	800efe0 <chSysHalt>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 800b5e8:	9b03      	ldr	r3, [sp, #12]
 800b5ea:	891a      	ldrh	r2, [r3, #8]
 800b5ec:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b5f0:	2101      	movs	r1, #1
 800b5f2:	fa01 f303 	lsl.w	r3, r1, r3
 800b5f6:	b29b      	uxth	r3, r3
 800b5f8:	4013      	ands	r3, r2
 800b5fa:	b29b      	uxth	r3, r3
 800b5fc:	2b00      	cmp	r3, #0
 800b5fe:	d002      	beq.n	800b606 <usbStartTransmitI+0x46>
 800b600:	4814      	ldr	r0, [pc, #80]	; (800b654 <usbStartTransmitI+0x94>)
 800b602:	f003 fced 	bl	800efe0 <chSysHalt>

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800b606:	9b03      	ldr	r3, [sp, #12]
 800b608:	891a      	ldrh	r2, [r3, #8]
 800b60a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b60e:	2101      	movs	r1, #1
 800b610:	fa01 f303 	lsl.w	r3, r1, r3
 800b614:	b29b      	uxth	r3, r3
 800b616:	4313      	orrs	r3, r2
 800b618:	b29a      	uxth	r2, r3
 800b61a:	9b03      	ldr	r3, [sp, #12]
 800b61c:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 800b61e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b622:	9a03      	ldr	r2, [sp, #12]
 800b624:	3302      	adds	r3, #2
 800b626:	009b      	lsls	r3, r3, #2
 800b628:	4413      	add	r3, r2
 800b62a:	685b      	ldr	r3, [r3, #4]
 800b62c:	695b      	ldr	r3, [r3, #20]
 800b62e:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 800b630:	9b05      	ldr	r3, [sp, #20]
 800b632:	9a01      	ldr	r2, [sp, #4]
 800b634:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 800b636:	9b05      	ldr	r3, [sp, #20]
 800b638:	9a00      	ldr	r2, [sp, #0]
 800b63a:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 800b63c:	9b05      	ldr	r3, [sp, #20]
 800b63e:	2200      	movs	r2, #0
 800b640:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 800b642:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800b646:	4619      	mov	r1, r3
 800b648:	9803      	ldr	r0, [sp, #12]
 800b64a:	f002 f9e1 	bl	800da10 <usb_lld_start_in>
}
 800b64e:	b007      	add	sp, #28
 800b650:	f85d fb04 	ldr.w	pc, [sp], #4
 800b654:	08015e38 	.word	0x08015e38
	...

0800b660 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 800b660:	b500      	push	{lr}
 800b662:	b085      	sub	sp, #20
 800b664:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 800b666:	9b01      	ldr	r3, [sp, #4]
 800b668:	2202      	movs	r2, #2
 800b66a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 800b66c:	9b01      	ldr	r3, [sp, #4]
 800b66e:	2200      	movs	r2, #0
 800b670:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
  usbp->address       = 0;
 800b674:	9b01      	ldr	r3, [sp, #4]
 800b676:	2200      	movs	r2, #0
 800b678:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usbp->configuration = 0;
 800b67c:	9b01      	ldr	r3, [sp, #4]
 800b67e:	2200      	movs	r2, #0
 800b680:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
  usbp->transmitting  = 0;
 800b684:	9b01      	ldr	r3, [sp, #4]
 800b686:	2200      	movs	r2, #0
 800b688:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 800b68a:	9b01      	ldr	r3, [sp, #4]
 800b68c:	2200      	movs	r2, #0
 800b68e:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800b690:	2300      	movs	r3, #0
 800b692:	9303      	str	r3, [sp, #12]
 800b694:	e009      	b.n	800b6aa <_usb_reset+0x4a>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 800b696:	9a01      	ldr	r2, [sp, #4]
 800b698:	9b03      	ldr	r3, [sp, #12]
 800b69a:	3302      	adds	r3, #2
 800b69c:	009b      	lsls	r3, r3, #2
 800b69e:	4413      	add	r3, r2
 800b6a0:	2200      	movs	r2, #0
 800b6a2:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800b6a4:	9b03      	ldr	r3, [sp, #12]
 800b6a6:	3301      	adds	r3, #1
 800b6a8:	9303      	str	r3, [sp, #12]
 800b6aa:	9b03      	ldr	r3, [sp, #12]
 800b6ac:	2b05      	cmp	r3, #5
 800b6ae:	d9f2      	bls.n	800b696 <_usb_reset+0x36>
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_STP_WAITING;
 800b6b0:	9b01      	ldr	r3, [sp, #4]
 800b6b2:	2200      	movs	r2, #0
 800b6b4:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

  /* Low level reset.*/
  usb_lld_reset(usbp);
 800b6b8:	9801      	ldr	r0, [sp, #4]
 800b6ba:	f001 fec9 	bl	800d450 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 800b6be:	9b01      	ldr	r3, [sp, #4]
 800b6c0:	685b      	ldr	r3, [r3, #4]
 800b6c2:	681b      	ldr	r3, [r3, #0]
 800b6c4:	2b00      	cmp	r3, #0
 800b6c6:	d005      	beq.n	800b6d4 <_usb_reset+0x74>
 800b6c8:	9b01      	ldr	r3, [sp, #4]
 800b6ca:	685b      	ldr	r3, [r3, #4]
 800b6cc:	681b      	ldr	r3, [r3, #0]
 800b6ce:	2100      	movs	r1, #0
 800b6d0:	9801      	ldr	r0, [sp, #4]
 800b6d2:	4798      	blx	r3
}
 800b6d4:	b005      	add	sp, #20
 800b6d6:	f85d fb04 	ldr.w	pc, [sp], #4
 800b6da:	bf00      	nop
 800b6dc:	0000      	movs	r0, r0
	...

0800b6e0 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 800b6e0:	b500      	push	{lr}
 800b6e2:	b083      	sub	sp, #12
 800b6e4:	9001      	str	r0, [sp, #4]
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 800b6e6:	9b01      	ldr	r3, [sp, #4]
 800b6e8:	781a      	ldrb	r2, [r3, #0]
 800b6ea:	9b01      	ldr	r3, [sp, #4]
 800b6ec:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;
 800b6f0:	9b01      	ldr	r3, [sp, #4]
 800b6f2:	2205      	movs	r2, #5
 800b6f4:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800b6f6:	9b01      	ldr	r3, [sp, #4]
 800b6f8:	685b      	ldr	r3, [r3, #4]
 800b6fa:	681b      	ldr	r3, [r3, #0]
 800b6fc:	2b00      	cmp	r3, #0
 800b6fe:	d005      	beq.n	800b70c <_usb_suspend+0x2c>
 800b700:	9b01      	ldr	r3, [sp, #4]
 800b702:	685b      	ldr	r3, [r3, #4]
 800b704:	681b      	ldr	r3, [r3, #0]
 800b706:	2104      	movs	r1, #4
 800b708:	9801      	ldr	r0, [sp, #4]
 800b70a:	4798      	blx	r3
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 800b70c:	b003      	add	sp, #12
 800b70e:	f85d fb04 	ldr.w	pc, [sp], #4
 800b712:	bf00      	nop
	...

0800b720 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 800b720:	b500      	push	{lr}
 800b722:	b083      	sub	sp, #12
 800b724:	9001      	str	r0, [sp, #4]

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 800b726:	9b01      	ldr	r3, [sp, #4]
 800b728:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
 800b72c:	9b01      	ldr	r3, [sp, #4]
 800b72e:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800b730:	9b01      	ldr	r3, [sp, #4]
 800b732:	685b      	ldr	r3, [r3, #4]
 800b734:	681b      	ldr	r3, [r3, #0]
 800b736:	2b00      	cmp	r3, #0
 800b738:	d005      	beq.n	800b746 <_usb_wakeup+0x26>
 800b73a:	9b01      	ldr	r3, [sp, #4]
 800b73c:	685b      	ldr	r3, [r3, #4]
 800b73e:	681b      	ldr	r3, [r3, #0]
 800b740:	2105      	movs	r1, #5
 800b742:	9801      	ldr	r0, [sp, #4]
 800b744:	4798      	blx	r3
}
 800b746:	b003      	add	sp, #12
 800b748:	f85d fb04 	ldr.w	pc, [sp], #4
 800b74c:	0000      	movs	r0, r0
	...

0800b750 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 800b750:	b500      	push	{lr}
 800b752:	b085      	sub	sp, #20
 800b754:	9001      	str	r0, [sp, #4]
 800b756:	460b      	mov	r3, r1
 800b758:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  /* Is the EP0 state machine in the correct state for handling setup
     packets?*/
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 800b75c:	9b01      	ldr	r3, [sp, #4]
 800b75e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 800b762:	2b00      	cmp	r3, #0
 800b764:	d003      	beq.n	800b76e <_usb_ep0setup+0x1e>
    /* This is unexpected could require handling with a warning event.*/
    /* TODO: handling here.*/

    /* Resetting the EP0 state machine and going ahead.*/
    usbp->ep0state = USB_EP0_STP_WAITING;
 800b766:	9b01      	ldr	r3, [sp, #4]
 800b768:	2200      	movs	r2, #0
 800b76a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  }

  /* Reading the setup data into the driver buffer.*/
  usbReadSetup(usbp, ep, usbp->setup);
 800b76e:	9b01      	ldr	r3, [sp, #4]
 800b770:	f103 025c 	add.w	r2, r3, #92	; 0x5c
 800b774:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800b778:	4619      	mov	r1, r3
 800b77a:	9801      	ldr	r0, [sp, #4]
 800b77c:	f002 f890 	bl	800d8a0 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 800b780:	9b01      	ldr	r3, [sp, #4]
 800b782:	685b      	ldr	r3, [r3, #4]
 800b784:	689b      	ldr	r3, [r3, #8]
 800b786:	2b00      	cmp	r3, #0
 800b788:	d00a      	beq.n	800b7a0 <_usb_ep0setup+0x50>
      !(usbp->config->requests_hook_cb(usbp))) {
 800b78a:	9b01      	ldr	r3, [sp, #4]
 800b78c:	685b      	ldr	r3, [r3, #4]
 800b78e:	689b      	ldr	r3, [r3, #8]
 800b790:	9801      	ldr	r0, [sp, #4]
 800b792:	4798      	blx	r3
 800b794:	4603      	mov	r3, r0
 800b796:	f083 0301 	eor.w	r3, r3, #1
 800b79a:	b2db      	uxtb	r3, r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 800b79c:	2b00      	cmp	r3, #0
 800b79e:	d027      	beq.n	800b7f0 <_usb_ep0setup+0xa0>
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 800b7a0:	9b01      	ldr	r3, [sp, #4]
 800b7a2:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800b7a6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800b7aa:	2b00      	cmp	r3, #0
 800b7ac:	d108      	bne.n	800b7c0 <_usb_ep0setup+0x70>
        !default_handler(usbp)) {
 800b7ae:	9801      	ldr	r0, [sp, #4]
 800b7b0:	f7ff fbd6 	bl	800af60 <default_handler>
 800b7b4:	4603      	mov	r3, r0
 800b7b6:	f083 0301 	eor.w	r3, r3, #1
 800b7ba:	b2db      	uxtb	r3, r3
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 800b7bc:	2b00      	cmp	r3, #0
 800b7be:	d017      	beq.n	800b7f0 <_usb_ep0setup+0xa0>
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 800b7c0:	2100      	movs	r1, #0
 800b7c2:	9801      	ldr	r0, [sp, #4]
 800b7c4:	f002 f9f4 	bl	800dbb0 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 800b7c8:	2100      	movs	r1, #0
 800b7ca:	9801      	ldr	r0, [sp, #4]
 800b7cc:	f002 f9d0 	bl	800db70 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800b7d0:	9b01      	ldr	r3, [sp, #4]
 800b7d2:	685b      	ldr	r3, [r3, #4]
 800b7d4:	681b      	ldr	r3, [r3, #0]
 800b7d6:	2b00      	cmp	r3, #0
 800b7d8:	d005      	beq.n	800b7e6 <_usb_ep0setup+0x96>
 800b7da:	9b01      	ldr	r3, [sp, #4]
 800b7dc:	685b      	ldr	r3, [r3, #4]
 800b7de:	681b      	ldr	r3, [r3, #0]
 800b7e0:	2106      	movs	r1, #6
 800b7e2:	9801      	ldr	r0, [sp, #4]
 800b7e4:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 800b7e6:	9b01      	ldr	r3, [sp, #4]
 800b7e8:	2206      	movs	r2, #6
 800b7ea:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 800b7ee:	e05b      	b.n	800b8a8 <_usb_ep0setup+0x158>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 800b7f0:	9b01      	ldr	r3, [sp, #4]
 800b7f2:	3362      	adds	r3, #98	; 0x62
 800b7f4:	4618      	mov	r0, r3
 800b7f6:	f7ff fb7b 	bl	800aef0 <get_hword>
 800b7fa:	4603      	mov	r3, r0
 800b7fc:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 800b7fe:	9b01      	ldr	r3, [sp, #4]
 800b800:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b802:	9a03      	ldr	r2, [sp, #12]
 800b804:	429a      	cmp	r2, r3
 800b806:	d202      	bcs.n	800b80e <_usb_ep0setup+0xbe>
    usbp->ep0n = max;
 800b808:	9b01      	ldr	r3, [sp, #4]
 800b80a:	9a03      	ldr	r2, [sp, #12]
 800b80c:	655a      	str	r2, [r3, #84]	; 0x54
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800b80e:	9b01      	ldr	r3, [sp, #4]
 800b810:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800b814:	b25b      	sxtb	r3, r3
 800b816:	2b00      	cmp	r3, #0
 800b818:	da23      	bge.n	800b862 <_usb_ep0setup+0x112>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 800b81a:	9b01      	ldr	r3, [sp, #4]
 800b81c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b81e:	2b00      	cmp	r3, #0
 800b820:	d010      	beq.n	800b844 <_usb_ep0setup+0xf4>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_IN_TX;
 800b822:	9b01      	ldr	r3, [sp, #4]
 800b824:	2209      	movs	r2, #9
 800b826:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 800b82a:	f7ff fb51 	bl	800aed0 <osalSysLockFromISR.lto_priv.556>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800b82e:	9b01      	ldr	r3, [sp, #4]
 800b830:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b832:	9b01      	ldr	r3, [sp, #4]
 800b834:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b836:	2100      	movs	r1, #0
 800b838:	9801      	ldr	r0, [sp, #4]
 800b83a:	f7ff fec1 	bl	800b5c0 <usbStartTransmitI>
      osalSysUnlockFromISR();
 800b83e:	f7ff fb4f 	bl	800aee0 <osalSysUnlockFromISR.lto_priv.550>
         packet.*/
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, NULL, 0);
      osalSysUnlockFromISR();
 800b842:	e031      	b.n	800b8a8 <_usb_ep0setup+0x158>
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 800b844:	9b01      	ldr	r3, [sp, #4]
 800b846:	2214      	movs	r2, #20
 800b848:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 800b84c:	f7ff fb40 	bl	800aed0 <osalSysLockFromISR.lto_priv.556>
      usbStartReceiveI(usbp, 0, NULL, 0);
 800b850:	2300      	movs	r3, #0
 800b852:	2200      	movs	r2, #0
 800b854:	2100      	movs	r1, #0
 800b856:	9801      	ldr	r0, [sp, #4]
 800b858:	f7ff fe62 	bl	800b520 <usbStartReceiveI>
      osalSysUnlockFromISR();
 800b85c:	f7ff fb40 	bl	800aee0 <osalSysUnlockFromISR.lto_priv.550>
 800b860:	e022      	b.n	800b8a8 <_usb_ep0setup+0x158>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 800b862:	9b01      	ldr	r3, [sp, #4]
 800b864:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b866:	2b00      	cmp	r3, #0
 800b868:	d010      	beq.n	800b88c <_usb_ep0setup+0x13c>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_OUT_RX;
 800b86a:	9b01      	ldr	r3, [sp, #4]
 800b86c:	2215      	movs	r2, #21
 800b86e:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 800b872:	f7ff fb2d 	bl	800aed0 <osalSysLockFromISR.lto_priv.556>
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 800b876:	9b01      	ldr	r3, [sp, #4]
 800b878:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b87a:	9b01      	ldr	r3, [sp, #4]
 800b87c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b87e:	2100      	movs	r1, #0
 800b880:	9801      	ldr	r0, [sp, #4]
 800b882:	f7ff fe4d 	bl	800b520 <usbStartReceiveI>
      osalSysUnlockFromISR();
 800b886:	f7ff fb2b 	bl	800aee0 <osalSysUnlockFromISR.lto_priv.550>
 800b88a:	e00d      	b.n	800b8a8 <_usb_ep0setup+0x158>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 800b88c:	9b01      	ldr	r3, [sp, #4]
 800b88e:	220b      	movs	r2, #11
 800b890:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 800b894:	f7ff fb1c 	bl	800aed0 <osalSysLockFromISR.lto_priv.556>
      usbStartTransmitI(usbp, 0, NULL, 0);
 800b898:	2300      	movs	r3, #0
 800b89a:	2200      	movs	r2, #0
 800b89c:	2100      	movs	r1, #0
 800b89e:	9801      	ldr	r0, [sp, #4]
 800b8a0:	f7ff fe8e 	bl	800b5c0 <usbStartTransmitI>
      osalSysUnlockFromISR();
 800b8a4:	f7ff fb1c 	bl	800aee0 <osalSysUnlockFromISR.lto_priv.550>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 800b8a8:	b005      	add	sp, #20
 800b8aa:	f85d fb04 	ldr.w	pc, [sp], #4
 800b8ae:	bf00      	nop

0800b8b0 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 800b8b0:	b500      	push	{lr}
 800b8b2:	b085      	sub	sp, #20
 800b8b4:	9001      	str	r0, [sp, #4]
 800b8b6:	460b      	mov	r3, r1
 800b8b8:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800b8bc:	9b01      	ldr	r3, [sp, #4]
 800b8be:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 800b8c2:	2b15      	cmp	r3, #21
 800b8c4:	f200 808e 	bhi.w	800b9e4 <_usb_ep0in+0x134>
 800b8c8:	a201      	add	r2, pc, #4	; (adr r2, 800b8d0 <_usb_ep0in+0x20>)
 800b8ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b8ce:	bf00      	nop
 800b8d0:	0800b9af 	.word	0x0800b9af
 800b8d4:	0800b9e5 	.word	0x0800b9e5
 800b8d8:	0800b9e5 	.word	0x0800b9e5
 800b8dc:	0800b9e5 	.word	0x0800b9e5
 800b8e0:	0800b9e5 	.word	0x0800b9e5
 800b8e4:	0800b9e5 	.word	0x0800b9e5
 800b8e8:	0800b9b5 	.word	0x0800b9b5
 800b8ec:	0800b9e5 	.word	0x0800b9e5
 800b8f0:	0800b9e5 	.word	0x0800b9e5
 800b8f4:	0800b929 	.word	0x0800b929
 800b8f8:	0800b977 	.word	0x0800b977
 800b8fc:	0800b995 	.word	0x0800b995
 800b900:	0800b9e5 	.word	0x0800b9e5
 800b904:	0800b9e5 	.word	0x0800b9e5
 800b908:	0800b9e5 	.word	0x0800b9e5
 800b90c:	0800b9e5 	.word	0x0800b9e5
 800b910:	0800b9e5 	.word	0x0800b9e5
 800b914:	0800b9e5 	.word	0x0800b9e5
 800b918:	0800b9e5 	.word	0x0800b9e5
 800b91c:	0800b9e5 	.word	0x0800b9e5
 800b920:	0800b9af 	.word	0x0800b9af
 800b924:	0800b9af 	.word	0x0800b9af
  case USB_EP0_IN_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 800b928:	9b01      	ldr	r3, [sp, #4]
 800b92a:	3362      	adds	r3, #98	; 0x62
 800b92c:	4618      	mov	r0, r3
 800b92e:	f7ff fadf 	bl	800aef0 <get_hword>
 800b932:	4603      	mov	r3, r0
 800b934:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800b936:	9b01      	ldr	r3, [sp, #4]
 800b938:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b93a:	9a03      	ldr	r2, [sp, #12]
 800b93c:	429a      	cmp	r2, r3
 800b93e:	d91a      	bls.n	800b976 <_usb_ep0in+0xc6>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 800b940:	9b01      	ldr	r3, [sp, #4]
 800b942:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b944:	9a01      	ldr	r2, [sp, #4]
 800b946:	68d2      	ldr	r2, [r2, #12]
 800b948:	8a12      	ldrh	r2, [r2, #16]
 800b94a:	fbb3 f1f2 	udiv	r1, r3, r2
 800b94e:	fb02 f201 	mul.w	r2, r2, r1
 800b952:	1a9b      	subs	r3, r3, r2
    if ((usbp->ep0n < max) &&
 800b954:	2b00      	cmp	r3, #0
 800b956:	d10e      	bne.n	800b976 <_usb_ep0in+0xc6>
      osalSysLockFromISR();
 800b958:	f7ff faba 	bl	800aed0 <osalSysLockFromISR.lto_priv.556>
      usbStartTransmitI(usbp, 0, NULL, 0);
 800b95c:	2300      	movs	r3, #0
 800b95e:	2200      	movs	r2, #0
 800b960:	2100      	movs	r1, #0
 800b962:	9801      	ldr	r0, [sp, #4]
 800b964:	f7ff fe2c 	bl	800b5c0 <usbStartTransmitI>
      osalSysUnlockFromISR();
 800b968:	f7ff faba 	bl	800aee0 <osalSysUnlockFromISR.lto_priv.550>
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 800b96c:	9b01      	ldr	r3, [sp, #4]
 800b96e:	220a      	movs	r2, #10
 800b970:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 800b974:	e039      	b.n	800b9ea <_usb_ep0in+0x13a>
      return;
    }
    /* Falls through.*/
  case USB_EP0_IN_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 800b976:	9b01      	ldr	r3, [sp, #4]
 800b978:	2214      	movs	r2, #20
 800b97a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 800b97e:	f7ff faa7 	bl	800aed0 <osalSysLockFromISR.lto_priv.556>
    usbStartReceiveI(usbp, 0, NULL, 0);
 800b982:	2300      	movs	r3, #0
 800b984:	2200      	movs	r2, #0
 800b986:	2100      	movs	r1, #0
 800b988:	9801      	ldr	r0, [sp, #4]
 800b98a:	f7ff fdc9 	bl	800b520 <usbStartReceiveI>
    osalSysUnlockFromISR();
 800b98e:	f7ff faa7 	bl	800aee0 <osalSysUnlockFromISR.lto_priv.550>
 800b992:	e02a      	b.n	800b9ea <_usb_ep0in+0x13a>
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_IN_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 800b994:	9b01      	ldr	r3, [sp, #4]
 800b996:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800b998:	2b00      	cmp	r3, #0
 800b99a:	d003      	beq.n	800b9a4 <_usb_ep0in+0xf4>
      usbp->ep0endcb(usbp);
 800b99c:	9b01      	ldr	r3, [sp, #4]
 800b99e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800b9a0:	9801      	ldr	r0, [sp, #4]
 800b9a2:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 800b9a4:	9b01      	ldr	r3, [sp, #4]
 800b9a6:	2200      	movs	r2, #0
 800b9a8:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 800b9ac:	e01d      	b.n	800b9ea <_usb_ep0in+0x13a>
    return;
  case USB_EP0_STP_WAITING:
  case USB_EP0_OUT_WAITING_STS:
  case USB_EP0_OUT_RX:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 800b9ae:	4810      	ldr	r0, [pc, #64]	; (800b9f0 <_usb_ep0in+0x140>)
 800b9b0:	f003 fb16 	bl	800efe0 <chSysHalt>
    /* Falls through.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800b9b4:	2100      	movs	r1, #0
 800b9b6:	9801      	ldr	r0, [sp, #4]
 800b9b8:	f002 f8fa 	bl	800dbb0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800b9bc:	2100      	movs	r1, #0
 800b9be:	9801      	ldr	r0, [sp, #4]
 800b9c0:	f002 f8d6 	bl	800db70 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800b9c4:	9b01      	ldr	r3, [sp, #4]
 800b9c6:	685b      	ldr	r3, [r3, #4]
 800b9c8:	681b      	ldr	r3, [r3, #0]
 800b9ca:	2b00      	cmp	r3, #0
 800b9cc:	d005      	beq.n	800b9da <_usb_ep0in+0x12a>
 800b9ce:	9b01      	ldr	r3, [sp, #4]
 800b9d0:	685b      	ldr	r3, [r3, #4]
 800b9d2:	681b      	ldr	r3, [r3, #0]
 800b9d4:	2106      	movs	r1, #6
 800b9d6:	9801      	ldr	r0, [sp, #4]
 800b9d8:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 800b9da:	9b01      	ldr	r3, [sp, #4]
 800b9dc:	2206      	movs	r2, #6
 800b9de:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 800b9e2:	e002      	b.n	800b9ea <_usb_ep0in+0x13a>
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 800b9e4:	4802      	ldr	r0, [pc, #8]	; (800b9f0 <_usb_ep0in+0x140>)
 800b9e6:	f003 fafb 	bl	800efe0 <chSysHalt>
  }
}
 800b9ea:	b005      	add	sp, #20
 800b9ec:	f85d fb04 	ldr.w	pc, [sp], #4
 800b9f0:	08015e4c 	.word	0x08015e4c
	...

0800ba00 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 800ba00:	b500      	push	{lr}
 800ba02:	b083      	sub	sp, #12
 800ba04:	9001      	str	r0, [sp, #4]
 800ba06:	460b      	mov	r3, r1
 800ba08:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 800ba0c:	9b01      	ldr	r3, [sp, #4]
 800ba0e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 800ba12:	2b15      	cmp	r3, #21
 800ba14:	d86b      	bhi.n	800baee <_usb_ep0out+0xee>
 800ba16:	a201      	add	r2, pc, #4	; (adr r2, 800ba1c <_usb_ep0out+0x1c>)
 800ba18:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ba1c:	0800bab9 	.word	0x0800bab9
 800ba20:	0800baef 	.word	0x0800baef
 800ba24:	0800baef 	.word	0x0800baef
 800ba28:	0800baef 	.word	0x0800baef
 800ba2c:	0800baef 	.word	0x0800baef
 800ba30:	0800baef 	.word	0x0800baef
 800ba34:	0800babf 	.word	0x0800babf
 800ba38:	0800baef 	.word	0x0800baef
 800ba3c:	0800baef 	.word	0x0800baef
 800ba40:	0800bab9 	.word	0x0800bab9
 800ba44:	0800bab9 	.word	0x0800bab9
 800ba48:	0800bab9 	.word	0x0800bab9
 800ba4c:	0800baef 	.word	0x0800baef
 800ba50:	0800baef 	.word	0x0800baef
 800ba54:	0800baef 	.word	0x0800baef
 800ba58:	0800baef 	.word	0x0800baef
 800ba5c:	0800baef 	.word	0x0800baef
 800ba60:	0800baef 	.word	0x0800baef
 800ba64:	0800baef 	.word	0x0800baef
 800ba68:	0800baef 	.word	0x0800baef
 800ba6c:	0800ba93 	.word	0x0800ba93
 800ba70:	0800ba75 	.word	0x0800ba75
  case USB_EP0_OUT_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 800ba74:	9b01      	ldr	r3, [sp, #4]
 800ba76:	220b      	movs	r2, #11
 800ba78:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 800ba7c:	f7ff fa28 	bl	800aed0 <osalSysLockFromISR.lto_priv.556>
    usbStartTransmitI(usbp, 0, NULL, 0);
 800ba80:	2300      	movs	r3, #0
 800ba82:	2200      	movs	r2, #0
 800ba84:	2100      	movs	r1, #0
 800ba86:	9801      	ldr	r0, [sp, #4]
 800ba88:	f7ff fd9a 	bl	800b5c0 <usbStartTransmitI>
    osalSysUnlockFromISR();
 800ba8c:	f7ff fa28 	bl	800aee0 <osalSysUnlockFromISR.lto_priv.550>
 800ba90:	e030      	b.n	800baf4 <_usb_ep0out+0xf4>
    return;
  case USB_EP0_OUT_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 800ba92:	9b01      	ldr	r3, [sp, #4]
 800ba94:	68db      	ldr	r3, [r3, #12]
 800ba96:	699b      	ldr	r3, [r3, #24]
 800ba98:	685b      	ldr	r3, [r3, #4]
 800ba9a:	2b00      	cmp	r3, #0
 800ba9c:	d12a      	bne.n	800baf4 <_usb_ep0out+0xf4>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800ba9e:	9b01      	ldr	r3, [sp, #4]
 800baa0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800baa2:	2b00      	cmp	r3, #0
 800baa4:	d003      	beq.n	800baae <_usb_ep0out+0xae>
      usbp->ep0endcb(usbp);
 800baa6:	9b01      	ldr	r3, [sp, #4]
 800baa8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800baaa:	9801      	ldr	r0, [sp, #4]
 800baac:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 800baae:	9b01      	ldr	r3, [sp, #4]
 800bab0:	2200      	movs	r2, #0
 800bab2:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 800bab6:	e01d      	b.n	800baf4 <_usb_ep0out+0xf4>
  case USB_EP0_STP_WAITING:
  case USB_EP0_IN_TX:
  case USB_EP0_IN_WAITING_TX0:
  case USB_EP0_IN_SENDING_STS:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 800bab8:	4810      	ldr	r0, [pc, #64]	; (800bafc <_usb_ep0out+0xfc>)
 800baba:	f003 fa91 	bl	800efe0 <chSysHalt>
    /* Falls through.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800babe:	2100      	movs	r1, #0
 800bac0:	9801      	ldr	r0, [sp, #4]
 800bac2:	f002 f875 	bl	800dbb0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800bac6:	2100      	movs	r1, #0
 800bac8:	9801      	ldr	r0, [sp, #4]
 800baca:	f002 f851 	bl	800db70 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800bace:	9b01      	ldr	r3, [sp, #4]
 800bad0:	685b      	ldr	r3, [r3, #4]
 800bad2:	681b      	ldr	r3, [r3, #0]
 800bad4:	2b00      	cmp	r3, #0
 800bad6:	d005      	beq.n	800bae4 <_usb_ep0out+0xe4>
 800bad8:	9b01      	ldr	r3, [sp, #4]
 800bada:	685b      	ldr	r3, [r3, #4]
 800badc:	681b      	ldr	r3, [r3, #0]
 800bade:	2106      	movs	r1, #6
 800bae0:	9801      	ldr	r0, [sp, #4]
 800bae2:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 800bae4:	9b01      	ldr	r3, [sp, #4]
 800bae6:	2206      	movs	r2, #6
 800bae8:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 800baec:	e002      	b.n	800baf4 <_usb_ep0out+0xf4>
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 800baee:	4803      	ldr	r0, [pc, #12]	; (800bafc <_usb_ep0out+0xfc>)
 800baf0:	f003 fa76 	bl	800efe0 <chSysHalt>
  }
}
 800baf4:	b003      	add	sp, #12
 800baf6:	f85d fb04 	ldr.w	pc, [sp], #4
 800bafa:	bf00      	nop
 800bafc:	08015e58 	.word	0x08015e58

0800bb00 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 800bb00:	b082      	sub	sp, #8
 800bb02:	9001      	str	r0, [sp, #4]
 800bb04:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800bb06:	9b00      	ldr	r3, [sp, #0]
 800bb08:	b2db      	uxtb	r3, r3
 800bb0a:	4a11      	ldr	r2, [pc, #68]	; (800bb50 <nvicEnableVector+0x50>)
 800bb0c:	011b      	lsls	r3, r3, #4
 800bb0e:	b2d9      	uxtb	r1, r3
 800bb10:	9b01      	ldr	r3, [sp, #4]
 800bb12:	4413      	add	r3, r2
 800bb14:	f503 7340 	add.w	r3, r3, #768	; 0x300
 800bb18:	460a      	mov	r2, r1
 800bb1a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800bb1c:	9b01      	ldr	r3, [sp, #4]
 800bb1e:	f003 021f 	and.w	r2, r3, #31
 800bb22:	490b      	ldr	r1, [pc, #44]	; (800bb50 <nvicEnableVector+0x50>)
 800bb24:	9b01      	ldr	r3, [sp, #4]
 800bb26:	095b      	lsrs	r3, r3, #5
 800bb28:	2001      	movs	r0, #1
 800bb2a:	fa00 f202 	lsl.w	r2, r0, r2
 800bb2e:	3360      	adds	r3, #96	; 0x60
 800bb30:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800bb34:	9b01      	ldr	r3, [sp, #4]
 800bb36:	f003 021f 	and.w	r2, r3, #31
 800bb3a:	4905      	ldr	r1, [pc, #20]	; (800bb50 <nvicEnableVector+0x50>)
 800bb3c:	9b01      	ldr	r3, [sp, #4]
 800bb3e:	095b      	lsrs	r3, r3, #5
 800bb40:	2001      	movs	r0, #1
 800bb42:	fa00 f202 	lsl.w	r2, r0, r2
 800bb46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800bb4a:	b002      	add	sp, #8
 800bb4c:	4770      	bx	lr
 800bb4e:	bf00      	nop
 800bb50:	e000e100 	.word	0xe000e100
	...

0800bb60 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 800bb60:	b508      	push	{r3, lr}

#if HAL_USE_PAL
  nvicEnableVector(EXTI0_IRQn, STM32_IRQ_EXTI0_PRIORITY);
 800bb62:	2106      	movs	r1, #6
 800bb64:	2006      	movs	r0, #6
 800bb66:	f7ff ffcb 	bl	800bb00 <nvicEnableVector>
  nvicEnableVector(EXTI1_IRQn, STM32_IRQ_EXTI1_PRIORITY);
 800bb6a:	2106      	movs	r1, #6
 800bb6c:	2007      	movs	r0, #7
 800bb6e:	f7ff ffc7 	bl	800bb00 <nvicEnableVector>
  nvicEnableVector(EXTI2_IRQn, STM32_IRQ_EXTI2_PRIORITY);
 800bb72:	2106      	movs	r1, #6
 800bb74:	2008      	movs	r0, #8
 800bb76:	f7ff ffc3 	bl	800bb00 <nvicEnableVector>
  nvicEnableVector(EXTI3_IRQn, STM32_IRQ_EXTI3_PRIORITY);
 800bb7a:	2106      	movs	r1, #6
 800bb7c:	2009      	movs	r0, #9
 800bb7e:	f7ff ffbf 	bl	800bb00 <nvicEnableVector>
  nvicEnableVector(EXTI4_IRQn, STM32_IRQ_EXTI4_PRIORITY);
 800bb82:	2106      	movs	r1, #6
 800bb84:	200a      	movs	r0, #10
 800bb86:	f7ff ffbb 	bl	800bb00 <nvicEnableVector>
  nvicEnableVector(EXTI9_5_IRQn, STM32_IRQ_EXTI5_9_PRIORITY);
 800bb8a:	2106      	movs	r1, #6
 800bb8c:	2017      	movs	r0, #23
 800bb8e:	f7ff ffb7 	bl	800bb00 <nvicEnableVector>
  nvicEnableVector(EXTI15_10_IRQn, STM32_IRQ_EXTI10_15_PRIORITY);
 800bb92:	2106      	movs	r1, #6
 800bb94:	2028      	movs	r0, #40	; 0x28
 800bb96:	f7ff ffb3 	bl	800bb00 <nvicEnableVector>
#endif
}
 800bb9a:	bd08      	pop	{r3, pc}
 800bb9c:	0000      	movs	r0, r0
	...

0800bba0 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800bba0:	4b0d      	ldr	r3, [pc, #52]	; (800bbd8 <hal_lld_backup_domain_init+0x38>)
 800bba2:	681b      	ldr	r3, [r3, #0]
 800bba4:	4a0c      	ldr	r2, [pc, #48]	; (800bbd8 <hal_lld_backup_domain_init+0x38>)
 800bba6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800bbaa:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800bbac:	4b0b      	ldr	r3, [pc, #44]	; (800bbdc <hal_lld_backup_domain_init+0x3c>)
 800bbae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800bbb0:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800bbb4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800bbb8:	d006      	beq.n	800bbc8 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800bbba:	4b08      	ldr	r3, [pc, #32]	; (800bbdc <hal_lld_backup_domain_init+0x3c>)
 800bbbc:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800bbc0:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800bbc2:	4b06      	ldr	r3, [pc, #24]	; (800bbdc <hal_lld_backup_domain_init+0x3c>)
 800bbc4:	2200      	movs	r2, #0
 800bbc6:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 800bbc8:	4b03      	ldr	r3, [pc, #12]	; (800bbd8 <hal_lld_backup_domain_init+0x38>)
 800bbca:	685b      	ldr	r3, [r3, #4]
 800bbcc:	4a02      	ldr	r2, [pc, #8]	; (800bbd8 <hal_lld_backup_domain_init+0x38>)
 800bbce:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800bbd2:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 800bbd4:	4770      	bx	lr
 800bbd6:	bf00      	nop
 800bbd8:	40007000 	.word	0x40007000
 800bbdc:	40023800 	.word	0x40023800

0800bbe0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 800bbe0:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 800bbe2:	4b26      	ldr	r3, [pc, #152]	; (800bc7c <hal_lld_init+0x9c>)
 800bbe4:	691b      	ldr	r3, [r3, #16]
 800bbe6:	4a25      	ldr	r2, [pc, #148]	; (800bc7c <hal_lld_init+0x9c>)
 800bbe8:	ea6f 53c3 	mvn.w	r3, r3, lsl #23
 800bbec:	ea6f 53d3 	mvn.w	r3, r3, lsr #23
 800bbf0:	6113      	str	r3, [r2, #16]
 800bbf2:	4b22      	ldr	r3, [pc, #136]	; (800bc7c <hal_lld_init+0x9c>)
 800bbf4:	691b      	ldr	r3, [r3, #16]
 800bbf6:	4a21      	ldr	r2, [pc, #132]	; (800bc7c <hal_lld_init+0x9c>)
 800bbf8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800bbfc:	6113      	str	r3, [r2, #16]
 800bbfe:	4b1f      	ldr	r3, [pc, #124]	; (800bc7c <hal_lld_init+0x9c>)
 800bc00:	691b      	ldr	r3, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 800bc02:	4b1e      	ldr	r3, [pc, #120]	; (800bc7c <hal_lld_init+0x9c>)
 800bc04:	695b      	ldr	r3, [r3, #20]
 800bc06:	4b1d      	ldr	r3, [pc, #116]	; (800bc7c <hal_lld_init+0x9c>)
 800bc08:	f04f 32ff 	mov.w	r2, #4294967295
 800bc0c:	615a      	str	r2, [r3, #20]
 800bc0e:	4b1b      	ldr	r3, [pc, #108]	; (800bc7c <hal_lld_init+0x9c>)
 800bc10:	695b      	ldr	r3, [r3, #20]
 800bc12:	4b1a      	ldr	r3, [pc, #104]	; (800bc7c <hal_lld_init+0x9c>)
 800bc14:	2200      	movs	r2, #0
 800bc16:	615a      	str	r2, [r3, #20]
 800bc18:	4b18      	ldr	r3, [pc, #96]	; (800bc7c <hal_lld_init+0x9c>)
 800bc1a:	695b      	ldr	r3, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800bc1c:	4b17      	ldr	r3, [pc, #92]	; (800bc7c <hal_lld_init+0x9c>)
 800bc1e:	6a1b      	ldr	r3, [r3, #32]
 800bc20:	4a16      	ldr	r2, [pc, #88]	; (800bc7c <hal_lld_init+0x9c>)
 800bc22:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 800bc26:	6213      	str	r3, [r2, #32]
 800bc28:	4b14      	ldr	r3, [pc, #80]	; (800bc7c <hal_lld_init+0x9c>)
 800bc2a:	6a1b      	ldr	r3, [r3, #32]
 800bc2c:	4a13      	ldr	r2, [pc, #76]	; (800bc7c <hal_lld_init+0x9c>)
 800bc2e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800bc32:	6213      	str	r3, [r2, #32]
 800bc34:	4b11      	ldr	r3, [pc, #68]	; (800bc7c <hal_lld_init+0x9c>)
 800bc36:	6a1b      	ldr	r3, [r3, #32]
  rccResetAPB2(~0);
 800bc38:	4b10      	ldr	r3, [pc, #64]	; (800bc7c <hal_lld_init+0x9c>)
 800bc3a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bc3c:	4b0f      	ldr	r3, [pc, #60]	; (800bc7c <hal_lld_init+0x9c>)
 800bc3e:	f04f 32ff 	mov.w	r2, #4294967295
 800bc42:	625a      	str	r2, [r3, #36]	; 0x24
 800bc44:	4b0d      	ldr	r3, [pc, #52]	; (800bc7c <hal_lld_init+0x9c>)
 800bc46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bc48:	4b0c      	ldr	r3, [pc, #48]	; (800bc7c <hal_lld_init+0x9c>)
 800bc4a:	2200      	movs	r2, #0
 800bc4c:	625a      	str	r2, [r3, #36]	; 0x24
 800bc4e:	4b0b      	ldr	r3, [pc, #44]	; (800bc7c <hal_lld_init+0x9c>)
 800bc50:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 800bc52:	4b0a      	ldr	r3, [pc, #40]	; (800bc7c <hal_lld_init+0x9c>)
 800bc54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800bc56:	4a09      	ldr	r2, [pc, #36]	; (800bc7c <hal_lld_init+0x9c>)
 800bc58:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800bc5c:	6413      	str	r3, [r2, #64]	; 0x40
 800bc5e:	4b07      	ldr	r3, [pc, #28]	; (800bc7c <hal_lld_init+0x9c>)
 800bc60:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800bc62:	4a06      	ldr	r2, [pc, #24]	; (800bc7c <hal_lld_init+0x9c>)
 800bc64:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800bc68:	6613      	str	r3, [r2, #96]	; 0x60
 800bc6a:	4b04      	ldr	r3, [pc, #16]	; (800bc7c <hal_lld_init+0x9c>)
 800bc6c:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 800bc6e:	f7ff ff97 	bl	800bba0 <hal_lld_backup_domain_init>

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800bc72:	f000 fba5 	bl	800c3c0 <dmaInit>
#endif

  /* IRQ subsystem initialization.*/
  irqInit();
 800bc76:	f7ff ff73 	bl	800bb60 <irqInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800bc7a:	bd08      	pop	{r3, pc}
 800bc7c:	40023800 	.word	0x40023800

0800bc80 <stm32_clock_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800bc80:	4b43      	ldr	r3, [pc, #268]	; (800bd90 <stm32_clock_init+0x110>)
 800bc82:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800bc86:	641a      	str	r2, [r3, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800bc88:	4b42      	ldr	r3, [pc, #264]	; (800bd94 <stm32_clock_init+0x114>)
 800bc8a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800bc8e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800bc90:	4b3f      	ldr	r3, [pc, #252]	; (800bd90 <stm32_clock_init+0x110>)
 800bc92:	681b      	ldr	r3, [r3, #0]
 800bc94:	4a3e      	ldr	r2, [pc, #248]	; (800bd90 <stm32_clock_init+0x110>)
 800bc96:	f043 0301 	orr.w	r3, r3, #1
 800bc9a:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800bc9c:	4b3c      	ldr	r3, [pc, #240]	; (800bd90 <stm32_clock_init+0x110>)
 800bc9e:	681b      	ldr	r3, [r3, #0]
 800bca0:	f003 0302 	and.w	r3, r3, #2
 800bca4:	2b00      	cmp	r3, #0
 800bca6:	d0f9      	beq.n	800bc9c <stm32_clock_init+0x1c>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 800bca8:	4b39      	ldr	r3, [pc, #228]	; (800bd90 <stm32_clock_init+0x110>)
 800bcaa:	689b      	ldr	r3, [r3, #8]
 800bcac:	4a38      	ldr	r2, [pc, #224]	; (800bd90 <stm32_clock_init+0x110>)
 800bcae:	f023 0303 	bic.w	r3, r3, #3
 800bcb2:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800bcb4:	4b36      	ldr	r3, [pc, #216]	; (800bd90 <stm32_clock_init+0x110>)
 800bcb6:	689b      	ldr	r3, [r3, #8]
 800bcb8:	f003 030c 	and.w	r3, r3, #12
 800bcbc:	2b00      	cmp	r3, #0
 800bcbe:	d1f9      	bne.n	800bcb4 <stm32_clock_init+0x34>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800bcc0:	4b33      	ldr	r3, [pc, #204]	; (800bd90 <stm32_clock_init+0x110>)
 800bcc2:	681b      	ldr	r3, [r3, #0]
 800bcc4:	4a32      	ldr	r2, [pc, #200]	; (800bd90 <stm32_clock_init+0x110>)
 800bcc6:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 800bcca:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800bccc:	4b30      	ldr	r3, [pc, #192]	; (800bd90 <stm32_clock_init+0x110>)
 800bcce:	2200      	movs	r2, #0
 800bcd0:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 800bcd2:	4b2f      	ldr	r3, [pc, #188]	; (800bd90 <stm32_clock_init+0x110>)
 800bcd4:	681b      	ldr	r3, [r3, #0]
 800bcd6:	4a2e      	ldr	r2, [pc, #184]	; (800bd90 <stm32_clock_init+0x110>)
 800bcd8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800bcdc:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800bcde:	4b2c      	ldr	r3, [pc, #176]	; (800bd90 <stm32_clock_init+0x110>)
 800bce0:	681b      	ldr	r3, [r3, #0]
 800bce2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800bce6:	2b00      	cmp	r3, #0
 800bce8:	d0f9      	beq.n	800bcde <stm32_clock_init+0x5e>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800bcea:	4b29      	ldr	r3, [pc, #164]	; (800bd90 <stm32_clock_init+0x110>)
 800bcec:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bcee:	4a28      	ldr	r2, [pc, #160]	; (800bd90 <stm32_clock_init+0x110>)
 800bcf0:	f043 0301 	orr.w	r3, r3, #1
 800bcf4:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800bcf6:	4b26      	ldr	r3, [pc, #152]	; (800bd90 <stm32_clock_init+0x110>)
 800bcf8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bcfa:	f003 0302 	and.w	r3, r3, #2
 800bcfe:	2b00      	cmp	r3, #0
 800bd00:	d0f9      	beq.n	800bcf6 <stm32_clock_init+0x76>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800bd02:	4b23      	ldr	r3, [pc, #140]	; (800bd90 <stm32_clock_init+0x110>)
 800bd04:	4a24      	ldr	r2, [pc, #144]	; (800bd98 <stm32_clock_init+0x118>)
 800bd06:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800bd08:	4b21      	ldr	r3, [pc, #132]	; (800bd90 <stm32_clock_init+0x110>)
 800bd0a:	681b      	ldr	r3, [r3, #0]
 800bd0c:	4a20      	ldr	r2, [pc, #128]	; (800bd90 <stm32_clock_init+0x110>)
 800bd0e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800bd12:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800bd14:	4b1f      	ldr	r3, [pc, #124]	; (800bd94 <stm32_clock_init+0x114>)
 800bd16:	685b      	ldr	r3, [r3, #4]
 800bd18:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800bd1c:	2b00      	cmp	r3, #0
 800bd1e:	d0f9      	beq.n	800bd14 <stm32_clock_init+0x94>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800bd20:	4b1b      	ldr	r3, [pc, #108]	; (800bd90 <stm32_clock_init+0x110>)
 800bd22:	681b      	ldr	r3, [r3, #0]
 800bd24:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800bd28:	2b00      	cmp	r3, #0
 800bd2a:	d0f9      	beq.n	800bd20 <stm32_clock_init+0xa0>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800bd2c:	4b18      	ldr	r3, [pc, #96]	; (800bd90 <stm32_clock_init+0x110>)
 800bd2e:	4a1b      	ldr	r2, [pc, #108]	; (800bd9c <stm32_clock_init+0x11c>)
 800bd30:	609a      	str	r2, [r3, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800bd32:	4b1b      	ldr	r3, [pc, #108]	; (800bda0 <stm32_clock_init+0x120>)
 800bd34:	681b      	ldr	r3, [r3, #0]
 800bd36:	4a1b      	ldr	r2, [pc, #108]	; (800bda4 <stm32_clock_init+0x124>)
 800bd38:	4293      	cmp	r3, r2
 800bd3a:	d109      	bne.n	800bd50 <stm32_clock_init+0xd0>
 800bd3c:	4b1a      	ldr	r3, [pc, #104]	; (800bda8 <stm32_clock_init+0x128>)
 800bd3e:	681b      	ldr	r3, [r3, #0]
 800bd40:	4a1a      	ldr	r2, [pc, #104]	; (800bdac <stm32_clock_init+0x12c>)
 800bd42:	4293      	cmp	r3, r2
 800bd44:	d104      	bne.n	800bd50 <stm32_clock_init+0xd0>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 800bd46:	4b1a      	ldr	r3, [pc, #104]	; (800bdb0 <stm32_clock_init+0x130>)
 800bd48:	f240 1205 	movw	r2, #261	; 0x105
 800bd4c:	601a      	str	r2, [r3, #0]
 800bd4e:	e003      	b.n	800bd58 <stm32_clock_init+0xd8>
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800bd50:	4b17      	ldr	r3, [pc, #92]	; (800bdb0 <stm32_clock_init+0x130>)
 800bd52:	f240 7205 	movw	r2, #1797	; 0x705
 800bd56:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800bd58:	4b0d      	ldr	r3, [pc, #52]	; (800bd90 <stm32_clock_init+0x110>)
 800bd5a:	689b      	ldr	r3, [r3, #8]
 800bd5c:	4a0c      	ldr	r2, [pc, #48]	; (800bd90 <stm32_clock_init+0x110>)
 800bd5e:	f043 0302 	orr.w	r3, r3, #2
 800bd62:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800bd64:	4b0a      	ldr	r3, [pc, #40]	; (800bd90 <stm32_clock_init+0x110>)
 800bd66:	689b      	ldr	r3, [r3, #8]
 800bd68:	f003 030c 	and.w	r3, r3, #12
 800bd6c:	2b08      	cmp	r3, #8
 800bd6e:	d1f9      	bne.n	800bd64 <stm32_clock_init+0xe4>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 800bd70:	4b07      	ldr	r3, [pc, #28]	; (800bd90 <stm32_clock_init+0x110>)
 800bd72:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800bd74:	4a06      	ldr	r2, [pc, #24]	; (800bd90 <stm32_clock_init+0x110>)
 800bd76:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800bd7a:	6453      	str	r3, [r2, #68]	; 0x44
 800bd7c:	4b04      	ldr	r3, [pc, #16]	; (800bd90 <stm32_clock_init+0x110>)
 800bd7e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800bd80:	4a03      	ldr	r2, [pc, #12]	; (800bd90 <stm32_clock_init+0x110>)
 800bd82:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800bd86:	6653      	str	r3, [r2, #100]	; 0x64
 800bd88:	4b01      	ldr	r3, [pc, #4]	; (800bd90 <stm32_clock_init+0x110>)
 800bd8a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
}
 800bd8c:	4770      	bx	lr
 800bd8e:	bf00      	nop
 800bd90:	40023800 	.word	0x40023800
 800bd94:	40007000 	.word	0x40007000
 800bd98:	07405408 	.word	0x07405408
 800bd9c:	38889400 	.word	0x38889400
 800bda0:	e0042000 	.word	0xe0042000
 800bda4:	20006411 	.word	0x20006411
 800bda8:	e000ed00 	.word	0xe000ed00
 800bdac:	410fc241 	.word	0x410fc241
 800bdb0:	40023c00 	.word	0x40023c00
	...

0800bdc0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 800bdc0:	b500      	push	{lr}
 800bdc2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800bdc4:	4810      	ldr	r0, [pc, #64]	; (800be08 <Vector6C+0x48>)
 800bdc6:	f003 fc0b 	bl	800f5e0 <_trace_isr_enter>
 800bdca:	f003 fad9 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800bdce:	4b0f      	ldr	r3, [pc, #60]	; (800be0c <Vector6C+0x4c>)
 800bdd0:	681b      	ldr	r3, [r3, #0]
 800bdd2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800bdd6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
 800bdd8:	4a0c      	ldr	r2, [pc, #48]	; (800be0c <Vector6C+0x4c>)
 800bdda:	9b01      	ldr	r3, [sp, #4]
 800bddc:	6093      	str	r3, [r2, #8]
  if (dma.streams[0].func)
 800bdde:	4b0c      	ldr	r3, [pc, #48]	; (800be10 <Vector6C+0x50>)
 800bde0:	685b      	ldr	r3, [r3, #4]
 800bde2:	2b00      	cmp	r3, #0
 800bde4:	d006      	beq.n	800bdf4 <Vector6C+0x34>
    dma.streams[0].func(dma.streams[0].param, flags);
 800bde6:	4b0a      	ldr	r3, [pc, #40]	; (800be10 <Vector6C+0x50>)
 800bde8:	685b      	ldr	r3, [r3, #4]
 800bdea:	4a09      	ldr	r2, [pc, #36]	; (800be10 <Vector6C+0x50>)
 800bdec:	6892      	ldr	r2, [r2, #8]
 800bdee:	9901      	ldr	r1, [sp, #4]
 800bdf0:	4610      	mov	r0, r2
 800bdf2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800bdf4:	f003 fae4 	bl	800f3c0 <_dbg_check_leave_isr>
 800bdf8:	4803      	ldr	r0, [pc, #12]	; (800be08 <Vector6C+0x48>)
 800bdfa:	f003 fc19 	bl	800f630 <_trace_isr_leave>
 800bdfe:	f008 faa7 	bl	8014350 <_port_irq_epilogue>
}
 800be02:	b003      	add	sp, #12
 800be04:	f85d fb04 	ldr.w	pc, [sp], #4
 800be08:	08015f24 	.word	0x08015f24
 800be0c:	40026000 	.word	0x40026000
 800be10:	20000d60 	.word	0x20000d60
	...

0800be20 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 800be20:	b500      	push	{lr}
 800be22:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800be24:	4811      	ldr	r0, [pc, #68]	; (800be6c <Vector70+0x4c>)
 800be26:	f003 fbdb 	bl	800f5e0 <_trace_isr_enter>
 800be2a:	f003 faa9 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800be2e:	4b10      	ldr	r3, [pc, #64]	; (800be70 <Vector70+0x50>)
 800be30:	681b      	ldr	r3, [r3, #0]
 800be32:	099b      	lsrs	r3, r3, #6
 800be34:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800be38:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
 800be3a:	4a0d      	ldr	r2, [pc, #52]	; (800be70 <Vector70+0x50>)
 800be3c:	9b01      	ldr	r3, [sp, #4]
 800be3e:	019b      	lsls	r3, r3, #6
 800be40:	6093      	str	r3, [r2, #8]
  if (dma.streams[1].func)
 800be42:	4b0c      	ldr	r3, [pc, #48]	; (800be74 <Vector70+0x54>)
 800be44:	68db      	ldr	r3, [r3, #12]
 800be46:	2b00      	cmp	r3, #0
 800be48:	d006      	beq.n	800be58 <Vector70+0x38>
    dma.streams[1].func(dma.streams[1].param, flags);
 800be4a:	4b0a      	ldr	r3, [pc, #40]	; (800be74 <Vector70+0x54>)
 800be4c:	68db      	ldr	r3, [r3, #12]
 800be4e:	4a09      	ldr	r2, [pc, #36]	; (800be74 <Vector70+0x54>)
 800be50:	6912      	ldr	r2, [r2, #16]
 800be52:	9901      	ldr	r1, [sp, #4]
 800be54:	4610      	mov	r0, r2
 800be56:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800be58:	f003 fab2 	bl	800f3c0 <_dbg_check_leave_isr>
 800be5c:	4803      	ldr	r0, [pc, #12]	; (800be6c <Vector70+0x4c>)
 800be5e:	f003 fbe7 	bl	800f630 <_trace_isr_leave>
 800be62:	f008 fa75 	bl	8014350 <_port_irq_epilogue>
}
 800be66:	b003      	add	sp, #12
 800be68:	f85d fb04 	ldr.w	pc, [sp], #4
 800be6c:	08015f30 	.word	0x08015f30
 800be70:	40026000 	.word	0x40026000
 800be74:	20000d60 	.word	0x20000d60
	...

0800be80 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 800be80:	b500      	push	{lr}
 800be82:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800be84:	4811      	ldr	r0, [pc, #68]	; (800becc <Vector74+0x4c>)
 800be86:	f003 fbab 	bl	800f5e0 <_trace_isr_enter>
 800be8a:	f003 fa79 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800be8e:	4b10      	ldr	r3, [pc, #64]	; (800bed0 <Vector74+0x50>)
 800be90:	681b      	ldr	r3, [r3, #0]
 800be92:	0c1b      	lsrs	r3, r3, #16
 800be94:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800be98:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
 800be9a:	4a0d      	ldr	r2, [pc, #52]	; (800bed0 <Vector74+0x50>)
 800be9c:	9b01      	ldr	r3, [sp, #4]
 800be9e:	041b      	lsls	r3, r3, #16
 800bea0:	6093      	str	r3, [r2, #8]
  if (dma.streams[2].func)
 800bea2:	4b0c      	ldr	r3, [pc, #48]	; (800bed4 <Vector74+0x54>)
 800bea4:	695b      	ldr	r3, [r3, #20]
 800bea6:	2b00      	cmp	r3, #0
 800bea8:	d006      	beq.n	800beb8 <Vector74+0x38>
    dma.streams[2].func(dma.streams[2].param, flags);
 800beaa:	4b0a      	ldr	r3, [pc, #40]	; (800bed4 <Vector74+0x54>)
 800beac:	695b      	ldr	r3, [r3, #20]
 800beae:	4a09      	ldr	r2, [pc, #36]	; (800bed4 <Vector74+0x54>)
 800beb0:	6992      	ldr	r2, [r2, #24]
 800beb2:	9901      	ldr	r1, [sp, #4]
 800beb4:	4610      	mov	r0, r2
 800beb6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800beb8:	f003 fa82 	bl	800f3c0 <_dbg_check_leave_isr>
 800bebc:	4803      	ldr	r0, [pc, #12]	; (800becc <Vector74+0x4c>)
 800bebe:	f003 fbb7 	bl	800f630 <_trace_isr_leave>
 800bec2:	f008 fa45 	bl	8014350 <_port_irq_epilogue>
}
 800bec6:	b003      	add	sp, #12
 800bec8:	f85d fb04 	ldr.w	pc, [sp], #4
 800becc:	08015f3c 	.word	0x08015f3c
 800bed0:	40026000 	.word	0x40026000
 800bed4:	20000d60 	.word	0x20000d60
	...

0800bee0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 800bee0:	b500      	push	{lr}
 800bee2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800bee4:	4811      	ldr	r0, [pc, #68]	; (800bf2c <Vector78+0x4c>)
 800bee6:	f003 fb7b 	bl	800f5e0 <_trace_isr_enter>
 800beea:	f003 fa49 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800beee:	4b10      	ldr	r3, [pc, #64]	; (800bf30 <Vector78+0x50>)
 800bef0:	681b      	ldr	r3, [r3, #0]
 800bef2:	0d9b      	lsrs	r3, r3, #22
 800bef4:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800bef8:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
 800befa:	4a0d      	ldr	r2, [pc, #52]	; (800bf30 <Vector78+0x50>)
 800befc:	9b01      	ldr	r3, [sp, #4]
 800befe:	059b      	lsls	r3, r3, #22
 800bf00:	6093      	str	r3, [r2, #8]
  if (dma.streams[3].func)
 800bf02:	4b0c      	ldr	r3, [pc, #48]	; (800bf34 <Vector78+0x54>)
 800bf04:	69db      	ldr	r3, [r3, #28]
 800bf06:	2b00      	cmp	r3, #0
 800bf08:	d006      	beq.n	800bf18 <Vector78+0x38>
    dma.streams[3].func(dma.streams[3].param, flags);
 800bf0a:	4b0a      	ldr	r3, [pc, #40]	; (800bf34 <Vector78+0x54>)
 800bf0c:	69db      	ldr	r3, [r3, #28]
 800bf0e:	4a09      	ldr	r2, [pc, #36]	; (800bf34 <Vector78+0x54>)
 800bf10:	6a12      	ldr	r2, [r2, #32]
 800bf12:	9901      	ldr	r1, [sp, #4]
 800bf14:	4610      	mov	r0, r2
 800bf16:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800bf18:	f003 fa52 	bl	800f3c0 <_dbg_check_leave_isr>
 800bf1c:	4803      	ldr	r0, [pc, #12]	; (800bf2c <Vector78+0x4c>)
 800bf1e:	f003 fb87 	bl	800f630 <_trace_isr_leave>
 800bf22:	f008 fa15 	bl	8014350 <_port_irq_epilogue>
}
 800bf26:	b003      	add	sp, #12
 800bf28:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf2c:	08015f48 	.word	0x08015f48
 800bf30:	40026000 	.word	0x40026000
 800bf34:	20000d60 	.word	0x20000d60
	...

0800bf40 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 800bf40:	b500      	push	{lr}
 800bf42:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800bf44:	4810      	ldr	r0, [pc, #64]	; (800bf88 <Vector7C+0x48>)
 800bf46:	f003 fb4b 	bl	800f5e0 <_trace_isr_enter>
 800bf4a:	f003 fa19 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800bf4e:	4b0f      	ldr	r3, [pc, #60]	; (800bf8c <Vector7C+0x4c>)
 800bf50:	685b      	ldr	r3, [r3, #4]
 800bf52:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800bf56:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
 800bf58:	4a0c      	ldr	r2, [pc, #48]	; (800bf8c <Vector7C+0x4c>)
 800bf5a:	9b01      	ldr	r3, [sp, #4]
 800bf5c:	60d3      	str	r3, [r2, #12]
  if (dma.streams[4].func)
 800bf5e:	4b0c      	ldr	r3, [pc, #48]	; (800bf90 <Vector7C+0x50>)
 800bf60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bf62:	2b00      	cmp	r3, #0
 800bf64:	d006      	beq.n	800bf74 <Vector7C+0x34>
    dma.streams[4].func(dma.streams[4].param, flags);
 800bf66:	4b0a      	ldr	r3, [pc, #40]	; (800bf90 <Vector7C+0x50>)
 800bf68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bf6a:	4a09      	ldr	r2, [pc, #36]	; (800bf90 <Vector7C+0x50>)
 800bf6c:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800bf6e:	9901      	ldr	r1, [sp, #4]
 800bf70:	4610      	mov	r0, r2
 800bf72:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800bf74:	f003 fa24 	bl	800f3c0 <_dbg_check_leave_isr>
 800bf78:	4803      	ldr	r0, [pc, #12]	; (800bf88 <Vector7C+0x48>)
 800bf7a:	f003 fb59 	bl	800f630 <_trace_isr_leave>
 800bf7e:	f008 f9e7 	bl	8014350 <_port_irq_epilogue>
}
 800bf82:	b003      	add	sp, #12
 800bf84:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf88:	08015f54 	.word	0x08015f54
 800bf8c:	40026000 	.word	0x40026000
 800bf90:	20000d60 	.word	0x20000d60
	...

0800bfa0 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 800bfa0:	b500      	push	{lr}
 800bfa2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800bfa4:	4811      	ldr	r0, [pc, #68]	; (800bfec <Vector80+0x4c>)
 800bfa6:	f003 fb1b 	bl	800f5e0 <_trace_isr_enter>
 800bfaa:	f003 f9e9 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800bfae:	4b10      	ldr	r3, [pc, #64]	; (800bff0 <Vector80+0x50>)
 800bfb0:	685b      	ldr	r3, [r3, #4]
 800bfb2:	099b      	lsrs	r3, r3, #6
 800bfb4:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800bfb8:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
 800bfba:	4a0d      	ldr	r2, [pc, #52]	; (800bff0 <Vector80+0x50>)
 800bfbc:	9b01      	ldr	r3, [sp, #4]
 800bfbe:	019b      	lsls	r3, r3, #6
 800bfc0:	60d3      	str	r3, [r2, #12]
  if (dma.streams[5].func)
 800bfc2:	4b0c      	ldr	r3, [pc, #48]	; (800bff4 <Vector80+0x54>)
 800bfc4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bfc6:	2b00      	cmp	r3, #0
 800bfc8:	d006      	beq.n	800bfd8 <Vector80+0x38>
    dma.streams[5].func(dma.streams[5].param, flags);
 800bfca:	4b0a      	ldr	r3, [pc, #40]	; (800bff4 <Vector80+0x54>)
 800bfcc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bfce:	4a09      	ldr	r2, [pc, #36]	; (800bff4 <Vector80+0x54>)
 800bfd0:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800bfd2:	9901      	ldr	r1, [sp, #4]
 800bfd4:	4610      	mov	r0, r2
 800bfd6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800bfd8:	f003 f9f2 	bl	800f3c0 <_dbg_check_leave_isr>
 800bfdc:	4803      	ldr	r0, [pc, #12]	; (800bfec <Vector80+0x4c>)
 800bfde:	f003 fb27 	bl	800f630 <_trace_isr_leave>
 800bfe2:	f008 f9b5 	bl	8014350 <_port_irq_epilogue>
}
 800bfe6:	b003      	add	sp, #12
 800bfe8:	f85d fb04 	ldr.w	pc, [sp], #4
 800bfec:	08015f60 	.word	0x08015f60
 800bff0:	40026000 	.word	0x40026000
 800bff4:	20000d60 	.word	0x20000d60
	...

0800c000 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 800c000:	b500      	push	{lr}
 800c002:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c004:	4811      	ldr	r0, [pc, #68]	; (800c04c <Vector84+0x4c>)
 800c006:	f003 faeb 	bl	800f5e0 <_trace_isr_enter>
 800c00a:	f003 f9b9 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800c00e:	4b10      	ldr	r3, [pc, #64]	; (800c050 <Vector84+0x50>)
 800c010:	685b      	ldr	r3, [r3, #4]
 800c012:	0c1b      	lsrs	r3, r3, #16
 800c014:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800c018:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
 800c01a:	4a0d      	ldr	r2, [pc, #52]	; (800c050 <Vector84+0x50>)
 800c01c:	9b01      	ldr	r3, [sp, #4]
 800c01e:	041b      	lsls	r3, r3, #16
 800c020:	60d3      	str	r3, [r2, #12]
  if (dma.streams[6].func)
 800c022:	4b0c      	ldr	r3, [pc, #48]	; (800c054 <Vector84+0x54>)
 800c024:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c026:	2b00      	cmp	r3, #0
 800c028:	d006      	beq.n	800c038 <Vector84+0x38>
    dma.streams[6].func(dma.streams[6].param, flags);
 800c02a:	4b0a      	ldr	r3, [pc, #40]	; (800c054 <Vector84+0x54>)
 800c02c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c02e:	4a09      	ldr	r2, [pc, #36]	; (800c054 <Vector84+0x54>)
 800c030:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800c032:	9901      	ldr	r1, [sp, #4]
 800c034:	4610      	mov	r0, r2
 800c036:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800c038:	f003 f9c2 	bl	800f3c0 <_dbg_check_leave_isr>
 800c03c:	4803      	ldr	r0, [pc, #12]	; (800c04c <Vector84+0x4c>)
 800c03e:	f003 faf7 	bl	800f630 <_trace_isr_leave>
 800c042:	f008 f985 	bl	8014350 <_port_irq_epilogue>
}
 800c046:	b003      	add	sp, #12
 800c048:	f85d fb04 	ldr.w	pc, [sp], #4
 800c04c:	08015f6c 	.word	0x08015f6c
 800c050:	40026000 	.word	0x40026000
 800c054:	20000d60 	.word	0x20000d60
	...

0800c060 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 800c060:	b500      	push	{lr}
 800c062:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c064:	4811      	ldr	r0, [pc, #68]	; (800c0ac <VectorFC+0x4c>)
 800c066:	f003 fabb 	bl	800f5e0 <_trace_isr_enter>
 800c06a:	f003 f989 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800c06e:	4b10      	ldr	r3, [pc, #64]	; (800c0b0 <VectorFC+0x50>)
 800c070:	685b      	ldr	r3, [r3, #4]
 800c072:	0d9b      	lsrs	r3, r3, #22
 800c074:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800c078:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
 800c07a:	4a0d      	ldr	r2, [pc, #52]	; (800c0b0 <VectorFC+0x50>)
 800c07c:	9b01      	ldr	r3, [sp, #4]
 800c07e:	059b      	lsls	r3, r3, #22
 800c080:	60d3      	str	r3, [r2, #12]
  if (dma.streams[7].func)
 800c082:	4b0c      	ldr	r3, [pc, #48]	; (800c0b4 <VectorFC+0x54>)
 800c084:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c086:	2b00      	cmp	r3, #0
 800c088:	d006      	beq.n	800c098 <VectorFC+0x38>
    dma.streams[7].func(dma.streams[7].param, flags);
 800c08a:	4b0a      	ldr	r3, [pc, #40]	; (800c0b4 <VectorFC+0x54>)
 800c08c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c08e:	4a09      	ldr	r2, [pc, #36]	; (800c0b4 <VectorFC+0x54>)
 800c090:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800c092:	9901      	ldr	r1, [sp, #4]
 800c094:	4610      	mov	r0, r2
 800c096:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800c098:	f003 f992 	bl	800f3c0 <_dbg_check_leave_isr>
 800c09c:	4803      	ldr	r0, [pc, #12]	; (800c0ac <VectorFC+0x4c>)
 800c09e:	f003 fac7 	bl	800f630 <_trace_isr_leave>
 800c0a2:	f008 f955 	bl	8014350 <_port_irq_epilogue>
}
 800c0a6:	b003      	add	sp, #12
 800c0a8:	f85d fb04 	ldr.w	pc, [sp], #4
 800c0ac:	08015f78 	.word	0x08015f78
 800c0b0:	40026000 	.word	0x40026000
 800c0b4:	20000d60 	.word	0x20000d60
	...

0800c0c0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 800c0c0:	b500      	push	{lr}
 800c0c2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c0c4:	4810      	ldr	r0, [pc, #64]	; (800c108 <Vector120+0x48>)
 800c0c6:	f003 fa8b 	bl	800f5e0 <_trace_isr_enter>
 800c0ca:	f003 f959 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800c0ce:	4b0f      	ldr	r3, [pc, #60]	; (800c10c <Vector120+0x4c>)
 800c0d0:	681b      	ldr	r3, [r3, #0]
 800c0d2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800c0d6:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
 800c0d8:	4a0c      	ldr	r2, [pc, #48]	; (800c10c <Vector120+0x4c>)
 800c0da:	9b01      	ldr	r3, [sp, #4]
 800c0dc:	6093      	str	r3, [r2, #8]
  if (dma.streams[8].func)
 800c0de:	4b0c      	ldr	r3, [pc, #48]	; (800c110 <Vector120+0x50>)
 800c0e0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c0e2:	2b00      	cmp	r3, #0
 800c0e4:	d006      	beq.n	800c0f4 <Vector120+0x34>
    dma.streams[8].func(dma.streams[8].param, flags);
 800c0e6:	4b0a      	ldr	r3, [pc, #40]	; (800c110 <Vector120+0x50>)
 800c0e8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c0ea:	4a09      	ldr	r2, [pc, #36]	; (800c110 <Vector120+0x50>)
 800c0ec:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800c0ee:	9901      	ldr	r1, [sp, #4]
 800c0f0:	4610      	mov	r0, r2
 800c0f2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800c0f4:	f003 f964 	bl	800f3c0 <_dbg_check_leave_isr>
 800c0f8:	4803      	ldr	r0, [pc, #12]	; (800c108 <Vector120+0x48>)
 800c0fa:	f003 fa99 	bl	800f630 <_trace_isr_leave>
 800c0fe:	f008 f927 	bl	8014350 <_port_irq_epilogue>
}
 800c102:	b003      	add	sp, #12
 800c104:	f85d fb04 	ldr.w	pc, [sp], #4
 800c108:	08015f84 	.word	0x08015f84
 800c10c:	40026400 	.word	0x40026400
 800c110:	20000d60 	.word	0x20000d60
	...

0800c120 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 800c120:	b500      	push	{lr}
 800c122:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c124:	4811      	ldr	r0, [pc, #68]	; (800c16c <Vector124+0x4c>)
 800c126:	f003 fa5b 	bl	800f5e0 <_trace_isr_enter>
 800c12a:	f003 f929 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800c12e:	4b10      	ldr	r3, [pc, #64]	; (800c170 <Vector124+0x50>)
 800c130:	681b      	ldr	r3, [r3, #0]
 800c132:	099b      	lsrs	r3, r3, #6
 800c134:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800c138:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
 800c13a:	4a0d      	ldr	r2, [pc, #52]	; (800c170 <Vector124+0x50>)
 800c13c:	9b01      	ldr	r3, [sp, #4]
 800c13e:	019b      	lsls	r3, r3, #6
 800c140:	6093      	str	r3, [r2, #8]
  if (dma.streams[9].func)
 800c142:	4b0c      	ldr	r3, [pc, #48]	; (800c174 <Vector124+0x54>)
 800c144:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c146:	2b00      	cmp	r3, #0
 800c148:	d006      	beq.n	800c158 <Vector124+0x38>
    dma.streams[9].func(dma.streams[9].param, flags);
 800c14a:	4b0a      	ldr	r3, [pc, #40]	; (800c174 <Vector124+0x54>)
 800c14c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c14e:	4a09      	ldr	r2, [pc, #36]	; (800c174 <Vector124+0x54>)
 800c150:	6d12      	ldr	r2, [r2, #80]	; 0x50
 800c152:	9901      	ldr	r1, [sp, #4]
 800c154:	4610      	mov	r0, r2
 800c156:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800c158:	f003 f932 	bl	800f3c0 <_dbg_check_leave_isr>
 800c15c:	4803      	ldr	r0, [pc, #12]	; (800c16c <Vector124+0x4c>)
 800c15e:	f003 fa67 	bl	800f630 <_trace_isr_leave>
 800c162:	f008 f8f5 	bl	8014350 <_port_irq_epilogue>
}
 800c166:	b003      	add	sp, #12
 800c168:	f85d fb04 	ldr.w	pc, [sp], #4
 800c16c:	08015f90 	.word	0x08015f90
 800c170:	40026400 	.word	0x40026400
 800c174:	20000d60 	.word	0x20000d60
	...

0800c180 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 800c180:	b500      	push	{lr}
 800c182:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c184:	4811      	ldr	r0, [pc, #68]	; (800c1cc <Vector128+0x4c>)
 800c186:	f003 fa2b 	bl	800f5e0 <_trace_isr_enter>
 800c18a:	f003 f8f9 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800c18e:	4b10      	ldr	r3, [pc, #64]	; (800c1d0 <Vector128+0x50>)
 800c190:	681b      	ldr	r3, [r3, #0]
 800c192:	0c1b      	lsrs	r3, r3, #16
 800c194:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800c198:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
 800c19a:	4a0d      	ldr	r2, [pc, #52]	; (800c1d0 <Vector128+0x50>)
 800c19c:	9b01      	ldr	r3, [sp, #4]
 800c19e:	041b      	lsls	r3, r3, #16
 800c1a0:	6093      	str	r3, [r2, #8]
  if (dma.streams[10].func)
 800c1a2:	4b0c      	ldr	r3, [pc, #48]	; (800c1d4 <Vector128+0x54>)
 800c1a4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800c1a6:	2b00      	cmp	r3, #0
 800c1a8:	d006      	beq.n	800c1b8 <Vector128+0x38>
    dma.streams[10].func(dma.streams[10].param, flags);
 800c1aa:	4b0a      	ldr	r3, [pc, #40]	; (800c1d4 <Vector128+0x54>)
 800c1ac:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800c1ae:	4a09      	ldr	r2, [pc, #36]	; (800c1d4 <Vector128+0x54>)
 800c1b0:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800c1b2:	9901      	ldr	r1, [sp, #4]
 800c1b4:	4610      	mov	r0, r2
 800c1b6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800c1b8:	f003 f902 	bl	800f3c0 <_dbg_check_leave_isr>
 800c1bc:	4803      	ldr	r0, [pc, #12]	; (800c1cc <Vector128+0x4c>)
 800c1be:	f003 fa37 	bl	800f630 <_trace_isr_leave>
 800c1c2:	f008 f8c5 	bl	8014350 <_port_irq_epilogue>
}
 800c1c6:	b003      	add	sp, #12
 800c1c8:	f85d fb04 	ldr.w	pc, [sp], #4
 800c1cc:	08015f9c 	.word	0x08015f9c
 800c1d0:	40026400 	.word	0x40026400
 800c1d4:	20000d60 	.word	0x20000d60
	...

0800c1e0 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 800c1e0:	b500      	push	{lr}
 800c1e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c1e4:	4811      	ldr	r0, [pc, #68]	; (800c22c <Vector12C+0x4c>)
 800c1e6:	f003 f9fb 	bl	800f5e0 <_trace_isr_enter>
 800c1ea:	f003 f8c9 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800c1ee:	4b10      	ldr	r3, [pc, #64]	; (800c230 <Vector12C+0x50>)
 800c1f0:	681b      	ldr	r3, [r3, #0]
 800c1f2:	0d9b      	lsrs	r3, r3, #22
 800c1f4:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800c1f8:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
 800c1fa:	4a0d      	ldr	r2, [pc, #52]	; (800c230 <Vector12C+0x50>)
 800c1fc:	9b01      	ldr	r3, [sp, #4]
 800c1fe:	059b      	lsls	r3, r3, #22
 800c200:	6093      	str	r3, [r2, #8]
  if (dma.streams[11].func)
 800c202:	4b0c      	ldr	r3, [pc, #48]	; (800c234 <Vector12C+0x54>)
 800c204:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800c206:	2b00      	cmp	r3, #0
 800c208:	d006      	beq.n	800c218 <Vector12C+0x38>
    dma.streams[11].func(dma.streams[11].param, flags);
 800c20a:	4b0a      	ldr	r3, [pc, #40]	; (800c234 <Vector12C+0x54>)
 800c20c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800c20e:	4a09      	ldr	r2, [pc, #36]	; (800c234 <Vector12C+0x54>)
 800c210:	6e12      	ldr	r2, [r2, #96]	; 0x60
 800c212:	9901      	ldr	r1, [sp, #4]
 800c214:	4610      	mov	r0, r2
 800c216:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800c218:	f003 f8d2 	bl	800f3c0 <_dbg_check_leave_isr>
 800c21c:	4803      	ldr	r0, [pc, #12]	; (800c22c <Vector12C+0x4c>)
 800c21e:	f003 fa07 	bl	800f630 <_trace_isr_leave>
 800c222:	f008 f895 	bl	8014350 <_port_irq_epilogue>
}
 800c226:	b003      	add	sp, #12
 800c228:	f85d fb04 	ldr.w	pc, [sp], #4
 800c22c:	08015fa8 	.word	0x08015fa8
 800c230:	40026400 	.word	0x40026400
 800c234:	20000d60 	.word	0x20000d60
	...

0800c240 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 800c240:	b500      	push	{lr}
 800c242:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c244:	4810      	ldr	r0, [pc, #64]	; (800c288 <Vector130+0x48>)
 800c246:	f003 f9cb 	bl	800f5e0 <_trace_isr_enter>
 800c24a:	f003 f899 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800c24e:	4b0f      	ldr	r3, [pc, #60]	; (800c28c <Vector130+0x4c>)
 800c250:	685b      	ldr	r3, [r3, #4]
 800c252:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800c256:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
 800c258:	4a0c      	ldr	r2, [pc, #48]	; (800c28c <Vector130+0x4c>)
 800c25a:	9b01      	ldr	r3, [sp, #4]
 800c25c:	60d3      	str	r3, [r2, #12]
  if (dma.streams[12].func)
 800c25e:	4b0c      	ldr	r3, [pc, #48]	; (800c290 <Vector130+0x50>)
 800c260:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800c262:	2b00      	cmp	r3, #0
 800c264:	d006      	beq.n	800c274 <Vector130+0x34>
    dma.streams[12].func(dma.streams[12].param, flags);
 800c266:	4b0a      	ldr	r3, [pc, #40]	; (800c290 <Vector130+0x50>)
 800c268:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800c26a:	4a09      	ldr	r2, [pc, #36]	; (800c290 <Vector130+0x50>)
 800c26c:	6e92      	ldr	r2, [r2, #104]	; 0x68
 800c26e:	9901      	ldr	r1, [sp, #4]
 800c270:	4610      	mov	r0, r2
 800c272:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800c274:	f003 f8a4 	bl	800f3c0 <_dbg_check_leave_isr>
 800c278:	4803      	ldr	r0, [pc, #12]	; (800c288 <Vector130+0x48>)
 800c27a:	f003 f9d9 	bl	800f630 <_trace_isr_leave>
 800c27e:	f008 f867 	bl	8014350 <_port_irq_epilogue>
}
 800c282:	b003      	add	sp, #12
 800c284:	f85d fb04 	ldr.w	pc, [sp], #4
 800c288:	08015fb4 	.word	0x08015fb4
 800c28c:	40026400 	.word	0x40026400
 800c290:	20000d60 	.word	0x20000d60
	...

0800c2a0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 800c2a0:	b500      	push	{lr}
 800c2a2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c2a4:	4811      	ldr	r0, [pc, #68]	; (800c2ec <Vector150+0x4c>)
 800c2a6:	f003 f99b 	bl	800f5e0 <_trace_isr_enter>
 800c2aa:	f003 f869 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800c2ae:	4b10      	ldr	r3, [pc, #64]	; (800c2f0 <Vector150+0x50>)
 800c2b0:	685b      	ldr	r3, [r3, #4]
 800c2b2:	099b      	lsrs	r3, r3, #6
 800c2b4:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800c2b8:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
 800c2ba:	4a0d      	ldr	r2, [pc, #52]	; (800c2f0 <Vector150+0x50>)
 800c2bc:	9b01      	ldr	r3, [sp, #4]
 800c2be:	019b      	lsls	r3, r3, #6
 800c2c0:	60d3      	str	r3, [r2, #12]
  if (dma.streams[13].func)
 800c2c2:	4b0c      	ldr	r3, [pc, #48]	; (800c2f4 <Vector150+0x54>)
 800c2c4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c2c6:	2b00      	cmp	r3, #0
 800c2c8:	d006      	beq.n	800c2d8 <Vector150+0x38>
    dma.streams[13].func(dma.streams[13].param, flags);
 800c2ca:	4b0a      	ldr	r3, [pc, #40]	; (800c2f4 <Vector150+0x54>)
 800c2cc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c2ce:	4a09      	ldr	r2, [pc, #36]	; (800c2f4 <Vector150+0x54>)
 800c2d0:	6f12      	ldr	r2, [r2, #112]	; 0x70
 800c2d2:	9901      	ldr	r1, [sp, #4]
 800c2d4:	4610      	mov	r0, r2
 800c2d6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800c2d8:	f003 f872 	bl	800f3c0 <_dbg_check_leave_isr>
 800c2dc:	4803      	ldr	r0, [pc, #12]	; (800c2ec <Vector150+0x4c>)
 800c2de:	f003 f9a7 	bl	800f630 <_trace_isr_leave>
 800c2e2:	f008 f835 	bl	8014350 <_port_irq_epilogue>
}
 800c2e6:	b003      	add	sp, #12
 800c2e8:	f85d fb04 	ldr.w	pc, [sp], #4
 800c2ec:	08015fc0 	.word	0x08015fc0
 800c2f0:	40026400 	.word	0x40026400
 800c2f4:	20000d60 	.word	0x20000d60
	...

0800c300 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 800c300:	b500      	push	{lr}
 800c302:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c304:	4811      	ldr	r0, [pc, #68]	; (800c34c <Vector154+0x4c>)
 800c306:	f003 f96b 	bl	800f5e0 <_trace_isr_enter>
 800c30a:	f003 f839 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800c30e:	4b10      	ldr	r3, [pc, #64]	; (800c350 <Vector154+0x50>)
 800c310:	685b      	ldr	r3, [r3, #4]
 800c312:	0c1b      	lsrs	r3, r3, #16
 800c314:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800c318:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
 800c31a:	4a0d      	ldr	r2, [pc, #52]	; (800c350 <Vector154+0x50>)
 800c31c:	9b01      	ldr	r3, [sp, #4]
 800c31e:	041b      	lsls	r3, r3, #16
 800c320:	60d3      	str	r3, [r2, #12]
  if (dma.streams[14].func)
 800c322:	4b0c      	ldr	r3, [pc, #48]	; (800c354 <Vector154+0x54>)
 800c324:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c326:	2b00      	cmp	r3, #0
 800c328:	d006      	beq.n	800c338 <Vector154+0x38>
    dma.streams[14].func(dma.streams[14].param, flags);
 800c32a:	4b0a      	ldr	r3, [pc, #40]	; (800c354 <Vector154+0x54>)
 800c32c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c32e:	4a09      	ldr	r2, [pc, #36]	; (800c354 <Vector154+0x54>)
 800c330:	6f92      	ldr	r2, [r2, #120]	; 0x78
 800c332:	9901      	ldr	r1, [sp, #4]
 800c334:	4610      	mov	r0, r2
 800c336:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800c338:	f003 f842 	bl	800f3c0 <_dbg_check_leave_isr>
 800c33c:	4803      	ldr	r0, [pc, #12]	; (800c34c <Vector154+0x4c>)
 800c33e:	f003 f977 	bl	800f630 <_trace_isr_leave>
 800c342:	f008 f805 	bl	8014350 <_port_irq_epilogue>
}
 800c346:	b003      	add	sp, #12
 800c348:	f85d fb04 	ldr.w	pc, [sp], #4
 800c34c:	08015fcc 	.word	0x08015fcc
 800c350:	40026400 	.word	0x40026400
 800c354:	20000d60 	.word	0x20000d60
	...

0800c360 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 800c360:	b500      	push	{lr}
 800c362:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c364:	4812      	ldr	r0, [pc, #72]	; (800c3b0 <Vector158+0x50>)
 800c366:	f003 f93b 	bl	800f5e0 <_trace_isr_enter>
 800c36a:	f003 f809 	bl	800f380 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800c36e:	4b11      	ldr	r3, [pc, #68]	; (800c3b4 <Vector158+0x54>)
 800c370:	685b      	ldr	r3, [r3, #4]
 800c372:	0d9b      	lsrs	r3, r3, #22
 800c374:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800c378:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
 800c37a:	4a0e      	ldr	r2, [pc, #56]	; (800c3b4 <Vector158+0x54>)
 800c37c:	9b01      	ldr	r3, [sp, #4]
 800c37e:	059b      	lsls	r3, r3, #22
 800c380:	60d3      	str	r3, [r2, #12]
  if (dma.streams[15].func)
 800c382:	4b0d      	ldr	r3, [pc, #52]	; (800c3b8 <Vector158+0x58>)
 800c384:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c386:	2b00      	cmp	r3, #0
 800c388:	d007      	beq.n	800c39a <Vector158+0x3a>
    dma.streams[15].func(dma.streams[15].param, flags);
 800c38a:	4b0b      	ldr	r3, [pc, #44]	; (800c3b8 <Vector158+0x58>)
 800c38c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c38e:	4a0a      	ldr	r2, [pc, #40]	; (800c3b8 <Vector158+0x58>)
 800c390:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
 800c394:	9901      	ldr	r1, [sp, #4]
 800c396:	4610      	mov	r0, r2
 800c398:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800c39a:	f003 f811 	bl	800f3c0 <_dbg_check_leave_isr>
 800c39e:	4804      	ldr	r0, [pc, #16]	; (800c3b0 <Vector158+0x50>)
 800c3a0:	f003 f946 	bl	800f630 <_trace_isr_leave>
 800c3a4:	f007 ffd4 	bl	8014350 <_port_irq_epilogue>
}
 800c3a8:	b003      	add	sp, #12
 800c3aa:	f85d fb04 	ldr.w	pc, [sp], #4
 800c3ae:	bf00      	nop
 800c3b0:	08015fd8 	.word	0x08015fd8
 800c3b4:	40026400 	.word	0x40026400
 800c3b8:	20000d60 	.word	0x20000d60
 800c3bc:	00000000 	.word	0x00000000

0800c3c0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 800c3c0:	b082      	sub	sp, #8
  unsigned i;

  dma.allocated_mask = 0U;
 800c3c2:	4b17      	ldr	r3, [pc, #92]	; (800c420 <dmaInit+0x60>)
 800c3c4:	2200      	movs	r2, #0
 800c3c6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 800c3c8:	2300      	movs	r3, #0
 800c3ca:	9301      	str	r3, [sp, #4]
 800c3cc:	e012      	b.n	800c3f4 <dmaInit+0x34>
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 800c3ce:	4915      	ldr	r1, [pc, #84]	; (800c424 <dmaInit+0x64>)
 800c3d0:	9a01      	ldr	r2, [sp, #4]
 800c3d2:	4613      	mov	r3, r2
 800c3d4:	005b      	lsls	r3, r3, #1
 800c3d6:	4413      	add	r3, r2
 800c3d8:	009b      	lsls	r3, r3, #2
 800c3da:	440b      	add	r3, r1
 800c3dc:	681b      	ldr	r3, [r3, #0]
 800c3de:	2200      	movs	r2, #0
 800c3e0:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 800c3e2:	4a0f      	ldr	r2, [pc, #60]	; (800c420 <dmaInit+0x60>)
 800c3e4:	9b01      	ldr	r3, [sp, #4]
 800c3e6:	00db      	lsls	r3, r3, #3
 800c3e8:	4413      	add	r3, r2
 800c3ea:	2200      	movs	r2, #0
 800c3ec:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 800c3ee:	9b01      	ldr	r3, [sp, #4]
 800c3f0:	3301      	adds	r3, #1
 800c3f2:	9301      	str	r3, [sp, #4]
 800c3f4:	9b01      	ldr	r3, [sp, #4]
 800c3f6:	2b0f      	cmp	r3, #15
 800c3f8:	d9e9      	bls.n	800c3ce <dmaInit+0xe>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 800c3fa:	4b0b      	ldr	r3, [pc, #44]	; (800c428 <dmaInit+0x68>)
 800c3fc:	f04f 32ff 	mov.w	r2, #4294967295
 800c400:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 800c402:	4b09      	ldr	r3, [pc, #36]	; (800c428 <dmaInit+0x68>)
 800c404:	f04f 32ff 	mov.w	r2, #4294967295
 800c408:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 800c40a:	4b08      	ldr	r3, [pc, #32]	; (800c42c <dmaInit+0x6c>)
 800c40c:	f04f 32ff 	mov.w	r2, #4294967295
 800c410:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 800c412:	4b06      	ldr	r3, [pc, #24]	; (800c42c <dmaInit+0x6c>)
 800c414:	f04f 32ff 	mov.w	r2, #4294967295
 800c418:	60da      	str	r2, [r3, #12]
}
 800c41a:	b002      	add	sp, #8
 800c41c:	4770      	bx	lr
 800c41e:	bf00      	nop
 800c420:	20000d60 	.word	0x20000d60
 800c424:	08015e64 	.word	0x08015e64
 800c428:	40026000 	.word	0x40026000
 800c42c:	40026400 	.word	0x40026400

0800c430 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 800c430:	b500      	push	{lr}
 800c432:	b08b      	sub	sp, #44	; 0x2c
 800c434:	9003      	str	r0, [sp, #12]
 800c436:	9102      	str	r1, [sp, #8]
 800c438:	9201      	str	r2, [sp, #4]
 800c43a:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 800c43c:	f002 ffe0 	bl	800f400 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 800c440:	9b03      	ldr	r3, [sp, #12]
 800c442:	2b0f      	cmp	r3, #15
 800c444:	d806      	bhi.n	800c454 <dmaStreamAllocI+0x24>
    startid = id;
 800c446:	9b03      	ldr	r3, [sp, #12]
 800c448:	9308      	str	r3, [sp, #32]
    endid   = id;
 800c44a:	9b03      	ldr	r3, [sp, #12]
 800c44c:	9307      	str	r3, [sp, #28]
  else {
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
 800c44e:	9b08      	ldr	r3, [sp, #32]
 800c450:	9309      	str	r3, [sp, #36]	; 0x24
 800c452:	e07b      	b.n	800c54c <dmaStreamAllocI+0x11c>
    osalDbgCheck(false);
 800c454:	4842      	ldr	r0, [pc, #264]	; (800c560 <dmaStreamAllocI+0x130>)
 800c456:	f002 fdc3 	bl	800efe0 <chSysHalt>
    return NULL;
 800c45a:	2300      	movs	r3, #0
 800c45c:	e07b      	b.n	800c556 <dmaStreamAllocI+0x126>
    uint32_t mask = (1U << i);
 800c45e:	2201      	movs	r2, #1
 800c460:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c462:	fa02 f303 	lsl.w	r3, r2, r3
 800c466:	9306      	str	r3, [sp, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 800c468:	4b3e      	ldr	r3, [pc, #248]	; (800c564 <dmaStreamAllocI+0x134>)
 800c46a:	681a      	ldr	r2, [r3, #0]
 800c46c:	9b06      	ldr	r3, [sp, #24]
 800c46e:	4013      	ands	r3, r2
 800c470:	2b00      	cmp	r3, #0
 800c472:	d168      	bne.n	800c546 <dmaStreamAllocI+0x116>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 800c474:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c476:	4613      	mov	r3, r2
 800c478:	005b      	lsls	r3, r3, #1
 800c47a:	4413      	add	r3, r2
 800c47c:	009b      	lsls	r3, r3, #2
 800c47e:	4a3a      	ldr	r2, [pc, #232]	; (800c568 <dmaStreamAllocI+0x138>)
 800c480:	4413      	add	r3, r2
 800c482:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 800c484:	4a37      	ldr	r2, [pc, #220]	; (800c564 <dmaStreamAllocI+0x134>)
 800c486:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c488:	00db      	lsls	r3, r3, #3
 800c48a:	4413      	add	r3, r2
 800c48c:	9a01      	ldr	r2, [sp, #4]
 800c48e:	605a      	str	r2, [r3, #4]
      dma.streams[i].param = param;
 800c490:	4a34      	ldr	r2, [pc, #208]	; (800c564 <dmaStreamAllocI+0x134>)
 800c492:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c494:	00db      	lsls	r3, r3, #3
 800c496:	4413      	add	r3, r2
 800c498:	9a00      	ldr	r2, [sp, #0]
 800c49a:	609a      	str	r2, [r3, #8]
      dma.allocated_mask  |= mask;
 800c49c:	4b31      	ldr	r3, [pc, #196]	; (800c564 <dmaStreamAllocI+0x134>)
 800c49e:	681a      	ldr	r2, [r3, #0]
 800c4a0:	9b06      	ldr	r3, [sp, #24]
 800c4a2:	4313      	orrs	r3, r2
 800c4a4:	4a2f      	ldr	r2, [pc, #188]	; (800c564 <dmaStreamAllocI+0x134>)
 800c4a6:	6013      	str	r3, [r2, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 800c4a8:	9b06      	ldr	r3, [sp, #24]
 800c4aa:	b2db      	uxtb	r3, r3
 800c4ac:	2b00      	cmp	r3, #0
 800c4ae:	d00d      	beq.n	800c4cc <dmaStreamAllocI+0x9c>
        rccEnableDMA1(true);
 800c4b0:	4b2e      	ldr	r3, [pc, #184]	; (800c56c <dmaStreamAllocI+0x13c>)
 800c4b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c4b4:	4a2d      	ldr	r2, [pc, #180]	; (800c56c <dmaStreamAllocI+0x13c>)
 800c4b6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800c4ba:	6313      	str	r3, [r2, #48]	; 0x30
 800c4bc:	4b2b      	ldr	r3, [pc, #172]	; (800c56c <dmaStreamAllocI+0x13c>)
 800c4be:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c4c0:	4a2a      	ldr	r2, [pc, #168]	; (800c56c <dmaStreamAllocI+0x13c>)
 800c4c2:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800c4c6:	6513      	str	r3, [r2, #80]	; 0x50
 800c4c8:	4b28      	ldr	r3, [pc, #160]	; (800c56c <dmaStreamAllocI+0x13c>)
 800c4ca:	6d1b      	ldr	r3, [r3, #80]	; 0x50
      }
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 800c4cc:	9b06      	ldr	r3, [sp, #24]
 800c4ce:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800c4d2:	2b00      	cmp	r3, #0
 800c4d4:	d00d      	beq.n	800c4f2 <dmaStreamAllocI+0xc2>
        rccEnableDMA2(true);
 800c4d6:	4b25      	ldr	r3, [pc, #148]	; (800c56c <dmaStreamAllocI+0x13c>)
 800c4d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c4da:	4a24      	ldr	r2, [pc, #144]	; (800c56c <dmaStreamAllocI+0x13c>)
 800c4dc:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800c4e0:	6313      	str	r3, [r2, #48]	; 0x30
 800c4e2:	4b22      	ldr	r3, [pc, #136]	; (800c56c <dmaStreamAllocI+0x13c>)
 800c4e4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c4e6:	4a21      	ldr	r2, [pc, #132]	; (800c56c <dmaStreamAllocI+0x13c>)
 800c4e8:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800c4ec:	6513      	str	r3, [r2, #80]	; 0x50
 800c4ee:	4b1f      	ldr	r3, [pc, #124]	; (800c56c <dmaStreamAllocI+0x13c>)
 800c4f0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
        rccEnableDMAMUX(true);
      }
#endif

      /* Putting the stream in a safe state.*/
      dmaStreamDisable(dmastp);
 800c4f2:	9b05      	ldr	r3, [sp, #20]
 800c4f4:	681b      	ldr	r3, [r3, #0]
 800c4f6:	681a      	ldr	r2, [r3, #0]
 800c4f8:	9b05      	ldr	r3, [sp, #20]
 800c4fa:	681b      	ldr	r3, [r3, #0]
 800c4fc:	f022 021f 	bic.w	r2, r2, #31
 800c500:	601a      	str	r2, [r3, #0]
 800c502:	9b05      	ldr	r3, [sp, #20]
 800c504:	681b      	ldr	r3, [r3, #0]
 800c506:	681b      	ldr	r3, [r3, #0]
 800c508:	f003 0301 	and.w	r3, r3, #1
 800c50c:	2b00      	cmp	r3, #0
 800c50e:	d1f8      	bne.n	800c502 <dmaStreamAllocI+0xd2>
 800c510:	9b05      	ldr	r3, [sp, #20]
 800c512:	7a5b      	ldrb	r3, [r3, #9]
 800c514:	4619      	mov	r1, r3
 800c516:	9b05      	ldr	r3, [sp, #20]
 800c518:	685b      	ldr	r3, [r3, #4]
 800c51a:	223d      	movs	r2, #61	; 0x3d
 800c51c:	408a      	lsls	r2, r1
 800c51e:	601a      	str	r2, [r3, #0]
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 800c520:	9b05      	ldr	r3, [sp, #20]
 800c522:	681b      	ldr	r3, [r3, #0]
 800c524:	2200      	movs	r2, #0
 800c526:	601a      	str	r2, [r3, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800c528:	9b05      	ldr	r3, [sp, #20]
 800c52a:	681b      	ldr	r3, [r3, #0]
 800c52c:	2221      	movs	r2, #33	; 0x21
 800c52e:	615a      	str	r2, [r3, #20]

      /* Enables the associated IRQ vector if a callback is defined.*/
      if (func != NULL) {
 800c530:	9b01      	ldr	r3, [sp, #4]
 800c532:	2b00      	cmp	r3, #0
 800c534:	d005      	beq.n	800c542 <dmaStreamAllocI+0x112>
        nvicEnableVector(dmastp->vector, priority);
 800c536:	9b05      	ldr	r3, [sp, #20]
 800c538:	7adb      	ldrb	r3, [r3, #11]
 800c53a:	9902      	ldr	r1, [sp, #8]
 800c53c:	4618      	mov	r0, r3
 800c53e:	f7ff fadf 	bl	800bb00 <nvicEnableVector>
      }

      return dmastp;
 800c542:	9b05      	ldr	r3, [sp, #20]
 800c544:	e007      	b.n	800c556 <dmaStreamAllocI+0x126>
  for (i = startid; i <= endid; i++) {
 800c546:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c548:	3301      	adds	r3, #1
 800c54a:	9309      	str	r3, [sp, #36]	; 0x24
 800c54c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c54e:	9b07      	ldr	r3, [sp, #28]
 800c550:	429a      	cmp	r2, r3
 800c552:	d984      	bls.n	800c45e <dmaStreamAllocI+0x2e>
    }
  }

  return NULL;
 800c554:	2300      	movs	r3, #0
}
 800c556:	4618      	mov	r0, r3
 800c558:	b00b      	add	sp, #44	; 0x2c
 800c55a:	f85d fb04 	ldr.w	pc, [sp], #4
 800c55e:	bf00      	nop
 800c560:	08015fe4 	.word	0x08015fe4
 800c564:	20000d60 	.word	0x20000d60
 800c568:	08015e64 	.word	0x08015e64
 800c56c:	40023800 	.word	0x40023800

0800c570 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 800c570:	4770      	bx	lr
 800c572:	bf00      	nop
	...

0800c580 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 800c580:	b08e      	sub	sp, #56	; 0x38
 800c582:	9003      	str	r0, [sp, #12]
 800c584:	9102      	str	r1, [sp, #8]
 800c586:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800c588:	9b01      	ldr	r3, [sp, #4]
 800c58a:	f003 0303 	and.w	r3, r3, #3
 800c58e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800c590:	9b01      	ldr	r3, [sp, #4]
 800c592:	089b      	lsrs	r3, r3, #2
 800c594:	f003 0301 	and.w	r3, r3, #1
 800c598:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800c59a:	9b01      	ldr	r3, [sp, #4]
 800c59c:	08db      	lsrs	r3, r3, #3
 800c59e:	f003 0303 	and.w	r3, r3, #3
 800c5a2:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 800c5a4:	9b01      	ldr	r3, [sp, #4]
 800c5a6:	095b      	lsrs	r3, r3, #5
 800c5a8:	f003 0303 	and.w	r3, r3, #3
 800c5ac:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800c5ae:	9b01      	ldr	r3, [sp, #4]
 800c5b0:	09db      	lsrs	r3, r3, #7
 800c5b2:	f003 030f 	and.w	r3, r3, #15
 800c5b6:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 800c5b8:	2300      	movs	r3, #0
 800c5ba:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800c5bc:	9b02      	ldr	r3, [sp, #8]
 800c5be:	f003 0301 	and.w	r3, r3, #1
 800c5c2:	2b00      	cmp	r3, #0
 800c5c4:	d079      	beq.n	800c6ba <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800c5c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c5c8:	f003 0307 	and.w	r3, r3, #7
 800c5cc:	009b      	lsls	r3, r3, #2
 800c5ce:	9a08      	ldr	r2, [sp, #32]
 800c5d0:	fa02 f303 	lsl.w	r3, r2, r3
 800c5d4:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 800c5d6:	2201      	movs	r2, #1
 800c5d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c5da:	fa02 f303 	lsl.w	r3, r2, r3
 800c5de:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 800c5e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c5e2:	005b      	lsls	r3, r3, #1
 800c5e4:	2203      	movs	r2, #3
 800c5e6:	fa02 f303 	lsl.w	r3, r2, r3
 800c5ea:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 800c5ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c5ee:	f003 0307 	and.w	r3, r3, #7
 800c5f2:	009b      	lsls	r3, r3, #2
 800c5f4:	220f      	movs	r2, #15
 800c5f6:	fa02 f303 	lsl.w	r3, r2, r3
 800c5fa:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800c5fc:	9b03      	ldr	r3, [sp, #12]
 800c5fe:	685a      	ldr	r2, [r3, #4]
 800c600:	9b06      	ldr	r3, [sp, #24]
 800c602:	43db      	mvns	r3, r3
 800c604:	401a      	ands	r2, r3
 800c606:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800c608:	431a      	orrs	r2, r3
 800c60a:	9b03      	ldr	r3, [sp, #12]
 800c60c:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800c60e:	9b03      	ldr	r3, [sp, #12]
 800c610:	689a      	ldr	r2, [r3, #8]
 800c612:	9b05      	ldr	r3, [sp, #20]
 800c614:	43db      	mvns	r3, r3
 800c616:	401a      	ands	r2, r3
 800c618:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c61a:	431a      	orrs	r2, r3
 800c61c:	9b03      	ldr	r3, [sp, #12]
 800c61e:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800c620:	9b03      	ldr	r3, [sp, #12]
 800c622:	68da      	ldr	r2, [r3, #12]
 800c624:	9b05      	ldr	r3, [sp, #20]
 800c626:	43db      	mvns	r3, r3
 800c628:	401a      	ands	r2, r3
 800c62a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c62c:	431a      	orrs	r2, r3
 800c62e:	9b03      	ldr	r3, [sp, #12]
 800c630:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 800c632:	9b01      	ldr	r3, [sp, #4]
 800c634:	f003 0303 	and.w	r3, r3, #3
 800c638:	2b02      	cmp	r3, #2
 800c63a:	d11f      	bne.n	800c67c <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 800c63c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c63e:	2b07      	cmp	r3, #7
 800c640:	d809      	bhi.n	800c656 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800c642:	9b03      	ldr	r3, [sp, #12]
 800c644:	6a1a      	ldr	r2, [r3, #32]
 800c646:	9b04      	ldr	r3, [sp, #16]
 800c648:	43db      	mvns	r3, r3
 800c64a:	401a      	ands	r2, r3
 800c64c:	9b07      	ldr	r3, [sp, #28]
 800c64e:	431a      	orrs	r2, r3
 800c650:	9b03      	ldr	r3, [sp, #12]
 800c652:	621a      	str	r2, [r3, #32]
 800c654:	e008      	b.n	800c668 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800c656:	9b03      	ldr	r3, [sp, #12]
 800c658:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800c65a:	9b04      	ldr	r3, [sp, #16]
 800c65c:	43db      	mvns	r3, r3
 800c65e:	401a      	ands	r2, r3
 800c660:	9b07      	ldr	r3, [sp, #28]
 800c662:	431a      	orrs	r2, r3
 800c664:	9b03      	ldr	r3, [sp, #12]
 800c666:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 800c668:	9b03      	ldr	r3, [sp, #12]
 800c66a:	681a      	ldr	r2, [r3, #0]
 800c66c:	9b05      	ldr	r3, [sp, #20]
 800c66e:	43db      	mvns	r3, r3
 800c670:	401a      	ands	r2, r3
 800c672:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800c674:	431a      	orrs	r2, r3
 800c676:	9b03      	ldr	r3, [sp, #12]
 800c678:	601a      	str	r2, [r3, #0]
 800c67a:	e01e      	b.n	800c6ba <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800c67c:	9b03      	ldr	r3, [sp, #12]
 800c67e:	681a      	ldr	r2, [r3, #0]
 800c680:	9b05      	ldr	r3, [sp, #20]
 800c682:	43db      	mvns	r3, r3
 800c684:	401a      	ands	r2, r3
 800c686:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800c688:	431a      	orrs	r2, r3
 800c68a:	9b03      	ldr	r3, [sp, #12]
 800c68c:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 800c68e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c690:	2b07      	cmp	r3, #7
 800c692:	d809      	bhi.n	800c6a8 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800c694:	9b03      	ldr	r3, [sp, #12]
 800c696:	6a1a      	ldr	r2, [r3, #32]
 800c698:	9b04      	ldr	r3, [sp, #16]
 800c69a:	43db      	mvns	r3, r3
 800c69c:	401a      	ands	r2, r3
 800c69e:	9b07      	ldr	r3, [sp, #28]
 800c6a0:	431a      	orrs	r2, r3
 800c6a2:	9b03      	ldr	r3, [sp, #12]
 800c6a4:	621a      	str	r2, [r3, #32]
 800c6a6:	e008      	b.n	800c6ba <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800c6a8:	9b03      	ldr	r3, [sp, #12]
 800c6aa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800c6ac:	9b04      	ldr	r3, [sp, #16]
 800c6ae:	43db      	mvns	r3, r3
 800c6b0:	401a      	ands	r2, r3
 800c6b2:	9b07      	ldr	r3, [sp, #28]
 800c6b4:	431a      	orrs	r2, r3
 800c6b6:	9b03      	ldr	r3, [sp, #12]
 800c6b8:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 800c6ba:	9b02      	ldr	r3, [sp, #8]
 800c6bc:	085b      	lsrs	r3, r3, #1
 800c6be:	9302      	str	r3, [sp, #8]
    if (!mask)
 800c6c0:	9b02      	ldr	r3, [sp, #8]
 800c6c2:	2b00      	cmp	r3, #0
 800c6c4:	d00f      	beq.n	800c6e6 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 800c6c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800c6c8:	005b      	lsls	r3, r3, #1
 800c6ca:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 800c6cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c6ce:	009b      	lsls	r3, r3, #2
 800c6d0:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 800c6d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c6d4:	009b      	lsls	r3, r3, #2
 800c6d6:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 800c6d8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800c6da:	009b      	lsls	r3, r3, #2
 800c6dc:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 800c6de:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c6e0:	3301      	adds	r3, #1
 800c6e2:	9309      	str	r3, [sp, #36]	; 0x24
 800c6e4:	e76a      	b.n	800c5bc <_pal_lld_setgroupmode+0x3c>
  }
}
 800c6e6:	b00e      	add	sp, #56	; 0x38
 800c6e8:	4770      	bx	lr
 800c6ea:	bf00      	nop
 800c6ec:	0000      	movs	r0, r0
	...

0800c6f0 <port_lock.lto_priv.389>:
static inline void port_lock(void) {
 800c6f0:	b082      	sub	sp, #8
 800c6f2:	2320      	movs	r3, #32
 800c6f4:	9301      	str	r3, [sp, #4]
 800c6f6:	9b01      	ldr	r3, [sp, #4]
 800c6f8:	f383 8811 	msr	BASEPRI, r3
}
 800c6fc:	b002      	add	sp, #8
 800c6fe:	4770      	bx	lr

0800c700 <port_unlock.lto_priv.358>:
static inline void port_unlock(void) {
 800c700:	b082      	sub	sp, #8
 800c702:	2300      	movs	r3, #0
 800c704:	9301      	str	r3, [sp, #4]
 800c706:	9b01      	ldr	r3, [sp, #4]
 800c708:	f383 8811 	msr	BASEPRI, r3
}
 800c70c:	b002      	add	sp, #8
 800c70e:	4770      	bx	lr

0800c710 <port_lock_from_isr.lto_priv.436>:
static inline void port_lock_from_isr(void) {
 800c710:	b508      	push	{r3, lr}
  port_lock();
 800c712:	f7ff ffed 	bl	800c6f0 <port_lock.lto_priv.389>
}
 800c716:	bd08      	pop	{r3, pc}
	...

0800c720 <port_unlock_from_isr.lto_priv.425>:
static inline void port_unlock_from_isr(void) {
 800c720:	b508      	push	{r3, lr}
  port_unlock();
 800c722:	f7ff ffed 	bl	800c700 <port_unlock.lto_priv.358>
}
 800c726:	bd08      	pop	{r3, pc}
	...

0800c730 <chSysLockFromISR.lto_priv.529>:
static inline void chSysLockFromISR(void) {
 800c730:	b508      	push	{r3, lr}
  port_lock_from_isr();
 800c732:	f7ff ffed 	bl	800c710 <port_lock_from_isr.lto_priv.436>
  _dbg_check_lock_from_isr();
 800c736:	f002 fdf3 	bl	800f320 <_dbg_check_lock_from_isr>
}
 800c73a:	bd08      	pop	{r3, pc}
 800c73c:	0000      	movs	r0, r0
	...

0800c740 <chSysUnlockFromISR.lto_priv.521>:
static inline void chSysUnlockFromISR(void) {
 800c740:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 800c742:	f002 fe05 	bl	800f350 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 800c746:	f7ff ffeb 	bl	800c720 <port_unlock_from_isr.lto_priv.425>
}
 800c74a:	bd08      	pop	{r3, pc}
 800c74c:	0000      	movs	r0, r0
	...

0800c750 <osalSysLockFromISR.lto_priv.557>:
static inline void osalSysLockFromISR(void) {
 800c750:	b508      	push	{r3, lr}
  chSysLockFromISR();
 800c752:	f7ff ffed 	bl	800c730 <chSysLockFromISR.lto_priv.529>
}
 800c756:	bd08      	pop	{r3, pc}
	...

0800c760 <osalSysUnlockFromISR.lto_priv.551>:
static inline void osalSysUnlockFromISR(void) {
 800c760:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 800c762:	f7ff ffed 	bl	800c740 <chSysUnlockFromISR.lto_priv.521>
}
 800c766:	bd08      	pop	{r3, pc}
	...

0800c770 <osalSysPolledDelayX>:
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 800c770:	b500      	push	{lr}
 800c772:	b083      	sub	sp, #12
 800c774:	9001      	str	r0, [sp, #4]
  chSysPolledDelayX(cycles);
 800c776:	9801      	ldr	r0, [sp, #4]
 800c778:	f002 fd22 	bl	800f1c0 <chSysPolledDelayX>
}
 800c77c:	b003      	add	sp, #12
 800c77e:	f85d fb04 	ldr.w	pc, [sp], #4
 800c782:	bf00      	nop
	...

0800c790 <otg_core_reset>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void otg_core_reset(USBDriver *usbp) {
 800c790:	b500      	push	{lr}
 800c792:	b085      	sub	sp, #20
 800c794:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 800c796:	9b01      	ldr	r3, [sp, #4]
 800c798:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c79a:	9303      	str	r3, [sp, #12]

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800c79c:	9b03      	ldr	r3, [sp, #12]
 800c79e:	691b      	ldr	r3, [r3, #16]
 800c7a0:	2b00      	cmp	r3, #0
 800c7a2:	dafb      	bge.n	800c79c <otg_core_reset+0xc>
    ;

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 800c7a4:	9b03      	ldr	r3, [sp, #12]
 800c7a6:	2201      	movs	r2, #1
 800c7a8:	611a      	str	r2, [r3, #16]
  osalSysPolledDelayX(12);
 800c7aa:	200c      	movs	r0, #12
 800c7ac:	f7ff ffe0 	bl	800c770 <osalSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 800c7b0:	9b03      	ldr	r3, [sp, #12]
 800c7b2:	691b      	ldr	r3, [r3, #16]
 800c7b4:	f003 0301 	and.w	r3, r3, #1
 800c7b8:	2b00      	cmp	r3, #0
 800c7ba:	d1f9      	bne.n	800c7b0 <otg_core_reset+0x20>
    ;

  osalSysPolledDelayX(18);
 800c7bc:	2012      	movs	r0, #18
 800c7be:	f7ff ffd7 	bl	800c770 <osalSysPolledDelayX>

  /* Wait AHB idle condition again.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800c7c2:	9b03      	ldr	r3, [sp, #12]
 800c7c4:	691b      	ldr	r3, [r3, #16]
 800c7c6:	2b00      	cmp	r3, #0
 800c7c8:	dafb      	bge.n	800c7c2 <otg_core_reset+0x32>
    ;
}
 800c7ca:	b005      	add	sp, #20
 800c7cc:	f85d fb04 	ldr.w	pc, [sp], #4

0800c7d0 <otg_disable_ep>:

static void otg_disable_ep(USBDriver *usbp) {
 800c7d0:	b084      	sub	sp, #16
 800c7d2:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 800c7d4:	9b01      	ldr	r3, [sp, #4]
 800c7d6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c7d8:	9302      	str	r3, [sp, #8]
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800c7da:	2300      	movs	r3, #0
 800c7dc:	9303      	str	r3, [sp, #12]
 800c7de:	e032      	b.n	800c846 <otg_disable_ep+0x76>
    otgp->ie[i].DIEPCTL = 0;
 800c7e0:	9a02      	ldr	r2, [sp, #8]
 800c7e2:	9b03      	ldr	r3, [sp, #12]
 800c7e4:	3348      	adds	r3, #72	; 0x48
 800c7e6:	015b      	lsls	r3, r3, #5
 800c7e8:	4413      	add	r3, r2
 800c7ea:	2200      	movs	r2, #0
 800c7ec:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 800c7ee:	9a02      	ldr	r2, [sp, #8]
 800c7f0:	9b03      	ldr	r3, [sp, #12]
 800c7f2:	015b      	lsls	r3, r3, #5
 800c7f4:	4413      	add	r3, r2
 800c7f6:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800c7fa:	2200      	movs	r2, #0
 800c7fc:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800c7fe:	9a02      	ldr	r2, [sp, #8]
 800c800:	9b03      	ldr	r3, [sp, #12]
 800c802:	015b      	lsls	r3, r3, #5
 800c804:	4413      	add	r3, r2
 800c806:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800c80a:	f04f 32ff 	mov.w	r2, #4294967295
 800c80e:	601a      	str	r2, [r3, #0]

    otgp->oe[i].DOEPCTL = 0;
 800c810:	9a02      	ldr	r2, [sp, #8]
 800c812:	9b03      	ldr	r3, [sp, #12]
 800c814:	3358      	adds	r3, #88	; 0x58
 800c816:	015b      	lsls	r3, r3, #5
 800c818:	4413      	add	r3, r2
 800c81a:	2200      	movs	r2, #0
 800c81c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 800c81e:	9a02      	ldr	r2, [sp, #8]
 800c820:	9b03      	ldr	r3, [sp, #12]
 800c822:	015b      	lsls	r3, r3, #5
 800c824:	4413      	add	r3, r2
 800c826:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800c82a:	2200      	movs	r2, #0
 800c82c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800c82e:	9a02      	ldr	r2, [sp, #8]
 800c830:	9b03      	ldr	r3, [sp, #12]
 800c832:	015b      	lsls	r3, r3, #5
 800c834:	4413      	add	r3, r2
 800c836:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800c83a:	f04f 32ff 	mov.w	r2, #4294967295
 800c83e:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800c840:	9b03      	ldr	r3, [sp, #12]
 800c842:	3301      	adds	r3, #1
 800c844:	9303      	str	r3, [sp, #12]
 800c846:	9b01      	ldr	r3, [sp, #4]
 800c848:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c84a:	689b      	ldr	r3, [r3, #8]
 800c84c:	9a03      	ldr	r2, [sp, #12]
 800c84e:	429a      	cmp	r2, r3
 800c850:	d9c6      	bls.n	800c7e0 <otg_disable_ep+0x10>
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800c852:	9b02      	ldr	r3, [sp, #8]
 800c854:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 800c858:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 800c85c:	b004      	add	sp, #16
 800c85e:	4770      	bx	lr

0800c860 <otg_rxfifo_flush>:

static void otg_rxfifo_flush(USBDriver *usbp) {
 800c860:	b500      	push	{lr}
 800c862:	b085      	sub	sp, #20
 800c864:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 800c866:	9b01      	ldr	r3, [sp, #4]
 800c868:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c86a:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 800c86c:	9b03      	ldr	r3, [sp, #12]
 800c86e:	2210      	movs	r2, #16
 800c870:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 800c872:	9b03      	ldr	r3, [sp, #12]
 800c874:	691b      	ldr	r3, [r3, #16]
 800c876:	f003 0310 	and.w	r3, r3, #16
 800c87a:	2b00      	cmp	r3, #0
 800c87c:	d1f9      	bne.n	800c872 <otg_rxfifo_flush+0x12>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 800c87e:	2012      	movs	r0, #18
 800c880:	f7ff ff76 	bl	800c770 <osalSysPolledDelayX>
}
 800c884:	b005      	add	sp, #20
 800c886:	f85d fb04 	ldr.w	pc, [sp], #4
 800c88a:	bf00      	nop
 800c88c:	0000      	movs	r0, r0
	...

0800c890 <otg_txfifo_flush>:

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 800c890:	b500      	push	{lr}
 800c892:	b085      	sub	sp, #20
 800c894:	9001      	str	r0, [sp, #4]
 800c896:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 800c898:	9b01      	ldr	r3, [sp, #4]
 800c89a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c89c:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800c89e:	9b00      	ldr	r3, [sp, #0]
 800c8a0:	019b      	lsls	r3, r3, #6
 800c8a2:	f043 0220 	orr.w	r2, r3, #32
 800c8a6:	9b03      	ldr	r3, [sp, #12]
 800c8a8:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800c8aa:	9b03      	ldr	r3, [sp, #12]
 800c8ac:	691b      	ldr	r3, [r3, #16]
 800c8ae:	f003 0320 	and.w	r3, r3, #32
 800c8b2:	2b00      	cmp	r3, #0
 800c8b4:	d1f9      	bne.n	800c8aa <otg_txfifo_flush+0x1a>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 800c8b6:	2012      	movs	r0, #18
 800c8b8:	f7ff ff5a 	bl	800c770 <osalSysPolledDelayX>
}
 800c8bc:	b005      	add	sp, #20
 800c8be:	f85d fb04 	ldr.w	pc, [sp], #4
 800c8c2:	bf00      	nop
	...

0800c8d0 <otg_ram_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {
 800c8d0:	b082      	sub	sp, #8
 800c8d2:	9001      	str	r0, [sp, #4]

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 800c8d4:	9b01      	ldr	r3, [sp, #4]
 800c8d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c8d8:	681a      	ldr	r2, [r3, #0]
 800c8da:	9b01      	ldr	r3, [sp, #4]
 800c8dc:	675a      	str	r2, [r3, #116]	; 0x74
}
 800c8de:	b002      	add	sp, #8
 800c8e0:	4770      	bx	lr
 800c8e2:	bf00      	nop
	...

0800c8f0 <otg_ram_alloc>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] size      size of the packet buffer to allocate in words
 *
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 800c8f0:	b500      	push	{lr}
 800c8f2:	b085      	sub	sp, #20
 800c8f4:	9001      	str	r0, [sp, #4]
 800c8f6:	9100      	str	r1, [sp, #0]
  uint32_t next;

  next = usbp->pmnext;
 800c8f8:	9b01      	ldr	r3, [sp, #4]
 800c8fa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c8fc:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 800c8fe:	9b01      	ldr	r3, [sp, #4]
 800c900:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800c902:	9b00      	ldr	r3, [sp, #0]
 800c904:	441a      	add	r2, r3
 800c906:	9b01      	ldr	r3, [sp, #4]
 800c908:	675a      	str	r2, [r3, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800c90a:	9b01      	ldr	r3, [sp, #4]
 800c90c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800c90e:	9b01      	ldr	r3, [sp, #4]
 800c910:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c912:	685b      	ldr	r3, [r3, #4]
 800c914:	429a      	cmp	r2, r3
 800c916:	d902      	bls.n	800c91e <otg_ram_alloc+0x2e>
 800c918:	4803      	ldr	r0, [pc, #12]	; (800c928 <otg_ram_alloc+0x38>)
 800c91a:	f002 fb61 	bl	800efe0 <chSysHalt>
                "OTG FIFO memory overflow");
  return next;
 800c91e:	9b03      	ldr	r3, [sp, #12]
}
 800c920:	4618      	mov	r0, r3
 800c922:	b005      	add	sp, #20
 800c924:	f85d fb04 	ldr.w	pc, [sp], #4
 800c928:	08016030 	.word	0x08016030
 800c92c:	00000000 	.word	0x00000000

0800c930 <otg_fifo_write_from_buffer>:
 *
 * @notapi
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {
 800c930:	b500      	push	{lr}
 800c932:	b085      	sub	sp, #20
 800c934:	9003      	str	r0, [sp, #12]
 800c936:	9102      	str	r1, [sp, #8]
 800c938:	9201      	str	r2, [sp, #4]

  osalDbgAssert(n > 0, "is zero");
 800c93a:	9b01      	ldr	r3, [sp, #4]
 800c93c:	2b00      	cmp	r3, #0
 800c93e:	d102      	bne.n	800c946 <otg_fifo_write_from_buffer+0x16>
 800c940:	4809      	ldr	r0, [pc, #36]	; (800c968 <otg_fifo_write_from_buffer+0x38>)
 800c942:	f002 fb4d 	bl	800efe0 <chSysHalt>

  while (true) {
    *fifop = *((uint32_t *)buf);
 800c946:	9b02      	ldr	r3, [sp, #8]
 800c948:	681a      	ldr	r2, [r3, #0]
 800c94a:	9b03      	ldr	r3, [sp, #12]
 800c94c:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 800c94e:	9b01      	ldr	r3, [sp, #4]
 800c950:	2b04      	cmp	r3, #4
 800c952:	d906      	bls.n	800c962 <otg_fifo_write_from_buffer+0x32>
      break;
    }
    n -= 4;
 800c954:	9b01      	ldr	r3, [sp, #4]
 800c956:	3b04      	subs	r3, #4
 800c958:	9301      	str	r3, [sp, #4]
    buf += 4;
 800c95a:	9b02      	ldr	r3, [sp, #8]
 800c95c:	3304      	adds	r3, #4
 800c95e:	9302      	str	r3, [sp, #8]
 800c960:	e7f1      	b.n	800c946 <otg_fifo_write_from_buffer+0x16>
  }
}
 800c962:	b005      	add	sp, #20
 800c964:	f85d fb04 	ldr.w	pc, [sp], #4
 800c968:	08016040 	.word	0x08016040
 800c96c:	00000000 	.word	0x00000000

0800c970 <otg_fifo_read_to_buffer>:
 * @notapi
 */
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {
 800c970:	b086      	sub	sp, #24
 800c972:	9003      	str	r0, [sp, #12]
 800c974:	9102      	str	r1, [sp, #8]
 800c976:	9201      	str	r2, [sp, #4]
 800c978:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 800c97a:	2300      	movs	r3, #0
 800c97c:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 800c97e:	2300      	movs	r3, #0
 800c980:	9304      	str	r3, [sp, #16]
 800c982:	e017      	b.n	800c9b4 <otg_fifo_read_to_buffer+0x44>

  while (i < n) {
    if ((i & 3) == 0){
 800c984:	9b04      	ldr	r3, [sp, #16]
 800c986:	f003 0303 	and.w	r3, r3, #3
 800c98a:	2b00      	cmp	r3, #0
 800c98c:	d102      	bne.n	800c994 <otg_fifo_read_to_buffer+0x24>
      w = *fifop;
 800c98e:	9b03      	ldr	r3, [sp, #12]
 800c990:	681b      	ldr	r3, [r3, #0]
 800c992:	9305      	str	r3, [sp, #20]
    }
    if (i < max) {
 800c994:	9a04      	ldr	r2, [sp, #16]
 800c996:	9b00      	ldr	r3, [sp, #0]
 800c998:	429a      	cmp	r2, r3
 800c99a:	d208      	bcs.n	800c9ae <otg_fifo_read_to_buffer+0x3e>
      *buf++ = (uint8_t)w;
 800c99c:	9b02      	ldr	r3, [sp, #8]
 800c99e:	1c5a      	adds	r2, r3, #1
 800c9a0:	9202      	str	r2, [sp, #8]
 800c9a2:	9a05      	ldr	r2, [sp, #20]
 800c9a4:	b2d2      	uxtb	r2, r2
 800c9a6:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 800c9a8:	9b05      	ldr	r3, [sp, #20]
 800c9aa:	0a1b      	lsrs	r3, r3, #8
 800c9ac:	9305      	str	r3, [sp, #20]
    }
    i++;
 800c9ae:	9b04      	ldr	r3, [sp, #16]
 800c9b0:	3301      	adds	r3, #1
 800c9b2:	9304      	str	r3, [sp, #16]
  while (i < n) {
 800c9b4:	9a04      	ldr	r2, [sp, #16]
 800c9b6:	9b01      	ldr	r3, [sp, #4]
 800c9b8:	429a      	cmp	r2, r3
 800c9ba:	d3e3      	bcc.n	800c984 <otg_fifo_read_to_buffer+0x14>
  }
}
 800c9bc:	b006      	add	sp, #24
 800c9be:	4770      	bx	lr

0800c9c0 <otg_rxfifo_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
 800c9c0:	b510      	push	{r4, lr}
 800c9c2:	b086      	sub	sp, #24
 800c9c4:	9001      	str	r0, [sp, #4]
  uint32_t sts, cnt, ep;

  /* Popping the event word out of the RX FIFO.*/
  sts = usbp->otg->GRXSTSP;
 800c9c6:	9b01      	ldr	r3, [sp, #4]
 800c9c8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c9ca:	6a1b      	ldr	r3, [r3, #32]
 800c9cc:	9305      	str	r3, [sp, #20]

  /* Event details.*/
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 800c9ce:	9b05      	ldr	r3, [sp, #20]
 800c9d0:	091b      	lsrs	r3, r3, #4
 800c9d2:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800c9d6:	9304      	str	r3, [sp, #16]
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800c9d8:	9b05      	ldr	r3, [sp, #20]
 800c9da:	f003 030f 	and.w	r3, r3, #15
 800c9de:	9303      	str	r3, [sp, #12]

  switch (sts & GRXSTSP_PKTSTS_MASK) {
 800c9e0:	9b05      	ldr	r3, [sp, #20]
 800c9e2:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 800c9e6:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 800c9ea:	d065      	beq.n	800cab8 <otg_rxfifo_handler+0xf8>
 800c9ec:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 800c9f0:	d806      	bhi.n	800ca00 <otg_rxfifo_handler+0x40>
 800c9f2:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800c9f6:	d061      	beq.n	800cabc <otg_rxfifo_handler+0xfc>
 800c9f8:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800c9fc:	d016      	beq.n	800ca2c <otg_rxfifo_handler+0x6c>
 800c9fe:	e060      	b.n	800cac2 <otg_rxfifo_handler+0x102>
 800ca00:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 800ca04:	d05c      	beq.n	800cac0 <otg_rxfifo_handler+0x100>
 800ca06:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 800ca0a:	d15a      	bne.n	800cac2 <otg_rxfifo_handler+0x102>
  case GRXSTSP_SETUP_DATA:
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800ca0c:	9b01      	ldr	r3, [sp, #4]
 800ca0e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ca10:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
 800ca14:	9a01      	ldr	r2, [sp, #4]
 800ca16:	9b03      	ldr	r3, [sp, #12]
 800ca18:	3302      	adds	r3, #2
 800ca1a:	009b      	lsls	r3, r3, #2
 800ca1c:	4413      	add	r3, r2
 800ca1e:	685b      	ldr	r3, [r3, #4]
 800ca20:	6a19      	ldr	r1, [r3, #32]
 800ca22:	2308      	movs	r3, #8
 800ca24:	9a04      	ldr	r2, [sp, #16]
 800ca26:	f7ff ffa3 	bl	800c970 <otg_fifo_read_to_buffer>
 800ca2a:	e04a      	b.n	800cac2 <otg_rxfifo_handler+0x102>
                            cnt, 8);
    break;
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_OUT_DATA:
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800ca2c:	9b01      	ldr	r3, [sp, #4]
 800ca2e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ca30:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 800ca34:	9a01      	ldr	r2, [sp, #4]
 800ca36:	9b03      	ldr	r3, [sp, #12]
 800ca38:	3302      	adds	r3, #2
 800ca3a:	009b      	lsls	r3, r3, #2
 800ca3c:	4413      	add	r3, r2
 800ca3e:	685b      	ldr	r3, [r3, #4]
 800ca40:	699b      	ldr	r3, [r3, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800ca42:	689c      	ldr	r4, [r3, #8]
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
 800ca44:	9a01      	ldr	r2, [sp, #4]
 800ca46:	9b03      	ldr	r3, [sp, #12]
 800ca48:	3302      	adds	r3, #2
 800ca4a:	009b      	lsls	r3, r3, #2
 800ca4c:	4413      	add	r3, r2
 800ca4e:	685b      	ldr	r3, [r3, #4]
 800ca50:	699b      	ldr	r3, [r3, #24]
 800ca52:	681a      	ldr	r2, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 800ca54:	9901      	ldr	r1, [sp, #4]
 800ca56:	9b03      	ldr	r3, [sp, #12]
 800ca58:	3302      	adds	r3, #2
 800ca5a:	009b      	lsls	r3, r3, #2
 800ca5c:	440b      	add	r3, r1
 800ca5e:	685b      	ldr	r3, [r3, #4]
 800ca60:	699b      	ldr	r3, [r3, #24]
 800ca62:	685b      	ldr	r3, [r3, #4]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800ca64:	1ad3      	subs	r3, r2, r3
 800ca66:	9a04      	ldr	r2, [sp, #16]
 800ca68:	4621      	mov	r1, r4
 800ca6a:	f7ff ff81 	bl	800c970 <otg_fifo_read_to_buffer>
    usbp->epc[ep]->out_state->rxbuf += cnt;
 800ca6e:	9a01      	ldr	r2, [sp, #4]
 800ca70:	9b03      	ldr	r3, [sp, #12]
 800ca72:	3302      	adds	r3, #2
 800ca74:	009b      	lsls	r3, r3, #2
 800ca76:	4413      	add	r3, r2
 800ca78:	685b      	ldr	r3, [r3, #4]
 800ca7a:	699b      	ldr	r3, [r3, #24]
 800ca7c:	6899      	ldr	r1, [r3, #8]
 800ca7e:	9a01      	ldr	r2, [sp, #4]
 800ca80:	9b03      	ldr	r3, [sp, #12]
 800ca82:	3302      	adds	r3, #2
 800ca84:	009b      	lsls	r3, r3, #2
 800ca86:	4413      	add	r3, r2
 800ca88:	685b      	ldr	r3, [r3, #4]
 800ca8a:	699b      	ldr	r3, [r3, #24]
 800ca8c:	9a04      	ldr	r2, [sp, #16]
 800ca8e:	440a      	add	r2, r1
 800ca90:	609a      	str	r2, [r3, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 800ca92:	9a01      	ldr	r2, [sp, #4]
 800ca94:	9b03      	ldr	r3, [sp, #12]
 800ca96:	3302      	adds	r3, #2
 800ca98:	009b      	lsls	r3, r3, #2
 800ca9a:	4413      	add	r3, r2
 800ca9c:	685b      	ldr	r3, [r3, #4]
 800ca9e:	699b      	ldr	r3, [r3, #24]
 800caa0:	6859      	ldr	r1, [r3, #4]
 800caa2:	9a01      	ldr	r2, [sp, #4]
 800caa4:	9b03      	ldr	r3, [sp, #12]
 800caa6:	3302      	adds	r3, #2
 800caa8:	009b      	lsls	r3, r3, #2
 800caaa:	4413      	add	r3, r2
 800caac:	685b      	ldr	r3, [r3, #4]
 800caae:	699b      	ldr	r3, [r3, #24]
 800cab0:	9a04      	ldr	r2, [sp, #16]
 800cab2:	440a      	add	r2, r1
 800cab4:	605a      	str	r2, [r3, #4]
 800cab6:	e004      	b.n	800cac2 <otg_rxfifo_handler+0x102>
    break;
  case GRXSTSP_OUT_COMP:
 800cab8:	bf00      	nop
 800caba:	e002      	b.n	800cac2 <otg_rxfifo_handler+0x102>
    break;
  case GRXSTSP_OUT_GLOBAL_NAK:
 800cabc:	bf00      	nop
 800cabe:	e000      	b.n	800cac2 <otg_rxfifo_handler+0x102>
  case GRXSTSP_SETUP_COMP:
 800cac0:	bf00      	nop
    break;
  default:
    break;
  }
}
 800cac2:	b006      	add	sp, #24
 800cac4:	bd10      	pop	{r4, pc}
 800cac6:	bf00      	nop
	...

0800cad0 <otg_txfifo_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 800cad0:	b500      	push	{lr}
 800cad2:	b085      	sub	sp, #20
 800cad4:	9001      	str	r0, [sp, #4]
 800cad6:	460b      	mov	r3, r1
 800cad8:	f88d 3003 	strb.w	r3, [sp, #3]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 800cadc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cae0:	9a01      	ldr	r2, [sp, #4]
 800cae2:	3302      	adds	r3, #2
 800cae4:	009b      	lsls	r3, r3, #2
 800cae6:	4413      	add	r3, r2
 800cae8:	685b      	ldr	r3, [r3, #4]
 800caea:	695b      	ldr	r3, [r3, #20]
 800caec:	685a      	ldr	r2, [r3, #4]
 800caee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800caf2:	9901      	ldr	r1, [sp, #4]
 800caf4:	3302      	adds	r3, #2
 800caf6:	009b      	lsls	r3, r3, #2
 800caf8:	440b      	add	r3, r1
 800cafa:	685b      	ldr	r3, [r3, #4]
 800cafc:	695b      	ldr	r3, [r3, #20]
 800cafe:	681b      	ldr	r3, [r3, #0]
 800cb00:	429a      	cmp	r2, r3
 800cb02:	d310      	bcc.n	800cb26 <otg_txfifo_handler+0x56>
#if 1
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 800cb04:	9b01      	ldr	r3, [sp, #4]
 800cb06:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800cb08:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
 800cb0c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cb10:	2201      	movs	r2, #1
 800cb12:	fa02 f303 	lsl.w	r3, r2, r3
 800cb16:	43da      	mvns	r2, r3
 800cb18:	9b01      	ldr	r3, [sp, #4]
 800cb1a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800cb1c:	400a      	ands	r2, r1
 800cb1e:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
#endif
      return true;
 800cb22:	2301      	movs	r3, #1
 800cb24:	e075      	b.n	800cc12 <otg_txfifo_handler+0x142>
    }

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 800cb26:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cb2a:	9a01      	ldr	r2, [sp, #4]
 800cb2c:	3302      	adds	r3, #2
 800cb2e:	009b      	lsls	r3, r3, #2
 800cb30:	4413      	add	r3, r2
 800cb32:	685b      	ldr	r3, [r3, #4]
 800cb34:	695b      	ldr	r3, [r3, #20]
 800cb36:	681a      	ldr	r2, [r3, #0]
 800cb38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cb3c:	9901      	ldr	r1, [sp, #4]
 800cb3e:	3302      	adds	r3, #2
 800cb40:	009b      	lsls	r3, r3, #2
 800cb42:	440b      	add	r3, r1
 800cb44:	685b      	ldr	r3, [r3, #4]
 800cb46:	695b      	ldr	r3, [r3, #20]
 800cb48:	685b      	ldr	r3, [r3, #4]
 800cb4a:	1ad3      	subs	r3, r2, r3
 800cb4c:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 800cb4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cb52:	9a01      	ldr	r2, [sp, #4]
 800cb54:	3302      	adds	r3, #2
 800cb56:	009b      	lsls	r3, r3, #2
 800cb58:	4413      	add	r3, r2
 800cb5a:	685b      	ldr	r3, [r3, #4]
 800cb5c:	8a1b      	ldrh	r3, [r3, #16]
 800cb5e:	461a      	mov	r2, r3
 800cb60:	9b03      	ldr	r3, [sp, #12]
 800cb62:	4293      	cmp	r3, r2
 800cb64:	d908      	bls.n	800cb78 <otg_txfifo_handler+0xa8>
      n = usbp->epc[ep]->in_maxsize;
 800cb66:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cb6a:	9a01      	ldr	r2, [sp, #4]
 800cb6c:	3302      	adds	r3, #2
 800cb6e:	009b      	lsls	r3, r3, #2
 800cb70:	4413      	add	r3, r2
 800cb72:	685b      	ldr	r3, [r3, #4]
 800cb74:	8a1b      	ldrh	r3, [r3, #16]
 800cb76:	9303      	str	r3, [sp, #12]

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800cb78:	9b01      	ldr	r3, [sp, #4]
 800cb7a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cb7c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cb80:	015b      	lsls	r3, r3, #5
 800cb82:	4413      	add	r3, r2
 800cb84:	f603 1318 	addw	r3, r3, #2328	; 0x918
 800cb88:	681b      	ldr	r3, [r3, #0]
 800cb8a:	b29b      	uxth	r3, r3
 800cb8c:	009b      	lsls	r3, r3, #2
 800cb8e:	9a03      	ldr	r2, [sp, #12]
 800cb90:	429a      	cmp	r2, r3
 800cb92:	d901      	bls.n	800cb98 <otg_txfifo_handler+0xc8>
      return false;
 800cb94:	2300      	movs	r3, #0
 800cb96:	e03c      	b.n	800cc12 <otg_txfifo_handler+0x142>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800cb98:	9b01      	ldr	r3, [sp, #4]
 800cb9a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cb9c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cba0:	3301      	adds	r3, #1
 800cba2:	031b      	lsls	r3, r3, #12
 800cba4:	18d0      	adds	r0, r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 800cba6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cbaa:	9a01      	ldr	r2, [sp, #4]
 800cbac:	3302      	adds	r3, #2
 800cbae:	009b      	lsls	r3, r3, #2
 800cbb0:	4413      	add	r3, r2
 800cbb2:	685b      	ldr	r3, [r3, #4]
 800cbb4:	695b      	ldr	r3, [r3, #20]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800cbb6:	689b      	ldr	r3, [r3, #8]
 800cbb8:	9a03      	ldr	r2, [sp, #12]
 800cbba:	4619      	mov	r1, r3
 800cbbc:	f7ff feb8 	bl	800c930 <otg_fifo_write_from_buffer>
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 800cbc0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cbc4:	9a01      	ldr	r2, [sp, #4]
 800cbc6:	3302      	adds	r3, #2
 800cbc8:	009b      	lsls	r3, r3, #2
 800cbca:	4413      	add	r3, r2
 800cbcc:	685b      	ldr	r3, [r3, #4]
 800cbce:	695b      	ldr	r3, [r3, #20]
 800cbd0:	6899      	ldr	r1, [r3, #8]
 800cbd2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cbd6:	9a01      	ldr	r2, [sp, #4]
 800cbd8:	3302      	adds	r3, #2
 800cbda:	009b      	lsls	r3, r3, #2
 800cbdc:	4413      	add	r3, r2
 800cbde:	685b      	ldr	r3, [r3, #4]
 800cbe0:	695b      	ldr	r3, [r3, #20]
 800cbe2:	9a03      	ldr	r2, [sp, #12]
 800cbe4:	440a      	add	r2, r1
 800cbe6:	609a      	str	r2, [r3, #8]
    usbp->epc[ep]->in_state->txcnt += n;
 800cbe8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cbec:	9a01      	ldr	r2, [sp, #4]
 800cbee:	3302      	adds	r3, #2
 800cbf0:	009b      	lsls	r3, r3, #2
 800cbf2:	4413      	add	r3, r2
 800cbf4:	685b      	ldr	r3, [r3, #4]
 800cbf6:	695b      	ldr	r3, [r3, #20]
 800cbf8:	6859      	ldr	r1, [r3, #4]
 800cbfa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cbfe:	9a01      	ldr	r2, [sp, #4]
 800cc00:	3302      	adds	r3, #2
 800cc02:	009b      	lsls	r3, r3, #2
 800cc04:	4413      	add	r3, r2
 800cc06:	685b      	ldr	r3, [r3, #4]
 800cc08:	695b      	ldr	r3, [r3, #20]
 800cc0a:	9a03      	ldr	r2, [sp, #12]
 800cc0c:	440a      	add	r2, r1
 800cc0e:	605a      	str	r2, [r3, #4]
 800cc10:	e764      	b.n	800cadc <otg_txfifo_handler+0xc>
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
  }
}
 800cc12:	4618      	mov	r0, r3
 800cc14:	b005      	add	sp, #20
 800cc16:	f85d fb04 	ldr.w	pc, [sp], #4
 800cc1a:	bf00      	nop
 800cc1c:	0000      	movs	r0, r0
	...

0800cc20 <otg_epin_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 800cc20:	b500      	push	{lr}
 800cc22:	b087      	sub	sp, #28
 800cc24:	9001      	str	r0, [sp, #4]
 800cc26:	460b      	mov	r3, r1
 800cc28:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800cc2c:	9b01      	ldr	r3, [sp, #4]
 800cc2e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800cc30:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 800cc32:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cc36:	9a05      	ldr	r2, [sp, #20]
 800cc38:	015b      	lsls	r3, r3, #5
 800cc3a:	4413      	add	r3, r2
 800cc3c:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800cc40:	681b      	ldr	r3, [r3, #0]
 800cc42:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 800cc44:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cc48:	9a05      	ldr	r2, [sp, #20]
 800cc4a:	015b      	lsls	r3, r3, #5
 800cc4c:	4413      	add	r3, r2
 800cc4e:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800cc52:	9a04      	ldr	r2, [sp, #16]
 800cc54:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 800cc56:	9b04      	ldr	r3, [sp, #16]
 800cc58:	f003 0301 	and.w	r3, r3, #1
 800cc5c:	2b00      	cmp	r3, #0
 800cc5e:	d051      	beq.n	800cd04 <otg_epin_handler+0xe4>
 800cc60:	9b05      	ldr	r3, [sp, #20]
 800cc62:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 800cc66:	f003 0301 	and.w	r3, r3, #1
 800cc6a:	2b00      	cmp	r3, #0
 800cc6c:	d04a      	beq.n	800cd04 <otg_epin_handler+0xe4>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800cc6e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cc72:	9a01      	ldr	r2, [sp, #4]
 800cc74:	3302      	adds	r3, #2
 800cc76:	009b      	lsls	r3, r3, #2
 800cc78:	4413      	add	r3, r2
 800cc7a:	685b      	ldr	r3, [r3, #4]
 800cc7c:	695b      	ldr	r3, [r3, #20]
 800cc7e:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 800cc80:	9b03      	ldr	r3, [sp, #12]
 800cc82:	681a      	ldr	r2, [r3, #0]
 800cc84:	9b03      	ldr	r3, [sp, #12]
 800cc86:	68db      	ldr	r3, [r3, #12]
 800cc88:	429a      	cmp	r2, r3
 800cc8a:	d214      	bcs.n	800ccb6 <otg_epin_handler+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800cc8c:	9b03      	ldr	r3, [sp, #12]
 800cc8e:	68da      	ldr	r2, [r3, #12]
 800cc90:	9b03      	ldr	r3, [sp, #12]
 800cc92:	681b      	ldr	r3, [r3, #0]
 800cc94:	1ad2      	subs	r2, r2, r3
 800cc96:	9b03      	ldr	r3, [sp, #12]
 800cc98:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 800cc9a:	9b03      	ldr	r3, [sp, #12]
 800cc9c:	2200      	movs	r2, #0
 800cc9e:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 800cca0:	f7ff fd56 	bl	800c750 <osalSysLockFromISR.lto_priv.557>
      usb_lld_start_in(usbp, ep);
 800cca4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cca8:	4619      	mov	r1, r3
 800ccaa:	9801      	ldr	r0, [sp, #4]
 800ccac:	f000 feb0 	bl	800da10 <usb_lld_start_in>
      osalSysUnlockFromISR();
 800ccb0:	f7ff fd56 	bl	800c760 <osalSysUnlockFromISR.lto_priv.551>
 800ccb4:	e026      	b.n	800cd04 <otg_epin_handler+0xe4>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 800ccb6:	9b01      	ldr	r3, [sp, #4]
 800ccb8:	891b      	ldrh	r3, [r3, #8]
 800ccba:	b21a      	sxth	r2, r3
 800ccbc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800ccc0:	2101      	movs	r1, #1
 800ccc2:	fa01 f303 	lsl.w	r3, r1, r3
 800ccc6:	b21b      	sxth	r3, r3
 800ccc8:	43db      	mvns	r3, r3
 800ccca:	b21b      	sxth	r3, r3
 800cccc:	4013      	ands	r3, r2
 800ccce:	b21b      	sxth	r3, r3
 800ccd0:	b29a      	uxth	r2, r3
 800ccd2:	9b01      	ldr	r3, [sp, #4]
 800ccd4:	811a      	strh	r2, [r3, #8]
 800ccd6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800ccda:	9a01      	ldr	r2, [sp, #4]
 800ccdc:	3302      	adds	r3, #2
 800ccde:	009b      	lsls	r3, r3, #2
 800cce0:	4413      	add	r3, r2
 800cce2:	685b      	ldr	r3, [r3, #4]
 800cce4:	689b      	ldr	r3, [r3, #8]
 800cce6:	2b00      	cmp	r3, #0
 800cce8:	d00c      	beq.n	800cd04 <otg_epin_handler+0xe4>
 800ccea:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800ccee:	9a01      	ldr	r2, [sp, #4]
 800ccf0:	3302      	adds	r3, #2
 800ccf2:	009b      	lsls	r3, r3, #2
 800ccf4:	4413      	add	r3, r2
 800ccf6:	685b      	ldr	r3, [r3, #4]
 800ccf8:	689b      	ldr	r3, [r3, #8]
 800ccfa:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800ccfe:	4611      	mov	r1, r2
 800cd00:	9801      	ldr	r0, [sp, #4]
 800cd02:	4798      	blx	r3
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 800cd04:	9b04      	ldr	r3, [sp, #16]
 800cd06:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800cd0a:	2b00      	cmp	r3, #0
 800cd0c:	d010      	beq.n	800cd30 <otg_epin_handler+0x110>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 800cd0e:	9b05      	ldr	r3, [sp, #20]
 800cd10:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 800cd14:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cd18:	2101      	movs	r1, #1
 800cd1a:	fa01 f303 	lsl.w	r3, r1, r3
 800cd1e:	4013      	ands	r3, r2
  if ((epint & DIEPINT_TXFE) &&
 800cd20:	2b00      	cmp	r3, #0
 800cd22:	d005      	beq.n	800cd30 <otg_epin_handler+0x110>
    /* TX FIFO empty or emptying.*/
    otg_txfifo_handler(usbp, ep);
 800cd24:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cd28:	4619      	mov	r1, r3
 800cd2a:	9801      	ldr	r0, [sp, #4]
 800cd2c:	f7ff fed0 	bl	800cad0 <otg_txfifo_handler>
  }
}
 800cd30:	b007      	add	sp, #28
 800cd32:	f85d fb04 	ldr.w	pc, [sp], #4
 800cd36:	bf00      	nop
	...

0800cd40 <otg_epout_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 800cd40:	b500      	push	{lr}
 800cd42:	b087      	sub	sp, #28
 800cd44:	9001      	str	r0, [sp, #4]
 800cd46:	460b      	mov	r3, r1
 800cd48:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800cd4c:	9b01      	ldr	r3, [sp, #4]
 800cd4e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800cd50:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800cd52:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cd56:	9a05      	ldr	r2, [sp, #20]
 800cd58:	015b      	lsls	r3, r3, #5
 800cd5a:	4413      	add	r3, r2
 800cd5c:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800cd60:	681b      	ldr	r3, [r3, #0]
 800cd62:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 800cd64:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cd68:	9a05      	ldr	r2, [sp, #20]
 800cd6a:	015b      	lsls	r3, r3, #5
 800cd6c:	4413      	add	r3, r2
 800cd6e:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800cd72:	9a04      	ldr	r2, [sp, #16]
 800cd74:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 800cd76:	9b04      	ldr	r3, [sp, #16]
 800cd78:	f003 0308 	and.w	r3, r3, #8
 800cd7c:	2b00      	cmp	r3, #0
 800cd7e:	d013      	beq.n	800cda8 <otg_epout_handler+0x68>
 800cd80:	9b05      	ldr	r3, [sp, #20]
 800cd82:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 800cd86:	f003 0308 	and.w	r3, r3, #8
 800cd8a:	2b00      	cmp	r3, #0
 800cd8c:	d00c      	beq.n	800cda8 <otg_epout_handler+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 800cd8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cd92:	9a01      	ldr	r2, [sp, #4]
 800cd94:	3302      	adds	r3, #2
 800cd96:	009b      	lsls	r3, r3, #2
 800cd98:	4413      	add	r3, r2
 800cd9a:	685b      	ldr	r3, [r3, #4]
 800cd9c:	685b      	ldr	r3, [r3, #4]
 800cd9e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800cda2:	4611      	mov	r1, r2
 800cda4:	9801      	ldr	r0, [sp, #4]
 800cda6:	4798      	blx	r3
  }

  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 800cda8:	9b04      	ldr	r3, [sp, #16]
 800cdaa:	f003 0301 	and.w	r3, r3, #1
 800cdae:	2b00      	cmp	r3, #0
 800cdb0:	d066      	beq.n	800ce80 <otg_epout_handler+0x140>
 800cdb2:	9b05      	ldr	r3, [sp, #20]
 800cdb4:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 800cdb8:	f003 0301 	and.w	r3, r3, #1
 800cdbc:	2b00      	cmp	r3, #0
 800cdbe:	d05f      	beq.n	800ce80 <otg_epout_handler+0x140>
    USBOutEndpointState *osp;

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 800cdc0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cdc4:	9a01      	ldr	r2, [sp, #4]
 800cdc6:	3302      	adds	r3, #2
 800cdc8:	009b      	lsls	r3, r3, #2
 800cdca:	4413      	add	r3, r2
 800cdcc:	685b      	ldr	r3, [r3, #4]
 800cdce:	699b      	ldr	r3, [r3, #24]
 800cdd0:	9303      	str	r3, [sp, #12]

    /* EP0 requires special handling.*/
    if (ep == 0) {
 800cdd2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cdd6:	2b00      	cmp	r3, #0
 800cdd8:	d12b      	bne.n	800ce32 <otg_epout_handler+0xf2>
#endif

      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800cdda:	9b03      	ldr	r3, [sp, #12]
 800cddc:	685a      	ldr	r2, [r3, #4]
 800cdde:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800cde2:	9901      	ldr	r1, [sp, #4]
 800cde4:	3302      	adds	r3, #2
 800cde6:	009b      	lsls	r3, r3, #2
 800cde8:	440b      	add	r3, r1
 800cdea:	685b      	ldr	r3, [r3, #4]
 800cdec:	8a5b      	ldrh	r3, [r3, #18]
 800cdee:	fbb2 f1f3 	udiv	r1, r2, r3
 800cdf2:	fb03 f301 	mul.w	r3, r3, r1
 800cdf6:	1ad3      	subs	r3, r2, r3
 800cdf8:	2b00      	cmp	r3, #0
 800cdfa:	d11a      	bne.n	800ce32 <otg_epout_handler+0xf2>
          (osp->rxsize < osp->totsize)) {
 800cdfc:	9b03      	ldr	r3, [sp, #12]
 800cdfe:	681a      	ldr	r2, [r3, #0]
 800ce00:	9b03      	ldr	r3, [sp, #12]
 800ce02:	68db      	ldr	r3, [r3, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800ce04:	429a      	cmp	r2, r3
 800ce06:	d214      	bcs.n	800ce32 <otg_epout_handler+0xf2>
        osp->rxsize = osp->totsize - osp->rxsize;
 800ce08:	9b03      	ldr	r3, [sp, #12]
 800ce0a:	68da      	ldr	r2, [r3, #12]
 800ce0c:	9b03      	ldr	r3, [sp, #12]
 800ce0e:	681b      	ldr	r3, [r3, #0]
 800ce10:	1ad2      	subs	r2, r2, r3
 800ce12:	9b03      	ldr	r3, [sp, #12]
 800ce14:	601a      	str	r2, [r3, #0]
        osp->rxcnt  = 0;
 800ce16:	9b03      	ldr	r3, [sp, #12]
 800ce18:	2200      	movs	r2, #0
 800ce1a:	605a      	str	r2, [r3, #4]
        osalSysLockFromISR();
 800ce1c:	f7ff fc98 	bl	800c750 <osalSysLockFromISR.lto_priv.557>
        usb_lld_start_out(usbp, ep);
 800ce20:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800ce24:	4619      	mov	r1, r3
 800ce26:	9801      	ldr	r0, [sp, #4]
 800ce28:	f000 fd52 	bl	800d8d0 <usb_lld_start_out>
        osalSysUnlockFromISR();
 800ce2c:	f7ff fc98 	bl	800c760 <osalSysUnlockFromISR.lto_priv.551>
 800ce30:	e026      	b.n	800ce80 <otg_epout_handler+0x140>
        return;
      }
    }

    /* End on OUT transfer.*/
    _usb_isr_invoke_out_cb(usbp, ep);
 800ce32:	9b01      	ldr	r3, [sp, #4]
 800ce34:	895b      	ldrh	r3, [r3, #10]
 800ce36:	b21a      	sxth	r2, r3
 800ce38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800ce3c:	2101      	movs	r1, #1
 800ce3e:	fa01 f303 	lsl.w	r3, r1, r3
 800ce42:	b21b      	sxth	r3, r3
 800ce44:	43db      	mvns	r3, r3
 800ce46:	b21b      	sxth	r3, r3
 800ce48:	4013      	ands	r3, r2
 800ce4a:	b21b      	sxth	r3, r3
 800ce4c:	b29a      	uxth	r2, r3
 800ce4e:	9b01      	ldr	r3, [sp, #4]
 800ce50:	815a      	strh	r2, [r3, #10]
 800ce52:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800ce56:	9a01      	ldr	r2, [sp, #4]
 800ce58:	3302      	adds	r3, #2
 800ce5a:	009b      	lsls	r3, r3, #2
 800ce5c:	4413      	add	r3, r2
 800ce5e:	685b      	ldr	r3, [r3, #4]
 800ce60:	68db      	ldr	r3, [r3, #12]
 800ce62:	2b00      	cmp	r3, #0
 800ce64:	d00c      	beq.n	800ce80 <otg_epout_handler+0x140>
 800ce66:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800ce6a:	9a01      	ldr	r2, [sp, #4]
 800ce6c:	3302      	adds	r3, #2
 800ce6e:	009b      	lsls	r3, r3, #2
 800ce70:	4413      	add	r3, r2
 800ce72:	685b      	ldr	r3, [r3, #4]
 800ce74:	68db      	ldr	r3, [r3, #12]
 800ce76:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800ce7a:	4611      	mov	r1, r2
 800ce7c:	9801      	ldr	r0, [sp, #4]
 800ce7e:	4798      	blx	r3
  }
}
 800ce80:	b007      	add	sp, #28
 800ce82:	f85d fb04 	ldr.w	pc, [sp], #4
 800ce86:	bf00      	nop
	...

0800ce90 <otg_isoc_in_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 800ce90:	b500      	push	{lr}
 800ce92:	b085      	sub	sp, #20
 800ce94:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 800ce96:	9b01      	ldr	r3, [sp, #4]
 800ce98:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ce9a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800ce9c:	2300      	movs	r3, #0
 800ce9e:	f88d 300f 	strb.w	r3, [sp, #15]
 800cea2:	e065      	b.n	800cf70 <otg_isoc_in_failed_handler+0xe0>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 800cea4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cea8:	9a02      	ldr	r2, [sp, #8]
 800ceaa:	3348      	adds	r3, #72	; 0x48
 800ceac:	015b      	lsls	r3, r3, #5
 800ceae:	4413      	add	r3, r2
 800ceb0:	681b      	ldr	r3, [r3, #0]
 800ceb2:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 800ceb6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800ceba:	d154      	bne.n	800cf66 <otg_isoc_in_failed_handler+0xd6>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 800cebc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cec0:	9a02      	ldr	r2, [sp, #8]
 800cec2:	3348      	adds	r3, #72	; 0x48
 800cec4:	015b      	lsls	r3, r3, #5
 800cec6:	4413      	add	r3, r2
 800cec8:	681b      	ldr	r3, [r3, #0]
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 800ceca:	2b00      	cmp	r3, #0
 800cecc:	da4b      	bge.n	800cf66 <otg_isoc_in_failed_handler+0xd6>
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 800cece:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800ced2:	9a02      	ldr	r2, [sp, #8]
 800ced4:	3348      	adds	r3, #72	; 0x48
 800ced6:	015b      	lsls	r3, r3, #5
 800ced8:	4413      	add	r3, r2
 800ceda:	681a      	ldr	r2, [r3, #0]
 800cedc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cee0:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 800cee4:	9902      	ldr	r1, [sp, #8]
 800cee6:	3348      	adds	r3, #72	; 0x48
 800cee8:	015b      	lsls	r3, r3, #5
 800ceea:	440b      	add	r3, r1
 800ceec:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 800ceee:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cef2:	9a02      	ldr	r2, [sp, #8]
 800cef4:	3348      	adds	r3, #72	; 0x48
 800cef6:	015b      	lsls	r3, r3, #5
 800cef8:	4413      	add	r3, r2
 800cefa:	681b      	ldr	r3, [r3, #0]
 800cefc:	2b00      	cmp	r3, #0
 800cefe:	dbf6      	blt.n	800ceee <otg_isoc_in_failed_handler+0x5e>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 800cf00:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cf04:	4619      	mov	r1, r3
 800cf06:	9801      	ldr	r0, [sp, #4]
 800cf08:	f7ff fcc2 	bl	800c890 <otg_txfifo_flush>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 800cf0c:	9b01      	ldr	r3, [sp, #4]
 800cf0e:	891b      	ldrh	r3, [r3, #8]
 800cf10:	b21a      	sxth	r2, r3
 800cf12:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cf16:	2101      	movs	r1, #1
 800cf18:	fa01 f303 	lsl.w	r3, r1, r3
 800cf1c:	b21b      	sxth	r3, r3
 800cf1e:	43db      	mvns	r3, r3
 800cf20:	b21b      	sxth	r3, r3
 800cf22:	4013      	ands	r3, r2
 800cf24:	b21b      	sxth	r3, r3
 800cf26:	b29a      	uxth	r2, r3
 800cf28:	9b01      	ldr	r3, [sp, #4]
 800cf2a:	811a      	strh	r2, [r3, #8]
 800cf2c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cf30:	9a01      	ldr	r2, [sp, #4]
 800cf32:	3302      	adds	r3, #2
 800cf34:	009b      	lsls	r3, r3, #2
 800cf36:	4413      	add	r3, r2
 800cf38:	685b      	ldr	r3, [r3, #4]
 800cf3a:	689b      	ldr	r3, [r3, #8]
 800cf3c:	2b00      	cmp	r3, #0
 800cf3e:	d00c      	beq.n	800cf5a <otg_isoc_in_failed_handler+0xca>
 800cf40:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cf44:	9a01      	ldr	r2, [sp, #4]
 800cf46:	3302      	adds	r3, #2
 800cf48:	009b      	lsls	r3, r3, #2
 800cf4a:	4413      	add	r3, r2
 800cf4c:	685b      	ldr	r3, [r3, #4]
 800cf4e:	689b      	ldr	r3, [r3, #8]
 800cf50:	f89d 200f 	ldrb.w	r2, [sp, #15]
 800cf54:	4611      	mov	r1, r2
 800cf56:	9801      	ldr	r0, [sp, #4]
 800cf58:	4798      	blx	r3

      /* TX FIFO empty or emptying.*/
      otg_txfifo_handler(usbp, ep);
 800cf5a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cf5e:	4619      	mov	r1, r3
 800cf60:	9801      	ldr	r0, [sp, #4]
 800cf62:	f7ff fdb5 	bl	800cad0 <otg_txfifo_handler>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800cf66:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cf6a:	3301      	adds	r3, #1
 800cf6c:	f88d 300f 	strb.w	r3, [sp, #15]
 800cf70:	f89d 200f 	ldrb.w	r2, [sp, #15]
 800cf74:	9b01      	ldr	r3, [sp, #4]
 800cf76:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800cf78:	689b      	ldr	r3, [r3, #8]
 800cf7a:	429a      	cmp	r2, r3
 800cf7c:	d992      	bls.n	800cea4 <otg_isoc_in_failed_handler+0x14>
    }
  }
}
 800cf7e:	b005      	add	sp, #20
 800cf80:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800cf90 <otg_isoc_out_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 800cf90:	b500      	push	{lr}
 800cf92:	b085      	sub	sp, #20
 800cf94:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 800cf96:	9b01      	ldr	r3, [sp, #4]
 800cf98:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800cf9a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800cf9c:	2300      	movs	r3, #0
 800cf9e:	f88d 300f 	strb.w	r3, [sp, #15]
 800cfa2:	e040      	b.n	800d026 <otg_isoc_out_failed_handler+0x96>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 800cfa4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cfa8:	9a02      	ldr	r2, [sp, #8]
 800cfaa:	3358      	adds	r3, #88	; 0x58
 800cfac:	015b      	lsls	r3, r3, #5
 800cfae:	4413      	add	r3, r2
 800cfb0:	681b      	ldr	r3, [r3, #0]
 800cfb2:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 800cfb6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800cfba:	d12f      	bne.n	800d01c <otg_isoc_out_failed_handler+0x8c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 800cfbc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cfc0:	9a02      	ldr	r2, [sp, #8]
 800cfc2:	3358      	adds	r3, #88	; 0x58
 800cfc4:	015b      	lsls	r3, r3, #5
 800cfc6:	4413      	add	r3, r2
 800cfc8:	681b      	ldr	r3, [r3, #0]
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 800cfca:	2b00      	cmp	r3, #0
 800cfcc:	da26      	bge.n	800d01c <otg_isoc_out_failed_handler+0x8c>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 800cfce:	9b01      	ldr	r3, [sp, #4]
 800cfd0:	895b      	ldrh	r3, [r3, #10]
 800cfd2:	b21a      	sxth	r2, r3
 800cfd4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cfd8:	2101      	movs	r1, #1
 800cfda:	fa01 f303 	lsl.w	r3, r1, r3
 800cfde:	b21b      	sxth	r3, r3
 800cfe0:	43db      	mvns	r3, r3
 800cfe2:	b21b      	sxth	r3, r3
 800cfe4:	4013      	ands	r3, r2
 800cfe6:	b21b      	sxth	r3, r3
 800cfe8:	b29a      	uxth	r2, r3
 800cfea:	9b01      	ldr	r3, [sp, #4]
 800cfec:	815a      	strh	r2, [r3, #10]
 800cfee:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800cff2:	9a01      	ldr	r2, [sp, #4]
 800cff4:	3302      	adds	r3, #2
 800cff6:	009b      	lsls	r3, r3, #2
 800cff8:	4413      	add	r3, r2
 800cffa:	685b      	ldr	r3, [r3, #4]
 800cffc:	68db      	ldr	r3, [r3, #12]
 800cffe:	2b00      	cmp	r3, #0
 800d000:	d00c      	beq.n	800d01c <otg_isoc_out_failed_handler+0x8c>
 800d002:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800d006:	9a01      	ldr	r2, [sp, #4]
 800d008:	3302      	adds	r3, #2
 800d00a:	009b      	lsls	r3, r3, #2
 800d00c:	4413      	add	r3, r2
 800d00e:	685b      	ldr	r3, [r3, #4]
 800d010:	68db      	ldr	r3, [r3, #12]
 800d012:	f89d 200f 	ldrb.w	r2, [sp, #15]
 800d016:	4611      	mov	r1, r2
 800d018:	9801      	ldr	r0, [sp, #4]
 800d01a:	4798      	blx	r3
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800d01c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800d020:	3301      	adds	r3, #1
 800d022:	f88d 300f 	strb.w	r3, [sp, #15]
 800d026:	f89d 200f 	ldrb.w	r2, [sp, #15]
 800d02a:	9b01      	ldr	r3, [sp, #4]
 800d02c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d02e:	689b      	ldr	r3, [r3, #8]
 800d030:	429a      	cmp	r2, r3
 800d032:	d9b7      	bls.n	800cfa4 <otg_isoc_out_failed_handler+0x14>
    }
  }
}
 800d034:	b005      	add	sp, #20
 800d036:	f85d fb04 	ldr.w	pc, [sp], #4
 800d03a:	bf00      	nop
 800d03c:	0000      	movs	r0, r0
	...

0800d040 <usb_lld_serve_interrupt>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 800d040:	b500      	push	{lr}
 800d042:	b087      	sub	sp, #28
 800d044:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 800d046:	9b01      	ldr	r3, [sp, #4]
 800d048:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d04a:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 800d04c:	9b05      	ldr	r3, [sp, #20]
 800d04e:	695b      	ldr	r3, [r3, #20]
 800d050:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 800d052:	9b05      	ldr	r3, [sp, #20]
 800d054:	699b      	ldr	r3, [r3, #24]
 800d056:	9a04      	ldr	r2, [sp, #16]
 800d058:	4013      	ands	r3, r2
 800d05a:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 800d05c:	9b05      	ldr	r3, [sp, #20]
 800d05e:	9a04      	ldr	r2, [sp, #16]
 800d060:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 800d062:	9b04      	ldr	r3, [sp, #16]
 800d064:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800d068:	2b00      	cmp	r3, #0
 800d06a:	d003      	beq.n	800d074 <usb_lld_serve_interrupt+0x34>
    /* Default reset action.*/
    _usb_reset(usbp);
 800d06c:	9801      	ldr	r0, [sp, #4]
 800d06e:	f7fe faf7 	bl	800b660 <_usb_reset>
 800d072:	e0e2      	b.n	800d23a <usb_lld_serve_interrupt+0x1fa>
    /* Preventing execution of more handlers, the core has been reset.*/
    return;
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 800d074:	9b04      	ldr	r3, [sp, #16]
 800d076:	2b00      	cmp	r3, #0
 800d078:	da19      	bge.n	800d0ae <usb_lld_serve_interrupt+0x6e>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 800d07a:	9b05      	ldr	r3, [sp, #20]
 800d07c:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 800d080:	f003 0303 	and.w	r3, r3, #3
 800d084:	2b00      	cmp	r3, #0
 800d086:	d007      	beq.n	800d098 <usb_lld_serve_interrupt+0x58>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 800d088:	9b05      	ldr	r3, [sp, #20]
 800d08a:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 800d08e:	f023 0203 	bic.w	r2, r3, #3
 800d092:	9b05      	ldr	r3, [sp, #20]
 800d094:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL &= ~DCTL_RWUSIG;
 800d098:	9b05      	ldr	r3, [sp, #20]
 800d09a:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 800d09e:	f023 0201 	bic.w	r2, r3, #1
 800d0a2:	9b05      	ldr	r3, [sp, #20]
 800d0a4:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 800d0a8:	9801      	ldr	r0, [sp, #4]
 800d0aa:	f7fe fb39 	bl	800b720 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 800d0ae:	9b04      	ldr	r3, [sp, #16]
 800d0b0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800d0b4:	2b00      	cmp	r3, #0
 800d0b6:	d002      	beq.n	800d0be <usb_lld_serve_interrupt+0x7e>
    /* Default suspend action.*/
    _usb_suspend(usbp);
 800d0b8:	9801      	ldr	r0, [sp, #4]
 800d0ba:	f7fe fb11 	bl	800b6e0 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 800d0be:	9b04      	ldr	r3, [sp, #16]
 800d0c0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800d0c4:	2b00      	cmp	r3, #0
 800d0c6:	d017      	beq.n	800d0f8 <usb_lld_serve_interrupt+0xb8>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 800d0c8:	9b05      	ldr	r3, [sp, #20]
 800d0ca:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 800d0ce:	f003 0306 	and.w	r3, r3, #6
 800d0d2:	2b00      	cmp	r3, #0
 800d0d4:	d108      	bne.n	800d0e8 <usb_lld_serve_interrupt+0xa8>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 800d0d6:	9b05      	ldr	r3, [sp, #20]
 800d0d8:	68db      	ldr	r3, [r3, #12]
 800d0da:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800d0de:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 800d0e2:	9b05      	ldr	r3, [sp, #20]
 800d0e4:	60da      	str	r2, [r3, #12]
 800d0e6:	e007      	b.n	800d0f8 <usb_lld_serve_interrupt+0xb8>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 800d0e8:	9b05      	ldr	r3, [sp, #20]
 800d0ea:	68db      	ldr	r3, [r3, #12]
 800d0ec:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800d0f0:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 800d0f4:	9b05      	ldr	r3, [sp, #20]
 800d0f6:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 800d0f8:	9b04      	ldr	r3, [sp, #16]
 800d0fa:	f003 0308 	and.w	r3, r3, #8
 800d0fe:	2b00      	cmp	r3, #0
 800d100:	d009      	beq.n	800d116 <usb_lld_serve_interrupt+0xd6>
    _usb_isr_invoke_sof_cb(usbp);
 800d102:	9b01      	ldr	r3, [sp, #4]
 800d104:	685b      	ldr	r3, [r3, #4]
 800d106:	68db      	ldr	r3, [r3, #12]
 800d108:	2b00      	cmp	r3, #0
 800d10a:	d004      	beq.n	800d116 <usb_lld_serve_interrupt+0xd6>
 800d10c:	9b01      	ldr	r3, [sp, #4]
 800d10e:	685b      	ldr	r3, [r3, #4]
 800d110:	68db      	ldr	r3, [r3, #12]
 800d112:	9801      	ldr	r0, [sp, #4]
 800d114:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 800d116:	9b04      	ldr	r3, [sp, #16]
 800d118:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800d11c:	2b00      	cmp	r3, #0
 800d11e:	d002      	beq.n	800d126 <usb_lld_serve_interrupt+0xe6>
    otg_isoc_in_failed_handler(usbp);
 800d120:	9801      	ldr	r0, [sp, #4]
 800d122:	f7ff feb5 	bl	800ce90 <otg_isoc_in_failed_handler>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 800d126:	9b04      	ldr	r3, [sp, #16]
 800d128:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800d12c:	2b00      	cmp	r3, #0
 800d12e:	d002      	beq.n	800d136 <usb_lld_serve_interrupt+0xf6>
    otg_isoc_out_failed_handler(usbp);
 800d130:	9801      	ldr	r0, [sp, #4]
 800d132:	f7ff ff2d 	bl	800cf90 <otg_isoc_out_failed_handler>
  }

  /* Performing the whole FIFO emptying in the ISR, it is advised to keep
     this IRQ at a very low priority level.*/
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 800d136:	9b04      	ldr	r3, [sp, #16]
 800d138:	f003 0310 	and.w	r3, r3, #16
 800d13c:	2b00      	cmp	r3, #0
 800d13e:	d002      	beq.n	800d146 <usb_lld_serve_interrupt+0x106>
    otg_rxfifo_handler(usbp);
 800d140:	9801      	ldr	r0, [sp, #4]
 800d142:	f7ff fc3d 	bl	800c9c0 <otg_rxfifo_handler>
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 800d146:	9b05      	ldr	r3, [sp, #20]
 800d148:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 800d14c:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_OEPINT) {
 800d14e:	9b04      	ldr	r3, [sp, #16]
 800d150:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800d154:	2b00      	cmp	r3, #0
 800d156:	d035      	beq.n	800d1c4 <usb_lld_serve_interrupt+0x184>
    if (src & (1 << 16))
 800d158:	9b03      	ldr	r3, [sp, #12]
 800d15a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800d15e:	2b00      	cmp	r3, #0
 800d160:	d003      	beq.n	800d16a <usb_lld_serve_interrupt+0x12a>
      otg_epout_handler(usbp, 0);
 800d162:	2100      	movs	r1, #0
 800d164:	9801      	ldr	r0, [sp, #4]
 800d166:	f7ff fdeb 	bl	800cd40 <otg_epout_handler>
    if (src & (1 << 17))
 800d16a:	9b03      	ldr	r3, [sp, #12]
 800d16c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d170:	2b00      	cmp	r3, #0
 800d172:	d003      	beq.n	800d17c <usb_lld_serve_interrupt+0x13c>
      otg_epout_handler(usbp, 1);
 800d174:	2101      	movs	r1, #1
 800d176:	9801      	ldr	r0, [sp, #4]
 800d178:	f7ff fde2 	bl	800cd40 <otg_epout_handler>
    if (src & (1 << 18))
 800d17c:	9b03      	ldr	r3, [sp, #12]
 800d17e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800d182:	2b00      	cmp	r3, #0
 800d184:	d003      	beq.n	800d18e <usb_lld_serve_interrupt+0x14e>
      otg_epout_handler(usbp, 2);
 800d186:	2102      	movs	r1, #2
 800d188:	9801      	ldr	r0, [sp, #4]
 800d18a:	f7ff fdd9 	bl	800cd40 <otg_epout_handler>
    if (src & (1 << 19))
 800d18e:	9b03      	ldr	r3, [sp, #12]
 800d190:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800d194:	2b00      	cmp	r3, #0
 800d196:	d003      	beq.n	800d1a0 <usb_lld_serve_interrupt+0x160>
      otg_epout_handler(usbp, 3);
 800d198:	2103      	movs	r1, #3
 800d19a:	9801      	ldr	r0, [sp, #4]
 800d19c:	f7ff fdd0 	bl	800cd40 <otg_epout_handler>
#if USB_MAX_ENDPOINTS >= 4
    if (src & (1 << 20))
 800d1a0:	9b03      	ldr	r3, [sp, #12]
 800d1a2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800d1a6:	2b00      	cmp	r3, #0
 800d1a8:	d003      	beq.n	800d1b2 <usb_lld_serve_interrupt+0x172>
      otg_epout_handler(usbp, 4);
 800d1aa:	2104      	movs	r1, #4
 800d1ac:	9801      	ldr	r0, [sp, #4]
 800d1ae:	f7ff fdc7 	bl	800cd40 <otg_epout_handler>
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 21))
 800d1b2:	9b03      	ldr	r3, [sp, #12]
 800d1b4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800d1b8:	2b00      	cmp	r3, #0
 800d1ba:	d003      	beq.n	800d1c4 <usb_lld_serve_interrupt+0x184>
      otg_epout_handler(usbp, 5);
 800d1bc:	2105      	movs	r1, #5
 800d1be:	9801      	ldr	r0, [sp, #4]
 800d1c0:	f7ff fdbe 	bl	800cd40 <otg_epout_handler>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 24))
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
 800d1c4:	9b04      	ldr	r3, [sp, #16]
 800d1c6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800d1ca:	2b00      	cmp	r3, #0
 800d1cc:	d035      	beq.n	800d23a <usb_lld_serve_interrupt+0x1fa>
    if (src & (1 << 0))
 800d1ce:	9b03      	ldr	r3, [sp, #12]
 800d1d0:	f003 0301 	and.w	r3, r3, #1
 800d1d4:	2b00      	cmp	r3, #0
 800d1d6:	d003      	beq.n	800d1e0 <usb_lld_serve_interrupt+0x1a0>
      otg_epin_handler(usbp, 0);
 800d1d8:	2100      	movs	r1, #0
 800d1da:	9801      	ldr	r0, [sp, #4]
 800d1dc:	f7ff fd20 	bl	800cc20 <otg_epin_handler>
    if (src & (1 << 1))
 800d1e0:	9b03      	ldr	r3, [sp, #12]
 800d1e2:	f003 0302 	and.w	r3, r3, #2
 800d1e6:	2b00      	cmp	r3, #0
 800d1e8:	d003      	beq.n	800d1f2 <usb_lld_serve_interrupt+0x1b2>
      otg_epin_handler(usbp, 1);
 800d1ea:	2101      	movs	r1, #1
 800d1ec:	9801      	ldr	r0, [sp, #4]
 800d1ee:	f7ff fd17 	bl	800cc20 <otg_epin_handler>
    if (src & (1 << 2))
 800d1f2:	9b03      	ldr	r3, [sp, #12]
 800d1f4:	f003 0304 	and.w	r3, r3, #4
 800d1f8:	2b00      	cmp	r3, #0
 800d1fa:	d003      	beq.n	800d204 <usb_lld_serve_interrupt+0x1c4>
      otg_epin_handler(usbp, 2);
 800d1fc:	2102      	movs	r1, #2
 800d1fe:	9801      	ldr	r0, [sp, #4]
 800d200:	f7ff fd0e 	bl	800cc20 <otg_epin_handler>
    if (src & (1 << 3))
 800d204:	9b03      	ldr	r3, [sp, #12]
 800d206:	f003 0308 	and.w	r3, r3, #8
 800d20a:	2b00      	cmp	r3, #0
 800d20c:	d003      	beq.n	800d216 <usb_lld_serve_interrupt+0x1d6>
      otg_epin_handler(usbp, 3);
 800d20e:	2103      	movs	r1, #3
 800d210:	9801      	ldr	r0, [sp, #4]
 800d212:	f7ff fd05 	bl	800cc20 <otg_epin_handler>
#if USB_MAX_ENDPOINTS >= 4
    if (src & (1 << 4))
 800d216:	9b03      	ldr	r3, [sp, #12]
 800d218:	f003 0310 	and.w	r3, r3, #16
 800d21c:	2b00      	cmp	r3, #0
 800d21e:	d003      	beq.n	800d228 <usb_lld_serve_interrupt+0x1e8>
      otg_epin_handler(usbp, 4);
 800d220:	2104      	movs	r1, #4
 800d222:	9801      	ldr	r0, [sp, #4]
 800d224:	f7ff fcfc 	bl	800cc20 <otg_epin_handler>
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 5))
 800d228:	9b03      	ldr	r3, [sp, #12]
 800d22a:	f003 0320 	and.w	r3, r3, #32
 800d22e:	2b00      	cmp	r3, #0
 800d230:	d003      	beq.n	800d23a <usb_lld_serve_interrupt+0x1fa>
      otg_epin_handler(usbp, 5);
 800d232:	2105      	movs	r1, #5
 800d234:	9801      	ldr	r0, [sp, #4]
 800d236:	f7ff fcf3 	bl	800cc20 <otg_epin_handler>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 8))
      otg_epin_handler(usbp, 8);
#endif
  }
}
 800d23a:	b007      	add	sp, #28
 800d23c:	f85d fb04 	ldr.w	pc, [sp], #4

0800d240 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 800d240:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 800d242:	4808      	ldr	r0, [pc, #32]	; (800d264 <Vector14C+0x24>)
 800d244:	f002 f9cc 	bl	800f5e0 <_trace_isr_enter>
 800d248:	f002 f89a 	bl	800f380 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD1);
 800d24c:	4806      	ldr	r0, [pc, #24]	; (800d268 <Vector14C+0x28>)
 800d24e:	f7ff fef7 	bl	800d040 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800d252:	f002 f8b5 	bl	800f3c0 <_dbg_check_leave_isr>
 800d256:	4803      	ldr	r0, [pc, #12]	; (800d264 <Vector14C+0x24>)
 800d258:	f002 f9ea 	bl	800f630 <_trace_isr_leave>
 800d25c:	f007 f878 	bl	8014350 <_port_irq_epilogue>
}
 800d260:	bd08      	pop	{r3, pc}
 800d262:	bf00      	nop
 800d264:	0801605c 	.word	0x0801605c
 800d268:	20000de4 	.word	0x20000de4
 800d26c:	00000000 	.word	0x00000000

0800d270 <Vector174>:
/**
 * @brief   OTG2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 800d270:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 800d272:	4808      	ldr	r0, [pc, #32]	; (800d294 <Vector174+0x24>)
 800d274:	f002 f9b4 	bl	800f5e0 <_trace_isr_enter>
 800d278:	f002 f882 	bl	800f380 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD2);
 800d27c:	4806      	ldr	r0, [pc, #24]	; (800d298 <Vector174+0x28>)
 800d27e:	f7ff fedf 	bl	800d040 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800d282:	f002 f89d 	bl	800f3c0 <_dbg_check_leave_isr>
 800d286:	4803      	ldr	r0, [pc, #12]	; (800d294 <Vector174+0x24>)
 800d288:	f002 f9d2 	bl	800f630 <_trace_isr_leave>
 800d28c:	f007 f860 	bl	8014350 <_port_irq_epilogue>
}
 800d290:	bd08      	pop	{r3, pc}
 800d292:	bf00      	nop
 800d294:	08016068 	.word	0x08016068
 800d298:	20000e5c 	.word	0x20000e5c
 800d29c:	00000000 	.word	0x00000000

0800d2a0 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 800d2a0:	b508      	push	{r3, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 800d2a2:	480a      	ldr	r0, [pc, #40]	; (800d2cc <usb_lld_init+0x2c>)
 800d2a4:	f7fe f84c 	bl	800b340 <usbObjectInit>
  USBD1.otg       = OTG_FS;
 800d2a8:	4b08      	ldr	r3, [pc, #32]	; (800d2cc <usb_lld_init+0x2c>)
 800d2aa:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 800d2ae:	66da      	str	r2, [r3, #108]	; 0x6c
  USBD1.otgparams = &fsparams;
 800d2b0:	4b06      	ldr	r3, [pc, #24]	; (800d2cc <usb_lld_init+0x2c>)
 800d2b2:	4a07      	ldr	r2, [pc, #28]	; (800d2d0 <usb_lld_init+0x30>)
 800d2b4:	671a      	str	r2, [r3, #112]	; 0x70

#endif

#if STM32_USB_USE_OTG2
  usbObjectInit(&USBD2);
 800d2b6:	4807      	ldr	r0, [pc, #28]	; (800d2d4 <usb_lld_init+0x34>)
 800d2b8:	f7fe f842 	bl	800b340 <usbObjectInit>
  USBD2.otg       = OTG_HS;
 800d2bc:	4b05      	ldr	r3, [pc, #20]	; (800d2d4 <usb_lld_init+0x34>)
 800d2be:	4a06      	ldr	r2, [pc, #24]	; (800d2d8 <usb_lld_init+0x38>)
 800d2c0:	66da      	str	r2, [r3, #108]	; 0x6c
  USBD2.otgparams = &hsparams;
 800d2c2:	4b04      	ldr	r3, [pc, #16]	; (800d2d4 <usb_lld_init+0x34>)
 800d2c4:	4a05      	ldr	r2, [pc, #20]	; (800d2dc <usb_lld_init+0x3c>)
 800d2c6:	671a      	str	r2, [r3, #112]	; 0x70
#endif
}
 800d2c8:	bd08      	pop	{r3, pc}
 800d2ca:	bf00      	nop
 800d2cc:	20000de4 	.word	0x20000de4
 800d2d0:	08016018 	.word	0x08016018
 800d2d4:	20000e5c 	.word	0x20000e5c
 800d2d8:	40040000 	.word	0x40040000
 800d2dc:	08016024 	.word	0x08016024

0800d2e0 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 800d2e0:	b500      	push	{lr}
 800d2e2:	b085      	sub	sp, #20
 800d2e4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 800d2e6:	9b01      	ldr	r3, [sp, #4]
 800d2e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d2ea:	9303      	str	r3, [sp, #12]

  if (usbp->state == USB_STOP) {
 800d2ec:	9b01      	ldr	r3, [sp, #4]
 800d2ee:	781b      	ldrb	r3, [r3, #0]
 800d2f0:	2b01      	cmp	r3, #1
 800d2f2:	f040 809a 	bne.w	800d42a <usb_lld_start+0x14a>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 800d2f6:	9b01      	ldr	r3, [sp, #4]
 800d2f8:	4a4d      	ldr	r2, [pc, #308]	; (800d430 <usb_lld_start+0x150>)
 800d2fa:	4293      	cmp	r3, r2
 800d2fc:	d126      	bne.n	800d34c <usb_lld_start+0x6c>
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(true);
 800d2fe:	4b4d      	ldr	r3, [pc, #308]	; (800d434 <usb_lld_start+0x154>)
 800d300:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d302:	4a4c      	ldr	r2, [pc, #304]	; (800d434 <usb_lld_start+0x154>)
 800d304:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800d308:	6353      	str	r3, [r2, #52]	; 0x34
 800d30a:	4b4a      	ldr	r3, [pc, #296]	; (800d434 <usb_lld_start+0x154>)
 800d30c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d30e:	4a49      	ldr	r2, [pc, #292]	; (800d434 <usb_lld_start+0x154>)
 800d310:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800d314:	6553      	str	r3, [r2, #84]	; 0x54
 800d316:	4b47      	ldr	r3, [pc, #284]	; (800d434 <usb_lld_start+0x154>)
 800d318:	6d5b      	ldr	r3, [r3, #84]	; 0x54
      rccResetOTG_FS();
 800d31a:	4b46      	ldr	r3, [pc, #280]	; (800d434 <usb_lld_start+0x154>)
 800d31c:	695b      	ldr	r3, [r3, #20]
 800d31e:	4a45      	ldr	r2, [pc, #276]	; (800d434 <usb_lld_start+0x154>)
 800d320:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800d324:	6153      	str	r3, [r2, #20]
 800d326:	4b43      	ldr	r3, [pc, #268]	; (800d434 <usb_lld_start+0x154>)
 800d328:	695b      	ldr	r3, [r3, #20]
 800d32a:	4a42      	ldr	r2, [pc, #264]	; (800d434 <usb_lld_start+0x154>)
 800d32c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800d330:	6153      	str	r3, [r2, #20]
 800d332:	4b40      	ldr	r3, [pc, #256]	; (800d434 <usb_lld_start+0x154>)
 800d334:	695b      	ldr	r3, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 800d336:	210e      	movs	r1, #14
 800d338:	2043      	movs	r0, #67	; 0x43
 800d33a:	f7fe fbe1 	bl	800bb00 <nvicEnableVector>

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 800d33e:	9b03      	ldr	r3, [sp, #12]
 800d340:	4a3d      	ldr	r2, [pc, #244]	; (800d438 <usb_lld_start+0x158>)
 800d342:	60da      	str	r2, [r3, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 800d344:	9b03      	ldr	r3, [sp, #12]
 800d346:	4a3d      	ldr	r2, [pc, #244]	; (800d43c <usb_lld_start+0x15c>)
 800d348:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
    }
#endif

#if STM32_USB_USE_OTG2
    if (&USBD2 == usbp) {
 800d34c:	9b01      	ldr	r3, [sp, #4]
 800d34e:	4a3c      	ldr	r2, [pc, #240]	; (800d440 <usb_lld_start+0x160>)
 800d350:	4293      	cmp	r3, r2
 800d352:	d134      	bne.n	800d3be <usb_lld_start+0xde>
      /* OTG HS clock enable and reset.*/
      rccEnableOTG_HS(true);
 800d354:	4b37      	ldr	r3, [pc, #220]	; (800d434 <usb_lld_start+0x154>)
 800d356:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d358:	4a36      	ldr	r2, [pc, #216]	; (800d434 <usb_lld_start+0x154>)
 800d35a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800d35e:	6313      	str	r3, [r2, #48]	; 0x30
 800d360:	4b34      	ldr	r3, [pc, #208]	; (800d434 <usb_lld_start+0x154>)
 800d362:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800d364:	4a33      	ldr	r2, [pc, #204]	; (800d434 <usb_lld_start+0x154>)
 800d366:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800d36a:	6513      	str	r3, [r2, #80]	; 0x50
 800d36c:	4b31      	ldr	r3, [pc, #196]	; (800d434 <usb_lld_start+0x154>)
 800d36e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
      rccResetOTG_HS();
 800d370:	4b30      	ldr	r3, [pc, #192]	; (800d434 <usb_lld_start+0x154>)
 800d372:	691b      	ldr	r3, [r3, #16]
 800d374:	4a2f      	ldr	r2, [pc, #188]	; (800d434 <usb_lld_start+0x154>)
 800d376:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800d37a:	6113      	str	r3, [r2, #16]
 800d37c:	4b2d      	ldr	r3, [pc, #180]	; (800d434 <usb_lld_start+0x154>)
 800d37e:	691b      	ldr	r3, [r3, #16]
 800d380:	4a2c      	ldr	r2, [pc, #176]	; (800d434 <usb_lld_start+0x154>)
 800d382:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 800d386:	6113      	str	r3, [r2, #16]
 800d388:	4b2a      	ldr	r3, [pc, #168]	; (800d434 <usb_lld_start+0x154>)
 800d38a:	691b      	ldr	r3, [r3, #16]
#if defined(BOARD_OTG2_USES_ULPI)
      rccEnableOTG_HSULPI(true);
#else
      /* Workaround for the problem described here:
         http://forum.chibios.org/phpbb/viewtopic.php?f=16&t=1798.*/
      rccDisableOTG_HSULPI();
 800d38c:	4b29      	ldr	r3, [pc, #164]	; (800d434 <usb_lld_start+0x154>)
 800d38e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d390:	4a28      	ldr	r2, [pc, #160]	; (800d434 <usb_lld_start+0x154>)
 800d392:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800d396:	6313      	str	r3, [r2, #48]	; 0x30
 800d398:	4b26      	ldr	r3, [pc, #152]	; (800d434 <usb_lld_start+0x154>)
 800d39a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800d39c:	4a25      	ldr	r2, [pc, #148]	; (800d434 <usb_lld_start+0x154>)
 800d39e:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800d3a2:	6513      	str	r3, [r2, #80]	; 0x50
 800d3a4:	4b23      	ldr	r3, [pc, #140]	; (800d434 <usb_lld_start+0x154>)
 800d3a6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
#endif

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
 800d3a8:	210e      	movs	r1, #14
 800d3aa:	204d      	movs	r0, #77	; 0x4d
 800d3ac:	f7fe fba8 	bl	800bb00 <nvicEnableVector>
#if defined(BOARD_OTG2_USES_ULPI)
      /* High speed ULPI PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_HS) |
                      GUSBCFG_SRPCAP | GUSBCFG_HNPCAP;
#else
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 800d3b0:	9b03      	ldr	r3, [sp, #12]
 800d3b2:	4a21      	ldr	r2, [pc, #132]	; (800d438 <usb_lld_start+0x158>)
 800d3b4:	60da      	str	r2, [r3, #12]
      /* USB 2.0 High Speed PHY in FS mode.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_HS_FS;
#endif
#else
      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 800d3b6:	9b03      	ldr	r3, [sp, #12]
 800d3b8:	4a20      	ldr	r2, [pc, #128]	; (800d43c <usb_lld_start+0x15c>)
 800d3ba:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#endif
    }
#endif

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 800d3be:	9b03      	ldr	r3, [sp, #12]
 800d3c0:	2200      	movs	r2, #0
 800d3c2:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 800d3c6:	9b03      	ldr	r3, [sp, #12]
 800d3c8:	22c0      	movs	r2, #192	; 0xc0
 800d3ca:	601a      	str	r2, [r3, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 800d3cc:	9b03      	ldr	r3, [sp, #12]
 800d3ce:	f44f 2250 	mov.w	r2, #851968	; 0xd0000
 800d3d2:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 800d3d4:	9801      	ldr	r0, [sp, #4]
 800d3d6:	f7ff f9db 	bl	800c790 <otg_core_reset>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 800d3da:	9b03      	ldr	r3, [sp, #12]
 800d3dc:	2200      	movs	r2, #0
 800d3de:	609a      	str	r2, [r3, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 800d3e0:	9801      	ldr	r0, [sp, #4]
 800d3e2:	f7ff f9f5 	bl	800c7d0 <otg_disable_ep>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 800d3e6:	9b03      	ldr	r3, [sp, #12]
 800d3e8:	2200      	movs	r2, #0
 800d3ea:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 800d3ee:	9b03      	ldr	r3, [sp, #12]
 800d3f0:	2200      	movs	r2, #0
 800d3f2:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 800d3f6:	9b03      	ldr	r3, [sp, #12]
 800d3f8:	2200      	movs	r2, #0
 800d3fa:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 800d3fe:	9b01      	ldr	r3, [sp, #4]
 800d400:	685b      	ldr	r3, [r3, #4]
 800d402:	68db      	ldr	r3, [r3, #12]
 800d404:	2b00      	cmp	r3, #0
 800d406:	d103      	bne.n	800d410 <usb_lld_start+0x130>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 800d408:	9b03      	ldr	r3, [sp, #12]
 800d40a:	4a0e      	ldr	r2, [pc, #56]	; (800d444 <usb_lld_start+0x164>)
 800d40c:	619a      	str	r2, [r3, #24]
 800d40e:	e002      	b.n	800d416 <usb_lld_start+0x136>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 800d410:	9b03      	ldr	r3, [sp, #12]
 800d412:	4a0d      	ldr	r2, [pc, #52]	; (800d448 <usb_lld_start+0x168>)
 800d414:	619a      	str	r2, [r3, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 800d416:	9b03      	ldr	r3, [sp, #12]
 800d418:	f04f 32ff 	mov.w	r2, #4294967295
 800d41c:	615a      	str	r2, [r3, #20]

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 800d41e:	9b03      	ldr	r3, [sp, #12]
 800d420:	689b      	ldr	r3, [r3, #8]
 800d422:	f043 0201 	orr.w	r2, r3, #1
 800d426:	9b03      	ldr	r3, [sp, #12]
 800d428:	609a      	str	r2, [r3, #8]
  }
}
 800d42a:	b005      	add	sp, #20
 800d42c:	f85d fb04 	ldr.w	pc, [sp], #4
 800d430:	20000de4 	.word	0x20000de4
 800d434:	40023800 	.word	0x40023800
 800d438:	40001440 	.word	0x40001440
 800d43c:	02200003 	.word	0x02200003
 800d440:	20000e5c 	.word	0x20000e5c
 800d444:	c0303c00 	.word	0xc0303c00
 800d448:	c0303c08 	.word	0xc0303c08
 800d44c:	00000000 	.word	0x00000000

0800d450 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 800d450:	b510      	push	{r4, lr}
 800d452:	b084      	sub	sp, #16
 800d454:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 800d456:	9b01      	ldr	r3, [sp, #4]
 800d458:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d45a:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 800d45c:	2100      	movs	r1, #0
 800d45e:	9801      	ldr	r0, [sp, #4]
 800d460:	f7ff fa16 	bl	800c890 <otg_txfifo_flush>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 800d464:	9b02      	ldr	r3, [sp, #8]
 800d466:	2200      	movs	r2, #0
 800d468:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800d46c:	9b02      	ldr	r3, [sp, #8]
 800d46e:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 800d472:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800d476:	2300      	movs	r3, #0
 800d478:	9303      	str	r3, [sp, #12]
 800d47a:	e024      	b.n	800d4c6 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800d47c:	9a02      	ldr	r2, [sp, #8]
 800d47e:	9b03      	ldr	r3, [sp, #12]
 800d480:	3348      	adds	r3, #72	; 0x48
 800d482:	015b      	lsls	r3, r3, #5
 800d484:	4413      	add	r3, r2
 800d486:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800d48a:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 800d48c:	9a02      	ldr	r2, [sp, #8]
 800d48e:	9b03      	ldr	r3, [sp, #12]
 800d490:	3358      	adds	r3, #88	; 0x58
 800d492:	015b      	lsls	r3, r3, #5
 800d494:	4413      	add	r3, r2
 800d496:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800d49a:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800d49c:	9a02      	ldr	r2, [sp, #8]
 800d49e:	9b03      	ldr	r3, [sp, #12]
 800d4a0:	015b      	lsls	r3, r3, #5
 800d4a2:	4413      	add	r3, r2
 800d4a4:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800d4a8:	f04f 32ff 	mov.w	r2, #4294967295
 800d4ac:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800d4ae:	9a02      	ldr	r2, [sp, #8]
 800d4b0:	9b03      	ldr	r3, [sp, #12]
 800d4b2:	015b      	lsls	r3, r3, #5
 800d4b4:	4413      	add	r3, r2
 800d4b6:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800d4ba:	f04f 32ff 	mov.w	r2, #4294967295
 800d4be:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800d4c0:	9b03      	ldr	r3, [sp, #12]
 800d4c2:	3301      	adds	r3, #1
 800d4c4:	9303      	str	r3, [sp, #12]
 800d4c6:	9b01      	ldr	r3, [sp, #4]
 800d4c8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d4ca:	689b      	ldr	r3, [r3, #8]
 800d4cc:	9a03      	ldr	r2, [sp, #12]
 800d4ce:	429a      	cmp	r2, r3
 800d4d0:	d9d4      	bls.n	800d47c <usb_lld_reset+0x2c>
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 800d4d2:	9801      	ldr	r0, [sp, #4]
 800d4d4:	f7ff f9fc 	bl	800c8d0 <otg_ram_reset>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 800d4d8:	9b01      	ldr	r3, [sp, #4]
 800d4da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d4dc:	681a      	ldr	r2, [r3, #0]
 800d4de:	9b02      	ldr	r3, [sp, #8]
 800d4e0:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 800d4e2:	9801      	ldr	r0, [sp, #4]
 800d4e4:	f7ff f9bc 	bl	800c860 <otg_rxfifo_flush>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 800d4e8:	9b02      	ldr	r3, [sp, #8]
 800d4ea:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 800d4ee:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 800d4f2:	9b02      	ldr	r3, [sp, #8]
 800d4f4:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 800d4f8:	9b02      	ldr	r3, [sp, #8]
 800d4fa:	699b      	ldr	r3, [r3, #24]
 800d4fc:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 800d500:	f043 0310 	orr.w	r3, r3, #16
 800d504:	9a02      	ldr	r2, [sp, #8]
 800d506:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 800d508:	9b02      	ldr	r3, [sp, #8]
 800d50a:	2209      	movs	r2, #9
 800d50c:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 800d510:	9b02      	ldr	r3, [sp, #8]
 800d512:	2209      	movs	r2, #9
 800d514:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 800d518:	9b01      	ldr	r3, [sp, #4]
 800d51a:	4a17      	ldr	r2, [pc, #92]	; (800d578 <usb_lld_reset+0x128>)
 800d51c:	60da      	str	r2, [r3, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 800d51e:	9b02      	ldr	r3, [sp, #8]
 800d520:	f04f 42c0 	mov.w	r2, #1610612736	; 0x60000000
 800d524:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 800d528:	2340      	movs	r3, #64	; 0x40
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 800d52a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800d52e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800d532:	9a02      	ldr	r2, [sp, #8]
 800d534:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 800d538:	9b02      	ldr	r3, [sp, #8]
 800d53a:	2200      	movs	r2, #0
 800d53c:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 800d540:	2340      	movs	r3, #64	; 0x40
 800d542:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800d546:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 800d54a:	9a02      	ldr	r2, [sp, #8]
 800d54c:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800d550:	2340      	movs	r3, #64	; 0x40
 800d552:	089b      	lsrs	r3, r3, #2
 800d554:	b29b      	uxth	r3, r3
 800d556:	041b      	lsls	r3, r3, #16
 800d558:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 800d55a:	2340      	movs	r3, #64	; 0x40
 800d55c:	089b      	lsrs	r3, r3, #2
 800d55e:	b29b      	uxth	r3, r3
 800d560:	4619      	mov	r1, r3
 800d562:	9801      	ldr	r0, [sp, #4]
 800d564:	f7ff f9c4 	bl	800c8f0 <otg_ram_alloc>
 800d568:	4603      	mov	r3, r0
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800d56a:	ea44 0203 	orr.w	r2, r4, r3
 800d56e:	9b02      	ldr	r3, [sp, #8]
 800d570:	629a      	str	r2, [r3, #40]	; 0x28
                                                  ep0config.in_maxsize / 4));
}
 800d572:	b004      	add	sp, #16
 800d574:	bd10      	pop	{r4, pc}
 800d576:	bf00      	nop
 800d578:	08015ff4 	.word	0x08015ff4
 800d57c:	00000000 	.word	0x00000000

0800d580 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 800d580:	b084      	sub	sp, #16
 800d582:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 800d584:	9b01      	ldr	r3, [sp, #4]
 800d586:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d588:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 800d58a:	9b03      	ldr	r3, [sp, #12]
 800d58c:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 800d590:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800d594:	9a01      	ldr	r2, [sp, #4]
 800d596:	f892 2066 	ldrb.w	r2, [r2, #102]	; 0x66
 800d59a:	0112      	lsls	r2, r2, #4
 800d59c:	431a      	orrs	r2, r3
 800d59e:	9b03      	ldr	r3, [sp, #12]
 800d5a0:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 800d5a4:	b004      	add	sp, #16
 800d5a6:	4770      	bx	lr
	...

0800d5b0 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 800d5b0:	b510      	push	{r4, lr}
 800d5b2:	b086      	sub	sp, #24
 800d5b4:	9001      	str	r0, [sp, #4]
 800d5b6:	460b      	mov	r3, r1
 800d5b8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 800d5bc:	9b01      	ldr	r3, [sp, #4]
 800d5be:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d5c0:	9303      	str	r3, [sp, #12]

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 800d5c2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d5c6:	9a01      	ldr	r2, [sp, #4]
 800d5c8:	3302      	adds	r3, #2
 800d5ca:	009b      	lsls	r3, r3, #2
 800d5cc:	4413      	add	r3, r2
 800d5ce:	685b      	ldr	r3, [r3, #4]
 800d5d0:	681b      	ldr	r3, [r3, #0]
 800d5d2:	f003 0303 	and.w	r3, r3, #3
 800d5d6:	2b03      	cmp	r3, #3
 800d5d8:	f200 8104 	bhi.w	800d7e4 <usb_lld_init_endpoint+0x234>
 800d5dc:	a201      	add	r2, pc, #4	; (adr r2, 800d5e4 <usb_lld_init_endpoint+0x34>)
 800d5de:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d5e2:	bf00      	nop
 800d5e4:	0800d5f5 	.word	0x0800d5f5
 800d5e8:	0800d5fb 	.word	0x0800d5fb
 800d5ec:	0800d601 	.word	0x0800d601
 800d5f0:	0800d607 	.word	0x0800d607
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 800d5f4:	4b7d      	ldr	r3, [pc, #500]	; (800d7ec <usb_lld_init_endpoint+0x23c>)
 800d5f6:	9305      	str	r3, [sp, #20]
 800d5f8:	e007      	b.n	800d60a <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 800d5fa:	4b7d      	ldr	r3, [pc, #500]	; (800d7f0 <usb_lld_init_endpoint+0x240>)
 800d5fc:	9305      	str	r3, [sp, #20]
 800d5fe:	e004      	b.n	800d60a <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 800d600:	4b7c      	ldr	r3, [pc, #496]	; (800d7f4 <usb_lld_init_endpoint+0x244>)
 800d602:	9305      	str	r3, [sp, #20]
 800d604:	e001      	b.n	800d60a <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 800d606:	4b7c      	ldr	r3, [pc, #496]	; (800d7f8 <usb_lld_init_endpoint+0x248>)
 800d608:	9305      	str	r3, [sp, #20]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 800d60a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d60e:	9a03      	ldr	r2, [sp, #12]
 800d610:	015b      	lsls	r3, r3, #5
 800d612:	4413      	add	r3, r2
 800d614:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800d618:	2200      	movs	r2, #0
 800d61a:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 800d61c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d620:	9a01      	ldr	r2, [sp, #4]
 800d622:	3302      	adds	r3, #2
 800d624:	009b      	lsls	r3, r3, #2
 800d626:	4413      	add	r3, r2
 800d628:	685b      	ldr	r3, [r3, #4]
 800d62a:	699b      	ldr	r3, [r3, #24]
 800d62c:	2b00      	cmp	r3, #0
 800d62e:	d01f      	beq.n	800d670 <usb_lld_init_endpoint+0xc0>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 800d630:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d634:	9a01      	ldr	r2, [sp, #4]
 800d636:	3302      	adds	r3, #2
 800d638:	009b      	lsls	r3, r3, #2
 800d63a:	4413      	add	r3, r2
 800d63c:	685b      	ldr	r3, [r3, #4]
 800d63e:	8a5b      	ldrh	r3, [r3, #18]
 800d640:	4619      	mov	r1, r3
 800d642:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d646:	9a05      	ldr	r2, [sp, #20]
 800d648:	430a      	orrs	r2, r1
 800d64a:	9903      	ldr	r1, [sp, #12]
 800d64c:	3358      	adds	r3, #88	; 0x58
 800d64e:	015b      	lsls	r3, r3, #5
 800d650:	440b      	add	r3, r1
 800d652:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 800d654:	9b03      	ldr	r3, [sp, #12]
 800d656:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800d65a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d65e:	3310      	adds	r3, #16
 800d660:	2101      	movs	r1, #1
 800d662:	fa01 f303 	lsl.w	r3, r1, r3
 800d666:	431a      	orrs	r2, r3
 800d668:	9b03      	ldr	r3, [sp, #12]
 800d66a:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 800d66e:	e01d      	b.n	800d6ac <usb_lld_init_endpoint+0xfc>
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 800d670:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d674:	9a03      	ldr	r2, [sp, #12]
 800d676:	3358      	adds	r3, #88	; 0x58
 800d678:	015b      	lsls	r3, r3, #5
 800d67a:	4413      	add	r3, r2
 800d67c:	681a      	ldr	r2, [r3, #0]
 800d67e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d682:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800d686:	9903      	ldr	r1, [sp, #12]
 800d688:	3358      	adds	r3, #88	; 0x58
 800d68a:	015b      	lsls	r3, r3, #5
 800d68c:	440b      	add	r3, r1
 800d68e:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 800d690:	9b03      	ldr	r3, [sp, #12]
 800d692:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800d696:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d69a:	3310      	adds	r3, #16
 800d69c:	2101      	movs	r1, #1
 800d69e:	fa01 f303 	lsl.w	r3, r1, r3
 800d6a2:	43db      	mvns	r3, r3
 800d6a4:	401a      	ands	r2, r3
 800d6a6:	9b03      	ldr	r3, [sp, #12]
 800d6a8:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 800d6ac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d6b0:	9a03      	ldr	r2, [sp, #12]
 800d6b2:	015b      	lsls	r3, r3, #5
 800d6b4:	4413      	add	r3, r2
 800d6b6:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800d6ba:	2200      	movs	r2, #0
 800d6bc:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->in_state != NULL) {
 800d6be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d6c2:	9a01      	ldr	r2, [sp, #4]
 800d6c4:	3302      	adds	r3, #2
 800d6c6:	009b      	lsls	r3, r3, #2
 800d6c8:	4413      	add	r3, r2
 800d6ca:	685b      	ldr	r3, [r3, #4]
 800d6cc:	695b      	ldr	r3, [r3, #20]
 800d6ce:	2b00      	cmp	r3, #0
 800d6d0:	d05b      	beq.n	800d78a <usb_lld_init_endpoint+0x1da>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 800d6d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d6d6:	9a01      	ldr	r2, [sp, #4]
 800d6d8:	3302      	adds	r3, #2
 800d6da:	009b      	lsls	r3, r3, #2
 800d6dc:	4413      	add	r3, r2
 800d6de:	685b      	ldr	r3, [r3, #4]
 800d6e0:	8a1b      	ldrh	r3, [r3, #16]
 800d6e2:	089b      	lsrs	r3, r3, #2
 800d6e4:	b29b      	uxth	r3, r3
 800d6e6:	9304      	str	r3, [sp, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 800d6e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d6ec:	9a01      	ldr	r2, [sp, #4]
 800d6ee:	3302      	adds	r3, #2
 800d6f0:	009b      	lsls	r3, r3, #2
 800d6f2:	4413      	add	r3, r2
 800d6f4:	685b      	ldr	r3, [r3, #4]
 800d6f6:	8b9b      	ldrh	r3, [r3, #28]
 800d6f8:	2b01      	cmp	r3, #1
 800d6fa:	d90c      	bls.n	800d716 <usb_lld_init_endpoint+0x166>
      fsize *= usbp->epc[ep]->in_multiplier;
 800d6fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d700:	9a01      	ldr	r2, [sp, #4]
 800d702:	3302      	adds	r3, #2
 800d704:	009b      	lsls	r3, r3, #2
 800d706:	4413      	add	r3, r2
 800d708:	685b      	ldr	r3, [r3, #4]
 800d70a:	8b9b      	ldrh	r3, [r3, #28]
 800d70c:	461a      	mov	r2, r3
 800d70e:	9b04      	ldr	r3, [sp, #16]
 800d710:	fb02 f303 	mul.w	r3, r2, r3
 800d714:	9304      	str	r3, [sp, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800d716:	9b04      	ldr	r3, [sp, #16]
 800d718:	041c      	lsls	r4, r3, #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 800d71a:	9904      	ldr	r1, [sp, #16]
 800d71c:	9801      	ldr	r0, [sp, #4]
 800d71e:	f7ff f8e7 	bl	800c8f0 <otg_ram_alloc>
 800d722:	4602      	mov	r2, r0
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800d724:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d728:	3b01      	subs	r3, #1
 800d72a:	4322      	orrs	r2, r4
 800d72c:	9903      	ldr	r1, [sp, #12]
 800d72e:	3340      	adds	r3, #64	; 0x40
 800d730:	009b      	lsls	r3, r3, #2
 800d732:	440b      	add	r3, r1
 800d734:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 800d736:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d73a:	4619      	mov	r1, r3
 800d73c:	9801      	ldr	r0, [sp, #4]
 800d73e:	f7ff f8a7 	bl	800c890 <otg_txfifo_flush>

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 800d742:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d746:	059b      	lsls	r3, r3, #22
 800d748:	461a      	mov	r2, r3
    otgp->ie[ep].DIEPCTL = ctl |
 800d74a:	9b05      	ldr	r3, [sp, #20]
 800d74c:	431a      	orrs	r2, r3
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 800d74e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d752:	9901      	ldr	r1, [sp, #4]
 800d754:	3302      	adds	r3, #2
 800d756:	009b      	lsls	r3, r3, #2
 800d758:	440b      	add	r3, r1
 800d75a:	685b      	ldr	r3, [r3, #4]
 800d75c:	8a1b      	ldrh	r3, [r3, #16]
 800d75e:	4619      	mov	r1, r3
    otgp->ie[ep].DIEPCTL = ctl |
 800d760:	f89d 3003 	ldrb.w	r3, [sp, #3]
                           DIEPCTL_TXFNUM(ep) |
 800d764:	430a      	orrs	r2, r1
    otgp->ie[ep].DIEPCTL = ctl |
 800d766:	9903      	ldr	r1, [sp, #12]
 800d768:	3348      	adds	r3, #72	; 0x48
 800d76a:	015b      	lsls	r3, r3, #5
 800d76c:	440b      	add	r3, r1
 800d76e:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 800d770:	9b03      	ldr	r3, [sp, #12]
 800d772:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800d776:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d77a:	2101      	movs	r1, #1
 800d77c:	fa01 f303 	lsl.w	r3, r1, r3
 800d780:	431a      	orrs	r2, r3
 800d782:	9b03      	ldr	r3, [sp, #12]
 800d784:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 800d788:	e02d      	b.n	800d7e6 <usb_lld_init_endpoint+0x236>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 800d78a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d78e:	3b01      	subs	r3, #1
 800d790:	9a03      	ldr	r2, [sp, #12]
 800d792:	3340      	adds	r3, #64	; 0x40
 800d794:	009b      	lsls	r3, r3, #2
 800d796:	4413      	add	r3, r2
 800d798:	4a18      	ldr	r2, [pc, #96]	; (800d7fc <usb_lld_init_endpoint+0x24c>)
 800d79a:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 800d79c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d7a0:	4619      	mov	r1, r3
 800d7a2:	9801      	ldr	r0, [sp, #4]
 800d7a4:	f7ff f874 	bl	800c890 <otg_txfifo_flush>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 800d7a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d7ac:	9a03      	ldr	r2, [sp, #12]
 800d7ae:	3348      	adds	r3, #72	; 0x48
 800d7b0:	015b      	lsls	r3, r3, #5
 800d7b2:	4413      	add	r3, r2
 800d7b4:	681a      	ldr	r2, [r3, #0]
 800d7b6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d7ba:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800d7be:	9903      	ldr	r1, [sp, #12]
 800d7c0:	3348      	adds	r3, #72	; 0x48
 800d7c2:	015b      	lsls	r3, r3, #5
 800d7c4:	440b      	add	r3, r1
 800d7c6:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 800d7c8:	9b03      	ldr	r3, [sp, #12]
 800d7ca:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800d7ce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d7d2:	2101      	movs	r1, #1
 800d7d4:	fa01 f303 	lsl.w	r3, r1, r3
 800d7d8:	43db      	mvns	r3, r3
 800d7da:	401a      	ands	r2, r3
 800d7dc:	9b03      	ldr	r3, [sp, #12]
 800d7de:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 800d7e2:	e000      	b.n	800d7e6 <usb_lld_init_endpoint+0x236>
  default:
 800d7e4:	bf00      	nop
  }
}
 800d7e6:	b006      	add	sp, #24
 800d7e8:	bd10      	pop	{r4, pc}
 800d7ea:	bf00      	nop
 800d7ec:	10008000 	.word	0x10008000
 800d7f0:	10048000 	.word	0x10048000
 800d7f4:	10088000 	.word	0x10088000
 800d7f8:	100c8000 	.word	0x100c8000
 800d7fc:	02000400 	.word	0x02000400

0800d800 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 800d800:	b500      	push	{lr}
 800d802:	b083      	sub	sp, #12
 800d804:	9001      	str	r0, [sp, #4]

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 800d806:	9801      	ldr	r0, [sp, #4]
 800d808:	f7ff f862 	bl	800c8d0 <otg_ram_reset>

  /* Disabling all endpoints.*/
  otg_disable_ep(usbp);
 800d80c:	9801      	ldr	r0, [sp, #4]
 800d80e:	f7fe ffdf 	bl	800c7d0 <otg_disable_ep>
}
 800d812:	b003      	add	sp, #12
 800d814:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800d820 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 800d820:	b084      	sub	sp, #16
 800d822:	9001      	str	r0, [sp, #4]
 800d824:	460b      	mov	r3, r1
 800d826:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 800d82a:	9b01      	ldr	r3, [sp, #4]
 800d82c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800d82e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d832:	3358      	adds	r3, #88	; 0x58
 800d834:	015b      	lsls	r3, r3, #5
 800d836:	4413      	add	r3, r2
 800d838:	681b      	ldr	r3, [r3, #0]
 800d83a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 800d83c:	9b03      	ldr	r3, [sp, #12]
 800d83e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800d842:	2b00      	cmp	r3, #0
 800d844:	d101      	bne.n	800d84a <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 800d846:	2300      	movs	r3, #0
 800d848:	e007      	b.n	800d85a <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 800d84a:	9b03      	ldr	r3, [sp, #12]
 800d84c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800d850:	2b00      	cmp	r3, #0
 800d852:	d001      	beq.n	800d858 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 800d854:	2301      	movs	r3, #1
 800d856:	e000      	b.n	800d85a <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 800d858:	2302      	movs	r3, #2
}
 800d85a:	4618      	mov	r0, r3
 800d85c:	b004      	add	sp, #16
 800d85e:	4770      	bx	lr

0800d860 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 800d860:	b084      	sub	sp, #16
 800d862:	9001      	str	r0, [sp, #4]
 800d864:	460b      	mov	r3, r1
 800d866:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 800d86a:	9b01      	ldr	r3, [sp, #4]
 800d86c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800d86e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d872:	3348      	adds	r3, #72	; 0x48
 800d874:	015b      	lsls	r3, r3, #5
 800d876:	4413      	add	r3, r2
 800d878:	681b      	ldr	r3, [r3, #0]
 800d87a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 800d87c:	9b03      	ldr	r3, [sp, #12]
 800d87e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800d882:	2b00      	cmp	r3, #0
 800d884:	d101      	bne.n	800d88a <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 800d886:	2300      	movs	r3, #0
 800d888:	e007      	b.n	800d89a <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 800d88a:	9b03      	ldr	r3, [sp, #12]
 800d88c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800d890:	2b00      	cmp	r3, #0
 800d892:	d001      	beq.n	800d898 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 800d894:	2301      	movs	r3, #1
 800d896:	e000      	b.n	800d89a <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 800d898:	2302      	movs	r3, #2
}
 800d89a:	4618      	mov	r0, r3
 800d89c:	b004      	add	sp, #16
 800d89e:	4770      	bx	lr

0800d8a0 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 800d8a0:	b500      	push	{lr}
 800d8a2:	b085      	sub	sp, #20
 800d8a4:	9003      	str	r0, [sp, #12]
 800d8a6:	460b      	mov	r3, r1
 800d8a8:	9201      	str	r2, [sp, #4]
 800d8aa:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 800d8ae:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800d8b2:	9a03      	ldr	r2, [sp, #12]
 800d8b4:	3302      	adds	r3, #2
 800d8b6:	009b      	lsls	r3, r3, #2
 800d8b8:	4413      	add	r3, r2
 800d8ba:	685b      	ldr	r3, [r3, #4]
 800d8bc:	6a1b      	ldr	r3, [r3, #32]
 800d8be:	2208      	movs	r2, #8
 800d8c0:	4619      	mov	r1, r3
 800d8c2:	9801      	ldr	r0, [sp, #4]
 800d8c4:	f7f2 fd26 	bl	8000314 <memcpy>
}
 800d8c8:	b005      	add	sp, #20
 800d8ca:	f85d fb04 	ldr.w	pc, [sp], #4
 800d8ce:	bf00      	nop

0800d8d0 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 800d8d0:	b086      	sub	sp, #24
 800d8d2:	9001      	str	r0, [sp, #4]
 800d8d4:	460b      	mov	r3, r1
 800d8d6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800d8da:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d8de:	9a01      	ldr	r2, [sp, #4]
 800d8e0:	3302      	adds	r3, #2
 800d8e2:	009b      	lsls	r3, r3, #2
 800d8e4:	4413      	add	r3, r2
 800d8e6:	685b      	ldr	r3, [r3, #4]
 800d8e8:	699b      	ldr	r3, [r3, #24]
 800d8ea:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800d8ec:	9b05      	ldr	r3, [sp, #20]
 800d8ee:	681a      	ldr	r2, [r3, #0]
 800d8f0:	9b05      	ldr	r3, [sp, #20]
 800d8f2:	60da      	str	r2, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 800d8f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d8f8:	2b00      	cmp	r3, #0
 800d8fa:	d106      	bne.n	800d90a <usb_lld_start_out+0x3a>
 800d8fc:	9b05      	ldr	r3, [sp, #20]
 800d8fe:	681b      	ldr	r3, [r3, #0]
 800d900:	2b40      	cmp	r3, #64	; 0x40
 800d902:	d902      	bls.n	800d90a <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 800d904:	9b05      	ldr	r3, [sp, #20]
 800d906:	2240      	movs	r2, #64	; 0x40
 800d908:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800d90a:	9b05      	ldr	r3, [sp, #20]
 800d90c:	681a      	ldr	r2, [r3, #0]
 800d90e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d912:	9901      	ldr	r1, [sp, #4]
 800d914:	3302      	adds	r3, #2
 800d916:	009b      	lsls	r3, r3, #2
 800d918:	440b      	add	r3, r1
 800d91a:	685b      	ldr	r3, [r3, #4]
 800d91c:	8a5b      	ldrh	r3, [r3, #18]
 800d91e:	4413      	add	r3, r2
 800d920:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 800d922:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d926:	9901      	ldr	r1, [sp, #4]
 800d928:	3302      	adds	r3, #2
 800d92a:	009b      	lsls	r3, r3, #2
 800d92c:	440b      	add	r3, r1
 800d92e:	685b      	ldr	r3, [r3, #4]
 800d930:	8a5b      	ldrh	r3, [r3, #18]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800d932:	fbb2 f3f3 	udiv	r3, r2, r3
 800d936:	9304      	str	r3, [sp, #16]
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 800d938:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d93c:	9a01      	ldr	r2, [sp, #4]
 800d93e:	3302      	adds	r3, #2
 800d940:	009b      	lsls	r3, r3, #2
 800d942:	4413      	add	r3, r2
 800d944:	685b      	ldr	r3, [r3, #4]
 800d946:	8a5b      	ldrh	r3, [r3, #18]
 800d948:	461a      	mov	r2, r3
 800d94a:	9b04      	ldr	r3, [sp, #16]
 800d94c:	fb03 f302 	mul.w	r3, r3, r2
 800d950:	3303      	adds	r3, #3
 800d952:	f023 0303 	bic.w	r3, r3, #3
 800d956:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 800d958:	9b04      	ldr	r3, [sp, #16]
 800d95a:	04da      	lsls	r2, r3, #19
 800d95c:	9b03      	ldr	r3, [sp, #12]
 800d95e:	431a      	orrs	r2, r3
 800d960:	9b01      	ldr	r3, [sp, #4]
 800d962:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800d964:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d968:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 800d96c:	015b      	lsls	r3, r3, #5
 800d96e:	440b      	add	r3, r1
 800d970:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800d974:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800d976:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d97a:	9a01      	ldr	r2, [sp, #4]
 800d97c:	3302      	adds	r3, #2
 800d97e:	009b      	lsls	r3, r3, #2
 800d980:	4413      	add	r3, r2
 800d982:	685b      	ldr	r3, [r3, #4]
 800d984:	681b      	ldr	r3, [r3, #0]
 800d986:	f003 0303 	and.w	r3, r3, #3
 800d98a:	2b01      	cmp	r3, #1
 800d98c:	d12c      	bne.n	800d9e8 <usb_lld_start_out+0x118>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 800d98e:	9b01      	ldr	r3, [sp, #4]
 800d990:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d992:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 800d996:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800d99a:	2b00      	cmp	r3, #0
 800d99c:	d012      	beq.n	800d9c4 <usb_lld_start_out+0xf4>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 800d99e:	9b01      	ldr	r3, [sp, #4]
 800d9a0:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800d9a2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d9a6:	3358      	adds	r3, #88	; 0x58
 800d9a8:	015b      	lsls	r3, r3, #5
 800d9aa:	4413      	add	r3, r2
 800d9ac:	681a      	ldr	r2, [r3, #0]
 800d9ae:	9b01      	ldr	r3, [sp, #4]
 800d9b0:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800d9b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d9b6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800d9ba:	3358      	adds	r3, #88	; 0x58
 800d9bc:	015b      	lsls	r3, r3, #5
 800d9be:	440b      	add	r3, r1
 800d9c0:	601a      	str	r2, [r3, #0]
 800d9c2:	e011      	b.n	800d9e8 <usb_lld_start_out+0x118>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 800d9c4:	9b01      	ldr	r3, [sp, #4]
 800d9c6:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800d9c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d9cc:	3358      	adds	r3, #88	; 0x58
 800d9ce:	015b      	lsls	r3, r3, #5
 800d9d0:	4413      	add	r3, r2
 800d9d2:	681a      	ldr	r2, [r3, #0]
 800d9d4:	9b01      	ldr	r3, [sp, #4]
 800d9d6:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800d9d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d9dc:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800d9e0:	3358      	adds	r3, #88	; 0x58
 800d9e2:	015b      	lsls	r3, r3, #5
 800d9e4:	440b      	add	r3, r1
 800d9e6:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 800d9e8:	9b01      	ldr	r3, [sp, #4]
 800d9ea:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800d9ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d9f0:	3358      	adds	r3, #88	; 0x58
 800d9f2:	015b      	lsls	r3, r3, #5
 800d9f4:	4413      	add	r3, r2
 800d9f6:	681a      	ldr	r2, [r3, #0]
 800d9f8:	9b01      	ldr	r3, [sp, #4]
 800d9fa:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800d9fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800da00:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800da04:	3358      	adds	r3, #88	; 0x58
 800da06:	015b      	lsls	r3, r3, #5
 800da08:	440b      	add	r3, r1
 800da0a:	601a      	str	r2, [r3, #0]
}
 800da0c:	b006      	add	sp, #24
 800da0e:	4770      	bx	lr

0800da10 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 800da10:	b084      	sub	sp, #16
 800da12:	9001      	str	r0, [sp, #4]
 800da14:	460b      	mov	r3, r1
 800da16:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800da1a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800da1e:	9a01      	ldr	r2, [sp, #4]
 800da20:	3302      	adds	r3, #2
 800da22:	009b      	lsls	r3, r3, #2
 800da24:	4413      	add	r3, r2
 800da26:	685b      	ldr	r3, [r3, #4]
 800da28:	695b      	ldr	r3, [r3, #20]
 800da2a:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800da2c:	9b03      	ldr	r3, [sp, #12]
 800da2e:	681a      	ldr	r2, [r3, #0]
 800da30:	9b03      	ldr	r3, [sp, #12]
 800da32:	60da      	str	r2, [r3, #12]
  if (isp->txsize == 0) {
 800da34:	9b03      	ldr	r3, [sp, #12]
 800da36:	681b      	ldr	r3, [r3, #0]
 800da38:	2b00      	cmp	r3, #0
 800da3a:	d10b      	bne.n	800da54 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800da3c:	9b01      	ldr	r3, [sp, #4]
 800da3e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800da40:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800da44:	015b      	lsls	r3, r3, #5
 800da46:	4413      	add	r3, r2
 800da48:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800da4c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800da50:	601a      	str	r2, [r3, #0]
 800da52:	e031      	b.n	800dab8 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 800da54:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800da58:	2b00      	cmp	r3, #0
 800da5a:	d106      	bne.n	800da6a <usb_lld_start_in+0x5a>
 800da5c:	9b03      	ldr	r3, [sp, #12]
 800da5e:	681b      	ldr	r3, [r3, #0]
 800da60:	2b40      	cmp	r3, #64	; 0x40
 800da62:	d902      	bls.n	800da6a <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 800da64:	9b03      	ldr	r3, [sp, #12]
 800da66:	2240      	movs	r2, #64	; 0x40
 800da68:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800da6a:	9b03      	ldr	r3, [sp, #12]
 800da6c:	681a      	ldr	r2, [r3, #0]
 800da6e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800da72:	9901      	ldr	r1, [sp, #4]
 800da74:	3302      	adds	r3, #2
 800da76:	009b      	lsls	r3, r3, #2
 800da78:	440b      	add	r3, r1
 800da7a:	685b      	ldr	r3, [r3, #4]
 800da7c:	8a1b      	ldrh	r3, [r3, #16]
 800da7e:	4413      	add	r3, r2
 800da80:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 800da82:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800da86:	9901      	ldr	r1, [sp, #4]
 800da88:	3302      	adds	r3, #2
 800da8a:	009b      	lsls	r3, r3, #2
 800da8c:	440b      	add	r3, r1
 800da8e:	685b      	ldr	r3, [r3, #4]
 800da90:	8a1b      	ldrh	r3, [r3, #16]
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800da92:	fbb2 f3f3 	udiv	r3, r2, r3
 800da96:	9302      	str	r3, [sp, #8]
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 800da98:	9b02      	ldr	r3, [sp, #8]
 800da9a:	04da      	lsls	r2, r3, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 800da9c:	9b03      	ldr	r3, [sp, #12]
 800da9e:	681b      	ldr	r3, [r3, #0]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 800daa0:	431a      	orrs	r2, r3
 800daa2:	9b01      	ldr	r3, [sp, #4]
 800daa4:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800daa6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800daaa:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800daae:	015b      	lsls	r3, r3, #5
 800dab0:	440b      	add	r3, r1
 800dab2:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800dab6:	601a      	str	r2, [r3, #0]
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800dab8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800dabc:	9a01      	ldr	r2, [sp, #4]
 800dabe:	3302      	adds	r3, #2
 800dac0:	009b      	lsls	r3, r3, #2
 800dac2:	4413      	add	r3, r2
 800dac4:	685b      	ldr	r3, [r3, #4]
 800dac6:	681b      	ldr	r3, [r3, #0]
 800dac8:	f003 0303 	and.w	r3, r3, #3
 800dacc:	2b01      	cmp	r3, #1
 800dace:	d12c      	bne.n	800db2a <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 800dad0:	9b01      	ldr	r3, [sp, #4]
 800dad2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800dad4:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 800dad8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800dadc:	2b00      	cmp	r3, #0
 800dade:	d012      	beq.n	800db06 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 800dae0:	9b01      	ldr	r3, [sp, #4]
 800dae2:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800dae4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800dae8:	3348      	adds	r3, #72	; 0x48
 800daea:	015b      	lsls	r3, r3, #5
 800daec:	4413      	add	r3, r2
 800daee:	681a      	ldr	r2, [r3, #0]
 800daf0:	9b01      	ldr	r3, [sp, #4]
 800daf2:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800daf4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800daf8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800dafc:	3348      	adds	r3, #72	; 0x48
 800dafe:	015b      	lsls	r3, r3, #5
 800db00:	440b      	add	r3, r1
 800db02:	601a      	str	r2, [r3, #0]
 800db04:	e011      	b.n	800db2a <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 800db06:	9b01      	ldr	r3, [sp, #4]
 800db08:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800db0a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800db0e:	3348      	adds	r3, #72	; 0x48
 800db10:	015b      	lsls	r3, r3, #5
 800db12:	4413      	add	r3, r2
 800db14:	681a      	ldr	r2, [r3, #0]
 800db16:	9b01      	ldr	r3, [sp, #4]
 800db18:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800db1a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800db1e:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800db22:	3348      	adds	r3, #72	; 0x48
 800db24:	015b      	lsls	r3, r3, #5
 800db26:	440b      	add	r3, r1
 800db28:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800db2a:	9b01      	ldr	r3, [sp, #4]
 800db2c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800db2e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800db32:	3348      	adds	r3, #72	; 0x48
 800db34:	015b      	lsls	r3, r3, #5
 800db36:	4413      	add	r3, r2
 800db38:	681a      	ldr	r2, [r3, #0]
 800db3a:	9b01      	ldr	r3, [sp, #4]
 800db3c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800db3e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800db42:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800db46:	3348      	adds	r3, #72	; 0x48
 800db48:	015b      	lsls	r3, r3, #5
 800db4a:	440b      	add	r3, r1
 800db4c:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800db4e:	9b01      	ldr	r3, [sp, #4]
 800db50:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800db52:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
 800db56:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800db5a:	2201      	movs	r2, #1
 800db5c:	409a      	lsls	r2, r3
 800db5e:	9b01      	ldr	r3, [sp, #4]
 800db60:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800db62:	430a      	orrs	r2, r1
 800db64:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 800db68:	b004      	add	sp, #16
 800db6a:	4770      	bx	lr
 800db6c:	0000      	movs	r0, r0
	...

0800db70 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 800db70:	b082      	sub	sp, #8
 800db72:	9001      	str	r0, [sp, #4]
 800db74:	460b      	mov	r3, r1
 800db76:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800db7a:	9b01      	ldr	r3, [sp, #4]
 800db7c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800db7e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800db82:	3358      	adds	r3, #88	; 0x58
 800db84:	015b      	lsls	r3, r3, #5
 800db86:	4413      	add	r3, r2
 800db88:	681a      	ldr	r2, [r3, #0]
 800db8a:	9b01      	ldr	r3, [sp, #4]
 800db8c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800db8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800db92:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800db96:	3358      	adds	r3, #88	; 0x58
 800db98:	015b      	lsls	r3, r3, #5
 800db9a:	440b      	add	r3, r1
 800db9c:	601a      	str	r2, [r3, #0]
}
 800db9e:	b002      	add	sp, #8
 800dba0:	4770      	bx	lr
 800dba2:	bf00      	nop
	...

0800dbb0 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 800dbb0:	b082      	sub	sp, #8
 800dbb2:	9001      	str	r0, [sp, #4]
 800dbb4:	460b      	mov	r3, r1
 800dbb6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800dbba:	9b01      	ldr	r3, [sp, #4]
 800dbbc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800dbbe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800dbc2:	3348      	adds	r3, #72	; 0x48
 800dbc4:	015b      	lsls	r3, r3, #5
 800dbc6:	4413      	add	r3, r2
 800dbc8:	681a      	ldr	r2, [r3, #0]
 800dbca:	9b01      	ldr	r3, [sp, #4]
 800dbcc:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800dbce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800dbd2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800dbd6:	3348      	adds	r3, #72	; 0x48
 800dbd8:	015b      	lsls	r3, r3, #5
 800dbda:	440b      	add	r3, r1
 800dbdc:	601a      	str	r2, [r3, #0]
}
 800dbde:	b002      	add	sp, #8
 800dbe0:	4770      	bx	lr
 800dbe2:	bf00      	nop
	...

0800dbf0 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 800dbf0:	b082      	sub	sp, #8
 800dbf2:	9001      	str	r0, [sp, #4]
 800dbf4:	460b      	mov	r3, r1
 800dbf6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 800dbfa:	9b01      	ldr	r3, [sp, #4]
 800dbfc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800dbfe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800dc02:	3358      	adds	r3, #88	; 0x58
 800dc04:	015b      	lsls	r3, r3, #5
 800dc06:	4413      	add	r3, r2
 800dc08:	681a      	ldr	r2, [r3, #0]
 800dc0a:	9b01      	ldr	r3, [sp, #4]
 800dc0c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800dc0e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800dc12:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800dc16:	3358      	adds	r3, #88	; 0x58
 800dc18:	015b      	lsls	r3, r3, #5
 800dc1a:	440b      	add	r3, r1
 800dc1c:	601a      	str	r2, [r3, #0]
}
 800dc1e:	b002      	add	sp, #8
 800dc20:	4770      	bx	lr
 800dc22:	bf00      	nop
	...

0800dc30 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 800dc30:	b082      	sub	sp, #8
 800dc32:	9001      	str	r0, [sp, #4]
 800dc34:	460b      	mov	r3, r1
 800dc36:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 800dc3a:	9b01      	ldr	r3, [sp, #4]
 800dc3c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800dc3e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800dc42:	3348      	adds	r3, #72	; 0x48
 800dc44:	015b      	lsls	r3, r3, #5
 800dc46:	4413      	add	r3, r2
 800dc48:	681a      	ldr	r2, [r3, #0]
 800dc4a:	9b01      	ldr	r3, [sp, #4]
 800dc4c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800dc4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800dc52:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800dc56:	3348      	adds	r3, #72	; 0x48
 800dc58:	015b      	lsls	r3, r3, #5
 800dc5a:	440b      	add	r3, r1
 800dc5c:	601a      	str	r2, [r3, #0]
}
 800dc5e:	b002      	add	sp, #8
 800dc60:	4770      	bx	lr
 800dc62:	bf00      	nop
	...

0800dc70 <port_lock.lto_priv.390>:
static inline void port_lock(void) {
 800dc70:	b082      	sub	sp, #8
 800dc72:	2320      	movs	r3, #32
 800dc74:	9301      	str	r3, [sp, #4]
 800dc76:	9b01      	ldr	r3, [sp, #4]
 800dc78:	f383 8811 	msr	BASEPRI, r3
}
 800dc7c:	b002      	add	sp, #8
 800dc7e:	4770      	bx	lr

0800dc80 <port_unlock.lto_priv.359>:
static inline void port_unlock(void) {
 800dc80:	b082      	sub	sp, #8
 800dc82:	2300      	movs	r3, #0
 800dc84:	9301      	str	r3, [sp, #4]
 800dc86:	9b01      	ldr	r3, [sp, #4]
 800dc88:	f383 8811 	msr	BASEPRI, r3
}
 800dc8c:	b002      	add	sp, #8
 800dc8e:	4770      	bx	lr

0800dc90 <port_lock_from_isr.lto_priv.437>:
static inline void port_lock_from_isr(void) {
 800dc90:	b508      	push	{r3, lr}
  port_lock();
 800dc92:	f7ff ffed 	bl	800dc70 <port_lock.lto_priv.390>
}
 800dc96:	bd08      	pop	{r3, pc}
	...

0800dca0 <port_unlock_from_isr.lto_priv.426>:
static inline void port_unlock_from_isr(void) {
 800dca0:	b508      	push	{r3, lr}
  port_unlock();
 800dca2:	f7ff ffed 	bl	800dc80 <port_unlock.lto_priv.359>
}
 800dca6:	bd08      	pop	{r3, pc}
	...

0800dcb0 <chSysLockFromISR.lto_priv.530>:
static inline void chSysLockFromISR(void) {
 800dcb0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 800dcb2:	f7ff ffed 	bl	800dc90 <port_lock_from_isr.lto_priv.437>
  _dbg_check_lock_from_isr();
 800dcb6:	f001 fb33 	bl	800f320 <_dbg_check_lock_from_isr>
}
 800dcba:	bd08      	pop	{r3, pc}
 800dcbc:	0000      	movs	r0, r0
	...

0800dcc0 <chSysUnlockFromISR.lto_priv.522>:
static inline void chSysUnlockFromISR(void) {
 800dcc0:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 800dcc2:	f001 fb45 	bl	800f350 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 800dcc6:	f7ff ffeb 	bl	800dca0 <port_unlock_from_isr.lto_priv.426>
}
 800dcca:	bd08      	pop	{r3, pc}
 800dccc:	0000      	movs	r0, r0
	...

0800dcd0 <osalSysHalt>:
static inline void osalSysHalt(const char *reason) {
 800dcd0:	b500      	push	{lr}
 800dcd2:	b083      	sub	sp, #12
 800dcd4:	9001      	str	r0, [sp, #4]
  chSysHalt(reason);
 800dcd6:	9801      	ldr	r0, [sp, #4]
 800dcd8:	f001 f982 	bl	800efe0 <chSysHalt>
}
 800dcdc:	b003      	add	sp, #12
 800dcde:	f85d fb04 	ldr.w	pc, [sp], #4
 800dce2:	bf00      	nop
	...

0800dcf0 <osalSysLockFromISR.lto_priv.558>:
static inline void osalSysLockFromISR(void) {
 800dcf0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 800dcf2:	f7ff ffdd 	bl	800dcb0 <chSysLockFromISR.lto_priv.530>
}
 800dcf6:	bd08      	pop	{r3, pc}
	...

0800dd00 <osalSysUnlockFromISR.lto_priv.552>:
static inline void osalSysUnlockFromISR(void) {
 800dd00:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 800dd02:	f7ff ffdd 	bl	800dcc0 <chSysUnlockFromISR.lto_priv.522>
}
 800dd06:	bd08      	pop	{r3, pc}
	...

0800dd10 <osalThreadResumeI.lto_priv.567>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 800dd10:	b500      	push	{lr}
 800dd12:	b083      	sub	sp, #12
 800dd14:	9001      	str	r0, [sp, #4]
 800dd16:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 800dd18:	9900      	ldr	r1, [sp, #0]
 800dd1a:	9801      	ldr	r0, [sp, #4]
 800dd1c:	f002 fdd0 	bl	80108c0 <chThdResumeI>
}
 800dd20:	b003      	add	sp, #12
 800dd22:	f85d fb04 	ldr.w	pc, [sp], #4
 800dd26:	bf00      	nop
	...

0800dd30 <spi_lld_serve_rx_interrupt>:
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 800dd30:	b500      	push	{lr}
 800dd32:	b083      	sub	sp, #12
 800dd34:	9001      	str	r0, [sp, #4]
 800dd36:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800dd38:	9b00      	ldr	r3, [sp, #0]
 800dd3a:	f003 030c 	and.w	r3, r3, #12
 800dd3e:	2b00      	cmp	r3, #0
 800dd40:	d002      	beq.n	800dd48 <spi_lld_serve_rx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 800dd42:	4848      	ldr	r0, [pc, #288]	; (800de64 <spi_lld_serve_rx_interrupt+0x134>)
 800dd44:	f7ff ffc4 	bl	800dcd0 <osalSysHalt>
  }
#else
  (void)flags;
#endif

  if (spip->config->circular) {
 800dd48:	9b01      	ldr	r3, [sp, #4]
 800dd4a:	685b      	ldr	r3, [r3, #4]
 800dd4c:	781b      	ldrb	r3, [r3, #0]
 800dd4e:	2b00      	cmp	r3, #0
 800dd50:	d028      	beq.n	800dda4 <spi_lld_serve_rx_interrupt+0x74>
    if ((flags & STM32_DMA_ISR_HTIF) != 0U) {
 800dd52:	9b00      	ldr	r3, [sp, #0]
 800dd54:	f003 0310 	and.w	r3, r3, #16
 800dd58:	2b00      	cmp	r3, #0
 800dd5a:	d009      	beq.n	800dd70 <spi_lld_serve_rx_interrupt+0x40>
      /* Half buffer interrupt.*/
      _spi_isr_half_code(spip);
 800dd5c:	9b01      	ldr	r3, [sp, #4]
 800dd5e:	685b      	ldr	r3, [r3, #4]
 800dd60:	685b      	ldr	r3, [r3, #4]
 800dd62:	2b00      	cmp	r3, #0
 800dd64:	d004      	beq.n	800dd70 <spi_lld_serve_rx_interrupt+0x40>
 800dd66:	9b01      	ldr	r3, [sp, #4]
 800dd68:	685b      	ldr	r3, [r3, #4]
 800dd6a:	685b      	ldr	r3, [r3, #4]
 800dd6c:	9801      	ldr	r0, [sp, #4]
 800dd6e:	4798      	blx	r3
    }
    if ((flags & STM32_DMA_ISR_TCIF) != 0U) {
 800dd70:	9b00      	ldr	r3, [sp, #0]
 800dd72:	f003 0320 	and.w	r3, r3, #32
 800dd76:	2b00      	cmp	r3, #0
 800dd78:	d06f      	beq.n	800de5a <spi_lld_serve_rx_interrupt+0x12a>
      /* End buffer interrupt.*/
      _spi_isr_full_code(spip);
 800dd7a:	9b01      	ldr	r3, [sp, #4]
 800dd7c:	685b      	ldr	r3, [r3, #4]
 800dd7e:	685b      	ldr	r3, [r3, #4]
 800dd80:	2b00      	cmp	r3, #0
 800dd82:	d06a      	beq.n	800de5a <spi_lld_serve_rx_interrupt+0x12a>
 800dd84:	9b01      	ldr	r3, [sp, #4]
 800dd86:	2204      	movs	r2, #4
 800dd88:	701a      	strb	r2, [r3, #0]
 800dd8a:	9b01      	ldr	r3, [sp, #4]
 800dd8c:	685b      	ldr	r3, [r3, #4]
 800dd8e:	685b      	ldr	r3, [r3, #4]
 800dd90:	9801      	ldr	r0, [sp, #4]
 800dd92:	4798      	blx	r3
 800dd94:	9b01      	ldr	r3, [sp, #4]
 800dd96:	781b      	ldrb	r3, [r3, #0]
 800dd98:	2b04      	cmp	r3, #4
 800dd9a:	d15e      	bne.n	800de5a <spi_lld_serve_rx_interrupt+0x12a>
 800dd9c:	9b01      	ldr	r3, [sp, #4]
 800dd9e:	2203      	movs	r2, #3
 800dda0:	701a      	strb	r2, [r3, #0]
 800dda2:	e05b      	b.n	800de5c <spi_lld_serve_rx_interrupt+0x12c>
    }
  }
  else {
    /* Stopping DMAs.*/
    dmaStreamDisable(spip->dmatx);
 800dda4:	9b01      	ldr	r3, [sp, #4]
 800dda6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800dda8:	681b      	ldr	r3, [r3, #0]
 800ddaa:	681a      	ldr	r2, [r3, #0]
 800ddac:	9b01      	ldr	r3, [sp, #4]
 800ddae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ddb0:	681b      	ldr	r3, [r3, #0]
 800ddb2:	f022 021f 	bic.w	r2, r2, #31
 800ddb6:	601a      	str	r2, [r3, #0]
 800ddb8:	9b01      	ldr	r3, [sp, #4]
 800ddba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ddbc:	681b      	ldr	r3, [r3, #0]
 800ddbe:	681b      	ldr	r3, [r3, #0]
 800ddc0:	f003 0301 	and.w	r3, r3, #1
 800ddc4:	2b00      	cmp	r3, #0
 800ddc6:	d1f7      	bne.n	800ddb8 <spi_lld_serve_rx_interrupt+0x88>
 800ddc8:	9b01      	ldr	r3, [sp, #4]
 800ddca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ddcc:	7a5b      	ldrb	r3, [r3, #9]
 800ddce:	4619      	mov	r1, r3
 800ddd0:	9b01      	ldr	r3, [sp, #4]
 800ddd2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ddd4:	685b      	ldr	r3, [r3, #4]
 800ddd6:	223d      	movs	r2, #61	; 0x3d
 800ddd8:	408a      	lsls	r2, r1
 800ddda:	601a      	str	r2, [r3, #0]
    dmaStreamDisable(spip->dmarx);
 800dddc:	9b01      	ldr	r3, [sp, #4]
 800ddde:	6a1b      	ldr	r3, [r3, #32]
 800dde0:	681b      	ldr	r3, [r3, #0]
 800dde2:	681a      	ldr	r2, [r3, #0]
 800dde4:	9b01      	ldr	r3, [sp, #4]
 800dde6:	6a1b      	ldr	r3, [r3, #32]
 800dde8:	681b      	ldr	r3, [r3, #0]
 800ddea:	f022 021f 	bic.w	r2, r2, #31
 800ddee:	601a      	str	r2, [r3, #0]
 800ddf0:	9b01      	ldr	r3, [sp, #4]
 800ddf2:	6a1b      	ldr	r3, [r3, #32]
 800ddf4:	681b      	ldr	r3, [r3, #0]
 800ddf6:	681b      	ldr	r3, [r3, #0]
 800ddf8:	f003 0301 	and.w	r3, r3, #1
 800ddfc:	2b00      	cmp	r3, #0
 800ddfe:	d1f7      	bne.n	800ddf0 <spi_lld_serve_rx_interrupt+0xc0>
 800de00:	9b01      	ldr	r3, [sp, #4]
 800de02:	6a1b      	ldr	r3, [r3, #32]
 800de04:	7a5b      	ldrb	r3, [r3, #9]
 800de06:	4619      	mov	r1, r3
 800de08:	9b01      	ldr	r3, [sp, #4]
 800de0a:	6a1b      	ldr	r3, [r3, #32]
 800de0c:	685b      	ldr	r3, [r3, #4]
 800de0e:	223d      	movs	r2, #61	; 0x3d
 800de10:	408a      	lsls	r2, r1
 800de12:	601a      	str	r2, [r3, #0]

    /* Portable SPI ISR code defined in the high level driver, note, it is
       a macro.*/
    _spi_isr_code(spip);
 800de14:	9b01      	ldr	r3, [sp, #4]
 800de16:	685b      	ldr	r3, [r3, #4]
 800de18:	685b      	ldr	r3, [r3, #4]
 800de1a:	2b00      	cmp	r3, #0
 800de1c:	d00f      	beq.n	800de3e <spi_lld_serve_rx_interrupt+0x10e>
 800de1e:	9b01      	ldr	r3, [sp, #4]
 800de20:	2204      	movs	r2, #4
 800de22:	701a      	strb	r2, [r3, #0]
 800de24:	9b01      	ldr	r3, [sp, #4]
 800de26:	685b      	ldr	r3, [r3, #4]
 800de28:	685b      	ldr	r3, [r3, #4]
 800de2a:	9801      	ldr	r0, [sp, #4]
 800de2c:	4798      	blx	r3
 800de2e:	9b01      	ldr	r3, [sp, #4]
 800de30:	781b      	ldrb	r3, [r3, #0]
 800de32:	2b04      	cmp	r3, #4
 800de34:	d106      	bne.n	800de44 <spi_lld_serve_rx_interrupt+0x114>
 800de36:	9b01      	ldr	r3, [sp, #4]
 800de38:	2202      	movs	r2, #2
 800de3a:	701a      	strb	r2, [r3, #0]
 800de3c:	e002      	b.n	800de44 <spi_lld_serve_rx_interrupt+0x114>
 800de3e:	9b01      	ldr	r3, [sp, #4]
 800de40:	2202      	movs	r2, #2
 800de42:	701a      	strb	r2, [r3, #0]
 800de44:	f7ff ff54 	bl	800dcf0 <osalSysLockFromISR.lto_priv.558>
 800de48:	9b01      	ldr	r3, [sp, #4]
 800de4a:	3308      	adds	r3, #8
 800de4c:	2100      	movs	r1, #0
 800de4e:	4618      	mov	r0, r3
 800de50:	f7ff ff5e 	bl	800dd10 <osalThreadResumeI.lto_priv.567>
 800de54:	f7ff ff54 	bl	800dd00 <osalSysUnlockFromISR.lto_priv.552>
 800de58:	e000      	b.n	800de5c <spi_lld_serve_rx_interrupt+0x12c>
      _spi_isr_full_code(spip);
 800de5a:	bf00      	nop
  }
}
 800de5c:	b003      	add	sp, #12
 800de5e:	f85d fb04 	ldr.w	pc, [sp], #4
 800de62:	bf00      	nop
 800de64:	08018dbc 	.word	0x08018dbc
	...

0800de70 <spi_lld_serve_tx_interrupt>:
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 800de70:	b500      	push	{lr}
 800de72:	b083      	sub	sp, #12
 800de74:	9001      	str	r0, [sp, #4]
 800de76:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800de78:	9b00      	ldr	r3, [sp, #0]
 800de7a:	f003 030c 	and.w	r3, r3, #12
 800de7e:	2b00      	cmp	r3, #0
 800de80:	d002      	beq.n	800de88 <spi_lld_serve_tx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 800de82:	4803      	ldr	r0, [pc, #12]	; (800de90 <spi_lld_serve_tx_interrupt+0x20>)
 800de84:	f7ff ff24 	bl	800dcd0 <osalSysHalt>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
 800de88:	b003      	add	sp, #12
 800de8a:	f85d fb04 	ldr.w	pc, [sp], #4
 800de8e:	bf00      	nop
 800de90:	08018dbc 	.word	0x08018dbc
	...

0800dea0 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 800dea0:	b508      	push	{r3, lr}
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800dea2:	4809      	ldr	r0, [pc, #36]	; (800dec8 <spi_lld_init+0x28>)
 800dea4:	f7fc fea4 	bl	800abf0 <spiObjectInit>
  SPID2.spi       = SPI2;
 800dea8:	4b07      	ldr	r3, [pc, #28]	; (800dec8 <spi_lld_init+0x28>)
 800deaa:	4a08      	ldr	r2, [pc, #32]	; (800decc <spi_lld_init+0x2c>)
 800deac:	61da      	str	r2, [r3, #28]
  SPID2.dmarx     = NULL;
 800deae:	4b06      	ldr	r3, [pc, #24]	; (800dec8 <spi_lld_init+0x28>)
 800deb0:	2200      	movs	r2, #0
 800deb2:	621a      	str	r2, [r3, #32]
  SPID2.dmatx     = NULL;
 800deb4:	4b04      	ldr	r3, [pc, #16]	; (800dec8 <spi_lld_init+0x28>)
 800deb6:	2200      	movs	r2, #0
 800deb8:	625a      	str	r2, [r3, #36]	; 0x24
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 800deba:	4b03      	ldr	r3, [pc, #12]	; (800dec8 <spi_lld_init+0x28>)
 800debc:	4a04      	ldr	r2, [pc, #16]	; (800ded0 <spi_lld_init+0x30>)
 800debe:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 800dec0:	4b01      	ldr	r3, [pc, #4]	; (800dec8 <spi_lld_init+0x28>)
 800dec2:	4a04      	ldr	r2, [pc, #16]	; (800ded4 <spi_lld_init+0x34>)
 800dec4:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 800dec6:	bd08      	pop	{r3, pc}
 800dec8:	20000eec 	.word	0x20000eec
 800decc:	40003800 	.word	0x40003800
 800ded0:	00010016 	.word	0x00010016
 800ded4:	00010046 	.word	0x00010046
	...

0800dee0 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 800dee0:	b500      	push	{lr}
 800dee2:	b083      	sub	sp, #12
 800dee4:	9001      	str	r0, [sp, #4]

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 800dee6:	9b01      	ldr	r3, [sp, #4]
 800dee8:	781b      	ldrb	r3, [r3, #0]
 800deea:	2b01      	cmp	r3, #1
 800deec:	d141      	bne.n	800df72 <spi_lld_start+0x92>
      osalDbgAssert(spip->dmatx != NULL, "unable to allocate stream");
      rccEnableSPI1(true);
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
 800deee:	9b01      	ldr	r3, [sp, #4]
 800def0:	4a53      	ldr	r2, [pc, #332]	; (800e040 <spi_lld_start+0x160>)
 800def2:	4293      	cmp	r3, r2
 800def4:	d12d      	bne.n	800df52 <spi_lld_start+0x72>
      spip->dmarx = dmaStreamAllocI(STM32_SPI_SPI2_RX_DMA_STREAM,
 800def6:	9b01      	ldr	r3, [sp, #4]
 800def8:	4a52      	ldr	r2, [pc, #328]	; (800e044 <spi_lld_start+0x164>)
 800defa:	210a      	movs	r1, #10
 800defc:	2003      	movs	r0, #3
 800defe:	f7fe fa97 	bl	800c430 <dmaStreamAllocI>
 800df02:	4602      	mov	r2, r0
 800df04:	9b01      	ldr	r3, [sp, #4]
 800df06:	621a      	str	r2, [r3, #32]
                                    STM32_SPI_SPI2_IRQ_PRIORITY,
                                    (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                                    (void *)spip);
      osalDbgAssert(spip->dmarx != NULL, "unable to allocate stream");
 800df08:	9b01      	ldr	r3, [sp, #4]
 800df0a:	6a1b      	ldr	r3, [r3, #32]
 800df0c:	2b00      	cmp	r3, #0
 800df0e:	d102      	bne.n	800df16 <spi_lld_start+0x36>
 800df10:	484d      	ldr	r0, [pc, #308]	; (800e048 <spi_lld_start+0x168>)
 800df12:	f001 f865 	bl	800efe0 <chSysHalt>
      spip->dmatx = dmaStreamAllocI(STM32_SPI_SPI2_TX_DMA_STREAM,
 800df16:	9b01      	ldr	r3, [sp, #4]
 800df18:	4a4c      	ldr	r2, [pc, #304]	; (800e04c <spi_lld_start+0x16c>)
 800df1a:	210a      	movs	r1, #10
 800df1c:	2004      	movs	r0, #4
 800df1e:	f7fe fa87 	bl	800c430 <dmaStreamAllocI>
 800df22:	4602      	mov	r2, r0
 800df24:	9b01      	ldr	r3, [sp, #4]
 800df26:	625a      	str	r2, [r3, #36]	; 0x24
                                    STM32_SPI_SPI2_IRQ_PRIORITY,
                                    (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                                    (void *)spip);
      osalDbgAssert(spip->dmatx != NULL, "unable to allocate stream");
 800df28:	9b01      	ldr	r3, [sp, #4]
 800df2a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800df2c:	2b00      	cmp	r3, #0
 800df2e:	d102      	bne.n	800df36 <spi_lld_start+0x56>
 800df30:	4845      	ldr	r0, [pc, #276]	; (800e048 <spi_lld_start+0x168>)
 800df32:	f001 f855 	bl	800efe0 <chSysHalt>
      rccEnableSPI2(true);
 800df36:	4b46      	ldr	r3, [pc, #280]	; (800e050 <spi_lld_start+0x170>)
 800df38:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800df3a:	4a45      	ldr	r2, [pc, #276]	; (800e050 <spi_lld_start+0x170>)
 800df3c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800df40:	6413      	str	r3, [r2, #64]	; 0x40
 800df42:	4b43      	ldr	r3, [pc, #268]	; (800e050 <spi_lld_start+0x170>)
 800df44:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800df46:	4a42      	ldr	r2, [pc, #264]	; (800e050 <spi_lld_start+0x170>)
 800df48:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800df4c:	6613      	str	r3, [r2, #96]	; 0x60
 800df4e:	4b40      	ldr	r3, [pc, #256]	; (800e050 <spi_lld_start+0x170>)
 800df50:	6e1b      	ldr	r3, [r3, #96]	; 0x60
      rccEnableSPI6(true);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800df52:	9b01      	ldr	r3, [sp, #4]
 800df54:	69db      	ldr	r3, [r3, #28]
 800df56:	f103 020c 	add.w	r2, r3, #12
 800df5a:	9b01      	ldr	r3, [sp, #4]
 800df5c:	6a1b      	ldr	r3, [r3, #32]
 800df5e:	681b      	ldr	r3, [r3, #0]
 800df60:	609a      	str	r2, [r3, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800df62:	9b01      	ldr	r3, [sp, #4]
 800df64:	69db      	ldr	r3, [r3, #28]
 800df66:	f103 020c 	add.w	r2, r3, #12
 800df6a:	9b01      	ldr	r3, [sp, #4]
 800df6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800df6e:	681b      	ldr	r3, [r3, #0]
 800df70:	609a      	str	r2, [r3, #8]
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800df72:	9b01      	ldr	r3, [sp, #4]
 800df74:	685b      	ldr	r3, [r3, #4]
 800df76:	8a1b      	ldrh	r3, [r3, #16]
 800df78:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800df7c:	2b00      	cmp	r3, #0
 800df7e:	d10c      	bne.n	800df9a <spi_lld_start+0xba>
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800df80:	9b01      	ldr	r3, [sp, #4]
 800df82:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800df84:	f423 42f0 	bic.w	r2, r3, #30720	; 0x7800
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800df88:	9b01      	ldr	r3, [sp, #4]
 800df8a:	629a      	str	r2, [r3, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800df8c:	9b01      	ldr	r3, [sp, #4]
 800df8e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800df90:	f423 42f0 	bic.w	r2, r3, #30720	; 0x7800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800df94:	9b01      	ldr	r3, [sp, #4]
 800df96:	62da      	str	r2, [r3, #44]	; 0x2c
 800df98:	e00f      	b.n	800dfba <spi_lld_start+0xda>
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800df9a:	9b01      	ldr	r3, [sp, #4]
 800df9c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800df9e:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800dfa2:	f443 5220 	orr.w	r2, r3, #10240	; 0x2800
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800dfa6:	9b01      	ldr	r3, [sp, #4]
 800dfa8:	629a      	str	r2, [r3, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800dfaa:	9b01      	ldr	r3, [sp, #4]
 800dfac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dfae:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800dfb2:	f443 5220 	orr.w	r2, r3, #10240	; 0x2800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800dfb6:	9b01      	ldr	r3, [sp, #4]
 800dfb8:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  if (spip->config->circular) {
 800dfba:	9b01      	ldr	r3, [sp, #4]
 800dfbc:	685b      	ldr	r3, [r3, #4]
 800dfbe:	781b      	ldrb	r3, [r3, #0]
 800dfc0:	2b00      	cmp	r3, #0
 800dfc2:	d00c      	beq.n	800dfde <spi_lld_start+0xfe>
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800dfc4:	9b01      	ldr	r3, [sp, #4]
 800dfc6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dfc8:	f443 7284 	orr.w	r2, r3, #264	; 0x108
 800dfcc:	9b01      	ldr	r3, [sp, #4]
 800dfce:	629a      	str	r2, [r3, #40]	; 0x28
    spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800dfd0:	9b01      	ldr	r3, [sp, #4]
 800dfd2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dfd4:	f443 7284 	orr.w	r2, r3, #264	; 0x108
 800dfd8:	9b01      	ldr	r3, [sp, #4]
 800dfda:	62da      	str	r2, [r3, #44]	; 0x2c
 800dfdc:	e00b      	b.n	800dff6 <spi_lld_start+0x116>
  }
  else {
    spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800dfde:	9b01      	ldr	r3, [sp, #4]
 800dfe0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dfe2:	f423 7284 	bic.w	r2, r3, #264	; 0x108
 800dfe6:	9b01      	ldr	r3, [sp, #4]
 800dfe8:	629a      	str	r2, [r3, #40]	; 0x28
    spip->txdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800dfea:	9b01      	ldr	r3, [sp, #4]
 800dfec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dfee:	f423 7284 	bic.w	r2, r3, #264	; 0x108
 800dff2:	9b01      	ldr	r3, [sp, #4]
 800dff4:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  /* SPI setup and enable.*/
  spip->spi->CR1 &= ~SPI_CR1_SPE;
 800dff6:	9b01      	ldr	r3, [sp, #4]
 800dff8:	69db      	ldr	r3, [r3, #28]
 800dffa:	681a      	ldr	r2, [r3, #0]
 800dffc:	9b01      	ldr	r3, [sp, #4]
 800dffe:	69db      	ldr	r3, [r3, #28]
 800e000:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800e004:	601a      	str	r2, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 800e006:	9b01      	ldr	r3, [sp, #4]
 800e008:	685b      	ldr	r3, [r3, #4]
 800e00a:	8a1b      	ldrh	r3, [r3, #16]
 800e00c:	f443 7341 	orr.w	r3, r3, #772	; 0x304
 800e010:	b29a      	uxth	r2, r3
 800e012:	9b01      	ldr	r3, [sp, #4]
 800e014:	69db      	ldr	r3, [r3, #28]
 800e016:	601a      	str	r2, [r3, #0]
                    SPI_CR1_SSI;
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800e018:	9b01      	ldr	r3, [sp, #4]
 800e01a:	685b      	ldr	r3, [r3, #4]
 800e01c:	8a5b      	ldrh	r3, [r3, #18]
 800e01e:	f043 0307 	orr.w	r3, r3, #7
 800e022:	b29a      	uxth	r2, r3
 800e024:	9b01      	ldr	r3, [sp, #4]
 800e026:	69db      	ldr	r3, [r3, #28]
 800e028:	605a      	str	r2, [r3, #4]
                    SPI_CR2_TXDMAEN;
  spip->spi->CR1 |= SPI_CR1_SPE;
 800e02a:	9b01      	ldr	r3, [sp, #4]
 800e02c:	69db      	ldr	r3, [r3, #28]
 800e02e:	681a      	ldr	r2, [r3, #0]
 800e030:	9b01      	ldr	r3, [sp, #4]
 800e032:	69db      	ldr	r3, [r3, #28]
 800e034:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800e038:	601a      	str	r2, [r3, #0]
}
 800e03a:	b003      	add	sp, #12
 800e03c:	f85d fb04 	ldr.w	pc, [sp], #4
 800e040:	20000eec 	.word	0x20000eec
 800e044:	0800dd31 	.word	0x0800dd31
 800e048:	08016074 	.word	0x08016074
 800e04c:	0800de71 	.word	0x0800de71
 800e050:	40023800 	.word	0x40023800
	...

0800e060 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 800e060:	b500      	push	{lr}
 800e062:	b085      	sub	sp, #20
 800e064:	9003      	str	r0, [sp, #12]
 800e066:	9102      	str	r1, [sp, #8]
 800e068:	9201      	str	r2, [sp, #4]
 800e06a:	9300      	str	r3, [sp, #0]

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
 800e06c:	9b02      	ldr	r3, [sp, #8]
 800e06e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e072:	d302      	bcc.n	800e07a <spi_lld_exchange+0x1a>
 800e074:	481e      	ldr	r0, [pc, #120]	; (800e0f0 <spi_lld_exchange+0x90>)
 800e076:	f000 ffb3 	bl	800efe0 <chSysHalt>

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800e07a:	9b03      	ldr	r3, [sp, #12]
 800e07c:	6a1b      	ldr	r3, [r3, #32]
 800e07e:	681b      	ldr	r3, [r3, #0]
 800e080:	9a00      	ldr	r2, [sp, #0]
 800e082:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800e084:	9b03      	ldr	r3, [sp, #12]
 800e086:	6a1b      	ldr	r3, [r3, #32]
 800e088:	681b      	ldr	r3, [r3, #0]
 800e08a:	9a02      	ldr	r2, [sp, #8]
 800e08c:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 800e08e:	9b03      	ldr	r3, [sp, #12]
 800e090:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e092:	9b03      	ldr	r3, [sp, #12]
 800e094:	6a1b      	ldr	r3, [r3, #32]
 800e096:	681b      	ldr	r3, [r3, #0]
 800e098:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800e09c:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800e09e:	9b03      	ldr	r3, [sp, #12]
 800e0a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e0a2:	681b      	ldr	r3, [r3, #0]
 800e0a4:	9a01      	ldr	r2, [sp, #4]
 800e0a6:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800e0a8:	9b03      	ldr	r3, [sp, #12]
 800e0aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e0ac:	681b      	ldr	r3, [r3, #0]
 800e0ae:	9a02      	ldr	r2, [sp, #8]
 800e0b0:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800e0b2:	9b03      	ldr	r3, [sp, #12]
 800e0b4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800e0b6:	9b03      	ldr	r3, [sp, #12]
 800e0b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e0ba:	681b      	ldr	r3, [r3, #0]
 800e0bc:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800e0c0:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800e0c2:	9b03      	ldr	r3, [sp, #12]
 800e0c4:	6a1b      	ldr	r3, [r3, #32]
 800e0c6:	681b      	ldr	r3, [r3, #0]
 800e0c8:	681a      	ldr	r2, [r3, #0]
 800e0ca:	9b03      	ldr	r3, [sp, #12]
 800e0cc:	6a1b      	ldr	r3, [r3, #32]
 800e0ce:	681b      	ldr	r3, [r3, #0]
 800e0d0:	f042 0201 	orr.w	r2, r2, #1
 800e0d4:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800e0d6:	9b03      	ldr	r3, [sp, #12]
 800e0d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e0da:	681b      	ldr	r3, [r3, #0]
 800e0dc:	681a      	ldr	r2, [r3, #0]
 800e0de:	9b03      	ldr	r3, [sp, #12]
 800e0e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e0e2:	681b      	ldr	r3, [r3, #0]
 800e0e4:	f042 0201 	orr.w	r2, r2, #1
 800e0e8:	601a      	str	r2, [r3, #0]
}
 800e0ea:	b005      	add	sp, #20
 800e0ec:	f85d fb04 	ldr.w	pc, [sp], #4
 800e0f0:	08016084 	.word	0x08016084
	...

0800e100 <port_lock.lto_priv.391>:
static inline void port_lock(void) {
 800e100:	b082      	sub	sp, #8
 800e102:	2320      	movs	r3, #32
 800e104:	9301      	str	r3, [sp, #4]
 800e106:	9b01      	ldr	r3, [sp, #4]
 800e108:	f383 8811 	msr	BASEPRI, r3
}
 800e10c:	b002      	add	sp, #8
 800e10e:	4770      	bx	lr

0800e110 <port_unlock.lto_priv.360>:
static inline void port_unlock(void) {
 800e110:	b082      	sub	sp, #8
 800e112:	2300      	movs	r3, #0
 800e114:	9301      	str	r3, [sp, #4]
 800e116:	9b01      	ldr	r3, [sp, #4]
 800e118:	f383 8811 	msr	BASEPRI, r3
}
 800e11c:	b002      	add	sp, #8
 800e11e:	4770      	bx	lr

0800e120 <port_lock_from_isr.lto_priv.438>:
static inline void port_lock_from_isr(void) {
 800e120:	b508      	push	{r3, lr}
  port_lock();
 800e122:	f7ff ffed 	bl	800e100 <port_lock.lto_priv.391>
}
 800e126:	bd08      	pop	{r3, pc}
	...

0800e130 <port_unlock_from_isr.lto_priv.427>:
static inline void port_unlock_from_isr(void) {
 800e130:	b508      	push	{r3, lr}
  port_unlock();
 800e132:	f7ff ffed 	bl	800e110 <port_unlock.lto_priv.360>
}
 800e136:	bd08      	pop	{r3, pc}
	...

0800e140 <chSysLockFromISR.lto_priv.531>:
static inline void chSysLockFromISR(void) {
 800e140:	b508      	push	{r3, lr}
  port_lock_from_isr();
 800e142:	f7ff ffed 	bl	800e120 <port_lock_from_isr.lto_priv.438>
  _dbg_check_lock_from_isr();
 800e146:	f001 f8eb 	bl	800f320 <_dbg_check_lock_from_isr>
}
 800e14a:	bd08      	pop	{r3, pc}
 800e14c:	0000      	movs	r0, r0
	...

0800e150 <chSysUnlockFromISR.lto_priv.523>:
static inline void chSysUnlockFromISR(void) {
 800e150:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 800e152:	f001 f8fd 	bl	800f350 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 800e156:	f7ff ffeb 	bl	800e130 <port_unlock_from_isr.lto_priv.427>
}
 800e15a:	bd08      	pop	{r3, pc}
 800e15c:	0000      	movs	r0, r0
	...

0800e160 <osalSysLockFromISR.lto_priv.559>:
static inline void osalSysLockFromISR(void) {
 800e160:	b508      	push	{r3, lr}
  chSysLockFromISR();
 800e162:	f7ff ffed 	bl	800e140 <chSysLockFromISR.lto_priv.531>
}
 800e166:	bd08      	pop	{r3, pc}
	...

0800e170 <osalSysUnlockFromISR.lto_priv.553>:
static inline void osalSysUnlockFromISR(void) {
 800e170:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 800e172:	f7ff ffed 	bl	800e150 <chSysUnlockFromISR.lto_priv.523>
}
 800e176:	bd08      	pop	{r3, pc}
	...

0800e180 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 800e180:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 800e182:	f000 ffc5 	bl	800f110 <chSysTimerHandlerI>
}
 800e186:	bd08      	pop	{r3, pc}
	...

0800e190 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 800e190:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 800e192:	480f      	ldr	r0, [pc, #60]	; (800e1d0 <VectorB0+0x40>)
 800e194:	f001 fa24 	bl	800f5e0 <_trace_isr_enter>
 800e198:	f001 f8f2 	bl	800f380 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800e19c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e1a0:	691b      	ldr	r3, [r3, #16]
 800e1a2:	f003 0302 	and.w	r3, r3, #2
 800e1a6:	2b00      	cmp	r3, #0
 800e1a8:	d009      	beq.n	800e1be <VectorB0+0x2e>
    STM32_ST_TIM->SR = 0U;
 800e1aa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e1ae:	2200      	movs	r2, #0
 800e1b0:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 800e1b2:	f7ff ffd5 	bl	800e160 <osalSysLockFromISR.lto_priv.559>
    osalOsTimerHandlerI();
 800e1b6:	f7ff ffe3 	bl	800e180 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 800e1ba:	f7ff ffd9 	bl	800e170 <osalSysUnlockFromISR.lto_priv.553>
  }

  OSAL_IRQ_EPILOGUE();
 800e1be:	f001 f8ff 	bl	800f3c0 <_dbg_check_leave_isr>
 800e1c2:	4803      	ldr	r0, [pc, #12]	; (800e1d0 <VectorB0+0x40>)
 800e1c4:	f001 fa34 	bl	800f630 <_trace_isr_leave>
 800e1c8:	f006 f8c2 	bl	8014350 <_port_irq_epilogue>
}
 800e1cc:	bd08      	pop	{r3, pc}
 800e1ce:	bf00      	nop
 800e1d0:	08016098 	.word	0x08016098
	...

0800e1e0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 800e1e0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800e1e2:	4b1d      	ldr	r3, [pc, #116]	; (800e258 <st_lld_init+0x78>)
 800e1e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e1e6:	4a1c      	ldr	r2, [pc, #112]	; (800e258 <st_lld_init+0x78>)
 800e1e8:	f043 0301 	orr.w	r3, r3, #1
 800e1ec:	6413      	str	r3, [r2, #64]	; 0x40
 800e1ee:	4b1a      	ldr	r3, [pc, #104]	; (800e258 <st_lld_init+0x78>)
 800e1f0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800e1f2:	4a19      	ldr	r2, [pc, #100]	; (800e258 <st_lld_init+0x78>)
 800e1f4:	f043 0301 	orr.w	r3, r3, #1
 800e1f8:	6613      	str	r3, [r2, #96]	; 0x60
 800e1fa:	4b17      	ldr	r3, [pc, #92]	; (800e258 <st_lld_init+0x78>)
 800e1fc:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800e1fe:	4b17      	ldr	r3, [pc, #92]	; (800e25c <st_lld_init+0x7c>)
 800e200:	689b      	ldr	r3, [r3, #8]
 800e202:	4a16      	ldr	r2, [pc, #88]	; (800e25c <st_lld_init+0x7c>)
 800e204:	f043 0301 	orr.w	r3, r3, #1
 800e208:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800e20a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e20e:	f242 02cf 	movw	r2, #8399	; 0x20cf
 800e212:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800e214:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e218:	f04f 32ff 	mov.w	r2, #4294967295
 800e21c:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800e21e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e222:	2200      	movs	r2, #0
 800e224:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 800e226:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e22a:	2200      	movs	r2, #0
 800e22c:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800e22e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e232:	2200      	movs	r2, #0
 800e234:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 800e236:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e23a:	2200      	movs	r2, #0
 800e23c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800e23e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e242:	2201      	movs	r2, #1
 800e244:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 800e246:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e24a:	2201      	movs	r2, #1
 800e24c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800e24e:	2108      	movs	r1, #8
 800e250:	201c      	movs	r0, #28
 800e252:	f7fd fc55 	bl	800bb00 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 800e256:	bd08      	pop	{r3, pc}
 800e258:	40023800 	.word	0x40023800
 800e25c:	e0042000 	.word	0xe0042000

0800e260 <VectorA4>:
 *          pointer is not equal to @p NULL in order to not perform an extra
 *          check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 800e260:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 800e262:	4808      	ldr	r0, [pc, #32]	; (800e284 <VectorA4+0x24>)
 800e264:	f001 f9bc 	bl	800f5e0 <_trace_isr_enter>
 800e268:	f001 f88a 	bl	800f380 <_dbg_check_enter_isr>

  pwm_lld_serve_interrupt(&PWMD1);
 800e26c:	4806      	ldr	r0, [pc, #24]	; (800e288 <VectorA4+0x28>)
 800e26e:	f000 f93f 	bl	800e4f0 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800e272:	f001 f8a5 	bl	800f3c0 <_dbg_check_leave_isr>
 800e276:	4803      	ldr	r0, [pc, #12]	; (800e284 <VectorA4+0x24>)
 800e278:	f001 f9da 	bl	800f630 <_trace_isr_leave>
 800e27c:	f006 f868 	bl	8014350 <_port_irq_epilogue>
}
 800e280:	bd08      	pop	{r3, pc}
 800e282:	bf00      	nop
 800e284:	080160a4 	.word	0x080160a4
 800e288:	20000f1c 	.word	0x20000f1c
 800e28c:	00000000 	.word	0x00000000

0800e290 <VectorAC>:
 *          associated callback pointer is not equal to @p NULL in order to not
 *          perform an extra check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 800e290:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 800e292:	4808      	ldr	r0, [pc, #32]	; (800e2b4 <VectorAC+0x24>)
 800e294:	f001 f9a4 	bl	800f5e0 <_trace_isr_enter>
 800e298:	f001 f872 	bl	800f380 <_dbg_check_enter_isr>

  pwm_lld_serve_interrupt(&PWMD1);
 800e29c:	4806      	ldr	r0, [pc, #24]	; (800e2b8 <VectorAC+0x28>)
 800e29e:	f000 f927 	bl	800e4f0 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800e2a2:	f001 f88d 	bl	800f3c0 <_dbg_check_leave_isr>
 800e2a6:	4803      	ldr	r0, [pc, #12]	; (800e2b4 <VectorAC+0x24>)
 800e2a8:	f001 f9c2 	bl	800f630 <_trace_isr_leave>
 800e2ac:	f006 f850 	bl	8014350 <_port_irq_epilogue>
}
 800e2b0:	bd08      	pop	{r3, pc}
 800e2b2:	bf00      	nop
 800e2b4:	080160b0 	.word	0x080160b0
 800e2b8:	20000f1c 	.word	0x20000f1c
 800e2bc:	00000000 	.word	0x00000000

0800e2c0 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 800e2c0:	b508      	push	{r3, lr}

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
 800e2c2:	4805      	ldr	r0, [pc, #20]	; (800e2d8 <pwm_lld_init+0x18>)
 800e2c4:	f7fb fd2c 	bl	8009d20 <pwmObjectInit>
  PWMD1.channels = STM32_TIM1_CHANNELS;
 800e2c8:	4b03      	ldr	r3, [pc, #12]	; (800e2d8 <pwm_lld_init+0x18>)
 800e2ca:	2204      	movs	r2, #4
 800e2cc:	741a      	strb	r2, [r3, #16]
  PWMD1.tim = STM32_TIM1;
 800e2ce:	4b02      	ldr	r3, [pc, #8]	; (800e2d8 <pwm_lld_init+0x18>)
 800e2d0:	4a02      	ldr	r2, [pc, #8]	; (800e2dc <pwm_lld_init+0x1c>)
 800e2d2:	619a      	str	r2, [r3, #24]
  /* Driver initialization.*/
  pwmObjectInit(&PWMD17);
  PWMD17.channels = STM32_TIM17_CHANNELS;
  PWMD17.tim = STM32_TIM17;
#endif
}
 800e2d4:	bd08      	pop	{r3, pc}
 800e2d6:	bf00      	nop
 800e2d8:	20000f1c 	.word	0x20000f1c
 800e2dc:	40010000 	.word	0x40010000

0800e2e0 <pwm_lld_start>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp) {
 800e2e0:	b500      	push	{lr}
 800e2e2:	b085      	sub	sp, #20
 800e2e4:	9001      	str	r0, [sp, #4]
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 800e2e6:	9b01      	ldr	r3, [sp, #4]
 800e2e8:	781b      	ldrb	r3, [r3, #0]
 800e2ea:	2b01      	cmp	r3, #1
 800e2ec:	d135      	bne.n	800e35a <pwm_lld_start+0x7a>
    /* Clock activation and timer reset.*/
#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
 800e2ee:	9b01      	ldr	r3, [sp, #4]
 800e2f0:	4a6e      	ldr	r2, [pc, #440]	; (800e4ac <pwm_lld_start+0x1cc>)
 800e2f2:	4293      	cmp	r3, r2
 800e2f4:	d126      	bne.n	800e344 <pwm_lld_start+0x64>
      rccEnableTIM1(true);
 800e2f6:	4b6e      	ldr	r3, [pc, #440]	; (800e4b0 <pwm_lld_start+0x1d0>)
 800e2f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e2fa:	4a6d      	ldr	r2, [pc, #436]	; (800e4b0 <pwm_lld_start+0x1d0>)
 800e2fc:	f043 0301 	orr.w	r3, r3, #1
 800e300:	6453      	str	r3, [r2, #68]	; 0x44
 800e302:	4b6b      	ldr	r3, [pc, #428]	; (800e4b0 <pwm_lld_start+0x1d0>)
 800e304:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e306:	4a6a      	ldr	r2, [pc, #424]	; (800e4b0 <pwm_lld_start+0x1d0>)
 800e308:	f043 0301 	orr.w	r3, r3, #1
 800e30c:	6653      	str	r3, [r2, #100]	; 0x64
 800e30e:	4b68      	ldr	r3, [pc, #416]	; (800e4b0 <pwm_lld_start+0x1d0>)
 800e310:	6e5b      	ldr	r3, [r3, #100]	; 0x64
      rccResetTIM1();
 800e312:	4b67      	ldr	r3, [pc, #412]	; (800e4b0 <pwm_lld_start+0x1d0>)
 800e314:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e316:	4a66      	ldr	r2, [pc, #408]	; (800e4b0 <pwm_lld_start+0x1d0>)
 800e318:	f043 0301 	orr.w	r3, r3, #1
 800e31c:	6253      	str	r3, [r2, #36]	; 0x24
 800e31e:	4b64      	ldr	r3, [pc, #400]	; (800e4b0 <pwm_lld_start+0x1d0>)
 800e320:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e322:	4a63      	ldr	r2, [pc, #396]	; (800e4b0 <pwm_lld_start+0x1d0>)
 800e324:	f023 0301 	bic.w	r3, r3, #1
 800e328:	6253      	str	r3, [r2, #36]	; 0x24
 800e32a:	4b61      	ldr	r3, [pc, #388]	; (800e4b0 <pwm_lld_start+0x1d0>)
 800e32c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
#if !defined(STM32_TIM1_SUPPRESS_ISR)
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
 800e32e:	2107      	movs	r1, #7
 800e330:	2019      	movs	r0, #25
 800e332:	f7fd fbe5 	bl	800bb00 <nvicEnableVector>
      nvicEnableVector(STM32_TIM1_CC_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
 800e336:	2107      	movs	r1, #7
 800e338:	201b      	movs	r0, #27
 800e33a:	f7fd fbe1 	bl	800bb00 <nvicEnableVector>
#endif
#if defined(STM32_TIM1CLK)
      pwmp->clock = STM32_TIM1CLK;
#else
      pwmp->clock = STM32_TIMCLK2;
 800e33e:	9b01      	ldr	r3, [sp, #4]
 800e340:	4a5c      	ldr	r2, [pc, #368]	; (800e4b4 <pwm_lld_start+0x1d4>)
 800e342:	615a      	str	r2, [r3, #20]
    }
#endif

    /* All channels configured in PWM1 mode with preload enabled and will
       stay that way until the driver is stopped.*/
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 800e344:	9b01      	ldr	r3, [sp, #4]
 800e346:	699b      	ldr	r3, [r3, #24]
 800e348:	f646 0268 	movw	r2, #26728	; 0x6868
 800e34c:	619a      	str	r2, [r3, #24]
                       STM32_TIM_CCMR1_OC2M(6) | STM32_TIM_CCMR1_OC2PE;
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 800e34e:	9b01      	ldr	r3, [sp, #4]
 800e350:	699b      	ldr	r3, [r3, #24]
 800e352:	f646 0268 	movw	r2, #26728	; 0x6868
 800e356:	61da      	str	r2, [r3, #28]
 800e358:	e017      	b.n	800e38a <pwm_lld_start+0xaa>
                       STM32_TIM_CCMR3_OC6M(6) | STM32_TIM_CCMR3_OC6PE;
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 800e35a:	9b01      	ldr	r3, [sp, #4]
 800e35c:	699b      	ldr	r3, [r3, #24]
 800e35e:	2200      	movs	r2, #0
 800e360:	601a      	str	r2, [r3, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 800e362:	9b01      	ldr	r3, [sp, #4]
 800e364:	699b      	ldr	r3, [r3, #24]
 800e366:	2200      	movs	r2, #0
 800e368:	635a      	str	r2, [r3, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 800e36a:	9b01      	ldr	r3, [sp, #4]
 800e36c:	699b      	ldr	r3, [r3, #24]
 800e36e:	2200      	movs	r2, #0
 800e370:	639a      	str	r2, [r3, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 800e372:	9b01      	ldr	r3, [sp, #4]
 800e374:	699b      	ldr	r3, [r3, #24]
 800e376:	2200      	movs	r2, #0
 800e378:	63da      	str	r2, [r3, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 800e37a:	9b01      	ldr	r3, [sp, #4]
 800e37c:	699b      	ldr	r3, [r3, #24]
 800e37e:	2200      	movs	r2, #0
 800e380:	641a      	str	r2, [r3, #64]	; 0x40
    if (pwmp->channels > 4) {
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
    }
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 800e382:	9b01      	ldr	r3, [sp, #4]
 800e384:	699b      	ldr	r3, [r3, #24]
 800e386:	2200      	movs	r2, #0
 800e388:	625a      	str	r2, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 800e38a:	9b01      	ldr	r3, [sp, #4]
 800e38c:	695a      	ldr	r2, [r3, #20]
 800e38e:	9b01      	ldr	r3, [sp, #4]
 800e390:	685b      	ldr	r3, [r3, #4]
 800e392:	681b      	ldr	r3, [r3, #0]
 800e394:	fbb2 f3f3 	udiv	r3, r2, r3
 800e398:	3b01      	subs	r3, #1
 800e39a:	9302      	str	r3, [sp, #8]
  osalDbgAssert((psc <= 0xFFFF) &&
 800e39c:	9b02      	ldr	r3, [sp, #8]
 800e39e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e3a2:	d20a      	bcs.n	800e3ba <pwm_lld_start+0xda>
 800e3a4:	9b02      	ldr	r3, [sp, #8]
 800e3a6:	3301      	adds	r3, #1
 800e3a8:	9a01      	ldr	r2, [sp, #4]
 800e3aa:	6852      	ldr	r2, [r2, #4]
 800e3ac:	6812      	ldr	r2, [r2, #0]
 800e3ae:	fb02 f203 	mul.w	r2, r2, r3
 800e3b2:	9b01      	ldr	r3, [sp, #4]
 800e3b4:	695b      	ldr	r3, [r3, #20]
 800e3b6:	429a      	cmp	r2, r3
 800e3b8:	d002      	beq.n	800e3c0 <pwm_lld_start+0xe0>
 800e3ba:	483f      	ldr	r0, [pc, #252]	; (800e4b8 <pwm_lld_start+0x1d8>)
 800e3bc:	f000 fe10 	bl	800efe0 <chSysHalt>
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
 800e3c0:	9b01      	ldr	r3, [sp, #4]
 800e3c2:	699b      	ldr	r3, [r3, #24]
 800e3c4:	9a02      	ldr	r2, [sp, #8]
 800e3c6:	629a      	str	r2, [r3, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 800e3c8:	9b01      	ldr	r3, [sp, #4]
 800e3ca:	689a      	ldr	r2, [r3, #8]
 800e3cc:	9b01      	ldr	r3, [sp, #4]
 800e3ce:	699b      	ldr	r3, [r3, #24]
 800e3d0:	3a01      	subs	r2, #1
 800e3d2:	62da      	str	r2, [r3, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 800e3d4:	9b01      	ldr	r3, [sp, #4]
 800e3d6:	685a      	ldr	r2, [r3, #4]
 800e3d8:	9b01      	ldr	r3, [sp, #4]
 800e3da:	699b      	ldr	r3, [r3, #24]
 800e3dc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800e3de:	605a      	str	r2, [r3, #4]

  /* Output enables and polarities setup.*/
  ccer = 0;
 800e3e0:	2300      	movs	r3, #0
 800e3e2:	9303      	str	r3, [sp, #12]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 800e3e4:	9b01      	ldr	r3, [sp, #4]
 800e3e6:	685b      	ldr	r3, [r3, #4]
 800e3e8:	68db      	ldr	r3, [r3, #12]
 800e3ea:	f003 030f 	and.w	r3, r3, #15
 800e3ee:	2b01      	cmp	r3, #1
 800e3f0:	d005      	beq.n	800e3fe <pwm_lld_start+0x11e>
 800e3f2:	2b02      	cmp	r3, #2
 800e3f4:	d107      	bne.n	800e406 <pwm_lld_start+0x126>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC1P;
 800e3f6:	9b03      	ldr	r3, [sp, #12]
 800e3f8:	f043 0302 	orr.w	r3, r3, #2
 800e3fc:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC1E;
 800e3fe:	9b03      	ldr	r3, [sp, #12]
 800e400:	f043 0301 	orr.w	r3, r3, #1
 800e404:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 800e406:	9b01      	ldr	r3, [sp, #4]
 800e408:	685b      	ldr	r3, [r3, #4]
 800e40a:	695b      	ldr	r3, [r3, #20]
 800e40c:	f003 030f 	and.w	r3, r3, #15
 800e410:	2b01      	cmp	r3, #1
 800e412:	d005      	beq.n	800e420 <pwm_lld_start+0x140>
 800e414:	2b02      	cmp	r3, #2
 800e416:	d107      	bne.n	800e428 <pwm_lld_start+0x148>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC2P;
 800e418:	9b03      	ldr	r3, [sp, #12]
 800e41a:	f043 0320 	orr.w	r3, r3, #32
 800e41e:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
 800e420:	9b03      	ldr	r3, [sp, #12]
 800e422:	f043 0310 	orr.w	r3, r3, #16
 800e426:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 800e428:	9b01      	ldr	r3, [sp, #4]
 800e42a:	685b      	ldr	r3, [r3, #4]
 800e42c:	69db      	ldr	r3, [r3, #28]
 800e42e:	f003 030f 	and.w	r3, r3, #15
 800e432:	2b01      	cmp	r3, #1
 800e434:	d005      	beq.n	800e442 <pwm_lld_start+0x162>
 800e436:	2b02      	cmp	r3, #2
 800e438:	d107      	bne.n	800e44a <pwm_lld_start+0x16a>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC3P;
 800e43a:	9b03      	ldr	r3, [sp, #12]
 800e43c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800e440:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
 800e442:	9b03      	ldr	r3, [sp, #12]
 800e444:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800e448:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  default:
    ;
  }
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 800e44a:	9b01      	ldr	r3, [sp, #4]
 800e44c:	685b      	ldr	r3, [r3, #4]
 800e44e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e450:	f003 030f 	and.w	r3, r3, #15
 800e454:	2b01      	cmp	r3, #1
 800e456:	d005      	beq.n	800e464 <pwm_lld_start+0x184>
 800e458:	2b02      	cmp	r3, #2
 800e45a:	d107      	bne.n	800e46c <pwm_lld_start+0x18c>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC4P;
 800e45c:	9b03      	ldr	r3, [sp, #12]
 800e45e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800e462:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC4E;
 800e464:	9b03      	ldr	r3, [sp, #12]
 800e466:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800e46a:	9303      	str	r3, [sp, #12]
      ;
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
 800e46c:	9b01      	ldr	r3, [sp, #4]
 800e46e:	699b      	ldr	r3, [r3, #24]
 800e470:	9a03      	ldr	r2, [sp, #12]
 800e472:	621a      	str	r2, [r3, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 800e474:	9b01      	ldr	r3, [sp, #4]
 800e476:	699b      	ldr	r3, [r3, #24]
 800e478:	2201      	movs	r2, #1
 800e47a:	615a      	str	r2, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 800e47c:	9b01      	ldr	r3, [sp, #4]
 800e47e:	699b      	ldr	r3, [r3, #24]
 800e480:	2200      	movs	r2, #0
 800e482:	611a      	str	r2, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 800e484:	9b01      	ldr	r3, [sp, #4]
 800e486:	685b      	ldr	r3, [r3, #4]
 800e488:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800e48a:	9b01      	ldr	r3, [sp, #4]
 800e48c:	699b      	ldr	r3, [r3, #24]
 800e48e:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800e492:	60da      	str	r2, [r3, #12]
                     ~STM32_TIM_DIER_IRQ_MASK;
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
#if STM32_PWM_USE_ADVANCED
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 800e494:	9b01      	ldr	r3, [sp, #4]
 800e496:	699b      	ldr	r3, [r3, #24]
 800e498:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800e49c:	645a      	str	r2, [r3, #68]	; 0x44
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 800e49e:	9b01      	ldr	r3, [sp, #4]
 800e4a0:	699b      	ldr	r3, [r3, #24]
 800e4a2:	2285      	movs	r2, #133	; 0x85
 800e4a4:	601a      	str	r2, [r3, #0]
                     STM32_TIM_CR1_CEN;
}
 800e4a6:	b005      	add	sp, #20
 800e4a8:	f85d fb04 	ldr.w	pc, [sp], #4
 800e4ac:	20000f1c 	.word	0x20000f1c
 800e4b0:	40023800 	.word	0x40023800
 800e4b4:	0a037a00 	.word	0x0a037a00
 800e4b8:	080160bc 	.word	0x080160bc
 800e4bc:	00000000 	.word	0x00000000

0800e4c0 <pwm_lld_enable_channel>:
 *
 * @notapi
 */
void pwm_lld_enable_channel(PWMDriver *pwmp,
                            pwmchannel_t channel,
                            pwmcnt_t width) {
 800e4c0:	b084      	sub	sp, #16
 800e4c2:	9003      	str	r0, [sp, #12]
 800e4c4:	460b      	mov	r3, r1
 800e4c6:	9201      	str	r2, [sp, #4]
 800e4c8:	f88d 300b 	strb.w	r3, [sp, #11]

  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
 800e4cc:	9b03      	ldr	r3, [sp, #12]
 800e4ce:	699a      	ldr	r2, [r3, #24]
 800e4d0:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800e4d4:	330c      	adds	r3, #12
 800e4d6:	009b      	lsls	r3, r3, #2
 800e4d8:	4413      	add	r3, r2
 800e4da:	9a01      	ldr	r2, [sp, #4]
 800e4dc:	605a      	str	r2, [r3, #4]
  if (channel < 4)
    pwmp->tim->CCR[channel] = width;
  else
    pwmp->tim->CCXR[channel - 4] = width;
#endif
}
 800e4de:	b004      	add	sp, #16
 800e4e0:	4770      	bx	lr
 800e4e2:	bf00      	nop
	...

0800e4f0 <pwm_lld_serve_interrupt>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 800e4f0:	b500      	push	{lr}
 800e4f2:	b085      	sub	sp, #20
 800e4f4:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = pwmp->tim->SR;
 800e4f6:	9b01      	ldr	r3, [sp, #4]
 800e4f8:	699b      	ldr	r3, [r3, #24]
 800e4fa:	691b      	ldr	r3, [r3, #16]
 800e4fc:	9303      	str	r3, [sp, #12]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 800e4fe:	9b01      	ldr	r3, [sp, #4]
 800e500:	699b      	ldr	r3, [r3, #24]
 800e502:	68db      	ldr	r3, [r3, #12]
 800e504:	b2db      	uxtb	r3, r3
 800e506:	9a03      	ldr	r2, [sp, #12]
 800e508:	4013      	ands	r3, r2
 800e50a:	9303      	str	r3, [sp, #12]
  pwmp->tim->SR = ~sr;
 800e50c:	9b01      	ldr	r3, [sp, #4]
 800e50e:	699b      	ldr	r3, [r3, #24]
 800e510:	9a03      	ldr	r2, [sp, #12]
 800e512:	43d2      	mvns	r2, r2
 800e514:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800e516:	9b03      	ldr	r3, [sp, #12]
 800e518:	f003 0302 	and.w	r3, r3, #2
 800e51c:	2b00      	cmp	r3, #0
 800e51e:	d009      	beq.n	800e534 <pwm_lld_serve_interrupt+0x44>
      (pwmp->config->channels[0].callback != NULL))
 800e520:	9b01      	ldr	r3, [sp, #4]
 800e522:	685b      	ldr	r3, [r3, #4]
 800e524:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800e526:	2b00      	cmp	r3, #0
 800e528:	d004      	beq.n	800e534 <pwm_lld_serve_interrupt+0x44>
    pwmp->config->channels[0].callback(pwmp);
 800e52a:	9b01      	ldr	r3, [sp, #4]
 800e52c:	685b      	ldr	r3, [r3, #4]
 800e52e:	691b      	ldr	r3, [r3, #16]
 800e530:	9801      	ldr	r0, [sp, #4]
 800e532:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800e534:	9b03      	ldr	r3, [sp, #12]
 800e536:	f003 0304 	and.w	r3, r3, #4
 800e53a:	2b00      	cmp	r3, #0
 800e53c:	d009      	beq.n	800e552 <pwm_lld_serve_interrupt+0x62>
      (pwmp->config->channels[1].callback != NULL))
 800e53e:	9b01      	ldr	r3, [sp, #4]
 800e540:	685b      	ldr	r3, [r3, #4]
 800e542:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800e544:	2b00      	cmp	r3, #0
 800e546:	d004      	beq.n	800e552 <pwm_lld_serve_interrupt+0x62>
    pwmp->config->channels[1].callback(pwmp);
 800e548:	9b01      	ldr	r3, [sp, #4]
 800e54a:	685b      	ldr	r3, [r3, #4]
 800e54c:	699b      	ldr	r3, [r3, #24]
 800e54e:	9801      	ldr	r0, [sp, #4]
 800e550:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800e552:	9b03      	ldr	r3, [sp, #12]
 800e554:	f003 0308 	and.w	r3, r3, #8
 800e558:	2b00      	cmp	r3, #0
 800e55a:	d009      	beq.n	800e570 <pwm_lld_serve_interrupt+0x80>
      (pwmp->config->channels[2].callback != NULL))
 800e55c:	9b01      	ldr	r3, [sp, #4]
 800e55e:	685b      	ldr	r3, [r3, #4]
 800e560:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800e562:	2b00      	cmp	r3, #0
 800e564:	d004      	beq.n	800e570 <pwm_lld_serve_interrupt+0x80>
    pwmp->config->channels[2].callback(pwmp);
 800e566:	9b01      	ldr	r3, [sp, #4]
 800e568:	685b      	ldr	r3, [r3, #4]
 800e56a:	6a1b      	ldr	r3, [r3, #32]
 800e56c:	9801      	ldr	r0, [sp, #4]
 800e56e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800e570:	9b03      	ldr	r3, [sp, #12]
 800e572:	f003 0310 	and.w	r3, r3, #16
 800e576:	2b00      	cmp	r3, #0
 800e578:	d009      	beq.n	800e58e <pwm_lld_serve_interrupt+0x9e>
      (pwmp->config->channels[3].callback != NULL))
 800e57a:	9b01      	ldr	r3, [sp, #4]
 800e57c:	685b      	ldr	r3, [r3, #4]
 800e57e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800e580:	2b00      	cmp	r3, #0
 800e582:	d004      	beq.n	800e58e <pwm_lld_serve_interrupt+0x9e>
    pwmp->config->channels[3].callback(pwmp);
 800e584:	9b01      	ldr	r3, [sp, #4]
 800e586:	685b      	ldr	r3, [r3, #4]
 800e588:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e58a:	9801      	ldr	r0, [sp, #4]
 800e58c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 800e58e:	9b03      	ldr	r3, [sp, #12]
 800e590:	f003 0301 	and.w	r3, r3, #1
 800e594:	2b00      	cmp	r3, #0
 800e596:	d009      	beq.n	800e5ac <pwm_lld_serve_interrupt+0xbc>
 800e598:	9b01      	ldr	r3, [sp, #4]
 800e59a:	685b      	ldr	r3, [r3, #4]
 800e59c:	689b      	ldr	r3, [r3, #8]
 800e59e:	2b00      	cmp	r3, #0
 800e5a0:	d004      	beq.n	800e5ac <pwm_lld_serve_interrupt+0xbc>
    pwmp->config->callback(pwmp);
 800e5a2:	9b01      	ldr	r3, [sp, #4]
 800e5a4:	685b      	ldr	r3, [r3, #4]
 800e5a6:	689b      	ldr	r3, [r3, #8]
 800e5a8:	9801      	ldr	r0, [sp, #4]
 800e5aa:	4798      	blx	r3
}
 800e5ac:	b005      	add	sp, #20
 800e5ae:	f85d fb04 	ldr.w	pc, [sp], #4
 800e5b2:	bf00      	nop
	...

0800e5c0 <port_lock.lto_priv.392>:
static inline void port_lock(void) {
 800e5c0:	b082      	sub	sp, #8
 800e5c2:	2320      	movs	r3, #32
 800e5c4:	9301      	str	r3, [sp, #4]
 800e5c6:	9b01      	ldr	r3, [sp, #4]
 800e5c8:	f383 8811 	msr	BASEPRI, r3
}
 800e5cc:	b002      	add	sp, #8
 800e5ce:	4770      	bx	lr

0800e5d0 <port_unlock.lto_priv.361>:
static inline void port_unlock(void) {
 800e5d0:	b082      	sub	sp, #8
 800e5d2:	2300      	movs	r3, #0
 800e5d4:	9301      	str	r3, [sp, #4]
 800e5d6:	9b01      	ldr	r3, [sp, #4]
 800e5d8:	f383 8811 	msr	BASEPRI, r3
}
 800e5dc:	b002      	add	sp, #8
 800e5de:	4770      	bx	lr

0800e5e0 <port_lock_from_isr.lto_priv.439>:
static inline void port_lock_from_isr(void) {
 800e5e0:	b508      	push	{r3, lr}
  port_lock();
 800e5e2:	f7ff ffed 	bl	800e5c0 <port_lock.lto_priv.392>
}
 800e5e6:	bd08      	pop	{r3, pc}
	...

0800e5f0 <port_unlock_from_isr.lto_priv.428>:
static inline void port_unlock_from_isr(void) {
 800e5f0:	b508      	push	{r3, lr}
  port_unlock();
 800e5f2:	f7ff ffed 	bl	800e5d0 <port_unlock.lto_priv.361>
}
 800e5f6:	bd08      	pop	{r3, pc}
	...

0800e600 <chSysLockFromISR.lto_priv.532>:
static inline void chSysLockFromISR(void) {
 800e600:	b508      	push	{r3, lr}
  port_lock_from_isr();
 800e602:	f7ff ffed 	bl	800e5e0 <port_lock_from_isr.lto_priv.439>
  _dbg_check_lock_from_isr();
 800e606:	f000 fe8b 	bl	800f320 <_dbg_check_lock_from_isr>
}
 800e60a:	bd08      	pop	{r3, pc}
 800e60c:	0000      	movs	r0, r0
	...

0800e610 <chSysUnlockFromISR.lto_priv.524>:
static inline void chSysUnlockFromISR(void) {
 800e610:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 800e612:	f000 fe9d 	bl	800f350 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 800e616:	f7ff ffeb 	bl	800e5f0 <port_unlock_from_isr.lto_priv.428>
}
 800e61a:	bd08      	pop	{r3, pc}
 800e61c:	0000      	movs	r0, r0
	...

0800e620 <osalSysLockFromISR.lto_priv.560>:
static inline void osalSysLockFromISR(void) {
 800e620:	b508      	push	{r3, lr}
  chSysLockFromISR();
 800e622:	f7ff ffed 	bl	800e600 <chSysLockFromISR.lto_priv.532>
}
 800e626:	bd08      	pop	{r3, pc}
	...

0800e630 <osalSysUnlockFromISR.lto_priv.554>:
static inline void osalSysUnlockFromISR(void) {
 800e630:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 800e632:	f7ff ffed 	bl	800e610 <chSysUnlockFromISR.lto_priv.524>
}
 800e636:	bd08      	pop	{r3, pc}
	...

0800e640 <osalEventBroadcastFlagsI.lto_priv.548>:
                                            eventflags_t flags) {
 800e640:	b500      	push	{lr}
 800e642:	b083      	sub	sp, #12
 800e644:	9001      	str	r0, [sp, #4]
 800e646:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 800e648:	9900      	ldr	r1, [sp, #0]
 800e64a:	9801      	ldr	r0, [sp, #4]
 800e64c:	f003 fc48 	bl	8011ee0 <chEvtBroadcastFlagsI>
}
 800e650:	b003      	add	sp, #12
 800e652:	f85d fb04 	ldr.w	pc, [sp], #4
 800e656:	bf00      	nop
	...

0800e660 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 800e660:	b084      	sub	sp, #16
 800e662:	9001      	str	r0, [sp, #4]
 800e664:	9100      	str	r1, [sp, #0]
  uint32_t fck;
  USART_TypeDef *u = sdp->usart;
 800e666:	9b01      	ldr	r3, [sp, #4]
 800e668:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e66a:	9302      	str	r3, [sp, #8]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 800e66c:	9b01      	ldr	r3, [sp, #4]
 800e66e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e670:	4a2c      	ldr	r2, [pc, #176]	; (800e724 <usart_init+0xc4>)
 800e672:	4293      	cmp	r3, r2
 800e674:	d004      	beq.n	800e680 <usart_init+0x20>
 800e676:	9b01      	ldr	r3, [sp, #4]
 800e678:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e67a:	4a2b      	ldr	r2, [pc, #172]	; (800e728 <usart_init+0xc8>)
 800e67c:	4293      	cmp	r3, r2
 800e67e:	d106      	bne.n	800e68e <usart_init+0x2e>
#else
  if (sdp->usart == USART1)
#endif
    fck = STM32_PCLK2 / config->speed;
 800e680:	9b00      	ldr	r3, [sp, #0]
 800e682:	681b      	ldr	r3, [r3, #0]
 800e684:	4a29      	ldr	r2, [pc, #164]	; (800e72c <usart_init+0xcc>)
 800e686:	fbb2 f3f3 	udiv	r3, r2, r3
 800e68a:	9303      	str	r3, [sp, #12]
 800e68c:	e005      	b.n	800e69a <usart_init+0x3a>
  else
    fck = STM32_PCLK1 / config->speed;
 800e68e:	9b00      	ldr	r3, [sp, #0]
 800e690:	681b      	ldr	r3, [r3, #0]
 800e692:	4a27      	ldr	r2, [pc, #156]	; (800e730 <usart_init+0xd0>)
 800e694:	fbb2 f3f3 	udiv	r3, r2, r3
 800e698:	9303      	str	r3, [sp, #12]

  /* Correcting USARTDIV when oversampling by 8 instead of 16.
     Fraction is still 4 bits wide, but only lower 3 bits used.
     Mantissa is doubled, but Fraction is left the same.*/
#if defined(USART_CR1_OVER8)
  if (config->cr1 & USART_CR1_OVER8)
 800e69a:	9b00      	ldr	r3, [sp, #0]
 800e69c:	889b      	ldrh	r3, [r3, #4]
 800e69e:	b21b      	sxth	r3, r3
 800e6a0:	2b00      	cmp	r3, #0
 800e6a2:	da08      	bge.n	800e6b6 <usart_init+0x56>
    fck = ((fck & ~7) * 2) | (fck & 7);
 800e6a4:	9b03      	ldr	r3, [sp, #12]
 800e6a6:	f023 0307 	bic.w	r3, r3, #7
 800e6aa:	005a      	lsls	r2, r3, #1
 800e6ac:	9b03      	ldr	r3, [sp, #12]
 800e6ae:	f003 0307 	and.w	r3, r3, #7
 800e6b2:	4313      	orrs	r3, r2
 800e6b4:	9303      	str	r3, [sp, #12]
#endif
  u->BRR = fck;
 800e6b6:	9b02      	ldr	r3, [sp, #8]
 800e6b8:	9a03      	ldr	r2, [sp, #12]
 800e6ba:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800e6bc:	9b00      	ldr	r3, [sp, #0]
 800e6be:	88db      	ldrh	r3, [r3, #6]
 800e6c0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e6c4:	b29b      	uxth	r3, r3
 800e6c6:	461a      	mov	r2, r3
 800e6c8:	9b02      	ldr	r3, [sp, #8]
 800e6ca:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800e6cc:	9b00      	ldr	r3, [sp, #0]
 800e6ce:	891b      	ldrh	r3, [r3, #8]
 800e6d0:	f043 0301 	orr.w	r3, r3, #1
 800e6d4:	b29b      	uxth	r3, r3
 800e6d6:	461a      	mov	r2, r3
 800e6d8:	9b02      	ldr	r3, [sp, #8]
 800e6da:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800e6dc:	9b00      	ldr	r3, [sp, #0]
 800e6de:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800e6e0:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 800e6e4:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 800e6e8:	b29b      	uxth	r3, r3
 800e6ea:	461a      	mov	r2, r3
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800e6ec:	9b02      	ldr	r3, [sp, #8]
 800e6ee:	60da      	str	r2, [r3, #12]
                         USART_CR1_RE;
  u->SR = 0;
 800e6f0:	9b02      	ldr	r3, [sp, #8]
 800e6f2:	2200      	movs	r2, #0
 800e6f4:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 800e6f6:	9b02      	ldr	r3, [sp, #8]
 800e6f8:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 800e6fa:	9b02      	ldr	r3, [sp, #8]
 800e6fc:	685b      	ldr	r3, [r3, #4]

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 800e6fe:	9b00      	ldr	r3, [sp, #0]
 800e700:	889b      	ldrh	r3, [r3, #4]
 800e702:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 800e706:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800e70a:	d104      	bne.n	800e716 <usart_init+0xb6>
    sdp->rxmask = 0x7F;
 800e70c:	9b01      	ldr	r3, [sp, #4]
 800e70e:	227f      	movs	r2, #127	; 0x7f
 800e710:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
 800e714:	e003      	b.n	800e71e <usart_init+0xbe>
  }
  else {
    sdp->rxmask = 0xFF;
 800e716:	9b01      	ldr	r3, [sp, #4]
 800e718:	22ff      	movs	r2, #255	; 0xff
 800e71a:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
  }
}
 800e71e:	b004      	add	sp, #16
 800e720:	4770      	bx	lr
 800e722:	bf00      	nop
 800e724:	40011000 	.word	0x40011000
 800e728:	40011400 	.word	0x40011400
 800e72c:	0501bd00 	.word	0x0501bd00
 800e730:	0280de80 	.word	0x0280de80
	...

0800e740 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
 800e740:	b500      	push	{lr}
 800e742:	b085      	sub	sp, #20
 800e744:	9001      	str	r0, [sp, #4]
 800e746:	460b      	mov	r3, r1
 800e748:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
 800e74c:	2300      	movs	r3, #0
 800e74e:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
 800e750:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800e754:	f003 0308 	and.w	r3, r3, #8
 800e758:	2b00      	cmp	r3, #0
 800e75a:	d003      	beq.n	800e764 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
 800e75c:	9b03      	ldr	r3, [sp, #12]
 800e75e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800e762:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
 800e764:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800e768:	f003 0301 	and.w	r3, r3, #1
 800e76c:	2b00      	cmp	r3, #0
 800e76e:	d003      	beq.n	800e778 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
 800e770:	9b03      	ldr	r3, [sp, #12]
 800e772:	f043 0320 	orr.w	r3, r3, #32
 800e776:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
 800e778:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800e77c:	f003 0302 	and.w	r3, r3, #2
 800e780:	2b00      	cmp	r3, #0
 800e782:	d003      	beq.n	800e78c <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
 800e784:	9b03      	ldr	r3, [sp, #12]
 800e786:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e78a:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
 800e78c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800e790:	f003 0304 	and.w	r3, r3, #4
 800e794:	2b00      	cmp	r3, #0
 800e796:	d003      	beq.n	800e7a0 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
 800e798:	9b03      	ldr	r3, [sp, #12]
 800e79a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800e79e:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
 800e7a0:	9b01      	ldr	r3, [sp, #4]
 800e7a2:	3304      	adds	r3, #4
 800e7a4:	9903      	ldr	r1, [sp, #12]
 800e7a6:	4618      	mov	r0, r3
 800e7a8:	f7ff ff4a 	bl	800e640 <osalEventBroadcastFlagsI.lto_priv.548>
}
 800e7ac:	b005      	add	sp, #20
 800e7ae:	f85d fb04 	ldr.w	pc, [sp], #4
 800e7b2:	bf00      	nop
	...

0800e7c0 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 800e7c0:	b500      	push	{lr}
 800e7c2:	b089      	sub	sp, #36	; 0x24
 800e7c4:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 800e7c6:	9b01      	ldr	r3, [sp, #4]
 800e7c8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e7ca:	9306      	str	r3, [sp, #24]
  uint16_t cr1 = u->CR1;
 800e7cc:	9b06      	ldr	r3, [sp, #24]
 800e7ce:	68db      	ldr	r3, [r3, #12]
 800e7d0:	f8ad 3016 	strh.w	r3, [sp, #22]
  uint16_t sr = u->SR;
 800e7d4:	9b06      	ldr	r3, [sp, #24]
 800e7d6:	681b      	ldr	r3, [r3, #0]
 800e7d8:	f8ad 301e 	strh.w	r3, [sp, #30]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 800e7dc:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800e7e0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800e7e4:	2b00      	cmp	r3, #0
 800e7e6:	d00e      	beq.n	800e806 <serve_interrupt+0x46>
    osalSysLockFromISR();
 800e7e8:	f7ff ff1a 	bl	800e620 <osalSysLockFromISR.lto_priv.560>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 800e7ec:	9b01      	ldr	r3, [sp, #4]
 800e7ee:	3304      	adds	r3, #4
 800e7f0:	f44f 7100 	mov.w	r1, #512	; 0x200
 800e7f4:	4618      	mov	r0, r3
 800e7f6:	f7ff ff23 	bl	800e640 <osalEventBroadcastFlagsI.lto_priv.548>
    u->SR = ~USART_SR_LBD;
 800e7fa:	9b06      	ldr	r3, [sp, #24]
 800e7fc:	f46f 7280 	mvn.w	r2, #256	; 0x100
 800e800:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 800e802:	f7ff ff15 	bl	800e630 <osalSysUnlockFromISR.lto_priv.554>
  }

  /* Data available.*/
  osalSysLockFromISR();
 800e806:	f7ff ff0b 	bl	800e620 <osalSysLockFromISR.lto_priv.560>
 800e80a:	e024      	b.n	800e856 <serve_interrupt+0x96>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 800e80c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800e810:	f003 030f 	and.w	r3, r3, #15
 800e814:	2b00      	cmp	r3, #0
 800e816:	d005      	beq.n	800e824 <serve_interrupt+0x64>
      set_error(sdp, sr);
 800e818:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800e81c:	4619      	mov	r1, r3
 800e81e:	9801      	ldr	r0, [sp, #4]
 800e820:	f7ff ff8e 	bl	800e740 <set_error>
    b = (uint8_t)u->DR & sdp->rxmask;
 800e824:	9b06      	ldr	r3, [sp, #24]
 800e826:	685b      	ldr	r3, [r3, #4]
 800e828:	b2da      	uxtb	r2, r3
 800e82a:	9b01      	ldr	r3, [sp, #4]
 800e82c:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 800e830:	4013      	ands	r3, r2
 800e832:	f88d 300f 	strb.w	r3, [sp, #15]
    if (sr & USART_SR_RXNE)
 800e836:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800e83a:	f003 0320 	and.w	r3, r3, #32
 800e83e:	2b00      	cmp	r3, #0
 800e840:	d005      	beq.n	800e84e <serve_interrupt+0x8e>
      sdIncomingDataI(sdp, b);
 800e842:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800e846:	4619      	mov	r1, r3
 800e848:	9801      	ldr	r0, [sp, #4]
 800e84a:	f7fb fcb9 	bl	800a1c0 <sdIncomingDataI>
    sr = u->SR;
 800e84e:	9b06      	ldr	r3, [sp, #24]
 800e850:	681b      	ldr	r3, [r3, #0]
 800e852:	f8ad 301e 	strh.w	r3, [sp, #30]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800e856:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800e85a:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 800e85e:	2b00      	cmp	r3, #0
 800e860:	d1d4      	bne.n	800e80c <serve_interrupt+0x4c>
  }
  osalSysUnlockFromISR();
 800e862:	f7ff fee5 	bl	800e630 <osalSysUnlockFromISR.lto_priv.554>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800e866:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800e86a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e86e:	2b00      	cmp	r3, #0
 800e870:	d022      	beq.n	800e8b8 <serve_interrupt+0xf8>
 800e872:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800e876:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e87a:	2b00      	cmp	r3, #0
 800e87c:	d01c      	beq.n	800e8b8 <serve_interrupt+0xf8>
    msg_t b;
    osalSysLockFromISR();
 800e87e:	f7ff fecf 	bl	800e620 <osalSysLockFromISR.lto_priv.560>
    b = oqGetI(&sdp->oqueue);
 800e882:	9b01      	ldr	r3, [sp, #4]
 800e884:	3330      	adds	r3, #48	; 0x30
 800e886:	4618      	mov	r0, r3
 800e888:	f7fb f972 	bl	8009b70 <oqGetI>
 800e88c:	9004      	str	r0, [sp, #16]
    if (b < MSG_OK) {
 800e88e:	9b04      	ldr	r3, [sp, #16]
 800e890:	2b00      	cmp	r3, #0
 800e892:	da0c      	bge.n	800e8ae <serve_interrupt+0xee>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 800e894:	9b01      	ldr	r3, [sp, #4]
 800e896:	3304      	adds	r3, #4
 800e898:	2108      	movs	r1, #8
 800e89a:	4618      	mov	r0, r3
 800e89c:	f7ff fed0 	bl	800e640 <osalEventBroadcastFlagsI.lto_priv.548>
      u->CR1 = cr1 & ~USART_CR1_TXEIE;
 800e8a0:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800e8a4:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800e8a8:	9b06      	ldr	r3, [sp, #24]
 800e8aa:	60da      	str	r2, [r3, #12]
 800e8ac:	e002      	b.n	800e8b4 <serve_interrupt+0xf4>
    }
    else
      u->DR = b;
 800e8ae:	9a04      	ldr	r2, [sp, #16]
 800e8b0:	9b06      	ldr	r3, [sp, #24]
 800e8b2:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 800e8b4:	f7ff febc 	bl	800e630 <osalSysUnlockFromISR.lto_priv.554>
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 800e8b8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800e8bc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e8c0:	2b00      	cmp	r3, #0
 800e8c2:	d027      	beq.n	800e914 <serve_interrupt+0x154>
 800e8c4:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800e8c8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e8cc:	2b00      	cmp	r3, #0
 800e8ce:	d021      	beq.n	800e914 <serve_interrupt+0x154>
    osalSysLockFromISR();
 800e8d0:	f7ff fea6 	bl	800e620 <osalSysLockFromISR.lto_priv.560>
    if (oqIsEmptyI(&sdp->oqueue)) {
 800e8d4:	9b01      	ldr	r3, [sp, #4]
 800e8d6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800e8d8:	9b01      	ldr	r3, [sp, #4]
 800e8da:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e8dc:	429a      	cmp	r2, r3
 800e8de:	d105      	bne.n	800e8ec <serve_interrupt+0x12c>
 800e8e0:	9b01      	ldr	r3, [sp, #4]
 800e8e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e8e4:	2b00      	cmp	r3, #0
 800e8e6:	d001      	beq.n	800e8ec <serve_interrupt+0x12c>
 800e8e8:	2301      	movs	r3, #1
 800e8ea:	e000      	b.n	800e8ee <serve_interrupt+0x12e>
 800e8ec:	2300      	movs	r3, #0
 800e8ee:	f003 0301 	and.w	r3, r3, #1
 800e8f2:	b2db      	uxtb	r3, r3
 800e8f4:	2b00      	cmp	r3, #0
 800e8f6:	d00b      	beq.n	800e910 <serve_interrupt+0x150>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 800e8f8:	9b01      	ldr	r3, [sp, #4]
 800e8fa:	3304      	adds	r3, #4
 800e8fc:	2110      	movs	r1, #16
 800e8fe:	4618      	mov	r0, r3
 800e900:	f7ff fe9e 	bl	800e640 <osalEventBroadcastFlagsI.lto_priv.548>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 800e904:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800e908:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 800e90c:	9b06      	ldr	r3, [sp, #24]
 800e90e:	60da      	str	r2, [r3, #12]
    }
    osalSysUnlockFromISR();
 800e910:	f7ff fe8e 	bl	800e630 <osalSysUnlockFromISR.lto_priv.554>
  }
}
 800e914:	b009      	add	sp, #36	; 0x24
 800e916:	f85d fb04 	ldr.w	pc, [sp], #4
 800e91a:	bf00      	nop
 800e91c:	0000      	movs	r0, r0
	...

0800e920 <notify2>:
  USART1->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
}
#endif

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {
 800e920:	b082      	sub	sp, #8
 800e922:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 800e924:	4b03      	ldr	r3, [pc, #12]	; (800e934 <notify2+0x14>)
 800e926:	68db      	ldr	r3, [r3, #12]
 800e928:	4a02      	ldr	r2, [pc, #8]	; (800e934 <notify2+0x14>)
 800e92a:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800e92e:	60d3      	str	r3, [r2, #12]
}
 800e930:	b002      	add	sp, #8
 800e932:	4770      	bx	lr
 800e934:	40004400 	.word	0x40004400
	...

0800e940 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 800e940:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 800e942:	4808      	ldr	r0, [pc, #32]	; (800e964 <VectorD8+0x24>)
 800e944:	f000 fe4c 	bl	800f5e0 <_trace_isr_enter>
 800e948:	f000 fd1a 	bl	800f380 <_dbg_check_enter_isr>

  serve_interrupt(&SD2);
 800e94c:	4806      	ldr	r0, [pc, #24]	; (800e968 <VectorD8+0x28>)
 800e94e:	f7ff ff37 	bl	800e7c0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800e952:	f000 fd35 	bl	800f3c0 <_dbg_check_leave_isr>
 800e956:	4803      	ldr	r0, [pc, #12]	; (800e964 <VectorD8+0x24>)
 800e958:	f000 fe6a 	bl	800f630 <_trace_isr_leave>
 800e95c:	f005 fcf8 	bl	8014350 <_port_irq_epilogue>
}
 800e960:	bd08      	pop	{r3, pc}
 800e962:	bf00      	nop
 800e964:	080160d8 	.word	0x080160d8
 800e968:	20000f38 	.word	0x20000f38
 800e96c:	00000000 	.word	0x00000000

0800e970 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 800e970:	b508      	push	{r3, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 800e972:	4a04      	ldr	r2, [pc, #16]	; (800e984 <sd_lld_init+0x14>)
 800e974:	2100      	movs	r1, #0
 800e976:	4804      	ldr	r0, [pc, #16]	; (800e988 <sd_lld_init+0x18>)
 800e978:	f7fb fbca 	bl	800a110 <sdObjectInit>
  SD2.usart = USART2;
 800e97c:	4b02      	ldr	r3, [pc, #8]	; (800e988 <sd_lld_init+0x18>)
 800e97e:	4a03      	ldr	r2, [pc, #12]	; (800e98c <sd_lld_init+0x1c>)
 800e980:	675a      	str	r2, [r3, #116]	; 0x74

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
 800e982:	bd08      	pop	{r3, pc}
 800e984:	0800e921 	.word	0x0800e921
 800e988:	20000f38 	.word	0x20000f38
 800e98c:	40004400 	.word	0x40004400

0800e990 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 800e990:	b500      	push	{lr}
 800e992:	b083      	sub	sp, #12
 800e994:	9001      	str	r0, [sp, #4]
 800e996:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 800e998:	9b00      	ldr	r3, [sp, #0]
 800e99a:	2b00      	cmp	r3, #0
 800e99c:	d101      	bne.n	800e9a2 <sd_lld_start+0x12>
    config = &default_config;
 800e99e:	4b11      	ldr	r3, [pc, #68]	; (800e9e4 <sd_lld_start+0x54>)
 800e9a0:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 800e9a2:	9b01      	ldr	r3, [sp, #4]
 800e9a4:	7a1b      	ldrb	r3, [r3, #8]
 800e9a6:	2b01      	cmp	r3, #1
 800e9a8:	d115      	bne.n	800e9d6 <sd_lld_start+0x46>
      rccEnableUSART1(true);
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 800e9aa:	9b01      	ldr	r3, [sp, #4]
 800e9ac:	4a0e      	ldr	r2, [pc, #56]	; (800e9e8 <sd_lld_start+0x58>)
 800e9ae:	4293      	cmp	r3, r2
 800e9b0:	d111      	bne.n	800e9d6 <sd_lld_start+0x46>
      rccEnableUSART2(true);
 800e9b2:	4b0e      	ldr	r3, [pc, #56]	; (800e9ec <sd_lld_start+0x5c>)
 800e9b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e9b6:	4a0d      	ldr	r2, [pc, #52]	; (800e9ec <sd_lld_start+0x5c>)
 800e9b8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800e9bc:	6413      	str	r3, [r2, #64]	; 0x40
 800e9be:	4b0b      	ldr	r3, [pc, #44]	; (800e9ec <sd_lld_start+0x5c>)
 800e9c0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800e9c2:	4a0a      	ldr	r2, [pc, #40]	; (800e9ec <sd_lld_start+0x5c>)
 800e9c4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800e9c8:	6613      	str	r3, [r2, #96]	; 0x60
 800e9ca:	4b08      	ldr	r3, [pc, #32]	; (800e9ec <sd_lld_start+0x5c>)
 800e9cc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 800e9ce:	210c      	movs	r1, #12
 800e9d0:	2026      	movs	r0, #38	; 0x26
 800e9d2:	f7fd f895 	bl	800bb00 <nvicEnableVector>
      rccEnableUART8(true);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
 800e9d6:	9900      	ldr	r1, [sp, #0]
 800e9d8:	9801      	ldr	r0, [sp, #4]
 800e9da:	f7ff fe41 	bl	800e660 <usart_init>
}
 800e9de:	b003      	add	sp, #12
 800e9e0:	f85d fb04 	ldr.w	pc, [sp], #4
 800e9e4:	080160cc 	.word	0x080160cc
 800e9e8:	20000f38 	.word	0x20000f38
 800e9ec:	40023800 	.word	0x40023800

0800e9f0 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 800e9f0:	b082      	sub	sp, #8
 800e9f2:	9001      	str	r0, [sp, #4]
 800e9f4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 800e9f6:	9b00      	ldr	r3, [sp, #0]
 800e9f8:	685a      	ldr	r2, [r3, #4]
 800e9fa:	9b01      	ldr	r3, [sp, #4]
 800e9fc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800e9fe:	9b00      	ldr	r3, [sp, #0]
 800ea00:	689a      	ldr	r2, [r3, #8]
 800ea02:	9b01      	ldr	r3, [sp, #4]
 800ea04:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 800ea06:	9b00      	ldr	r3, [sp, #0]
 800ea08:	68da      	ldr	r2, [r3, #12]
 800ea0a:	9b01      	ldr	r3, [sp, #4]
 800ea0c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800ea0e:	9b00      	ldr	r3, [sp, #0]
 800ea10:	691a      	ldr	r2, [r3, #16]
 800ea12:	9b01      	ldr	r3, [sp, #4]
 800ea14:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 800ea16:	9b00      	ldr	r3, [sp, #0]
 800ea18:	695a      	ldr	r2, [r3, #20]
 800ea1a:	9b01      	ldr	r3, [sp, #4]
 800ea1c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800ea1e:	9b00      	ldr	r3, [sp, #0]
 800ea20:	699a      	ldr	r2, [r3, #24]
 800ea22:	9b01      	ldr	r3, [sp, #4]
 800ea24:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800ea26:	9b00      	ldr	r3, [sp, #0]
 800ea28:	681a      	ldr	r2, [r3, #0]
 800ea2a:	9b01      	ldr	r3, [sp, #4]
 800ea2c:	601a      	str	r2, [r3, #0]
}
 800ea2e:	b002      	add	sp, #8
 800ea30:	4770      	bx	lr
 800ea32:	bf00      	nop
	...

0800ea40 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 800ea40:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 800ea42:	4b24      	ldr	r3, [pc, #144]	; (800ead4 <stm32_gpio_init+0x94>)
 800ea44:	691b      	ldr	r3, [r3, #16]
 800ea46:	4a23      	ldr	r2, [pc, #140]	; (800ead4 <stm32_gpio_init+0x94>)
 800ea48:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 800ea4c:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 800ea50:	6113      	str	r3, [r2, #16]
 800ea52:	4b20      	ldr	r3, [pc, #128]	; (800ead4 <stm32_gpio_init+0x94>)
 800ea54:	691b      	ldr	r3, [r3, #16]
 800ea56:	4a1f      	ldr	r2, [pc, #124]	; (800ead4 <stm32_gpio_init+0x94>)
 800ea58:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 800ea5c:	f023 0301 	bic.w	r3, r3, #1
 800ea60:	6113      	str	r3, [r2, #16]
 800ea62:	4b1c      	ldr	r3, [pc, #112]	; (800ead4 <stm32_gpio_init+0x94>)
 800ea64:	691b      	ldr	r3, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 800ea66:	4b1b      	ldr	r3, [pc, #108]	; (800ead4 <stm32_gpio_init+0x94>)
 800ea68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ea6a:	4a1a      	ldr	r2, [pc, #104]	; (800ead4 <stm32_gpio_init+0x94>)
 800ea6c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 800ea70:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 800ea74:	6313      	str	r3, [r2, #48]	; 0x30
 800ea76:	4b17      	ldr	r3, [pc, #92]	; (800ead4 <stm32_gpio_init+0x94>)
 800ea78:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800ea7a:	4a16      	ldr	r2, [pc, #88]	; (800ead4 <stm32_gpio_init+0x94>)
 800ea7c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 800ea80:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 800ea84:	6513      	str	r3, [r2, #80]	; 0x50
 800ea86:	4b13      	ldr	r3, [pc, #76]	; (800ead4 <stm32_gpio_init+0x94>)
 800ea88:	6d1b      	ldr	r3, [r3, #80]	; 0x50

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 800ea8a:	4913      	ldr	r1, [pc, #76]	; (800ead8 <stm32_gpio_init+0x98>)
 800ea8c:	4813      	ldr	r0, [pc, #76]	; (800eadc <stm32_gpio_init+0x9c>)
 800ea8e:	f7ff ffaf 	bl	800e9f0 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 800ea92:	4913      	ldr	r1, [pc, #76]	; (800eae0 <stm32_gpio_init+0xa0>)
 800ea94:	4813      	ldr	r0, [pc, #76]	; (800eae4 <stm32_gpio_init+0xa4>)
 800ea96:	f7ff ffab 	bl	800e9f0 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 800ea9a:	4913      	ldr	r1, [pc, #76]	; (800eae8 <stm32_gpio_init+0xa8>)
 800ea9c:	4813      	ldr	r0, [pc, #76]	; (800eaec <stm32_gpio_init+0xac>)
 800ea9e:	f7ff ffa7 	bl	800e9f0 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 800eaa2:	4913      	ldr	r1, [pc, #76]	; (800eaf0 <stm32_gpio_init+0xb0>)
 800eaa4:	4813      	ldr	r0, [pc, #76]	; (800eaf4 <stm32_gpio_init+0xb4>)
 800eaa6:	f7ff ffa3 	bl	800e9f0 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 800eaaa:	4913      	ldr	r1, [pc, #76]	; (800eaf8 <stm32_gpio_init+0xb8>)
 800eaac:	4813      	ldr	r0, [pc, #76]	; (800eafc <stm32_gpio_init+0xbc>)
 800eaae:	f7ff ff9f 	bl	800e9f0 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 800eab2:	4913      	ldr	r1, [pc, #76]	; (800eb00 <stm32_gpio_init+0xc0>)
 800eab4:	4813      	ldr	r0, [pc, #76]	; (800eb04 <stm32_gpio_init+0xc4>)
 800eab6:	f7ff ff9b 	bl	800e9f0 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 800eaba:	4913      	ldr	r1, [pc, #76]	; (800eb08 <stm32_gpio_init+0xc8>)
 800eabc:	4813      	ldr	r0, [pc, #76]	; (800eb0c <stm32_gpio_init+0xcc>)
 800eabe:	f7ff ff97 	bl	800e9f0 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 800eac2:	4913      	ldr	r1, [pc, #76]	; (800eb10 <stm32_gpio_init+0xd0>)
 800eac4:	4813      	ldr	r0, [pc, #76]	; (800eb14 <stm32_gpio_init+0xd4>)
 800eac6:	f7ff ff93 	bl	800e9f0 <gpio_init>
#endif
#if STM32_HAS_GPIOI
  gpio_init(GPIOI, &gpio_default_config.PIData);
 800eaca:	4913      	ldr	r1, [pc, #76]	; (800eb18 <stm32_gpio_init+0xd8>)
 800eacc:	4813      	ldr	r0, [pc, #76]	; (800eb1c <stm32_gpio_init+0xdc>)
 800eace:	f7ff ff8f 	bl	800e9f0 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 800ead2:	bd08      	pop	{r3, pc}
 800ead4:	40023800 	.word	0x40023800
 800ead8:	080160e4 	.word	0x080160e4
 800eadc:	40020000 	.word	0x40020000
 800eae0:	08016100 	.word	0x08016100
 800eae4:	40020400 	.word	0x40020400
 800eae8:	0801611c 	.word	0x0801611c
 800eaec:	40020800 	.word	0x40020800
 800eaf0:	08016138 	.word	0x08016138
 800eaf4:	40020c00 	.word	0x40020c00
 800eaf8:	08016154 	.word	0x08016154
 800eafc:	40021000 	.word	0x40021000
 800eb00:	08016170 	.word	0x08016170
 800eb04:	40021400 	.word	0x40021400
 800eb08:	0801618c 	.word	0x0801618c
 800eb0c:	40021800 	.word	0x40021800
 800eb10:	080161a8 	.word	0x080161a8
 800eb14:	40021c00 	.word	0x40021c00
 800eb18:	080161c4 	.word	0x080161c4
 800eb1c:	40022000 	.word	0x40022000

0800eb20 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 800eb20:	b508      	push	{r3, lr}

  stm32_gpio_init();
 800eb22:	f7ff ff8d 	bl	800ea40 <stm32_gpio_init>
  stm32_clock_init();
 800eb26:	f7fd f8ab 	bl	800bc80 <stm32_clock_init>
}
 800eb2a:	bd08      	pop	{r3, pc}
 800eb2c:	0000      	movs	r0, r0
	...

0800eb30 <boardInit>:
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {

}
 800eb30:	4770      	bx	lr
 800eb32:	bf00      	nop
	...

0800eb40 <chTimeAddX.lto_priv.539>:
                                   sysinterval_t interval) {
 800eb40:	b082      	sub	sp, #8
 800eb42:	9001      	str	r0, [sp, #4]
 800eb44:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
 800eb46:	9a01      	ldr	r2, [sp, #4]
 800eb48:	9b00      	ldr	r3, [sp, #0]
 800eb4a:	4413      	add	r3, r2
}
 800eb4c:	4618      	mov	r0, r3
 800eb4e:	b002      	add	sp, #8
 800eb50:	4770      	bx	lr
 800eb52:	bf00      	nop
	...

0800eb60 <chTimeDiffX.lto_priv.514>:
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 800eb60:	b082      	sub	sp, #8
 800eb62:	9001      	str	r0, [sp, #4]
 800eb64:	9100      	str	r1, [sp, #0]
  return (sysinterval_t)((systime_t)(end - start));
 800eb66:	9a00      	ldr	r2, [sp, #0]
 800eb68:	9b01      	ldr	r3, [sp, #4]
 800eb6a:	1ad3      	subs	r3, r2, r3
}
 800eb6c:	4618      	mov	r0, r3
 800eb6e:	b002      	add	sp, #8
 800eb70:	4770      	bx	lr
 800eb72:	bf00      	nop
	...

0800eb80 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800eb80:	b084      	sub	sp, #16
 800eb82:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800eb84:	9b01      	ldr	r3, [sp, #4]
 800eb86:	f003 0307 	and.w	r3, r3, #7
 800eb8a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800eb8c:	4b0a      	ldr	r3, [pc, #40]	; (800ebb8 <__NVIC_SetPriorityGrouping+0x38>)
 800eb8e:	68db      	ldr	r3, [r3, #12]
 800eb90:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800eb92:	9a02      	ldr	r2, [sp, #8]
 800eb94:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800eb98:	4013      	ands	r3, r2
 800eb9a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800eb9c:	9b03      	ldr	r3, [sp, #12]
 800eb9e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800eba0:	9b02      	ldr	r3, [sp, #8]
 800eba2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800eba4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800eba8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800ebac:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 800ebae:	4a02      	ldr	r2, [pc, #8]	; (800ebb8 <__NVIC_SetPriorityGrouping+0x38>)
 800ebb0:	9b02      	ldr	r3, [sp, #8]
 800ebb2:	60d3      	str	r3, [r2, #12]
}
 800ebb4:	b004      	add	sp, #16
 800ebb6:	4770      	bx	lr
 800ebb8:	e000ed00 	.word	0xe000ed00
 800ebbc:	00000000 	.word	0x00000000

0800ebc0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800ebc0:	b082      	sub	sp, #8
 800ebc2:	4603      	mov	r3, r0
 800ebc4:	9100      	str	r1, [sp, #0]
 800ebc6:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
 800ebca:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800ebce:	2b00      	cmp	r3, #0
 800ebd0:	db0a      	blt.n	800ebe8 <__NVIC_SetPriority+0x28>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800ebd2:	9b00      	ldr	r3, [sp, #0]
 800ebd4:	b2da      	uxtb	r2, r3
 800ebd6:	490b      	ldr	r1, [pc, #44]	; (800ec04 <__NVIC_SetPriority+0x44>)
 800ebd8:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800ebdc:	0112      	lsls	r2, r2, #4
 800ebde:	b2d2      	uxtb	r2, r2
 800ebe0:	440b      	add	r3, r1
 800ebe2:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
 800ebe6:	e00b      	b.n	800ec00 <__NVIC_SetPriority+0x40>
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800ebe8:	9b00      	ldr	r3, [sp, #0]
 800ebea:	b2da      	uxtb	r2, r3
 800ebec:	4906      	ldr	r1, [pc, #24]	; (800ec08 <__NVIC_SetPriority+0x48>)
 800ebee:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ebf2:	f003 030f 	and.w	r3, r3, #15
 800ebf6:	3b04      	subs	r3, #4
 800ebf8:	0112      	lsls	r2, r2, #4
 800ebfa:	b2d2      	uxtb	r2, r2
 800ebfc:	440b      	add	r3, r1
 800ebfe:	761a      	strb	r2, [r3, #24]
  }
}
 800ec00:	b002      	add	sp, #8
 800ec02:	4770      	bx	lr
 800ec04:	e000e100 	.word	0xe000e100
 800ec08:	e000ed00 	.word	0xe000ed00
 800ec0c:	00000000 	.word	0x00000000

0800ec10 <port_init>:
static inline void port_init(void) {
 800ec10:	b508      	push	{r3, lr}
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 800ec12:	2003      	movs	r0, #3
 800ec14:	f7ff ffb4 	bl	800eb80 <__NVIC_SetPriorityGrouping>
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800ec18:	4b0b      	ldr	r3, [pc, #44]	; (800ec48 <port_init+0x38>)
 800ec1a:	68db      	ldr	r3, [r3, #12]
 800ec1c:	4a0a      	ldr	r2, [pc, #40]	; (800ec48 <port_init+0x38>)
 800ec1e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800ec22:	60d3      	str	r3, [r2, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800ec24:	4b09      	ldr	r3, [pc, #36]	; (800ec4c <port_init+0x3c>)
 800ec26:	681b      	ldr	r3, [r3, #0]
 800ec28:	4a08      	ldr	r2, [pc, #32]	; (800ec4c <port_init+0x3c>)
 800ec2a:	f043 0301 	orr.w	r3, r3, #1
 800ec2e:	6013      	str	r3, [r2, #0]
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 800ec30:	2101      	movs	r1, #1
 800ec32:	f06f 0004 	mvn.w	r0, #4
 800ec36:	f7ff ffc3 	bl	800ebc0 <__NVIC_SetPriority>
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 800ec3a:	2102      	movs	r1, #2
 800ec3c:	f06f 0001 	mvn.w	r0, #1
 800ec40:	f7ff ffbe 	bl	800ebc0 <__NVIC_SetPriority>
}
 800ec44:	bd08      	pop	{r3, pc}
 800ec46:	bf00      	nop
 800ec48:	e000edf0 	.word	0xe000edf0
 800ec4c:	e0001000 	.word	0xe0001000

0800ec50 <port_get_irq_status>:
static inline syssts_t port_get_irq_status(void) {
 800ec50:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ec52:	f3ef 8311 	mrs	r3, BASEPRI
 800ec56:	9300      	str	r3, [sp, #0]
  return(result);
 800ec58:	9b00      	ldr	r3, [sp, #0]
  sts = (syssts_t)__get_BASEPRI();
 800ec5a:	9301      	str	r3, [sp, #4]
  return sts;
 800ec5c:	9b01      	ldr	r3, [sp, #4]
}
 800ec5e:	4618      	mov	r0, r3
 800ec60:	b002      	add	sp, #8
 800ec62:	4770      	bx	lr
	...

0800ec70 <port_irq_enabled>:
static inline bool port_irq_enabled(syssts_t sts) {
 800ec70:	b082      	sub	sp, #8
 800ec72:	9001      	str	r0, [sp, #4]
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 800ec74:	9b01      	ldr	r3, [sp, #4]
 800ec76:	2b00      	cmp	r3, #0
 800ec78:	bf0c      	ite	eq
 800ec7a:	2301      	moveq	r3, #1
 800ec7c:	2300      	movne	r3, #0
 800ec7e:	b2db      	uxtb	r3, r3
}
 800ec80:	4618      	mov	r0, r3
 800ec82:	b002      	add	sp, #8
 800ec84:	4770      	bx	lr
 800ec86:	bf00      	nop
	...

0800ec90 <port_is_isr_context>:
static inline bool port_is_isr_context(void) {
 800ec90:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ec92:	f3ef 8305 	mrs	r3, IPSR
 800ec96:	9301      	str	r3, [sp, #4]
  return(result);
 800ec98:	9b01      	ldr	r3, [sp, #4]
  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 800ec9a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800ec9e:	2b00      	cmp	r3, #0
 800eca0:	bf14      	ite	ne
 800eca2:	2301      	movne	r3, #1
 800eca4:	2300      	moveq	r3, #0
 800eca6:	b2db      	uxtb	r3, r3
}
 800eca8:	4618      	mov	r0, r3
 800ecaa:	b002      	add	sp, #8
 800ecac:	4770      	bx	lr
 800ecae:	bf00      	nop

0800ecb0 <port_lock.lto_priv.393>:
static inline void port_lock(void) {
 800ecb0:	b082      	sub	sp, #8
 800ecb2:	2320      	movs	r3, #32
 800ecb4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ecb6:	9b01      	ldr	r3, [sp, #4]
 800ecb8:	f383 8811 	msr	BASEPRI, r3
}
 800ecbc:	b002      	add	sp, #8
 800ecbe:	4770      	bx	lr

0800ecc0 <port_unlock.lto_priv.362>:
static inline void port_unlock(void) {
 800ecc0:	b082      	sub	sp, #8
 800ecc2:	2300      	movs	r3, #0
 800ecc4:	9301      	str	r3, [sp, #4]
 800ecc6:	9b01      	ldr	r3, [sp, #4]
 800ecc8:	f383 8811 	msr	BASEPRI, r3
}
 800eccc:	b002      	add	sp, #8
 800ecce:	4770      	bx	lr

0800ecd0 <port_lock_from_isr.lto_priv.440>:
static inline void port_lock_from_isr(void) {
 800ecd0:	b508      	push	{r3, lr}
  port_lock();
 800ecd2:	f7ff ffed 	bl	800ecb0 <port_lock.lto_priv.393>
}
 800ecd6:	bd08      	pop	{r3, pc}
	...

0800ece0 <port_unlock_from_isr.lto_priv.429>:
static inline void port_unlock_from_isr(void) {
 800ece0:	b508      	push	{r3, lr}
  port_unlock();
 800ece2:	f7ff ffed 	bl	800ecc0 <port_unlock.lto_priv.362>
}
 800ece6:	bd08      	pop	{r3, pc}
	...

0800ecf0 <port_disable>:
  __ASM volatile ("cpsid i" : : : "memory");
 800ecf0:	b672      	cpsid	i
}
 800ecf2:	4770      	bx	lr
	...

0800ed00 <port_enable>:
static inline void port_enable(void) {
 800ed00:	b082      	sub	sp, #8
 800ed02:	2300      	movs	r3, #0
 800ed04:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ed06:	9b01      	ldr	r3, [sp, #4]
 800ed08:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 800ed0c:	b662      	cpsie	i
}
 800ed0e:	b002      	add	sp, #8
 800ed10:	4770      	bx	lr
 800ed12:	bf00      	nop
	...

0800ed20 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 800ed20:	4770      	bx	lr
 800ed22:	bf00      	nop
	...

0800ed30 <port_rt_get_counter_value.lto_priv.498>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 800ed30:	4b01      	ldr	r3, [pc, #4]	; (800ed38 <port_rt_get_counter_value.lto_priv.498+0x8>)
 800ed32:	685b      	ldr	r3, [r3, #4]
}
 800ed34:	4618      	mov	r0, r3
 800ed36:	4770      	bx	lr
 800ed38:	e0001000 	.word	0xe0001000
 800ed3c:	00000000 	.word	0x00000000

0800ed40 <st_lld_get_counter.lto_priv.344>:
  return (systime_t)STM32_ST_TIM->CNT;
 800ed40:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800ed44:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800ed46:	4618      	mov	r0, r3
 800ed48:	4770      	bx	lr
 800ed4a:	bf00      	nop
 800ed4c:	0000      	movs	r0, r0
	...

0800ed50 <port_timer_stop_alarm.lto_priv.537>:
static inline void port_timer_stop_alarm(void) {
 800ed50:	b508      	push	{r3, lr}
  stStopAlarm();
 800ed52:	f7f9 ff1d 	bl	8008b90 <stStopAlarm>
}
 800ed56:	bd08      	pop	{r3, pc}
	...

0800ed60 <port_timer_set_alarm.lto_priv.535>:
static inline void port_timer_set_alarm(systime_t time) {
 800ed60:	b500      	push	{lr}
 800ed62:	b083      	sub	sp, #12
 800ed64:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 800ed66:	9801      	ldr	r0, [sp, #4]
 800ed68:	f7f9 ff1a 	bl	8008ba0 <stSetAlarm>
}
 800ed6c:	b003      	add	sp, #12
 800ed6e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ed72:	bf00      	nop
	...

0800ed80 <port_timer_get_time.lto_priv.338>:
static inline systime_t port_timer_get_time(void) {
 800ed80:	b508      	push	{r3, lr}
  return stGetCounter();
 800ed82:	f7ff ffdd 	bl	800ed40 <st_lld_get_counter.lto_priv.344>
 800ed86:	4603      	mov	r3, r0
}
 800ed88:	4618      	mov	r0, r3
 800ed8a:	bd08      	pop	{r3, pc}
 800ed8c:	0000      	movs	r0, r0
	...

0800ed90 <chSysEnable>:
static inline void chSysEnable(void) {
 800ed90:	b508      	push	{r3, lr}
  _dbg_check_enable();
 800ed92:	f000 fa7d 	bl	800f290 <_dbg_check_enable>
  port_enable();
 800ed96:	f7ff ffb3 	bl	800ed00 <port_enable>
}
 800ed9a:	bd08      	pop	{r3, pc}
 800ed9c:	0000      	movs	r0, r0
	...

0800eda0 <chSysLock.lto_priv.321>:
static inline void chSysLock(void) {
 800eda0:	b508      	push	{r3, lr}
  port_lock();
 800eda2:	f7ff ff85 	bl	800ecb0 <port_lock.lto_priv.393>
  _dbg_check_lock();
 800eda6:	f000 fa8b 	bl	800f2c0 <_dbg_check_lock>
}
 800edaa:	bd08      	pop	{r3, pc}
 800edac:	0000      	movs	r0, r0
	...

0800edb0 <chSysUnlock.lto_priv.297>:
static inline void chSysUnlock(void) {
 800edb0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 800edb2:	f000 fa9d 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800edb6:	4b09      	ldr	r3, [pc, #36]	; (800eddc <chSysUnlock.lto_priv.297+0x2c>)
 800edb8:	681b      	ldr	r3, [r3, #0]
 800edba:	4a08      	ldr	r2, [pc, #32]	; (800eddc <chSysUnlock.lto_priv.297+0x2c>)
 800edbc:	4293      	cmp	r3, r2
 800edbe:	d00a      	beq.n	800edd6 <chSysUnlock.lto_priv.297+0x26>
 800edc0:	4b06      	ldr	r3, [pc, #24]	; (800eddc <chSysUnlock.lto_priv.297+0x2c>)
 800edc2:	699b      	ldr	r3, [r3, #24]
 800edc4:	689a      	ldr	r2, [r3, #8]
 800edc6:	4b05      	ldr	r3, [pc, #20]	; (800eddc <chSysUnlock.lto_priv.297+0x2c>)
 800edc8:	681b      	ldr	r3, [r3, #0]
 800edca:	689b      	ldr	r3, [r3, #8]
 800edcc:	429a      	cmp	r2, r3
 800edce:	d202      	bcs.n	800edd6 <chSysUnlock.lto_priv.297+0x26>
 800edd0:	4803      	ldr	r0, [pc, #12]	; (800ede0 <chSysUnlock.lto_priv.297+0x30>)
 800edd2:	f000 f905 	bl	800efe0 <chSysHalt>
  port_unlock();
 800edd6:	f7ff ff73 	bl	800ecc0 <port_unlock.lto_priv.362>
}
 800edda:	bd08      	pop	{r3, pc}
 800eddc:	20001090 	.word	0x20001090
 800ede0:	08016bdc 	.word	0x08016bdc
	...

0800edf0 <chSysLockFromISR.lto_priv.533>:
static inline void chSysLockFromISR(void) {
 800edf0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 800edf2:	f7ff ff6d 	bl	800ecd0 <port_lock_from_isr.lto_priv.440>
  _dbg_check_lock_from_isr();
 800edf6:	f000 fa93 	bl	800f320 <_dbg_check_lock_from_isr>
}
 800edfa:	bd08      	pop	{r3, pc}
 800edfc:	0000      	movs	r0, r0
	...

0800ee00 <chSysUnlockFromISR.lto_priv.525>:
static inline void chSysUnlockFromISR(void) {
 800ee00:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 800ee02:	f000 faa5 	bl	800f350 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 800ee06:	f7ff ff6b 	bl	800ece0 <port_unlock_from_isr.lto_priv.429>
}
 800ee0a:	bd08      	pop	{r3, pc}
 800ee0c:	0000      	movs	r0, r0
	...

0800ee10 <chVTGetSystemTimeX.lto_priv.283>:
static inline systime_t chVTGetSystemTimeX(void) {
 800ee10:	b508      	push	{r3, lr}
  return port_timer_get_time();
 800ee12:	f7ff ffb5 	bl	800ed80 <port_timer_get_time.lto_priv.338>
 800ee16:	4603      	mov	r3, r0
}
 800ee18:	4618      	mov	r0, r3
 800ee1a:	bd08      	pop	{r3, pc}
 800ee1c:	0000      	movs	r0, r0
	...

0800ee20 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 800ee20:	b530      	push	{r4, r5, lr}
 800ee22:	b087      	sub	sp, #28

  chDbgCheckClassI();
 800ee24:	f000 faec 	bl	800f400 <chDbgCheckClassI>
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 800ee28:	4b47      	ldr	r3, [pc, #284]	; (800ef48 <chVTDoTickI+0x128>)
 800ee2a:	69db      	ldr	r3, [r3, #28]
 800ee2c:	9305      	str	r3, [sp, #20]
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
 800ee2e:	f7ff ffef 	bl	800ee10 <chVTGetSystemTimeX.lto_priv.283>
 800ee32:	9002      	str	r0, [sp, #8]
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 800ee34:	4b44      	ldr	r3, [pc, #272]	; (800ef48 <chVTDoTickI+0x128>)
 800ee36:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ee38:	9902      	ldr	r1, [sp, #8]
 800ee3a:	4618      	mov	r0, r3
 800ee3c:	f7ff fe90 	bl	800eb60 <chTimeDiffX.lto_priv.514>
 800ee40:	9003      	str	r0, [sp, #12]

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 800ee42:	9b05      	ldr	r3, [sp, #20]
 800ee44:	689b      	ldr	r3, [r3, #8]
 800ee46:	9a03      	ldr	r2, [sp, #12]
 800ee48:	429a      	cmp	r2, r3
 800ee4a:	d332      	bcc.n	800eeb2 <chVTDoTickI+0x92>
    /* Consuming all timers between "vtp->lasttime" and now.*/
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
 800ee4c:	4b3e      	ldr	r3, [pc, #248]	; (800ef48 <chVTDoTickI+0x128>)
 800ee4e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800ee50:	9b05      	ldr	r3, [sp, #20]
 800ee52:	689b      	ldr	r3, [r3, #8]
 800ee54:	4413      	add	r3, r2
 800ee56:	4a3c      	ldr	r2, [pc, #240]	; (800ef48 <chVTDoTickI+0x128>)
 800ee58:	6293      	str	r3, [r2, #40]	; 0x28
      nowdelta -= vtp->delta;
 800ee5a:	9b05      	ldr	r3, [sp, #20]
 800ee5c:	689b      	ldr	r3, [r3, #8]
 800ee5e:	9a03      	ldr	r2, [sp, #12]
 800ee60:	1ad3      	subs	r3, r2, r3
 800ee62:	9303      	str	r3, [sp, #12]

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800ee64:	9b05      	ldr	r3, [sp, #20]
 800ee66:	681b      	ldr	r3, [r3, #0]
 800ee68:	4a38      	ldr	r2, [pc, #224]	; (800ef4c <chVTDoTickI+0x12c>)
 800ee6a:	605a      	str	r2, [r3, #4]
      ch.vtlist.next = vtp->next;
 800ee6c:	9b05      	ldr	r3, [sp, #20]
 800ee6e:	681b      	ldr	r3, [r3, #0]
 800ee70:	4a35      	ldr	r2, [pc, #212]	; (800ef48 <chVTDoTickI+0x128>)
 800ee72:	61d3      	str	r3, [r2, #28]
      fn = vtp->func;
 800ee74:	9b05      	ldr	r3, [sp, #20]
 800ee76:	68db      	ldr	r3, [r3, #12]
 800ee78:	9301      	str	r3, [sp, #4]
      vtp->func = NULL;
 800ee7a:	9b05      	ldr	r3, [sp, #20]
 800ee7c:	2200      	movs	r2, #0
 800ee7e:	60da      	str	r2, [r3, #12]

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800ee80:	4b31      	ldr	r3, [pc, #196]	; (800ef48 <chVTDoTickI+0x128>)
 800ee82:	69db      	ldr	r3, [r3, #28]
 800ee84:	4a31      	ldr	r2, [pc, #196]	; (800ef4c <chVTDoTickI+0x12c>)
 800ee86:	4293      	cmp	r3, r2
 800ee88:	d101      	bne.n	800ee8e <chVTDoTickI+0x6e>
        port_timer_stop_alarm();
 800ee8a:	f7ff ff61 	bl	800ed50 <port_timer_stop_alarm.lto_priv.537>
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
 800ee8e:	f7ff ffb7 	bl	800ee00 <chSysUnlockFromISR.lto_priv.525>
      fn(vtp->par);
 800ee92:	9b05      	ldr	r3, [sp, #20]
 800ee94:	691a      	ldr	r2, [r3, #16]
 800ee96:	9b01      	ldr	r3, [sp, #4]
 800ee98:	4610      	mov	r0, r2
 800ee9a:	4798      	blx	r3
      chSysLockFromISR();
 800ee9c:	f7ff ffa8 	bl	800edf0 <chSysLockFromISR.lto_priv.533>

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 800eea0:	4b29      	ldr	r3, [pc, #164]	; (800ef48 <chVTDoTickI+0x128>)
 800eea2:	69db      	ldr	r3, [r3, #28]
 800eea4:	9305      	str	r3, [sp, #20]
    }
    while (vtp->delta <= nowdelta);
 800eea6:	9b05      	ldr	r3, [sp, #20]
 800eea8:	689b      	ldr	r3, [r3, #8]
 800eeaa:	9a03      	ldr	r2, [sp, #12]
 800eeac:	429a      	cmp	r2, r3
 800eeae:	d2cd      	bcs.n	800ee4c <chVTDoTickI+0x2c>
 800eeb0:	e7bd      	b.n	800ee2e <chVTDoTickI+0xe>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800eeb2:	4b25      	ldr	r3, [pc, #148]	; (800ef48 <chVTDoTickI+0x128>)
 800eeb4:	69db      	ldr	r3, [r3, #28]
 800eeb6:	4a25      	ldr	r2, [pc, #148]	; (800ef4c <chVTDoTickI+0x12c>)
 800eeb8:	4293      	cmp	r3, r2
 800eeba:	d043      	beq.n	800ef44 <chVTDoTickI+0x124>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 800eebc:	4b22      	ldr	r3, [pc, #136]	; (800ef48 <chVTDoTickI+0x128>)
 800eebe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800eec0:	9b03      	ldr	r3, [sp, #12]
 800eec2:	4413      	add	r3, r2
 800eec4:	4a20      	ldr	r2, [pc, #128]	; (800ef48 <chVTDoTickI+0x128>)
 800eec6:	6293      	str	r3, [r2, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 800eec8:	4b1f      	ldr	r3, [pc, #124]	; (800ef48 <chVTDoTickI+0x128>)
 800eeca:	69db      	ldr	r3, [r3, #28]
 800eecc:	6899      	ldr	r1, [r3, #8]
 800eece:	4b1e      	ldr	r3, [pc, #120]	; (800ef48 <chVTDoTickI+0x128>)
 800eed0:	69db      	ldr	r3, [r3, #28]
 800eed2:	9a03      	ldr	r2, [sp, #12]
 800eed4:	1a8a      	subs	r2, r1, r2
 800eed6:	609a      	str	r2, [r3, #8]

  /* Recalculating the next alarm time.*/
  delta = chTimeDiffX(now, chTimeAddX(ch.vtlist.lasttime, vtp->delta));
 800eed8:	4b1b      	ldr	r3, [pc, #108]	; (800ef48 <chVTDoTickI+0x128>)
 800eeda:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800eedc:	9b05      	ldr	r3, [sp, #20]
 800eede:	689b      	ldr	r3, [r3, #8]
 800eee0:	4619      	mov	r1, r3
 800eee2:	4610      	mov	r0, r2
 800eee4:	f7ff fe2c 	bl	800eb40 <chTimeAddX.lto_priv.539>
 800eee8:	4603      	mov	r3, r0
 800eeea:	4619      	mov	r1, r3
 800eeec:	9802      	ldr	r0, [sp, #8]
 800eeee:	f7ff fe37 	bl	800eb60 <chTimeDiffX.lto_priv.514>
 800eef2:	9004      	str	r0, [sp, #16]
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 800eef4:	9b04      	ldr	r3, [sp, #16]
 800eef6:	2b01      	cmp	r3, #1
 800eef8:	d801      	bhi.n	800eefe <chVTDoTickI+0xde>
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800eefa:	2302      	movs	r3, #2
 800eefc:	9304      	str	r3, [sp, #16]
  /* The delta could be too large for the physical timer to handle.*/
  else if (delta > (sysinterval_t)TIME_MAX_SYSTIME) {
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));
 800eefe:	9904      	ldr	r1, [sp, #16]
 800ef00:	9802      	ldr	r0, [sp, #8]
 800ef02:	f7ff fe1d 	bl	800eb40 <chTimeAddX.lto_priv.539>
 800ef06:	4603      	mov	r3, r0
 800ef08:	4618      	mov	r0, r3
 800ef0a:	f7ff ff29 	bl	800ed60 <port_timer_set_alarm.lto_priv.535>

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 800ef0e:	4b0e      	ldr	r3, [pc, #56]	; (800ef48 <chVTDoTickI+0x128>)
 800ef10:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 800ef12:	f7ff ff7d 	bl	800ee10 <chVTGetSystemTimeX.lto_priv.283>
 800ef16:	4603      	mov	r3, r0
 800ef18:	4619      	mov	r1, r3
 800ef1a:	4620      	mov	r0, r4
 800ef1c:	f7ff fe20 	bl	800eb60 <chTimeDiffX.lto_priv.514>
 800ef20:	4604      	mov	r4, r0
 800ef22:	4b09      	ldr	r3, [pc, #36]	; (800ef48 <chVTDoTickI+0x128>)
 800ef24:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 800ef26:	9904      	ldr	r1, [sp, #16]
 800ef28:	9802      	ldr	r0, [sp, #8]
 800ef2a:	f7ff fe09 	bl	800eb40 <chTimeAddX.lto_priv.539>
 800ef2e:	4603      	mov	r3, r0
 800ef30:	4619      	mov	r1, r3
 800ef32:	4628      	mov	r0, r5
 800ef34:	f7ff fe14 	bl	800eb60 <chTimeDiffX.lto_priv.514>
 800ef38:	4603      	mov	r3, r0
 800ef3a:	429c      	cmp	r4, r3
 800ef3c:	d902      	bls.n	800ef44 <chVTDoTickI+0x124>
 800ef3e:	4804      	ldr	r0, [pc, #16]	; (800ef50 <chVTDoTickI+0x130>)
 800ef40:	f000 f84e 	bl	800efe0 <chSysHalt>
              chTimeDiffX(ch.vtlist.lasttime, chTimeAddX(now, delta)),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800ef44:	b007      	add	sp, #28
 800ef46:	bd30      	pop	{r4, r5, pc}
 800ef48:	20001090 	.word	0x20001090
 800ef4c:	200010ac 	.word	0x200010ac
 800ef50:	08016bd0 	.word	0x08016bd0
	...

0800ef60 <_idle_thread.lto_priv.199>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 800ef60:	b500      	push	{lr}
 800ef62:	b083      	sub	sp, #12
 800ef64:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 800ef66:	f7ff fedb 	bl	800ed20 <port_wait_for_interrupt>
 800ef6a:	e7fc      	b.n	800ef66 <_idle_thread.lto_priv.199+0x6>
 800ef6c:	0000      	movs	r0, r0
	...

0800ef70 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 800ef70:	b508      	push	{r3, lr}

  _scheduler_init();
 800ef72:	f000 fdfd 	bl	800fb70 <_scheduler_init>
  _vt_init();
 800ef76:	f000 fc0b 	bl	800f790 <_vt_init>
  _trace_init();
 800ef7a:	f000 fad9 	bl	800f530 <_trace_init>

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 800ef7e:	4b13      	ldr	r3, [pc, #76]	; (800efcc <chSysInit+0x5c>)
 800ef80:	2200      	movs	r2, #0
 800ef82:	631a      	str	r2, [r3, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 800ef84:	4b11      	ldr	r3, [pc, #68]	; (800efcc <chSysInit+0x5c>)
 800ef86:	2200      	movs	r2, #0
 800ef88:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 800ef8a:	f001 fd89 	bl	8010aa0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 800ef8e:	f003 fee7 	bl	8012d60 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 800ef92:	f003 ff65 	bl	8012e60 <_heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  _factory_init();
 800ef96:	f004 ff4b 	bl	8013e30 <_factory_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 800ef9a:	2280      	movs	r2, #128	; 0x80
 800ef9c:	490c      	ldr	r1, [pc, #48]	; (800efd0 <chSysInit+0x60>)
 800ef9e:	480d      	ldr	r0, [pc, #52]	; (800efd4 <chSysInit+0x64>)
 800efa0:	f001 f9b6 	bl	8010310 <_thread_init>
 800efa4:	4602      	mov	r2, r0
 800efa6:	4b09      	ldr	r3, [pc, #36]	; (800efcc <chSysInit+0x5c>)
 800efa8:	619a      	str	r2, [r3, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 800efaa:	4b08      	ldr	r3, [pc, #32]	; (800efcc <chSysInit+0x5c>)
 800efac:	699b      	ldr	r3, [r3, #24]
 800efae:	4a0a      	ldr	r2, [pc, #40]	; (800efd8 <chSysInit+0x68>)
 800efb0:	61da      	str	r2, [r3, #28]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 800efb2:	4b06      	ldr	r3, [pc, #24]	; (800efcc <chSysInit+0x5c>)
 800efb4:	699b      	ldr	r3, [r3, #24]
 800efb6:	2201      	movs	r2, #1
 800efb8:	f883 2020 	strb.w	r2, [r3, #32]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
 800efbc:	f7ff fe28 	bl	800ec10 <port_init>

  /* Initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* It is alive now.*/
  chSysEnable();
 800efc0:	f7ff fee6 	bl	800ed90 <chSysEnable>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 800efc4:	4805      	ldr	r0, [pc, #20]	; (800efdc <chSysInit+0x6c>)
 800efc6:	f001 fa5b 	bl	8010480 <chThdCreate>
  }
#endif
}
 800efca:	bd08      	pop	{r3, pc}
 800efcc:	20001090 	.word	0x20001090
 800efd0:	08016d0c 	.word	0x08016d0c
 800efd4:	200018d0 	.word	0x200018d0
 800efd8:	20000400 	.word	0x20000400
 800efdc:	08016bb8 	.word	0x08016bb8

0800efe0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 800efe0:	b500      	push	{lr}
 800efe2:	b083      	sub	sp, #12
 800efe4:	9001      	str	r0, [sp, #4]

  port_disable();
 800efe6:	f7ff fe83 	bl	800ecf0 <port_disable>

  /* Logging the event.*/
  _trace_halt(reason);
 800efea:	9801      	ldr	r0, [sp, #4]
 800efec:	f000 fb48 	bl	800f680 <_trace_halt>

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800eff0:	4a01      	ldr	r2, [pc, #4]	; (800eff8 <chSysHalt+0x18>)
 800eff2:	9b01      	ldr	r3, [sp, #4]
 800eff4:	62d3      	str	r3, [r2, #44]	; 0x2c
 800eff6:	e7fe      	b.n	800eff6 <chSysHalt+0x16>
 800eff8:	20001090 	.word	0x20001090
 800effc:	00000000 	.word	0x00000000

0800f000 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 800f000:	b500      	push	{lr}
 800f002:	b087      	sub	sp, #28
 800f004:	9001      	str	r0, [sp, #4]
  cnt_t n;

  chDbgCheckClassI();
 800f006:	f000 f9fb 	bl	800f400 <chDbgCheckClassI>

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 800f00a:	9b01      	ldr	r3, [sp, #4]
 800f00c:	f003 0301 	and.w	r3, r3, #1
 800f010:	2b00      	cmp	r3, #0
 800f012:	d022      	beq.n	800f05a <chSysIntegrityCheckI+0x5a>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800f014:	2300      	movs	r3, #0
 800f016:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.queue.next;
 800f018:	4b3a      	ldr	r3, [pc, #232]	; (800f104 <chSysIntegrityCheckI+0x104>)
 800f01a:	681b      	ldr	r3, [r3, #0]
 800f01c:	9304      	str	r3, [sp, #16]
 800f01e:	e005      	b.n	800f02c <chSysIntegrityCheckI+0x2c>
    while (tp != (thread_t *)&ch.rlist.queue) {
      n++;
 800f020:	9b05      	ldr	r3, [sp, #20]
 800f022:	3301      	adds	r3, #1
 800f024:	9305      	str	r3, [sp, #20]
      tp = tp->queue.next;
 800f026:	9b04      	ldr	r3, [sp, #16]
 800f028:	681b      	ldr	r3, [r3, #0]
 800f02a:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.queue) {
 800f02c:	9b04      	ldr	r3, [sp, #16]
 800f02e:	4a35      	ldr	r2, [pc, #212]	; (800f104 <chSysIntegrityCheckI+0x104>)
 800f030:	4293      	cmp	r3, r2
 800f032:	d1f5      	bne.n	800f020 <chSysIntegrityCheckI+0x20>
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
 800f034:	4b33      	ldr	r3, [pc, #204]	; (800f104 <chSysIntegrityCheckI+0x104>)
 800f036:	685b      	ldr	r3, [r3, #4]
 800f038:	9304      	str	r3, [sp, #16]
 800f03a:	e005      	b.n	800f048 <chSysIntegrityCheckI+0x48>
    while (tp != (thread_t *)&ch.rlist.queue) {
      n--;
 800f03c:	9b05      	ldr	r3, [sp, #20]
 800f03e:	3b01      	subs	r3, #1
 800f040:	9305      	str	r3, [sp, #20]
      tp = tp->queue.prev;
 800f042:	9b04      	ldr	r3, [sp, #16]
 800f044:	685b      	ldr	r3, [r3, #4]
 800f046:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.queue) {
 800f048:	9b04      	ldr	r3, [sp, #16]
 800f04a:	4a2e      	ldr	r2, [pc, #184]	; (800f104 <chSysIntegrityCheckI+0x104>)
 800f04c:	4293      	cmp	r3, r2
 800f04e:	d1f5      	bne.n	800f03c <chSysIntegrityCheckI+0x3c>
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800f050:	9b05      	ldr	r3, [sp, #20]
 800f052:	2b00      	cmp	r3, #0
 800f054:	d001      	beq.n	800f05a <chSysIntegrityCheckI+0x5a>
      return true;
 800f056:	2301      	movs	r3, #1
 800f058:	e050      	b.n	800f0fc <chSysIntegrityCheckI+0xfc>
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 800f05a:	9b01      	ldr	r3, [sp, #4]
 800f05c:	f003 0302 	and.w	r3, r3, #2
 800f060:	2b00      	cmp	r3, #0
 800f062:	d022      	beq.n	800f0aa <chSysIntegrityCheckI+0xaa>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 800f064:	2300      	movs	r3, #0
 800f066:	9305      	str	r3, [sp, #20]
    vtp = ch.vtlist.next;
 800f068:	4b26      	ldr	r3, [pc, #152]	; (800f104 <chSysIntegrityCheckI+0x104>)
 800f06a:	69db      	ldr	r3, [r3, #28]
 800f06c:	9303      	str	r3, [sp, #12]
 800f06e:	e005      	b.n	800f07c <chSysIntegrityCheckI+0x7c>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n++;
 800f070:	9b05      	ldr	r3, [sp, #20]
 800f072:	3301      	adds	r3, #1
 800f074:	9305      	str	r3, [sp, #20]
      vtp = vtp->next;
 800f076:	9b03      	ldr	r3, [sp, #12]
 800f078:	681b      	ldr	r3, [r3, #0]
 800f07a:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800f07c:	9b03      	ldr	r3, [sp, #12]
 800f07e:	4a22      	ldr	r2, [pc, #136]	; (800f108 <chSysIntegrityCheckI+0x108>)
 800f080:	4293      	cmp	r3, r2
 800f082:	d1f5      	bne.n	800f070 <chSysIntegrityCheckI+0x70>
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
 800f084:	4b1f      	ldr	r3, [pc, #124]	; (800f104 <chSysIntegrityCheckI+0x104>)
 800f086:	6a1b      	ldr	r3, [r3, #32]
 800f088:	9303      	str	r3, [sp, #12]
 800f08a:	e005      	b.n	800f098 <chSysIntegrityCheckI+0x98>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n--;
 800f08c:	9b05      	ldr	r3, [sp, #20]
 800f08e:	3b01      	subs	r3, #1
 800f090:	9305      	str	r3, [sp, #20]
      vtp = vtp->prev;
 800f092:	9b03      	ldr	r3, [sp, #12]
 800f094:	685b      	ldr	r3, [r3, #4]
 800f096:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800f098:	9b03      	ldr	r3, [sp, #12]
 800f09a:	4a1b      	ldr	r2, [pc, #108]	; (800f108 <chSysIntegrityCheckI+0x108>)
 800f09c:	4293      	cmp	r3, r2
 800f09e:	d1f5      	bne.n	800f08c <chSysIntegrityCheckI+0x8c>
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800f0a0:	9b05      	ldr	r3, [sp, #20]
 800f0a2:	2b00      	cmp	r3, #0
 800f0a4:	d001      	beq.n	800f0aa <chSysIntegrityCheckI+0xaa>
      return true;
 800f0a6:	2301      	movs	r3, #1
 800f0a8:	e028      	b.n	800f0fc <chSysIntegrityCheckI+0xfc>
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800f0aa:	9b01      	ldr	r3, [sp, #4]
 800f0ac:	f003 0304 	and.w	r3, r3, #4
 800f0b0:	2b00      	cmp	r3, #0
 800f0b2:	d022      	beq.n	800f0fa <chSysIntegrityCheckI+0xfa>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800f0b4:	2300      	movs	r3, #0
 800f0b6:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.newer;
 800f0b8:	4b12      	ldr	r3, [pc, #72]	; (800f104 <chSysIntegrityCheckI+0x104>)
 800f0ba:	691b      	ldr	r3, [r3, #16]
 800f0bc:	9302      	str	r3, [sp, #8]
 800f0be:	e005      	b.n	800f0cc <chSysIntegrityCheckI+0xcc>
    while (tp != (thread_t *)&ch.rlist) {
      n++;
 800f0c0:	9b05      	ldr	r3, [sp, #20]
 800f0c2:	3301      	adds	r3, #1
 800f0c4:	9305      	str	r3, [sp, #20]
      tp = tp->newer;
 800f0c6:	9b02      	ldr	r3, [sp, #8]
 800f0c8:	691b      	ldr	r3, [r3, #16]
 800f0ca:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 800f0cc:	9b02      	ldr	r3, [sp, #8]
 800f0ce:	4a0d      	ldr	r2, [pc, #52]	; (800f104 <chSysIntegrityCheckI+0x104>)
 800f0d0:	4293      	cmp	r3, r2
 800f0d2:	d1f5      	bne.n	800f0c0 <chSysIntegrityCheckI+0xc0>
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
 800f0d4:	4b0b      	ldr	r3, [pc, #44]	; (800f104 <chSysIntegrityCheckI+0x104>)
 800f0d6:	695b      	ldr	r3, [r3, #20]
 800f0d8:	9302      	str	r3, [sp, #8]
 800f0da:	e005      	b.n	800f0e8 <chSysIntegrityCheckI+0xe8>
    while (tp != (thread_t *)&ch.rlist) {
      n--;
 800f0dc:	9b05      	ldr	r3, [sp, #20]
 800f0de:	3b01      	subs	r3, #1
 800f0e0:	9305      	str	r3, [sp, #20]
      tp = tp->older;
 800f0e2:	9b02      	ldr	r3, [sp, #8]
 800f0e4:	695b      	ldr	r3, [r3, #20]
 800f0e6:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 800f0e8:	9b02      	ldr	r3, [sp, #8]
 800f0ea:	4a06      	ldr	r2, [pc, #24]	; (800f104 <chSysIntegrityCheckI+0x104>)
 800f0ec:	4293      	cmp	r3, r2
 800f0ee:	d1f5      	bne.n	800f0dc <chSysIntegrityCheckI+0xdc>
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800f0f0:	9b05      	ldr	r3, [sp, #20]
 800f0f2:	2b00      	cmp	r3, #0
 800f0f4:	d001      	beq.n	800f0fa <chSysIntegrityCheckI+0xfa>
      return true;
 800f0f6:	2301      	movs	r3, #1
 800f0f8:	e000      	b.n	800f0fc <chSysIntegrityCheckI+0xfc>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 800f0fa:	2300      	movs	r3, #0
}
 800f0fc:	4618      	mov	r0, r3
 800f0fe:	b007      	add	sp, #28
 800f100:	f85d fb04 	ldr.w	pc, [sp], #4
 800f104:	20001090 	.word	0x20001090
 800f108:	200010ac 	.word	0x200010ac
 800f10c:	00000000 	.word	0x00000000

0800f110 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 800f110:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 800f112:	f000 f975 	bl	800f400 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
 800f116:	f7ff fe83 	bl	800ee20 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800f11a:	bd08      	pop	{r3, pc}
 800f11c:	0000      	movs	r0, r0
	...

0800f120 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 800f120:	b500      	push	{lr}
 800f122:	b083      	sub	sp, #12

  syssts_t sts = port_get_irq_status();
 800f124:	f7ff fd94 	bl	800ec50 <port_get_irq_status>
 800f128:	9001      	str	r0, [sp, #4]
  if (port_irq_enabled(sts)) {
 800f12a:	9801      	ldr	r0, [sp, #4]
 800f12c:	f7ff fda0 	bl	800ec70 <port_irq_enabled>
 800f130:	4603      	mov	r3, r0
 800f132:	2b00      	cmp	r3, #0
 800f134:	d009      	beq.n	800f14a <chSysGetStatusAndLockX+0x2a>
    if (port_is_isr_context()) {
 800f136:	f7ff fdab 	bl	800ec90 <port_is_isr_context>
 800f13a:	4603      	mov	r3, r0
 800f13c:	2b00      	cmp	r3, #0
 800f13e:	d002      	beq.n	800f146 <chSysGetStatusAndLockX+0x26>
      chSysLockFromISR();
 800f140:	f7ff fe56 	bl	800edf0 <chSysLockFromISR.lto_priv.533>
 800f144:	e001      	b.n	800f14a <chSysGetStatusAndLockX+0x2a>
    }
    else {
      chSysLock();
 800f146:	f7ff fe2b 	bl	800eda0 <chSysLock.lto_priv.321>
    }
  }
  return sts;
 800f14a:	9b01      	ldr	r3, [sp, #4]
}
 800f14c:	4618      	mov	r0, r3
 800f14e:	b003      	add	sp, #12
 800f150:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800f160 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 800f160:	b500      	push	{lr}
 800f162:	b083      	sub	sp, #12
 800f164:	9001      	str	r0, [sp, #4]

  if (port_irq_enabled(sts)) {
 800f166:	9801      	ldr	r0, [sp, #4]
 800f168:	f7ff fd82 	bl	800ec70 <port_irq_enabled>
 800f16c:	4603      	mov	r3, r0
 800f16e:	2b00      	cmp	r3, #0
 800f170:	d00b      	beq.n	800f18a <chSysRestoreStatusX+0x2a>
    if (port_is_isr_context()) {
 800f172:	f7ff fd8d 	bl	800ec90 <port_is_isr_context>
 800f176:	4603      	mov	r3, r0
 800f178:	2b00      	cmp	r3, #0
 800f17a:	d002      	beq.n	800f182 <chSysRestoreStatusX+0x22>
      chSysUnlockFromISR();
 800f17c:	f7ff fe40 	bl	800ee00 <chSysUnlockFromISR.lto_priv.525>
 800f180:	e003      	b.n	800f18a <chSysRestoreStatusX+0x2a>
    }
    else {
      chSchRescheduleS();
 800f182:	f000 fe95 	bl	800feb0 <chSchRescheduleS>
      chSysUnlock();
 800f186:	f7ff fe13 	bl	800edb0 <chSysUnlock.lto_priv.297>
    }
  }
}
 800f18a:	b003      	add	sp, #12
 800f18c:	f85d fb04 	ldr.w	pc, [sp], #4

0800f190 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 800f190:	b084      	sub	sp, #16
 800f192:	9003      	str	r0, [sp, #12]
 800f194:	9102      	str	r1, [sp, #8]
 800f196:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 800f198:	9a03      	ldr	r2, [sp, #12]
 800f19a:	9b02      	ldr	r3, [sp, #8]
 800f19c:	1ad2      	subs	r2, r2, r3
 800f19e:	9901      	ldr	r1, [sp, #4]
 800f1a0:	9b02      	ldr	r3, [sp, #8]
 800f1a2:	1acb      	subs	r3, r1, r3
 800f1a4:	429a      	cmp	r2, r3
 800f1a6:	bf34      	ite	cc
 800f1a8:	2301      	movcc	r3, #1
 800f1aa:	2300      	movcs	r3, #0
 800f1ac:	b2db      	uxtb	r3, r3
}
 800f1ae:	4618      	mov	r0, r3
 800f1b0:	b004      	add	sp, #16
 800f1b2:	4770      	bx	lr
	...

0800f1c0 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 800f1c0:	b500      	push	{lr}
 800f1c2:	b085      	sub	sp, #20
 800f1c4:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 800f1c6:	f7ff fdb3 	bl	800ed30 <port_rt_get_counter_value.lto_priv.498>
 800f1ca:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800f1cc:	9a03      	ldr	r2, [sp, #12]
 800f1ce:	9b01      	ldr	r3, [sp, #4]
 800f1d0:	4413      	add	r3, r2
 800f1d2:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 800f1d4:	f7ff fdac 	bl	800ed30 <port_rt_get_counter_value.lto_priv.498>
 800f1d8:	4603      	mov	r3, r0
 800f1da:	9a02      	ldr	r2, [sp, #8]
 800f1dc:	9903      	ldr	r1, [sp, #12]
 800f1de:	4618      	mov	r0, r3
 800f1e0:	f7ff ffd6 	bl	800f190 <chSysIsCounterWithinX>
 800f1e4:	4603      	mov	r3, r0
 800f1e6:	2b00      	cmp	r3, #0
 800f1e8:	d1f4      	bne.n	800f1d4 <chSysPolledDelayX+0x14>
  }
}
 800f1ea:	b005      	add	sp, #20
 800f1ec:	f85d fb04 	ldr.w	pc, [sp], #4

0800f1f0 <port_lock.lto_priv.394>:
static inline void port_lock(void) {
 800f1f0:	b082      	sub	sp, #8
 800f1f2:	2320      	movs	r3, #32
 800f1f4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f1f6:	9b01      	ldr	r3, [sp, #4]
 800f1f8:	f383 8811 	msr	BASEPRI, r3
}
 800f1fc:	b002      	add	sp, #8
 800f1fe:	4770      	bx	lr

0800f200 <port_unlock.lto_priv.363>:
static inline void port_unlock(void) {
 800f200:	b082      	sub	sp, #8
 800f202:	2300      	movs	r3, #0
 800f204:	9301      	str	r3, [sp, #4]
 800f206:	9b01      	ldr	r3, [sp, #4]
 800f208:	f383 8811 	msr	BASEPRI, r3
}
 800f20c:	b002      	add	sp, #8
 800f20e:	4770      	bx	lr

0800f210 <port_lock_from_isr.lto_priv.441>:
static inline void port_lock_from_isr(void) {
 800f210:	b508      	push	{r3, lr}
  port_lock();
 800f212:	f7ff ffed 	bl	800f1f0 <port_lock.lto_priv.394>
}
 800f216:	bd08      	pop	{r3, pc}
	...

0800f220 <port_unlock_from_isr.lto_priv.430>:
static inline void port_unlock_from_isr(void) {
 800f220:	b508      	push	{r3, lr}
  port_unlock();
 800f222:	f7ff ffed 	bl	800f200 <port_unlock.lto_priv.363>
}
 800f226:	bd08      	pop	{r3, pc}
	...

0800f230 <_dbg_check_disable>:
/**
 * @brief   Guard code for @p chSysDisable().
 *
 * @notapi
 */
void _dbg_check_disable(void) {
 800f230:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f232:	4b06      	ldr	r3, [pc, #24]	; (800f24c <_dbg_check_disable+0x1c>)
 800f234:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f236:	2b00      	cmp	r3, #0
 800f238:	d103      	bne.n	800f242 <_dbg_check_disable+0x12>
 800f23a:	4b04      	ldr	r3, [pc, #16]	; (800f24c <_dbg_check_disable+0x1c>)
 800f23c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f23e:	2b00      	cmp	r3, #0
 800f240:	d002      	beq.n	800f248 <_dbg_check_disable+0x18>
    chSysHalt("SV#1");
 800f242:	4803      	ldr	r0, [pc, #12]	; (800f250 <_dbg_check_disable+0x20>)
 800f244:	f7ff fecc 	bl	800efe0 <chSysHalt>
  }
}
 800f248:	bd08      	pop	{r3, pc}
 800f24a:	bf00      	nop
 800f24c:	20001090 	.word	0x20001090
 800f250:	08018dc8 	.word	0x08018dc8
	...

0800f260 <_dbg_check_suspend>:
/**
 * @brief   Guard code for @p chSysSuspend().
 *
 * @notapi
 */
void _dbg_check_suspend(void) {
 800f260:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f262:	4b06      	ldr	r3, [pc, #24]	; (800f27c <_dbg_check_suspend+0x1c>)
 800f264:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f266:	2b00      	cmp	r3, #0
 800f268:	d103      	bne.n	800f272 <_dbg_check_suspend+0x12>
 800f26a:	4b04      	ldr	r3, [pc, #16]	; (800f27c <_dbg_check_suspend+0x1c>)
 800f26c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f26e:	2b00      	cmp	r3, #0
 800f270:	d002      	beq.n	800f278 <_dbg_check_suspend+0x18>
    chSysHalt("SV#2");
 800f272:	4803      	ldr	r0, [pc, #12]	; (800f280 <_dbg_check_suspend+0x20>)
 800f274:	f7ff feb4 	bl	800efe0 <chSysHalt>
  }
}
 800f278:	bd08      	pop	{r3, pc}
 800f27a:	bf00      	nop
 800f27c:	20001090 	.word	0x20001090
 800f280:	08018dd0 	.word	0x08018dd0
	...

0800f290 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 800f290:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f292:	4b06      	ldr	r3, [pc, #24]	; (800f2ac <_dbg_check_enable+0x1c>)
 800f294:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f296:	2b00      	cmp	r3, #0
 800f298:	d103      	bne.n	800f2a2 <_dbg_check_enable+0x12>
 800f29a:	4b04      	ldr	r3, [pc, #16]	; (800f2ac <_dbg_check_enable+0x1c>)
 800f29c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f29e:	2b00      	cmp	r3, #0
 800f2a0:	d002      	beq.n	800f2a8 <_dbg_check_enable+0x18>
    chSysHalt("SV#3");
 800f2a2:	4803      	ldr	r0, [pc, #12]	; (800f2b0 <_dbg_check_enable+0x20>)
 800f2a4:	f7ff fe9c 	bl	800efe0 <chSysHalt>
  }
}
 800f2a8:	bd08      	pop	{r3, pc}
 800f2aa:	bf00      	nop
 800f2ac:	20001090 	.word	0x20001090
 800f2b0:	08018dd8 	.word	0x08018dd8
	...

0800f2c0 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 800f2c0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f2c2:	4b07      	ldr	r3, [pc, #28]	; (800f2e0 <_dbg_check_lock+0x20>)
 800f2c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f2c6:	2b00      	cmp	r3, #0
 800f2c8:	d103      	bne.n	800f2d2 <_dbg_check_lock+0x12>
 800f2ca:	4b05      	ldr	r3, [pc, #20]	; (800f2e0 <_dbg_check_lock+0x20>)
 800f2cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f2ce:	2b00      	cmp	r3, #0
 800f2d0:	d002      	beq.n	800f2d8 <_dbg_check_lock+0x18>
    chSysHalt("SV#4");
 800f2d2:	4804      	ldr	r0, [pc, #16]	; (800f2e4 <_dbg_check_lock+0x24>)
 800f2d4:	f7ff fe84 	bl	800efe0 <chSysHalt>
  }
  _dbg_enter_lock();
 800f2d8:	4b01      	ldr	r3, [pc, #4]	; (800f2e0 <_dbg_check_lock+0x20>)
 800f2da:	2201      	movs	r2, #1
 800f2dc:	635a      	str	r2, [r3, #52]	; 0x34
}
 800f2de:	bd08      	pop	{r3, pc}
 800f2e0:	20001090 	.word	0x20001090
 800f2e4:	08018de0 	.word	0x08018de0
	...

0800f2f0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 800f2f0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800f2f2:	4b07      	ldr	r3, [pc, #28]	; (800f310 <_dbg_check_unlock+0x20>)
 800f2f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f2f6:	2b00      	cmp	r3, #0
 800f2f8:	d103      	bne.n	800f302 <_dbg_check_unlock+0x12>
 800f2fa:	4b05      	ldr	r3, [pc, #20]	; (800f310 <_dbg_check_unlock+0x20>)
 800f2fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f2fe:	2b00      	cmp	r3, #0
 800f300:	dc02      	bgt.n	800f308 <_dbg_check_unlock+0x18>
    chSysHalt("SV#5");
 800f302:	4804      	ldr	r0, [pc, #16]	; (800f314 <_dbg_check_unlock+0x24>)
 800f304:	f7ff fe6c 	bl	800efe0 <chSysHalt>
  }
  _dbg_leave_lock();
 800f308:	4b01      	ldr	r3, [pc, #4]	; (800f310 <_dbg_check_unlock+0x20>)
 800f30a:	2200      	movs	r2, #0
 800f30c:	635a      	str	r2, [r3, #52]	; 0x34
}
 800f30e:	bd08      	pop	{r3, pc}
 800f310:	20001090 	.word	0x20001090
 800f314:	08018de8 	.word	0x08018de8
	...

0800f320 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 800f320:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f322:	4b07      	ldr	r3, [pc, #28]	; (800f340 <_dbg_check_lock_from_isr+0x20>)
 800f324:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f326:	2b00      	cmp	r3, #0
 800f328:	dd03      	ble.n	800f332 <_dbg_check_lock_from_isr+0x12>
 800f32a:	4b05      	ldr	r3, [pc, #20]	; (800f340 <_dbg_check_lock_from_isr+0x20>)
 800f32c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f32e:	2b00      	cmp	r3, #0
 800f330:	d002      	beq.n	800f338 <_dbg_check_lock_from_isr+0x18>
    chSysHalt("SV#6");
 800f332:	4804      	ldr	r0, [pc, #16]	; (800f344 <_dbg_check_lock_from_isr+0x24>)
 800f334:	f7ff fe54 	bl	800efe0 <chSysHalt>
  }
  _dbg_enter_lock();
 800f338:	4b01      	ldr	r3, [pc, #4]	; (800f340 <_dbg_check_lock_from_isr+0x20>)
 800f33a:	2201      	movs	r2, #1
 800f33c:	635a      	str	r2, [r3, #52]	; 0x34
}
 800f33e:	bd08      	pop	{r3, pc}
 800f340:	20001090 	.word	0x20001090
 800f344:	08018df0 	.word	0x08018df0
	...

0800f350 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 800f350:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800f352:	4b07      	ldr	r3, [pc, #28]	; (800f370 <_dbg_check_unlock_from_isr+0x20>)
 800f354:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f356:	2b00      	cmp	r3, #0
 800f358:	dd03      	ble.n	800f362 <_dbg_check_unlock_from_isr+0x12>
 800f35a:	4b05      	ldr	r3, [pc, #20]	; (800f370 <_dbg_check_unlock_from_isr+0x20>)
 800f35c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f35e:	2b00      	cmp	r3, #0
 800f360:	dc02      	bgt.n	800f368 <_dbg_check_unlock_from_isr+0x18>
    chSysHalt("SV#7");
 800f362:	4804      	ldr	r0, [pc, #16]	; (800f374 <_dbg_check_unlock_from_isr+0x24>)
 800f364:	f7ff fe3c 	bl	800efe0 <chSysHalt>
  }
  _dbg_leave_lock();
 800f368:	4b01      	ldr	r3, [pc, #4]	; (800f370 <_dbg_check_unlock_from_isr+0x20>)
 800f36a:	2200      	movs	r2, #0
 800f36c:	635a      	str	r2, [r3, #52]	; 0x34
}
 800f36e:	bd08      	pop	{r3, pc}
 800f370:	20001090 	.word	0x20001090
 800f374:	08018df8 	.word	0x08018df8
	...

0800f380 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 800f380:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800f382:	f7ff ff45 	bl	800f210 <port_lock_from_isr.lto_priv.441>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f386:	4b09      	ldr	r3, [pc, #36]	; (800f3ac <_dbg_check_enter_isr+0x2c>)
 800f388:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f38a:	2b00      	cmp	r3, #0
 800f38c:	db03      	blt.n	800f396 <_dbg_check_enter_isr+0x16>
 800f38e:	4b07      	ldr	r3, [pc, #28]	; (800f3ac <_dbg_check_enter_isr+0x2c>)
 800f390:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f392:	2b00      	cmp	r3, #0
 800f394:	d002      	beq.n	800f39c <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
 800f396:	4806      	ldr	r0, [pc, #24]	; (800f3b0 <_dbg_check_enter_isr+0x30>)
 800f398:	f7ff fe22 	bl	800efe0 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800f39c:	4b03      	ldr	r3, [pc, #12]	; (800f3ac <_dbg_check_enter_isr+0x2c>)
 800f39e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f3a0:	3301      	adds	r3, #1
 800f3a2:	4a02      	ldr	r2, [pc, #8]	; (800f3ac <_dbg_check_enter_isr+0x2c>)
 800f3a4:	6313      	str	r3, [r2, #48]	; 0x30
  port_unlock_from_isr();
 800f3a6:	f7ff ff3b 	bl	800f220 <port_unlock_from_isr.lto_priv.430>
}
 800f3aa:	bd08      	pop	{r3, pc}
 800f3ac:	20001090 	.word	0x20001090
 800f3b0:	08018e00 	.word	0x08018e00
	...

0800f3c0 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 800f3c0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800f3c2:	f7ff ff25 	bl	800f210 <port_lock_from_isr.lto_priv.441>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f3c6:	4b09      	ldr	r3, [pc, #36]	; (800f3ec <_dbg_check_leave_isr+0x2c>)
 800f3c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f3ca:	2b00      	cmp	r3, #0
 800f3cc:	dd03      	ble.n	800f3d6 <_dbg_check_leave_isr+0x16>
 800f3ce:	4b07      	ldr	r3, [pc, #28]	; (800f3ec <_dbg_check_leave_isr+0x2c>)
 800f3d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f3d2:	2b00      	cmp	r3, #0
 800f3d4:	d002      	beq.n	800f3dc <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
 800f3d6:	4806      	ldr	r0, [pc, #24]	; (800f3f0 <_dbg_check_leave_isr+0x30>)
 800f3d8:	f7ff fe02 	bl	800efe0 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800f3dc:	4b03      	ldr	r3, [pc, #12]	; (800f3ec <_dbg_check_leave_isr+0x2c>)
 800f3de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f3e0:	3b01      	subs	r3, #1
 800f3e2:	4a02      	ldr	r2, [pc, #8]	; (800f3ec <_dbg_check_leave_isr+0x2c>)
 800f3e4:	6313      	str	r3, [r2, #48]	; 0x30
  port_unlock_from_isr();
 800f3e6:	f7ff ff1b 	bl	800f220 <port_unlock_from_isr.lto_priv.430>
}
 800f3ea:	bd08      	pop	{r3, pc}
 800f3ec:	20001090 	.word	0x20001090
 800f3f0:	08018e08 	.word	0x08018e08
	...

0800f400 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 800f400:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800f402:	4b06      	ldr	r3, [pc, #24]	; (800f41c <chDbgCheckClassI+0x1c>)
 800f404:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f406:	2b00      	cmp	r3, #0
 800f408:	db03      	blt.n	800f412 <chDbgCheckClassI+0x12>
 800f40a:	4b04      	ldr	r3, [pc, #16]	; (800f41c <chDbgCheckClassI+0x1c>)
 800f40c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f40e:	2b00      	cmp	r3, #0
 800f410:	dc02      	bgt.n	800f418 <chDbgCheckClassI+0x18>
    chSysHalt("SV#10");
 800f412:	4803      	ldr	r0, [pc, #12]	; (800f420 <chDbgCheckClassI+0x20>)
 800f414:	f7ff fde4 	bl	800efe0 <chSysHalt>
  }
}
 800f418:	bd08      	pop	{r3, pc}
 800f41a:	bf00      	nop
 800f41c:	20001090 	.word	0x20001090
 800f420:	08018e10 	.word	0x08018e10
	...

0800f430 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 800f430:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800f432:	4b06      	ldr	r3, [pc, #24]	; (800f44c <chDbgCheckClassS+0x1c>)
 800f434:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f436:	2b00      	cmp	r3, #0
 800f438:	d103      	bne.n	800f442 <chDbgCheckClassS+0x12>
 800f43a:	4b04      	ldr	r3, [pc, #16]	; (800f44c <chDbgCheckClassS+0x1c>)
 800f43c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f43e:	2b00      	cmp	r3, #0
 800f440:	dc02      	bgt.n	800f448 <chDbgCheckClassS+0x18>
    chSysHalt("SV#11");
 800f442:	4803      	ldr	r0, [pc, #12]	; (800f450 <chDbgCheckClassS+0x20>)
 800f444:	f7ff fdcc 	bl	800efe0 <chSysHalt>
  }
}
 800f448:	bd08      	pop	{r3, pc}
 800f44a:	bf00      	nop
 800f44c:	20001090 	.word	0x20001090
 800f450:	08018e18 	.word	0x08018e18
	...

0800f460 <port_lock.lto_priv.395>:
static inline void port_lock(void) {
 800f460:	b082      	sub	sp, #8
 800f462:	2320      	movs	r3, #32
 800f464:	9301      	str	r3, [sp, #4]
 800f466:	9b01      	ldr	r3, [sp, #4]
 800f468:	f383 8811 	msr	BASEPRI, r3
}
 800f46c:	b002      	add	sp, #8
 800f46e:	4770      	bx	lr

0800f470 <port_unlock.lto_priv.364>:
static inline void port_unlock(void) {
 800f470:	b082      	sub	sp, #8
 800f472:	2300      	movs	r3, #0
 800f474:	9301      	str	r3, [sp, #4]
 800f476:	9b01      	ldr	r3, [sp, #4]
 800f478:	f383 8811 	msr	BASEPRI, r3
}
 800f47c:	b002      	add	sp, #8
 800f47e:	4770      	bx	lr

0800f480 <port_lock_from_isr.lto_priv.442>:
static inline void port_lock_from_isr(void) {
 800f480:	b508      	push	{r3, lr}
  port_lock();
 800f482:	f7ff ffed 	bl	800f460 <port_lock.lto_priv.395>
}
 800f486:	bd08      	pop	{r3, pc}
	...

0800f490 <port_unlock_from_isr.lto_priv.431>:
static inline void port_unlock_from_isr(void) {
 800f490:	b508      	push	{r3, lr}
  port_unlock();
 800f492:	f7ff ffed 	bl	800f470 <port_unlock.lto_priv.364>
}
 800f496:	bd08      	pop	{r3, pc}
	...

0800f4a0 <port_rt_get_counter_value.lto_priv.499>:
  return DWT->CYCCNT;
 800f4a0:	4b01      	ldr	r3, [pc, #4]	; (800f4a8 <port_rt_get_counter_value.lto_priv.499+0x8>)
 800f4a2:	685b      	ldr	r3, [r3, #4]
}
 800f4a4:	4618      	mov	r0, r3
 800f4a6:	4770      	bx	lr
 800f4a8:	e0001000 	.word	0xe0001000
 800f4ac:	00000000 	.word	0x00000000

0800f4b0 <st_lld_get_counter.lto_priv.345>:
  return (systime_t)STM32_ST_TIM->CNT;
 800f4b0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800f4b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800f4b6:	4618      	mov	r0, r3
 800f4b8:	4770      	bx	lr
 800f4ba:	bf00      	nop
 800f4bc:	0000      	movs	r0, r0
	...

0800f4c0 <port_timer_get_time.lto_priv.339>:
static inline systime_t port_timer_get_time(void) {
 800f4c0:	b508      	push	{r3, lr}
  return stGetCounter();
 800f4c2:	f7ff fff5 	bl	800f4b0 <st_lld_get_counter.lto_priv.345>
 800f4c6:	4603      	mov	r3, r0
}
 800f4c8:	4618      	mov	r0, r3
 800f4ca:	bd08      	pop	{r3, pc}
 800f4cc:	0000      	movs	r0, r0
	...

0800f4d0 <chVTGetSystemTimeX.lto_priv.284>:
static inline systime_t chVTGetSystemTimeX(void) {
 800f4d0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 800f4d2:	f7ff fff5 	bl	800f4c0 <port_timer_get_time.lto_priv.339>
 800f4d6:	4603      	mov	r3, r0
}
 800f4d8:	4618      	mov	r0, r3
 800f4da:	bd08      	pop	{r3, pc}
 800f4dc:	0000      	movs	r0, r0
	...

0800f4e0 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {
 800f4e0:	b510      	push	{r4, lr}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 800f4e2:	4b0f      	ldr	r3, [pc, #60]	; (800f520 <trace_next+0x40>)
 800f4e4:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 800f4e6:	f7ff fff3 	bl	800f4d0 <chVTGetSystemTimeX.lto_priv.284>
 800f4ea:	4603      	mov	r3, r0
 800f4ec:	6063      	str	r3, [r4, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800f4ee:	f7ff ffd7 	bl	800f4a0 <port_rt_get_counter_value.lto_priv.499>
 800f4f2:	4601      	mov	r1, r0
 800f4f4:	4b0a      	ldr	r3, [pc, #40]	; (800f520 <trace_next+0x40>)
 800f4f6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f4f8:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 800f4fc:	6813      	ldr	r3, [r2, #0]
 800f4fe:	f361 231f 	bfi	r3, r1, #8, #24
 800f502:	6013      	str	r3, [r2, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 800f504:	4b06      	ldr	r3, [pc, #24]	; (800f520 <trace_next+0x40>)
 800f506:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f508:	3310      	adds	r3, #16
 800f50a:	4a05      	ldr	r2, [pc, #20]	; (800f520 <trace_next+0x40>)
 800f50c:	63d3      	str	r3, [r2, #60]	; 0x3c
 800f50e:	4b04      	ldr	r3, [pc, #16]	; (800f520 <trace_next+0x40>)
 800f510:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f512:	4a04      	ldr	r2, [pc, #16]	; (800f524 <trace_next+0x44>)
 800f514:	4293      	cmp	r3, r2
 800f516:	d302      	bcc.n	800f51e <trace_next+0x3e>
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 800f518:	4b01      	ldr	r3, [pc, #4]	; (800f520 <trace_next+0x40>)
 800f51a:	4a03      	ldr	r2, [pc, #12]	; (800f528 <trace_next+0x48>)
 800f51c:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 800f51e:	bd10      	pop	{r4, pc}
 800f520:	20001090 	.word	0x20001090
 800f524:	200018d0 	.word	0x200018d0
 800f528:	200010d0 	.word	0x200010d0
 800f52c:	00000000 	.word	0x00000000

0800f530 <_trace_init>:
#if (CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED) || defined(__DOXYGEN__)
/**
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _trace_init(void) {
 800f530:	b082      	sub	sp, #8
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 800f532:	4b10      	ldr	r3, [pc, #64]	; (800f574 <_trace_init+0x44>)
 800f534:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 800f538:	871a      	strh	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 800f53a:	4b0e      	ldr	r3, [pc, #56]	; (800f574 <_trace_init+0x44>)
 800f53c:	2280      	movs	r2, #128	; 0x80
 800f53e:	875a      	strh	r2, [r3, #58]	; 0x3a
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 800f540:	4b0c      	ldr	r3, [pc, #48]	; (800f574 <_trace_init+0x44>)
 800f542:	4a0d      	ldr	r2, [pc, #52]	; (800f578 <_trace_init+0x48>)
 800f544:	63da      	str	r2, [r3, #60]	; 0x3c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800f546:	2300      	movs	r3, #0
 800f548:	9301      	str	r3, [sp, #4]
 800f54a:	e00d      	b.n	800f568 <_trace_init+0x38>
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800f54c:	4a09      	ldr	r2, [pc, #36]	; (800f574 <_trace_init+0x44>)
 800f54e:	9b01      	ldr	r3, [sp, #4]
 800f550:	3301      	adds	r3, #1
 800f552:	011b      	lsls	r3, r3, #4
 800f554:	4413      	add	r3, r2
 800f556:	f103 0228 	add.w	r2, r3, #40	; 0x28
 800f55a:	7a13      	ldrb	r3, [r2, #8]
 800f55c:	f36f 0302 	bfc	r3, #0, #3
 800f560:	7213      	strb	r3, [r2, #8]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800f562:	9b01      	ldr	r3, [sp, #4]
 800f564:	3301      	adds	r3, #1
 800f566:	9301      	str	r3, [sp, #4]
 800f568:	9b01      	ldr	r3, [sp, #4]
 800f56a:	2b7f      	cmp	r3, #127	; 0x7f
 800f56c:	d9ee      	bls.n	800f54c <_trace_init+0x1c>
  }
}
 800f56e:	b002      	add	sp, #8
 800f570:	4770      	bx	lr
 800f572:	bf00      	nop
 800f574:	20001090 	.word	0x20001090
 800f578:	200010d0 	.word	0x200010d0
 800f57c:	00000000 	.word	0x00000000

0800f580 <_trace_switch>:
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {
 800f580:	b500      	push	{lr}
 800f582:	b083      	sub	sp, #12
 800f584:	9001      	str	r0, [sp, #4]
 800f586:	9100      	str	r1, [sp, #0]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800f588:	4b14      	ldr	r3, [pc, #80]	; (800f5dc <_trace_switch+0x5c>)
 800f58a:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800f58c:	f003 0301 	and.w	r3, r3, #1
 800f590:	2b00      	cmp	r3, #0
 800f592:	d11f      	bne.n	800f5d4 <_trace_switch+0x54>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800f594:	4b11      	ldr	r3, [pc, #68]	; (800f5dc <_trace_switch+0x5c>)
 800f596:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f598:	7813      	ldrb	r3, [r2, #0]
 800f59a:	2101      	movs	r1, #1
 800f59c:	f361 0302 	bfi	r3, r1, #0, #3
 800f5a0:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800f5a2:	9b00      	ldr	r3, [sp, #0]
 800f5a4:	f893 1020 	ldrb.w	r1, [r3, #32]
 800f5a8:	4b0c      	ldr	r3, [pc, #48]	; (800f5dc <_trace_switch+0x5c>)
 800f5aa:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f5ac:	460b      	mov	r3, r1
 800f5ae:	f003 031f 	and.w	r3, r3, #31
 800f5b2:	b2d9      	uxtb	r1, r3
 800f5b4:	7813      	ldrb	r3, [r2, #0]
 800f5b6:	f361 03c7 	bfi	r3, r1, #3, #5
 800f5ba:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800f5bc:	4b07      	ldr	r3, [pc, #28]	; (800f5dc <_trace_switch+0x5c>)
 800f5be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f5c0:	4a06      	ldr	r2, [pc, #24]	; (800f5dc <_trace_switch+0x5c>)
 800f5c2:	6992      	ldr	r2, [r2, #24]
 800f5c4:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800f5c6:	4b05      	ldr	r3, [pc, #20]	; (800f5dc <_trace_switch+0x5c>)
 800f5c8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f5ca:	9a00      	ldr	r2, [sp, #0]
 800f5cc:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800f5ce:	60da      	str	r2, [r3, #12]
    trace_next();
 800f5d0:	f7ff ff86 	bl	800f4e0 <trace_next>
  }
}
 800f5d4:	b003      	add	sp, #12
 800f5d6:	f85d fb04 	ldr.w	pc, [sp], #4
 800f5da:	bf00      	nop
 800f5dc:	20001090 	.word	0x20001090

0800f5e0 <_trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {
 800f5e0:	b500      	push	{lr}
 800f5e2:	b083      	sub	sp, #12
 800f5e4:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800f5e6:	4b10      	ldr	r3, [pc, #64]	; (800f628 <_trace_isr_enter+0x48>)
 800f5e8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800f5ea:	f003 0302 	and.w	r3, r3, #2
 800f5ee:	2b00      	cmp	r3, #0
 800f5f0:	d116      	bne.n	800f620 <_trace_isr_enter+0x40>
    port_lock_from_isr();
 800f5f2:	f7ff ff45 	bl	800f480 <port_lock_from_isr.lto_priv.442>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800f5f6:	4b0c      	ldr	r3, [pc, #48]	; (800f628 <_trace_isr_enter+0x48>)
 800f5f8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f5fa:	7813      	ldrb	r3, [r2, #0]
 800f5fc:	2102      	movs	r1, #2
 800f5fe:	f361 0302 	bfi	r3, r1, #0, #3
 800f602:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800f604:	4b08      	ldr	r3, [pc, #32]	; (800f628 <_trace_isr_enter+0x48>)
 800f606:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f608:	7813      	ldrb	r3, [r2, #0]
 800f60a:	f36f 03c7 	bfc	r3, #3, #5
 800f60e:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800f610:	4b05      	ldr	r3, [pc, #20]	; (800f628 <_trace_isr_enter+0x48>)
 800f612:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f614:	9a01      	ldr	r2, [sp, #4]
 800f616:	609a      	str	r2, [r3, #8]
    trace_next();
 800f618:	f7ff ff62 	bl	800f4e0 <trace_next>
    port_unlock_from_isr();
 800f61c:	f7ff ff38 	bl	800f490 <port_unlock_from_isr.lto_priv.431>
  }
}
 800f620:	b003      	add	sp, #12
 800f622:	f85d fb04 	ldr.w	pc, [sp], #4
 800f626:	bf00      	nop
 800f628:	20001090 	.word	0x20001090
 800f62c:	00000000 	.word	0x00000000

0800f630 <_trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {
 800f630:	b500      	push	{lr}
 800f632:	b083      	sub	sp, #12
 800f634:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800f636:	4b10      	ldr	r3, [pc, #64]	; (800f678 <_trace_isr_leave+0x48>)
 800f638:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800f63a:	f003 0302 	and.w	r3, r3, #2
 800f63e:	2b00      	cmp	r3, #0
 800f640:	d116      	bne.n	800f670 <_trace_isr_leave+0x40>
    port_lock_from_isr();
 800f642:	f7ff ff1d 	bl	800f480 <port_lock_from_isr.lto_priv.442>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800f646:	4b0c      	ldr	r3, [pc, #48]	; (800f678 <_trace_isr_leave+0x48>)
 800f648:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f64a:	7813      	ldrb	r3, [r2, #0]
 800f64c:	2103      	movs	r1, #3
 800f64e:	f361 0302 	bfi	r3, r1, #0, #3
 800f652:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800f654:	4b08      	ldr	r3, [pc, #32]	; (800f678 <_trace_isr_leave+0x48>)
 800f656:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f658:	7813      	ldrb	r3, [r2, #0]
 800f65a:	f36f 03c7 	bfc	r3, #3, #5
 800f65e:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800f660:	4b05      	ldr	r3, [pc, #20]	; (800f678 <_trace_isr_leave+0x48>)
 800f662:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f664:	9a01      	ldr	r2, [sp, #4]
 800f666:	609a      	str	r2, [r3, #8]
    trace_next();
 800f668:	f7ff ff3a 	bl	800f4e0 <trace_next>
    port_unlock_from_isr();
 800f66c:	f7ff ff10 	bl	800f490 <port_unlock_from_isr.lto_priv.431>
  }
}
 800f670:	b003      	add	sp, #12
 800f672:	f85d fb04 	ldr.w	pc, [sp], #4
 800f676:	bf00      	nop
 800f678:	20001090 	.word	0x20001090
 800f67c:	00000000 	.word	0x00000000

0800f680 <_trace_halt>:
 *
 * @param[in] reason    the halt error string
 *
 * @notapi
 */
void _trace_halt(const char *reason) {
 800f680:	b500      	push	{lr}
 800f682:	b083      	sub	sp, #12
 800f684:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 800f686:	4b0e      	ldr	r3, [pc, #56]	; (800f6c0 <_trace_halt+0x40>)
 800f688:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800f68a:	f003 0304 	and.w	r3, r3, #4
 800f68e:	2b00      	cmp	r3, #0
 800f690:	d112      	bne.n	800f6b8 <_trace_halt+0x38>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 800f692:	4b0b      	ldr	r3, [pc, #44]	; (800f6c0 <_trace_halt+0x40>)
 800f694:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f696:	7813      	ldrb	r3, [r2, #0]
 800f698:	2104      	movs	r1, #4
 800f69a:	f361 0302 	bfi	r3, r1, #0, #3
 800f69e:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
 800f6a0:	4b07      	ldr	r3, [pc, #28]	; (800f6c0 <_trace_halt+0x40>)
 800f6a2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f6a4:	7813      	ldrb	r3, [r2, #0]
 800f6a6:	f36f 03c7 	bfc	r3, #3, #5
 800f6aa:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 800f6ac:	4b04      	ldr	r3, [pc, #16]	; (800f6c0 <_trace_halt+0x40>)
 800f6ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f6b0:	9a01      	ldr	r2, [sp, #4]
 800f6b2:	609a      	str	r2, [r3, #8]
    trace_next();
 800f6b4:	f7ff ff14 	bl	800f4e0 <trace_next>
  }
}
 800f6b8:	b003      	add	sp, #12
 800f6ba:	f85d fb04 	ldr.w	pc, [sp], #4
 800f6be:	bf00      	nop
 800f6c0:	20001090 	.word	0x20001090
	...

0800f6d0 <chTimeAddX.lto_priv.540>:
                                   sysinterval_t interval) {
 800f6d0:	b082      	sub	sp, #8
 800f6d2:	9001      	str	r0, [sp, #4]
 800f6d4:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
 800f6d6:	9a01      	ldr	r2, [sp, #4]
 800f6d8:	9b00      	ldr	r3, [sp, #0]
 800f6da:	4413      	add	r3, r2
}
 800f6dc:	4618      	mov	r0, r3
 800f6de:	b002      	add	sp, #8
 800f6e0:	4770      	bx	lr
 800f6e2:	bf00      	nop
	...

0800f6f0 <chTimeDiffX.lto_priv.515>:
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 800f6f0:	b082      	sub	sp, #8
 800f6f2:	9001      	str	r0, [sp, #4]
 800f6f4:	9100      	str	r1, [sp, #0]
  return (sysinterval_t)((systime_t)(end - start));
 800f6f6:	9a00      	ldr	r2, [sp, #0]
 800f6f8:	9b01      	ldr	r3, [sp, #4]
 800f6fa:	1ad3      	subs	r3, r2, r3
}
 800f6fc:	4618      	mov	r0, r3
 800f6fe:	b002      	add	sp, #8
 800f700:	4770      	bx	lr
 800f702:	bf00      	nop
	...

0800f710 <st_lld_get_counter.lto_priv.346>:
  return (systime_t)STM32_ST_TIM->CNT;
 800f710:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800f714:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800f716:	4618      	mov	r0, r3
 800f718:	4770      	bx	lr
 800f71a:	bf00      	nop
 800f71c:	0000      	movs	r0, r0
	...

0800f720 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 800f720:	b500      	push	{lr}
 800f722:	b083      	sub	sp, #12
 800f724:	9001      	str	r0, [sp, #4]
  stStartAlarm(time);
 800f726:	9801      	ldr	r0, [sp, #4]
 800f728:	f7f9 fa1a 	bl	8008b60 <stStartAlarm>
}
 800f72c:	b003      	add	sp, #12
 800f72e:	f85d fb04 	ldr.w	pc, [sp], #4
 800f732:	bf00      	nop
	...

0800f740 <port_timer_stop_alarm.lto_priv.538>:
static inline void port_timer_stop_alarm(void) {
 800f740:	b508      	push	{r3, lr}
  stStopAlarm();
 800f742:	f7f9 fa25 	bl	8008b90 <stStopAlarm>
}
 800f746:	bd08      	pop	{r3, pc}
	...

0800f750 <port_timer_set_alarm.lto_priv.536>:
static inline void port_timer_set_alarm(systime_t time) {
 800f750:	b500      	push	{lr}
 800f752:	b083      	sub	sp, #12
 800f754:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 800f756:	9801      	ldr	r0, [sp, #4]
 800f758:	f7f9 fa22 	bl	8008ba0 <stSetAlarm>
}
 800f75c:	b003      	add	sp, #12
 800f75e:	f85d fb04 	ldr.w	pc, [sp], #4
 800f762:	bf00      	nop
	...

0800f770 <port_timer_get_time.lto_priv.340>:
static inline systime_t port_timer_get_time(void) {
 800f770:	b508      	push	{r3, lr}
  return stGetCounter();
 800f772:	f7ff ffcd 	bl	800f710 <st_lld_get_counter.lto_priv.346>
 800f776:	4603      	mov	r3, r0
}
 800f778:	4618      	mov	r0, r3
 800f77a:	bd08      	pop	{r3, pc}
 800f77c:	0000      	movs	r0, r0
	...

0800f780 <chVTGetSystemTimeX.lto_priv.285>:
static inline systime_t chVTGetSystemTimeX(void) {
 800f780:	b508      	push	{r3, lr}
  return port_timer_get_time();
 800f782:	f7ff fff5 	bl	800f770 <port_timer_get_time.lto_priv.340>
 800f786:	4603      	mov	r3, r0
}
 800f788:	4618      	mov	r0, r3
 800f78a:	bd08      	pop	{r3, pc}
 800f78c:	0000      	movs	r0, r0
	...

0800f790 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 800f790:	4b06      	ldr	r3, [pc, #24]	; (800f7ac <_vt_init+0x1c>)
 800f792:	4a07      	ldr	r2, [pc, #28]	; (800f7b0 <_vt_init+0x20>)
 800f794:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 800f796:	4b05      	ldr	r3, [pc, #20]	; (800f7ac <_vt_init+0x1c>)
 800f798:	4a05      	ldr	r2, [pc, #20]	; (800f7b0 <_vt_init+0x20>)
 800f79a:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (sysinterval_t)-1;
 800f79c:	4b03      	ldr	r3, [pc, #12]	; (800f7ac <_vt_init+0x1c>)
 800f79e:	f04f 32ff 	mov.w	r2, #4294967295
 800f7a2:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 800f7a4:	4b01      	ldr	r3, [pc, #4]	; (800f7ac <_vt_init+0x1c>)
 800f7a6:	2200      	movs	r2, #0
 800f7a8:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800f7aa:	4770      	bx	lr
 800f7ac:	20001090 	.word	0x20001090
 800f7b0:	200010ac 	.word	0x200010ac
	...

0800f7c0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 800f7c0:	b500      	push	{lr}
 800f7c2:	b089      	sub	sp, #36	; 0x24
 800f7c4:	9003      	str	r0, [sp, #12]
 800f7c6:	9102      	str	r1, [sp, #8]
 800f7c8:	9201      	str	r2, [sp, #4]
 800f7ca:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  sysinterval_t delta;

  chDbgCheckClassI();
 800f7cc:	f7ff fe18 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800f7d0:	9b03      	ldr	r3, [sp, #12]
 800f7d2:	2b00      	cmp	r3, #0
 800f7d4:	d005      	beq.n	800f7e2 <chVTDoSetI+0x22>
 800f7d6:	9b01      	ldr	r3, [sp, #4]
 800f7d8:	2b00      	cmp	r3, #0
 800f7da:	d002      	beq.n	800f7e2 <chVTDoSetI+0x22>
 800f7dc:	9b02      	ldr	r3, [sp, #8]
 800f7de:	2b00      	cmp	r3, #0
 800f7e0:	d102      	bne.n	800f7e8 <chVTDoSetI+0x28>
 800f7e2:	484c      	ldr	r0, [pc, #304]	; (800f914 <chVTDoSetI+0x154>)
 800f7e4:	f7ff fbfc 	bl	800efe0 <chSysHalt>

  vtp->par = par;
 800f7e8:	9b03      	ldr	r3, [sp, #12]
 800f7ea:	9a00      	ldr	r2, [sp, #0]
 800f7ec:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 800f7ee:	9b03      	ldr	r3, [sp, #12]
 800f7f0:	9a01      	ldr	r2, [sp, #4]
 800f7f2:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 800f7f4:	f7ff ffc4 	bl	800f780 <chVTGetSystemTimeX.lto_priv.285>
 800f7f8:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 800f7fa:	9b02      	ldr	r3, [sp, #8]
 800f7fc:	2b01      	cmp	r3, #1
 800f7fe:	d801      	bhi.n	800f804 <chVTDoSetI+0x44>
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800f800:	2302      	movs	r3, #2
 800f802:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800f804:	4b44      	ldr	r3, [pc, #272]	; (800f918 <chVTDoSetI+0x158>)
 800f806:	69db      	ldr	r3, [r3, #28]
 800f808:	4a44      	ldr	r2, [pc, #272]	; (800f91c <chVTDoSetI+0x15c>)
 800f80a:	4293      	cmp	r3, r2
 800f80c:	d11c      	bne.n	800f848 <chVTDoSetI+0x88>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 800f80e:	4a42      	ldr	r2, [pc, #264]	; (800f918 <chVTDoSetI+0x158>)
 800f810:	9b05      	ldr	r3, [sp, #20]
 800f812:	6293      	str	r3, [r2, #40]	; 0x28
      ch.vtlist.next = vtp;
 800f814:	4a40      	ldr	r2, [pc, #256]	; (800f918 <chVTDoSetI+0x158>)
 800f816:	9b03      	ldr	r3, [sp, #12]
 800f818:	61d3      	str	r3, [r2, #28]
      ch.vtlist.prev = vtp;
 800f81a:	4a3f      	ldr	r2, [pc, #252]	; (800f918 <chVTDoSetI+0x158>)
 800f81c:	9b03      	ldr	r3, [sp, #12]
 800f81e:	6213      	str	r3, [r2, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 800f820:	9b03      	ldr	r3, [sp, #12]
 800f822:	4a3e      	ldr	r2, [pc, #248]	; (800f91c <chVTDoSetI+0x15c>)
 800f824:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800f826:	9b03      	ldr	r3, [sp, #12]
 800f828:	4a3c      	ldr	r2, [pc, #240]	; (800f91c <chVTDoSetI+0x15c>)
 800f82a:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 800f82c:	9b03      	ldr	r3, [sp, #12]
 800f82e:	9a02      	ldr	r2, [sp, #8]
 800f830:	609a      	str	r2, [r3, #8]
        delay = (sysinterval_t)TIME_MAX_SYSTIME;
      }
#endif

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(chTimeAddX(ch.vtlist.lasttime, delay));
 800f832:	4b39      	ldr	r3, [pc, #228]	; (800f918 <chVTDoSetI+0x158>)
 800f834:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f836:	9902      	ldr	r1, [sp, #8]
 800f838:	4618      	mov	r0, r3
 800f83a:	f7ff ff49 	bl	800f6d0 <chTimeAddX.lto_priv.540>
 800f83e:	4603      	mov	r3, r0
 800f840:	4618      	mov	r0, r3
 800f842:	f7ff ff6d 	bl	800f720 <port_timer_start_alarm>
 800f846:	e061      	b.n	800f90c <chVTDoSetI+0x14c>

      return;
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
 800f848:	4b33      	ldr	r3, [pc, #204]	; (800f918 <chVTDoSetI+0x158>)
 800f84a:	69db      	ldr	r3, [r3, #28]
 800f84c:	9307      	str	r3, [sp, #28]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 800f84e:	4b32      	ldr	r3, [pc, #200]	; (800f918 <chVTDoSetI+0x158>)
 800f850:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f852:	9905      	ldr	r1, [sp, #20]
 800f854:	4618      	mov	r0, r3
 800f856:	f7ff ff4b 	bl	800f6f0 <chTimeDiffX.lto_priv.515>
 800f85a:	4602      	mov	r2, r0
 800f85c:	9b02      	ldr	r3, [sp, #8]
 800f85e:	4413      	add	r3, r2
 800f860:	9306      	str	r3, [sp, #24]

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 800f862:	4b2d      	ldr	r3, [pc, #180]	; (800f918 <chVTDoSetI+0x158>)
 800f864:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f866:	9905      	ldr	r1, [sp, #20]
 800f868:	4618      	mov	r0, r3
 800f86a:	f7ff ff41 	bl	800f6f0 <chTimeDiffX.lto_priv.515>
 800f86e:	4602      	mov	r2, r0
 800f870:	9b06      	ldr	r3, [sp, #24]
 800f872:	4293      	cmp	r3, r2
 800f874:	d208      	bcs.n	800f888 <chVTDoSetI+0xc8>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 800f876:	9b07      	ldr	r3, [sp, #28]
 800f878:	689b      	ldr	r3, [r3, #8]
 800f87a:	9a06      	ldr	r2, [sp, #24]
 800f87c:	1ad3      	subs	r3, r2, r3
 800f87e:	9306      	str	r3, [sp, #24]
      p = p->next;
 800f880:	9b07      	ldr	r3, [sp, #28]
 800f882:	681b      	ldr	r3, [r3, #0]
 800f884:	9307      	str	r3, [sp, #28]
 800f886:	e020      	b.n	800f8ca <chVTDoSetI+0x10a>
    }
    else if (delta < p->delta) {
 800f888:	9b07      	ldr	r3, [sp, #28]
 800f88a:	689b      	ldr	r3, [r3, #8]
 800f88c:	9a06      	ldr	r2, [sp, #24]
 800f88e:	429a      	cmp	r2, r3
 800f890:	d21b      	bcs.n	800f8ca <chVTDoSetI+0x10a>
      sysinterval_t deadline_delta;

      /* A small delay that will become the first element in the delta list
         and next deadline.*/
      deadline_delta = delta;
 800f892:	9b06      	ldr	r3, [sp, #24]
 800f894:	9304      	str	r3, [sp, #16]
      /* The delta could be too large for the physical timer to handle.*/
      if (deadline_delta > (sysinterval_t)TIME_MAX_SYSTIME) {
        deadline_delta = (sysinterval_t)TIME_MAX_SYSTIME;
      }
#endif
      port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, deadline_delta));
 800f896:	4b20      	ldr	r3, [pc, #128]	; (800f918 <chVTDoSetI+0x158>)
 800f898:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f89a:	9904      	ldr	r1, [sp, #16]
 800f89c:	4618      	mov	r0, r3
 800f89e:	f7ff ff17 	bl	800f6d0 <chTimeAddX.lto_priv.540>
 800f8a2:	4603      	mov	r3, r0
 800f8a4:	4618      	mov	r0, r3
 800f8a6:	f7ff ff53 	bl	800f750 <port_timer_set_alarm.lto_priv.536>
 800f8aa:	e00e      	b.n	800f8ca <chVTDoSetI+0x10a>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 800f8ac:	9a07      	ldr	r2, [sp, #28]
 800f8ae:	9b03      	ldr	r3, [sp, #12]
 800f8b0:	429a      	cmp	r2, r3
 800f8b2:	d102      	bne.n	800f8ba <chVTDoSetI+0xfa>
 800f8b4:	4817      	ldr	r0, [pc, #92]	; (800f914 <chVTDoSetI+0x154>)
 800f8b6:	f7ff fb93 	bl	800efe0 <chSysHalt>

    delta -= p->delta;
 800f8ba:	9b07      	ldr	r3, [sp, #28]
 800f8bc:	689b      	ldr	r3, [r3, #8]
 800f8be:	9a06      	ldr	r2, [sp, #24]
 800f8c0:	1ad3      	subs	r3, r2, r3
 800f8c2:	9306      	str	r3, [sp, #24]
    p = p->next;
 800f8c4:	9b07      	ldr	r3, [sp, #28]
 800f8c6:	681b      	ldr	r3, [r3, #0]
 800f8c8:	9307      	str	r3, [sp, #28]
  while (p->delta < delta) {
 800f8ca:	9b07      	ldr	r3, [sp, #28]
 800f8cc:	689b      	ldr	r3, [r3, #8]
 800f8ce:	9a06      	ldr	r2, [sp, #24]
 800f8d0:	429a      	cmp	r2, r3
 800f8d2:	d8eb      	bhi.n	800f8ac <chVTDoSetI+0xec>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800f8d4:	9b03      	ldr	r3, [sp, #12]
 800f8d6:	9a07      	ldr	r2, [sp, #28]
 800f8d8:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 800f8da:	9b03      	ldr	r3, [sp, #12]
 800f8dc:	681b      	ldr	r3, [r3, #0]
 800f8de:	685a      	ldr	r2, [r3, #4]
 800f8e0:	9b03      	ldr	r3, [sp, #12]
 800f8e2:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 800f8e4:	9b03      	ldr	r3, [sp, #12]
 800f8e6:	685b      	ldr	r3, [r3, #4]
 800f8e8:	9a03      	ldr	r2, [sp, #12]
 800f8ea:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 800f8ec:	9b07      	ldr	r3, [sp, #28]
 800f8ee:	9a03      	ldr	r2, [sp, #12]
 800f8f0:	605a      	str	r2, [r3, #4]
  vtp->delta = delta;
 800f8f2:	9b03      	ldr	r3, [sp, #12]
 800f8f4:	9a06      	ldr	r2, [sp, #24]
 800f8f6:	609a      	str	r2, [r3, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 800f8f8:	9b07      	ldr	r3, [sp, #28]
 800f8fa:	689a      	ldr	r2, [r3, #8]
 800f8fc:	9b06      	ldr	r3, [sp, #24]
 800f8fe:	1ad2      	subs	r2, r2, r3
 800f900:	9b07      	ldr	r3, [sp, #28]
 800f902:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 800f904:	4b04      	ldr	r3, [pc, #16]	; (800f918 <chVTDoSetI+0x158>)
 800f906:	f04f 32ff 	mov.w	r2, #4294967295
 800f90a:	625a      	str	r2, [r3, #36]	; 0x24
}
 800f90c:	b009      	add	sp, #36	; 0x24
 800f90e:	f85d fb04 	ldr.w	pc, [sp], #4
 800f912:	bf00      	nop
 800f914:	08016be8 	.word	0x08016be8
 800f918:	20001090 	.word	0x20001090
 800f91c:	200010ac 	.word	0x200010ac

0800f920 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 800f920:	b510      	push	{r4, lr}
 800f922:	b084      	sub	sp, #16
 800f924:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800f926:	f7ff fd6b 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 800f92a:	9b01      	ldr	r3, [sp, #4]
 800f92c:	2b00      	cmp	r3, #0
 800f92e:	d102      	bne.n	800f936 <chVTDoResetI+0x16>
 800f930:	483a      	ldr	r0, [pc, #232]	; (800fa1c <chVTDoResetI+0xfc>)
 800f932:	f7ff fb55 	bl	800efe0 <chSysHalt>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 800f936:	9b01      	ldr	r3, [sp, #4]
 800f938:	68db      	ldr	r3, [r3, #12]
 800f93a:	2b00      	cmp	r3, #0
 800f93c:	d102      	bne.n	800f944 <chVTDoResetI+0x24>
 800f93e:	4837      	ldr	r0, [pc, #220]	; (800fa1c <chVTDoResetI+0xfc>)
 800f940:	f7ff fb4e 	bl	800efe0 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 800f944:	4b36      	ldr	r3, [pc, #216]	; (800fa20 <chVTDoResetI+0x100>)
 800f946:	69db      	ldr	r3, [r3, #28]
 800f948:	9a01      	ldr	r2, [sp, #4]
 800f94a:	429a      	cmp	r2, r3
 800f94c:	d01b      	beq.n	800f986 <chVTDoResetI+0x66>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800f94e:	9b01      	ldr	r3, [sp, #4]
 800f950:	685b      	ldr	r3, [r3, #4]
 800f952:	9a01      	ldr	r2, [sp, #4]
 800f954:	6812      	ldr	r2, [r2, #0]
 800f956:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 800f958:	9b01      	ldr	r3, [sp, #4]
 800f95a:	681b      	ldr	r3, [r3, #0]
 800f95c:	9a01      	ldr	r2, [sp, #4]
 800f95e:	6852      	ldr	r2, [r2, #4]
 800f960:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 800f962:	9b01      	ldr	r3, [sp, #4]
 800f964:	2200      	movs	r2, #0
 800f966:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800f968:	9b01      	ldr	r3, [sp, #4]
 800f96a:	681b      	ldr	r3, [r3, #0]
 800f96c:	4a2d      	ldr	r2, [pc, #180]	; (800fa24 <chVTDoResetI+0x104>)
 800f96e:	4293      	cmp	r3, r2
 800f970:	d051      	beq.n	800fa16 <chVTDoResetI+0xf6>
      vtp->next->delta += vtp->delta;
 800f972:	9b01      	ldr	r3, [sp, #4]
 800f974:	681b      	ldr	r3, [r3, #0]
 800f976:	6899      	ldr	r1, [r3, #8]
 800f978:	9b01      	ldr	r3, [sp, #4]
 800f97a:	689a      	ldr	r2, [r3, #8]
 800f97c:	9b01      	ldr	r3, [sp, #4]
 800f97e:	681b      	ldr	r3, [r3, #0]
 800f980:	440a      	add	r2, r1
 800f982:	609a      	str	r2, [r3, #8]
 800f984:	e048      	b.n	800fa18 <chVTDoResetI+0xf8>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 800f986:	9b01      	ldr	r3, [sp, #4]
 800f988:	681b      	ldr	r3, [r3, #0]
 800f98a:	4a25      	ldr	r2, [pc, #148]	; (800fa20 <chVTDoResetI+0x100>)
 800f98c:	61d3      	str	r3, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 800f98e:	4b24      	ldr	r3, [pc, #144]	; (800fa20 <chVTDoResetI+0x100>)
 800f990:	69db      	ldr	r3, [r3, #28]
 800f992:	4a24      	ldr	r2, [pc, #144]	; (800fa24 <chVTDoResetI+0x104>)
 800f994:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 800f996:	9b01      	ldr	r3, [sp, #4]
 800f998:	2200      	movs	r2, #0
 800f99a:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800f99c:	4b20      	ldr	r3, [pc, #128]	; (800fa20 <chVTDoResetI+0x100>)
 800f99e:	69db      	ldr	r3, [r3, #28]
 800f9a0:	4a20      	ldr	r2, [pc, #128]	; (800fa24 <chVTDoResetI+0x104>)
 800f9a2:	4293      	cmp	r3, r2
 800f9a4:	d102      	bne.n	800f9ac <chVTDoResetI+0x8c>
    port_timer_stop_alarm();
 800f9a6:	f7ff fecb 	bl	800f740 <port_timer_stop_alarm.lto_priv.538>
 800f9aa:	e035      	b.n	800fa18 <chVTDoResetI+0xf8>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800f9ac:	4b1c      	ldr	r3, [pc, #112]	; (800fa20 <chVTDoResetI+0x100>)
 800f9ae:	69db      	ldr	r3, [r3, #28]
 800f9b0:	6899      	ldr	r1, [r3, #8]
 800f9b2:	9b01      	ldr	r3, [sp, #4]
 800f9b4:	689a      	ldr	r2, [r3, #8]
 800f9b6:	4b1a      	ldr	r3, [pc, #104]	; (800fa20 <chVTDoResetI+0x100>)
 800f9b8:	69db      	ldr	r3, [r3, #28]
 800f9ba:	440a      	add	r2, r1
 800f9bc:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 800f9be:	4b18      	ldr	r3, [pc, #96]	; (800fa20 <chVTDoResetI+0x100>)
 800f9c0:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 800f9c2:	f7ff fedd 	bl	800f780 <chVTGetSystemTimeX.lto_priv.285>
 800f9c6:	4603      	mov	r3, r0
 800f9c8:	4619      	mov	r1, r3
 800f9ca:	4620      	mov	r0, r4
 800f9cc:	f7ff fe90 	bl	800f6f0 <chTimeDiffX.lto_priv.515>
 800f9d0:	9002      	str	r0, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 800f9d2:	4b13      	ldr	r3, [pc, #76]	; (800fa20 <chVTDoResetI+0x100>)
 800f9d4:	69db      	ldr	r3, [r3, #28]
 800f9d6:	689b      	ldr	r3, [r3, #8]
 800f9d8:	9a02      	ldr	r2, [sp, #8]
 800f9da:	429a      	cmp	r2, r3
 800f9dc:	d21c      	bcs.n	800fa18 <chVTDoResetI+0xf8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 800f9de:	4b10      	ldr	r3, [pc, #64]	; (800fa20 <chVTDoResetI+0x100>)
 800f9e0:	69db      	ldr	r3, [r3, #28]
 800f9e2:	689a      	ldr	r2, [r3, #8]
 800f9e4:	9b02      	ldr	r3, [sp, #8]
 800f9e6:	1ad3      	subs	r3, r2, r3
 800f9e8:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 800f9ea:	9b03      	ldr	r3, [sp, #12]
 800f9ec:	2b01      	cmp	r3, #1
 800f9ee:	d803      	bhi.n	800f9f8 <chVTDoResetI+0xd8>
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800f9f0:	9b02      	ldr	r3, [sp, #8]
 800f9f2:	3302      	adds	r3, #2
 800f9f4:	9303      	str	r3, [sp, #12]
 800f9f6:	e003      	b.n	800fa00 <chVTDoResetI+0xe0>
  }
  else {
    delta = nowdelta + delta;
 800f9f8:	9a03      	ldr	r2, [sp, #12]
 800f9fa:	9b02      	ldr	r3, [sp, #8]
 800f9fc:	4413      	add	r3, r2
 800f9fe:	9303      	str	r3, [sp, #12]
    if (delta > (sysinterval_t)TIME_MAX_SYSTIME) {
      delta = (sysinterval_t)TIME_MAX_SYSTIME;
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
 800fa00:	4b07      	ldr	r3, [pc, #28]	; (800fa20 <chVTDoResetI+0x100>)
 800fa02:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800fa04:	9903      	ldr	r1, [sp, #12]
 800fa06:	4618      	mov	r0, r3
 800fa08:	f7ff fe62 	bl	800f6d0 <chTimeAddX.lto_priv.540>
 800fa0c:	4603      	mov	r3, r0
 800fa0e:	4618      	mov	r0, r3
 800fa10:	f7ff fe9e 	bl	800f750 <port_timer_set_alarm.lto_priv.536>
 800fa14:	e000      	b.n	800fa18 <chVTDoResetI+0xf8>
      vtp->next->delta += vtp->delta;
 800fa16:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800fa18:	b004      	add	sp, #16
 800fa1a:	bd10      	pop	{r4, pc}
 800fa1c:	08016bf4 	.word	0x08016bf4
 800fa20:	20001090 	.word	0x20001090
 800fa24:	200010ac 	.word	0x200010ac
	...

0800fa30 <port_lock.lto_priv.396>:
static inline void port_lock(void) {
 800fa30:	b082      	sub	sp, #8
 800fa32:	2320      	movs	r3, #32
 800fa34:	9301      	str	r3, [sp, #4]
 800fa36:	9b01      	ldr	r3, [sp, #4]
 800fa38:	f383 8811 	msr	BASEPRI, r3
}
 800fa3c:	b002      	add	sp, #8
 800fa3e:	4770      	bx	lr

0800fa40 <port_unlock.lto_priv.365>:
static inline void port_unlock(void) {
 800fa40:	b082      	sub	sp, #8
 800fa42:	2300      	movs	r3, #0
 800fa44:	9301      	str	r3, [sp, #4]
 800fa46:	9b01      	ldr	r3, [sp, #4]
 800fa48:	f383 8811 	msr	BASEPRI, r3
}
 800fa4c:	b002      	add	sp, #8
 800fa4e:	4770      	bx	lr

0800fa50 <port_lock_from_isr.lto_priv.443>:
static inline void port_lock_from_isr(void) {
 800fa50:	b508      	push	{r3, lr}
  port_lock();
 800fa52:	f7ff ffed 	bl	800fa30 <port_lock.lto_priv.396>
}
 800fa56:	bd08      	pop	{r3, pc}
	...

0800fa60 <port_unlock_from_isr.lto_priv.432>:
static inline void port_unlock_from_isr(void) {
 800fa60:	b508      	push	{r3, lr}
  port_unlock();
 800fa62:	f7ff ffed 	bl	800fa40 <port_unlock.lto_priv.365>
}
 800fa66:	bd08      	pop	{r3, pc}
	...

0800fa70 <queue_init.lto_priv.462>:
static inline void queue_init(threads_queue_t *tqp) {
 800fa70:	b082      	sub	sp, #8
 800fa72:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 800fa74:	9b01      	ldr	r3, [sp, #4]
 800fa76:	9a01      	ldr	r2, [sp, #4]
 800fa78:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800fa7a:	9b01      	ldr	r3, [sp, #4]
 800fa7c:	9a01      	ldr	r2, [sp, #4]
 800fa7e:	605a      	str	r2, [r3, #4]
}
 800fa80:	b002      	add	sp, #8
 800fa82:	4770      	bx	lr
	...

0800fa90 <queue_fifo_remove.lto_priv.468>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800fa90:	b084      	sub	sp, #16
 800fa92:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 800fa94:	9b01      	ldr	r3, [sp, #4]
 800fa96:	681b      	ldr	r3, [r3, #0]
 800fa98:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 800fa9a:	9b03      	ldr	r3, [sp, #12]
 800fa9c:	681a      	ldr	r2, [r3, #0]
 800fa9e:	9b01      	ldr	r3, [sp, #4]
 800faa0:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800faa2:	9b01      	ldr	r3, [sp, #4]
 800faa4:	681b      	ldr	r3, [r3, #0]
 800faa6:	9a01      	ldr	r2, [sp, #4]
 800faa8:	605a      	str	r2, [r3, #4]

  return tp;
 800faaa:	9b03      	ldr	r3, [sp, #12]
}
 800faac:	4618      	mov	r0, r3
 800faae:	b004      	add	sp, #16
 800fab0:	4770      	bx	lr
 800fab2:	bf00      	nop
	...

0800fac0 <queue_dequeue.lto_priv.489>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 800fac0:	b082      	sub	sp, #8
 800fac2:	9001      	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 800fac4:	9b01      	ldr	r3, [sp, #4]
 800fac6:	685b      	ldr	r3, [r3, #4]
 800fac8:	9a01      	ldr	r2, [sp, #4]
 800faca:	6812      	ldr	r2, [r2, #0]
 800facc:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800face:	9b01      	ldr	r3, [sp, #4]
 800fad0:	681b      	ldr	r3, [r3, #0]
 800fad2:	9a01      	ldr	r2, [sp, #4]
 800fad4:	6852      	ldr	r2, [r2, #4]
 800fad6:	605a      	str	r2, [r3, #4]

  return tp;
 800fad8:	9b01      	ldr	r3, [sp, #4]
}
 800fada:	4618      	mov	r0, r3
 800fadc:	b002      	add	sp, #8
 800fade:	4770      	bx	lr

0800fae0 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 800fae0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 800fae2:	f7ff fc8d 	bl	800f400 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 800fae6:	4b06      	ldr	r3, [pc, #24]	; (800fb00 <chSchIsRescRequiredI+0x20>)
 800fae8:	681b      	ldr	r3, [r3, #0]
 800faea:	689a      	ldr	r2, [r3, #8]
 800faec:	4b04      	ldr	r3, [pc, #16]	; (800fb00 <chSchIsRescRequiredI+0x20>)
 800faee:	699b      	ldr	r3, [r3, #24]
 800faf0:	689b      	ldr	r3, [r3, #8]
 800faf2:	429a      	cmp	r2, r3
 800faf4:	bf8c      	ite	hi
 800faf6:	2301      	movhi	r3, #1
 800faf8:	2300      	movls	r3, #0
 800fafa:	b2db      	uxtb	r3, r3
}
 800fafc:	4618      	mov	r0, r3
 800fafe:	bd08      	pop	{r3, pc}
 800fb00:	20001090 	.word	0x20001090
	...

0800fb10 <chSysLockFromISR.lto_priv.534>:
static inline void chSysLockFromISR(void) {
 800fb10:	b508      	push	{r3, lr}
  port_lock_from_isr();
 800fb12:	f7ff ff9d 	bl	800fa50 <port_lock_from_isr.lto_priv.443>
  _dbg_check_lock_from_isr();
 800fb16:	f7ff fc03 	bl	800f320 <_dbg_check_lock_from_isr>
}
 800fb1a:	bd08      	pop	{r3, pc}
 800fb1c:	0000      	movs	r0, r0
	...

0800fb20 <chSysUnlockFromISR.lto_priv.526>:
static inline void chSysUnlockFromISR(void) {
 800fb20:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 800fb22:	f7ff fc15 	bl	800f350 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 800fb26:	f7ff ff9b 	bl	800fa60 <port_unlock_from_isr.lto_priv.432>
}
 800fb2a:	bd08      	pop	{r3, pc}
 800fb2c:	0000      	movs	r0, r0
	...

0800fb30 <chVTIsArmedI>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 800fb30:	b500      	push	{lr}
 800fb32:	b083      	sub	sp, #12
 800fb34:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 800fb36:	f7ff fc63 	bl	800f400 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
 800fb3a:	9b01      	ldr	r3, [sp, #4]
 800fb3c:	68db      	ldr	r3, [r3, #12]
 800fb3e:	2b00      	cmp	r3, #0
 800fb40:	bf14      	ite	ne
 800fb42:	2301      	movne	r3, #1
 800fb44:	2300      	moveq	r3, #0
 800fb46:	b2db      	uxtb	r3, r3
}
 800fb48:	4618      	mov	r0, r3
 800fb4a:	b003      	add	sp, #12
 800fb4c:	f85d fb04 	ldr.w	pc, [sp], #4

0800fb50 <chSemFastSignalI>:
static inline void chSemFastSignalI(semaphore_t *sp) {
 800fb50:	b500      	push	{lr}
 800fb52:	b083      	sub	sp, #12
 800fb54:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 800fb56:	f7ff fc53 	bl	800f400 <chDbgCheckClassI>
  sp->cnt++;
 800fb5a:	9b01      	ldr	r3, [sp, #4]
 800fb5c:	689b      	ldr	r3, [r3, #8]
 800fb5e:	1c5a      	adds	r2, r3, #1
 800fb60:	9b01      	ldr	r3, [sp, #4]
 800fb62:	609a      	str	r2, [r3, #8]
}
 800fb64:	b003      	add	sp, #12
 800fb66:	f85d fb04 	ldr.w	pc, [sp], #4
 800fb6a:	bf00      	nop
 800fb6c:	0000      	movs	r0, r0
	...

0800fb70 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 800fb70:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.queue);
 800fb72:	4806      	ldr	r0, [pc, #24]	; (800fb8c <_scheduler_init+0x1c>)
 800fb74:	f7ff ff7c 	bl	800fa70 <queue_init.lto_priv.462>
  ch.rlist.prio = NOPRIO;
 800fb78:	4b04      	ldr	r3, [pc, #16]	; (800fb8c <_scheduler_init+0x1c>)
 800fb7a:	2200      	movs	r2, #0
 800fb7c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 800fb7e:	4b03      	ldr	r3, [pc, #12]	; (800fb8c <_scheduler_init+0x1c>)
 800fb80:	4a02      	ldr	r2, [pc, #8]	; (800fb8c <_scheduler_init+0x1c>)
 800fb82:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 800fb84:	4b01      	ldr	r3, [pc, #4]	; (800fb8c <_scheduler_init+0x1c>)
 800fb86:	4a01      	ldr	r2, [pc, #4]	; (800fb8c <_scheduler_init+0x1c>)
 800fb88:	615a      	str	r2, [r3, #20]
#endif
}
 800fb8a:	bd08      	pop	{r3, pc}
 800fb8c:	20001090 	.word	0x20001090

0800fb90 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 800fb90:	b500      	push	{lr}
 800fb92:	b085      	sub	sp, #20
 800fb94:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800fb96:	f7ff fc33 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800fb9a:	9b01      	ldr	r3, [sp, #4]
 800fb9c:	2b00      	cmp	r3, #0
 800fb9e:	d102      	bne.n	800fba6 <chSchReadyI+0x16>
 800fba0:	4818      	ldr	r0, [pc, #96]	; (800fc04 <chSchReadyI+0x74>)
 800fba2:	f7ff fa1d 	bl	800efe0 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800fba6:	9b01      	ldr	r3, [sp, #4]
 800fba8:	f893 3020 	ldrb.w	r3, [r3, #32]
 800fbac:	2b00      	cmp	r3, #0
 800fbae:	d004      	beq.n	800fbba <chSchReadyI+0x2a>
 800fbb0:	9b01      	ldr	r3, [sp, #4]
 800fbb2:	f893 3020 	ldrb.w	r3, [r3, #32]
 800fbb6:	2b0f      	cmp	r3, #15
 800fbb8:	d102      	bne.n	800fbc0 <chSchReadyI+0x30>
 800fbba:	4812      	ldr	r0, [pc, #72]	; (800fc04 <chSchReadyI+0x74>)
 800fbbc:	f7ff fa10 	bl	800efe0 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800fbc0:	9b01      	ldr	r3, [sp, #4]
 800fbc2:	2200      	movs	r2, #0
 800fbc4:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 800fbc8:	4b0f      	ldr	r3, [pc, #60]	; (800fc08 <chSchReadyI+0x78>)
 800fbca:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 800fbcc:	9b03      	ldr	r3, [sp, #12]
 800fbce:	681b      	ldr	r3, [r3, #0]
 800fbd0:	9303      	str	r3, [sp, #12]
  } while (cp->prio >= tp->prio);
 800fbd2:	9b03      	ldr	r3, [sp, #12]
 800fbd4:	689a      	ldr	r2, [r3, #8]
 800fbd6:	9b01      	ldr	r3, [sp, #4]
 800fbd8:	689b      	ldr	r3, [r3, #8]
 800fbda:	429a      	cmp	r2, r3
 800fbdc:	d2f6      	bcs.n	800fbcc <chSchReadyI+0x3c>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800fbde:	9b01      	ldr	r3, [sp, #4]
 800fbe0:	9a03      	ldr	r2, [sp, #12]
 800fbe2:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800fbe4:	9b03      	ldr	r3, [sp, #12]
 800fbe6:	685a      	ldr	r2, [r3, #4]
 800fbe8:	9b01      	ldr	r3, [sp, #4]
 800fbea:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800fbec:	9b01      	ldr	r3, [sp, #4]
 800fbee:	685b      	ldr	r3, [r3, #4]
 800fbf0:	9a01      	ldr	r2, [sp, #4]
 800fbf2:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800fbf4:	9b03      	ldr	r3, [sp, #12]
 800fbf6:	9a01      	ldr	r2, [sp, #4]
 800fbf8:	605a      	str	r2, [r3, #4]

  return tp;
 800fbfa:	9b01      	ldr	r3, [sp, #4]
}
 800fbfc:	4618      	mov	r0, r3
 800fbfe:	b005      	add	sp, #20
 800fc00:	f85d fb04 	ldr.w	pc, [sp], #4
 800fc04:	08016c04 	.word	0x08016c04
 800fc08:	20001090 	.word	0x20001090
 800fc0c:	00000000 	.word	0x00000000

0800fc10 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 800fc10:	b500      	push	{lr}
 800fc12:	b085      	sub	sp, #20
 800fc14:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800fc16:	f7ff fbf3 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800fc1a:	9b01      	ldr	r3, [sp, #4]
 800fc1c:	2b00      	cmp	r3, #0
 800fc1e:	d102      	bne.n	800fc26 <chSchReadyAheadI+0x16>
 800fc20:	4818      	ldr	r0, [pc, #96]	; (800fc84 <chSchReadyAheadI+0x74>)
 800fc22:	f7ff f9dd 	bl	800efe0 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800fc26:	9b01      	ldr	r3, [sp, #4]
 800fc28:	f893 3020 	ldrb.w	r3, [r3, #32]
 800fc2c:	2b00      	cmp	r3, #0
 800fc2e:	d004      	beq.n	800fc3a <chSchReadyAheadI+0x2a>
 800fc30:	9b01      	ldr	r3, [sp, #4]
 800fc32:	f893 3020 	ldrb.w	r3, [r3, #32]
 800fc36:	2b0f      	cmp	r3, #15
 800fc38:	d102      	bne.n	800fc40 <chSchReadyAheadI+0x30>
 800fc3a:	4812      	ldr	r0, [pc, #72]	; (800fc84 <chSchReadyAheadI+0x74>)
 800fc3c:	f7ff f9d0 	bl	800efe0 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800fc40:	9b01      	ldr	r3, [sp, #4]
 800fc42:	2200      	movs	r2, #0
 800fc44:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 800fc48:	4b0f      	ldr	r3, [pc, #60]	; (800fc88 <chSchReadyAheadI+0x78>)
 800fc4a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 800fc4c:	9b03      	ldr	r3, [sp, #12]
 800fc4e:	681b      	ldr	r3, [r3, #0]
 800fc50:	9303      	str	r3, [sp, #12]
  } while (cp->prio > tp->prio);
 800fc52:	9b03      	ldr	r3, [sp, #12]
 800fc54:	689a      	ldr	r2, [r3, #8]
 800fc56:	9b01      	ldr	r3, [sp, #4]
 800fc58:	689b      	ldr	r3, [r3, #8]
 800fc5a:	429a      	cmp	r2, r3
 800fc5c:	d8f6      	bhi.n	800fc4c <chSchReadyAheadI+0x3c>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800fc5e:	9b01      	ldr	r3, [sp, #4]
 800fc60:	9a03      	ldr	r2, [sp, #12]
 800fc62:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800fc64:	9b03      	ldr	r3, [sp, #12]
 800fc66:	685a      	ldr	r2, [r3, #4]
 800fc68:	9b01      	ldr	r3, [sp, #4]
 800fc6a:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800fc6c:	9b01      	ldr	r3, [sp, #4]
 800fc6e:	685b      	ldr	r3, [r3, #4]
 800fc70:	9a01      	ldr	r2, [sp, #4]
 800fc72:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800fc74:	9b03      	ldr	r3, [sp, #12]
 800fc76:	9a01      	ldr	r2, [sp, #4]
 800fc78:	605a      	str	r2, [r3, #4]

  return tp;
 800fc7a:	9b01      	ldr	r3, [sp, #4]
}
 800fc7c:	4618      	mov	r0, r3
 800fc7e:	b005      	add	sp, #20
 800fc80:	f85d fb04 	ldr.w	pc, [sp], #4
 800fc84:	08016c10 	.word	0x08016c10
 800fc88:	20001090 	.word	0x20001090
 800fc8c:	00000000 	.word	0x00000000

0800fc90 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800fc90:	b500      	push	{lr}
 800fc92:	b087      	sub	sp, #28
 800fc94:	4603      	mov	r3, r0
 800fc96:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp = currp;
 800fc9a:	4b19      	ldr	r3, [pc, #100]	; (800fd00 <chSchGoSleepS+0x70>)
 800fc9c:	699b      	ldr	r3, [r3, #24]
 800fc9e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassS();
 800fca0:	f7ff fbc6 	bl	800f430 <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 800fca4:	9b05      	ldr	r3, [sp, #20]
 800fca6:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800fcaa:	f883 2020 	strb.w	r2, [r3, #32]
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800fcae:	4814      	ldr	r0, [pc, #80]	; (800fd00 <chSchGoSleepS+0x70>)
 800fcb0:	f7ff feee 	bl	800fa90 <queue_fifo_remove.lto_priv.468>
 800fcb4:	4602      	mov	r2, r0
 800fcb6:	4b12      	ldr	r3, [pc, #72]	; (800fd00 <chSchGoSleepS+0x70>)
 800fcb8:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800fcba:	4b11      	ldr	r3, [pc, #68]	; (800fd00 <chSchGoSleepS+0x70>)
 800fcbc:	699b      	ldr	r3, [r3, #24]
 800fcbe:	2201      	movs	r2, #1
 800fcc0:	f883 2020 	strb.w	r2, [r3, #32]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800fcc4:	4b0e      	ldr	r3, [pc, #56]	; (800fd00 <chSchGoSleepS+0x70>)
 800fcc6:	699b      	ldr	r3, [r3, #24]
 800fcc8:	9905      	ldr	r1, [sp, #20]
 800fcca:	4618      	mov	r0, r3
 800fccc:	f7ff fc58 	bl	800f580 <_trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800fcd0:	f3ef 8309 	mrs	r3, PSP
 800fcd4:	9303      	str	r3, [sp, #12]
  return(result);
 800fcd6:	9b03      	ldr	r3, [sp, #12]
 800fcd8:	9304      	str	r3, [sp, #16]
 800fcda:	9b04      	ldr	r3, [sp, #16]
 800fcdc:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800fce0:	9b05      	ldr	r3, [sp, #20]
 800fce2:	69db      	ldr	r3, [r3, #28]
 800fce4:	429a      	cmp	r2, r3
 800fce6:	d202      	bcs.n	800fcee <chSchGoSleepS+0x5e>
 800fce8:	4806      	ldr	r0, [pc, #24]	; (800fd04 <chSchGoSleepS+0x74>)
 800fcea:	f7ff f979 	bl	800efe0 <chSysHalt>
 800fcee:	4b04      	ldr	r3, [pc, #16]	; (800fd00 <chSchGoSleepS+0x70>)
 800fcf0:	699b      	ldr	r3, [r3, #24]
 800fcf2:	9905      	ldr	r1, [sp, #20]
 800fcf4:	4618      	mov	r0, r3
 800fcf6:	f7f0 faf3 	bl	80002e0 <_port_switch>
}
 800fcfa:	b007      	add	sp, #28
 800fcfc:	f85d fb04 	ldr.w	pc, [sp], #4
 800fd00:	20001090 	.word	0x20001090
 800fd04:	08018e20 	.word	0x08018e20
	...

0800fd10 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 800fd10:	b500      	push	{lr}
 800fd12:	b085      	sub	sp, #20
 800fd14:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 800fd16:	9b01      	ldr	r3, [sp, #4]
 800fd18:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 800fd1a:	f7ff fef9 	bl	800fb10 <chSysLockFromISR.lto_priv.534>
  switch (tp->state) {
 800fd1e:	9b03      	ldr	r3, [sp, #12]
 800fd20:	f893 3020 	ldrb.w	r3, [r3, #32]
 800fd24:	2b07      	cmp	r3, #7
 800fd26:	d823      	bhi.n	800fd70 <wakeup+0x60>
 800fd28:	a201      	add	r2, pc, #4	; (adr r2, 800fd30 <wakeup+0x20>)
 800fd2a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fd2e:	bf00      	nop
 800fd30:	0800fd51 	.word	0x0800fd51
 800fd34:	0800fd71 	.word	0x0800fd71
 800fd38:	0800fd71 	.word	0x0800fd71
 800fd3c:	0800fd57 	.word	0x0800fd57
 800fd40:	0800fd6b 	.word	0x0800fd6b
 800fd44:	0800fd61 	.word	0x0800fd61
 800fd48:	0800fd71 	.word	0x0800fd71
 800fd4c:	0800fd6b 	.word	0x0800fd6b
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 800fd50:	f7ff fee6 	bl	800fb20 <chSysUnlockFromISR.lto_priv.526>
 800fd54:	e015      	b.n	800fd82 <wakeup+0x72>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800fd56:	9b03      	ldr	r3, [sp, #12]
 800fd58:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800fd5a:	2200      	movs	r2, #0
 800fd5c:	601a      	str	r2, [r3, #0]
 800fd5e:	e007      	b.n	800fd70 <wakeup+0x60>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 800fd60:	9b03      	ldr	r3, [sp, #12]
 800fd62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800fd64:	4618      	mov	r0, r3
 800fd66:	f7ff fef3 	bl	800fb50 <chSemFastSignalI>
    /* Falls through.*/
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 800fd6a:	9803      	ldr	r0, [sp, #12]
 800fd6c:	f7ff fea8 	bl	800fac0 <queue_dequeue.lto_priv.489>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800fd70:	9b03      	ldr	r3, [sp, #12]
 800fd72:	f04f 32ff 	mov.w	r2, #4294967295
 800fd76:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800fd78:	9803      	ldr	r0, [sp, #12]
 800fd7a:	f7ff ff09 	bl	800fb90 <chSchReadyI>
  chSysUnlockFromISR();
 800fd7e:	f7ff fecf 	bl	800fb20 <chSysUnlockFromISR.lto_priv.526>
}
 800fd82:	b005      	add	sp, #20
 800fd84:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800fd90 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 800fd90:	b500      	push	{lr}
 800fd92:	b089      	sub	sp, #36	; 0x24
 800fd94:	4603      	mov	r3, r0
 800fd96:	9100      	str	r1, [sp, #0]
 800fd98:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
 800fd9c:	f7ff fb48 	bl	800f430 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 800fda0:	9b00      	ldr	r3, [sp, #0]
 800fda2:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fda6:	d017      	beq.n	800fdd8 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
 800fda8:	4b11      	ldr	r3, [pc, #68]	; (800fdf0 <chSchGoSleepTimeoutS+0x60>)
 800fdaa:	699b      	ldr	r3, [r3, #24]
 800fdac:	a803      	add	r0, sp, #12
 800fdae:	4a11      	ldr	r2, [pc, #68]	; (800fdf4 <chSchGoSleepTimeoutS+0x64>)
 800fdb0:	9900      	ldr	r1, [sp, #0]
 800fdb2:	f7ff fd05 	bl	800f7c0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800fdb6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800fdba:	4618      	mov	r0, r3
 800fdbc:	f7ff ff68 	bl	800fc90 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800fdc0:	ab03      	add	r3, sp, #12
 800fdc2:	4618      	mov	r0, r3
 800fdc4:	f7ff feb4 	bl	800fb30 <chVTIsArmedI>
 800fdc8:	4603      	mov	r3, r0
 800fdca:	2b00      	cmp	r3, #0
 800fdcc:	d009      	beq.n	800fde2 <chSchGoSleepTimeoutS+0x52>
      chVTDoResetI(&vt);
 800fdce:	ab03      	add	r3, sp, #12
 800fdd0:	4618      	mov	r0, r3
 800fdd2:	f7ff fda5 	bl	800f920 <chVTDoResetI>
 800fdd6:	e004      	b.n	800fde2 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
 800fdd8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800fddc:	4618      	mov	r0, r3
 800fdde:	f7ff ff57 	bl	800fc90 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 800fde2:	4b03      	ldr	r3, [pc, #12]	; (800fdf0 <chSchGoSleepTimeoutS+0x60>)
 800fde4:	699b      	ldr	r3, [r3, #24]
 800fde6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800fde8:	4618      	mov	r0, r3
 800fdea:	b009      	add	sp, #36	; 0x24
 800fdec:	f85d fb04 	ldr.w	pc, [sp], #4
 800fdf0:	20001090 	.word	0x20001090
 800fdf4:	0800fd11 	.word	0x0800fd11
	...

0800fe00 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800fe00:	b500      	push	{lr}
 800fe02:	b087      	sub	sp, #28
 800fe04:	9001      	str	r0, [sp, #4]
 800fe06:	9100      	str	r1, [sp, #0]
  thread_t *otp = currp;
 800fe08:	4b23      	ldr	r3, [pc, #140]	; (800fe98 <chSchWakeupS+0x98>)
 800fe0a:	699b      	ldr	r3, [r3, #24]
 800fe0c:	9305      	str	r3, [sp, #20]

  chDbgCheckClassS();
 800fe0e:	f7ff fb0f 	bl	800f430 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800fe12:	4b21      	ldr	r3, [pc, #132]	; (800fe98 <chSchWakeupS+0x98>)
 800fe14:	681b      	ldr	r3, [r3, #0]
 800fe16:	4a20      	ldr	r2, [pc, #128]	; (800fe98 <chSchWakeupS+0x98>)
 800fe18:	4293      	cmp	r3, r2
 800fe1a:	d00a      	beq.n	800fe32 <chSchWakeupS+0x32>
 800fe1c:	4b1e      	ldr	r3, [pc, #120]	; (800fe98 <chSchWakeupS+0x98>)
 800fe1e:	699b      	ldr	r3, [r3, #24]
 800fe20:	689a      	ldr	r2, [r3, #8]
 800fe22:	4b1d      	ldr	r3, [pc, #116]	; (800fe98 <chSchWakeupS+0x98>)
 800fe24:	681b      	ldr	r3, [r3, #0]
 800fe26:	689b      	ldr	r3, [r3, #8]
 800fe28:	429a      	cmp	r2, r3
 800fe2a:	d202      	bcs.n	800fe32 <chSchWakeupS+0x32>
 800fe2c:	481b      	ldr	r0, [pc, #108]	; (800fe9c <chSchWakeupS+0x9c>)
 800fe2e:	f7ff f8d7 	bl	800efe0 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800fe32:	9b01      	ldr	r3, [sp, #4]
 800fe34:	9a00      	ldr	r2, [sp, #0]
 800fe36:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800fe38:	9b01      	ldr	r3, [sp, #4]
 800fe3a:	689a      	ldr	r2, [r3, #8]
 800fe3c:	9b05      	ldr	r3, [sp, #20]
 800fe3e:	689b      	ldr	r3, [r3, #8]
 800fe40:	429a      	cmp	r2, r3
 800fe42:	d803      	bhi.n	800fe4c <chSchWakeupS+0x4c>
    (void) chSchReadyI(ntp);
 800fe44:	9801      	ldr	r0, [sp, #4]
 800fe46:	f7ff fea3 	bl	800fb90 <chSchReadyI>
 800fe4a:	e021      	b.n	800fe90 <chSchWakeupS+0x90>
  }
  else {
    otp = chSchReadyI(otp);
 800fe4c:	9805      	ldr	r0, [sp, #20]
 800fe4e:	f7ff fe9f 	bl	800fb90 <chSchReadyI>
 800fe52:	9005      	str	r0, [sp, #20]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 800fe54:	4a10      	ldr	r2, [pc, #64]	; (800fe98 <chSchWakeupS+0x98>)
 800fe56:	9b01      	ldr	r3, [sp, #4]
 800fe58:	6193      	str	r3, [r2, #24]
    ntp->state = CH_STATE_CURRENT;
 800fe5a:	9b01      	ldr	r3, [sp, #4]
 800fe5c:	2201      	movs	r2, #1
 800fe5e:	f883 2020 	strb.w	r2, [r3, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800fe62:	9905      	ldr	r1, [sp, #20]
 800fe64:	9801      	ldr	r0, [sp, #4]
 800fe66:	f7ff fb8b 	bl	800f580 <_trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800fe6a:	f3ef 8309 	mrs	r3, PSP
 800fe6e:	9303      	str	r3, [sp, #12]
  return(result);
 800fe70:	9b03      	ldr	r3, [sp, #12]
 800fe72:	9304      	str	r3, [sp, #16]
 800fe74:	9b04      	ldr	r3, [sp, #16]
 800fe76:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800fe7a:	9b05      	ldr	r3, [sp, #20]
 800fe7c:	69db      	ldr	r3, [r3, #28]
 800fe7e:	429a      	cmp	r2, r3
 800fe80:	d202      	bcs.n	800fe88 <chSchWakeupS+0x88>
 800fe82:	4807      	ldr	r0, [pc, #28]	; (800fea0 <chSchWakeupS+0xa0>)
 800fe84:	f7ff f8ac 	bl	800efe0 <chSysHalt>
 800fe88:	9905      	ldr	r1, [sp, #20]
 800fe8a:	9801      	ldr	r0, [sp, #4]
 800fe8c:	f7f0 fa28 	bl	80002e0 <_port_switch>
  }
}
 800fe90:	b007      	add	sp, #28
 800fe92:	f85d fb04 	ldr.w	pc, [sp], #4
 800fe96:	bf00      	nop
 800fe98:	20001090 	.word	0x20001090
 800fe9c:	08016c24 	.word	0x08016c24
 800fea0:	08018e20 	.word	0x08018e20
	...

0800feb0 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 800feb0:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 800feb2:	f7ff fabd 	bl	800f430 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 800feb6:	f7ff fe13 	bl	800fae0 <chSchIsRescRequiredI>
 800feba:	4603      	mov	r3, r0
 800febc:	2b00      	cmp	r3, #0
 800febe:	d001      	beq.n	800fec4 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
 800fec0:	f000 f856 	bl	800ff70 <chSchDoRescheduleAhead>
  }
}
 800fec4:	bd08      	pop	{r3, pc}
 800fec6:	bf00      	nop
	...

0800fed0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 800fed0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.queue);
 800fed2:	4b09      	ldr	r3, [pc, #36]	; (800fef8 <chSchIsPreemptionRequired+0x28>)
 800fed4:	681b      	ldr	r3, [r3, #0]
 800fed6:	689b      	ldr	r3, [r3, #8]
 800fed8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->prio;
 800feda:	4b07      	ldr	r3, [pc, #28]	; (800fef8 <chSchIsPreemptionRequired+0x28>)
 800fedc:	699b      	ldr	r3, [r3, #24]
 800fede:	689b      	ldr	r3, [r3, #8]
 800fee0:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800fee2:	9a01      	ldr	r2, [sp, #4]
 800fee4:	9b00      	ldr	r3, [sp, #0]
 800fee6:	429a      	cmp	r2, r3
 800fee8:	bf8c      	ite	hi
 800feea:	2301      	movhi	r3, #1
 800feec:	2300      	movls	r3, #0
 800feee:	b2db      	uxtb	r3, r3
#endif
}
 800fef0:	4618      	mov	r0, r3
 800fef2:	b002      	add	sp, #8
 800fef4:	4770      	bx	lr
 800fef6:	bf00      	nop
 800fef8:	20001090 	.word	0x20001090
 800fefc:	00000000 	.word	0x00000000

0800ff00 <chSchDoRescheduleBehind>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 800ff00:	b500      	push	{lr}
 800ff02:	b085      	sub	sp, #20
  thread_t *otp = currp;
 800ff04:	4b17      	ldr	r3, [pc, #92]	; (800ff64 <chSchDoRescheduleBehind+0x64>)
 800ff06:	699b      	ldr	r3, [r3, #24]
 800ff08:	9303      	str	r3, [sp, #12]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800ff0a:	4816      	ldr	r0, [pc, #88]	; (800ff64 <chSchDoRescheduleBehind+0x64>)
 800ff0c:	f7ff fdc0 	bl	800fa90 <queue_fifo_remove.lto_priv.468>
 800ff10:	4602      	mov	r2, r0
 800ff12:	4b14      	ldr	r3, [pc, #80]	; (800ff64 <chSchDoRescheduleBehind+0x64>)
 800ff14:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800ff16:	4b13      	ldr	r3, [pc, #76]	; (800ff64 <chSchDoRescheduleBehind+0x64>)
 800ff18:	699b      	ldr	r3, [r3, #24]
 800ff1a:	2201      	movs	r2, #1
 800ff1c:	f883 2020 	strb.w	r2, [r3, #32]
  /* It went behind peers so it gets a new time quantum.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);
 800ff20:	9803      	ldr	r0, [sp, #12]
 800ff22:	f7ff fe35 	bl	800fb90 <chSchReadyI>
 800ff26:	9003      	str	r0, [sp, #12]

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800ff28:	4b0e      	ldr	r3, [pc, #56]	; (800ff64 <chSchDoRescheduleBehind+0x64>)
 800ff2a:	699b      	ldr	r3, [r3, #24]
 800ff2c:	9903      	ldr	r1, [sp, #12]
 800ff2e:	4618      	mov	r0, r3
 800ff30:	f7ff fb26 	bl	800f580 <_trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800ff34:	f3ef 8309 	mrs	r3, PSP
 800ff38:	9301      	str	r3, [sp, #4]
  return(result);
 800ff3a:	9b01      	ldr	r3, [sp, #4]
 800ff3c:	9302      	str	r3, [sp, #8]
 800ff3e:	9b02      	ldr	r3, [sp, #8]
 800ff40:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800ff44:	9b03      	ldr	r3, [sp, #12]
 800ff46:	69db      	ldr	r3, [r3, #28]
 800ff48:	429a      	cmp	r2, r3
 800ff4a:	d202      	bcs.n	800ff52 <chSchDoRescheduleBehind+0x52>
 800ff4c:	4806      	ldr	r0, [pc, #24]	; (800ff68 <chSchDoRescheduleBehind+0x68>)
 800ff4e:	f7ff f847 	bl	800efe0 <chSysHalt>
 800ff52:	4b04      	ldr	r3, [pc, #16]	; (800ff64 <chSchDoRescheduleBehind+0x64>)
 800ff54:	699b      	ldr	r3, [r3, #24]
 800ff56:	9903      	ldr	r1, [sp, #12]
 800ff58:	4618      	mov	r0, r3
 800ff5a:	f7f0 f9c1 	bl	80002e0 <_port_switch>
}
 800ff5e:	b005      	add	sp, #20
 800ff60:	f85d fb04 	ldr.w	pc, [sp], #4
 800ff64:	20001090 	.word	0x20001090
 800ff68:	08018e20 	.word	0x08018e20
 800ff6c:	00000000 	.word	0x00000000

0800ff70 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 800ff70:	b500      	push	{lr}
 800ff72:	b085      	sub	sp, #20
  thread_t *otp = currp;
 800ff74:	4b17      	ldr	r3, [pc, #92]	; (800ffd4 <chSchDoRescheduleAhead+0x64>)
 800ff76:	699b      	ldr	r3, [r3, #24]
 800ff78:	9303      	str	r3, [sp, #12]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800ff7a:	4816      	ldr	r0, [pc, #88]	; (800ffd4 <chSchDoRescheduleAhead+0x64>)
 800ff7c:	f7ff fd88 	bl	800fa90 <queue_fifo_remove.lto_priv.468>
 800ff80:	4602      	mov	r2, r0
 800ff82:	4b14      	ldr	r3, [pc, #80]	; (800ffd4 <chSchDoRescheduleAhead+0x64>)
 800ff84:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800ff86:	4b13      	ldr	r3, [pc, #76]	; (800ffd4 <chSchDoRescheduleAhead+0x64>)
 800ff88:	699b      	ldr	r3, [r3, #24]
 800ff8a:	2201      	movs	r2, #1
 800ff8c:	f883 2020 	strb.w	r2, [r3, #32]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 800ff90:	9803      	ldr	r0, [sp, #12]
 800ff92:	f7ff fe3d 	bl	800fc10 <chSchReadyAheadI>
 800ff96:	9003      	str	r0, [sp, #12]

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800ff98:	4b0e      	ldr	r3, [pc, #56]	; (800ffd4 <chSchDoRescheduleAhead+0x64>)
 800ff9a:	699b      	ldr	r3, [r3, #24]
 800ff9c:	9903      	ldr	r1, [sp, #12]
 800ff9e:	4618      	mov	r0, r3
 800ffa0:	f7ff faee 	bl	800f580 <_trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800ffa4:	f3ef 8309 	mrs	r3, PSP
 800ffa8:	9301      	str	r3, [sp, #4]
  return(result);
 800ffaa:	9b01      	ldr	r3, [sp, #4]
 800ffac:	9302      	str	r3, [sp, #8]
 800ffae:	9b02      	ldr	r3, [sp, #8]
 800ffb0:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800ffb4:	9b03      	ldr	r3, [sp, #12]
 800ffb6:	69db      	ldr	r3, [r3, #28]
 800ffb8:	429a      	cmp	r2, r3
 800ffba:	d202      	bcs.n	800ffc2 <chSchDoRescheduleAhead+0x52>
 800ffbc:	4806      	ldr	r0, [pc, #24]	; (800ffd8 <chSchDoRescheduleAhead+0x68>)
 800ffbe:	f7ff f80f 	bl	800efe0 <chSysHalt>
 800ffc2:	4b04      	ldr	r3, [pc, #16]	; (800ffd4 <chSchDoRescheduleAhead+0x64>)
 800ffc4:	699b      	ldr	r3, [r3, #24]
 800ffc6:	9903      	ldr	r1, [sp, #12]
 800ffc8:	4618      	mov	r0, r3
 800ffca:	f7f0 f989 	bl	80002e0 <_port_switch>
}
 800ffce:	b005      	add	sp, #20
 800ffd0:	f85d fb04 	ldr.w	pc, [sp], #4
 800ffd4:	20001090 	.word	0x20001090
 800ffd8:	08018e20 	.word	0x08018e20
 800ffdc:	00000000 	.word	0x00000000

0800ffe0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 800ffe0:	b500      	push	{lr}
 800ffe2:	b085      	sub	sp, #20
  thread_t *otp = currp;
 800ffe4:	4b17      	ldr	r3, [pc, #92]	; (8010044 <chSchDoReschedule+0x64>)
 800ffe6:	699b      	ldr	r3, [r3, #24]
 800ffe8:	9303      	str	r3, [sp, #12]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800ffea:	4816      	ldr	r0, [pc, #88]	; (8010044 <chSchDoReschedule+0x64>)
 800ffec:	f7ff fd50 	bl	800fa90 <queue_fifo_remove.lto_priv.468>
 800fff0:	4602      	mov	r2, r0
 800fff2:	4b14      	ldr	r3, [pc, #80]	; (8010044 <chSchDoReschedule+0x64>)
 800fff4:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800fff6:	4b13      	ldr	r3, [pc, #76]	; (8010044 <chSchDoReschedule+0x64>)
 800fff8:	699b      	ldr	r3, [r3, #24]
 800fffa:	2201      	movs	r2, #1
 800fffc:	f883 2020 	strb.w	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8010000:	9803      	ldr	r0, [sp, #12]
 8010002:	f7ff fe05 	bl	800fc10 <chSchReadyAheadI>
 8010006:	9003      	str	r0, [sp, #12]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8010008:	4b0e      	ldr	r3, [pc, #56]	; (8010044 <chSchDoReschedule+0x64>)
 801000a:	699b      	ldr	r3, [r3, #24]
 801000c:	9903      	ldr	r1, [sp, #12]
 801000e:	4618      	mov	r0, r3
 8010010:	f7ff fab6 	bl	800f580 <_trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8010014:	f3ef 8309 	mrs	r3, PSP
 8010018:	9301      	str	r3, [sp, #4]
  return(result);
 801001a:	9b01      	ldr	r3, [sp, #4]
 801001c:	9302      	str	r3, [sp, #8]
 801001e:	9b02      	ldr	r3, [sp, #8]
 8010020:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8010024:	9b03      	ldr	r3, [sp, #12]
 8010026:	69db      	ldr	r3, [r3, #28]
 8010028:	429a      	cmp	r2, r3
 801002a:	d202      	bcs.n	8010032 <chSchDoReschedule+0x52>
 801002c:	4806      	ldr	r0, [pc, #24]	; (8010048 <chSchDoReschedule+0x68>)
 801002e:	f7fe ffd7 	bl	800efe0 <chSysHalt>
 8010032:	4b04      	ldr	r3, [pc, #16]	; (8010044 <chSchDoReschedule+0x64>)
 8010034:	699b      	ldr	r3, [r3, #24]
 8010036:	9903      	ldr	r1, [sp, #12]
 8010038:	4618      	mov	r0, r3
 801003a:	f7f0 f951 	bl	80002e0 <_port_switch>
}
 801003e:	b005      	add	sp, #20
 8010040:	f85d fb04 	ldr.w	pc, [sp], #4
 8010044:	20001090 	.word	0x20001090
 8010048:	08018e20 	.word	0x08018e20
 801004c:	00000000 	.word	0x00000000

08010050 <chTimeDiffX.lto_priv.516>:
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8010050:	b082      	sub	sp, #8
 8010052:	9001      	str	r0, [sp, #4]
 8010054:	9100      	str	r1, [sp, #0]
  return (sysinterval_t)((systime_t)(end - start));
 8010056:	9a00      	ldr	r2, [sp, #0]
 8010058:	9b01      	ldr	r3, [sp, #4]
 801005a:	1ad3      	subs	r3, r2, r3
}
 801005c:	4618      	mov	r0, r3
 801005e:	b002      	add	sp, #8
 8010060:	4770      	bx	lr
 8010062:	bf00      	nop
	...

08010070 <port_lock.lto_priv.397>:
static inline void port_lock(void) {
 8010070:	b082      	sub	sp, #8
 8010072:	2320      	movs	r3, #32
 8010074:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010076:	9b01      	ldr	r3, [sp, #4]
 8010078:	f383 8811 	msr	BASEPRI, r3
}
 801007c:	b002      	add	sp, #8
 801007e:	4770      	bx	lr

08010080 <port_unlock.lto_priv.366>:
static inline void port_unlock(void) {
 8010080:	b082      	sub	sp, #8
 8010082:	2300      	movs	r3, #0
 8010084:	9301      	str	r3, [sp, #4]
 8010086:	9b01      	ldr	r3, [sp, #4]
 8010088:	f383 8811 	msr	BASEPRI, r3
}
 801008c:	b002      	add	sp, #8
 801008e:	4770      	bx	lr

08010090 <st_lld_get_counter.lto_priv.347>:
  return (systime_t)STM32_ST_TIM->CNT;
 8010090:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8010094:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8010096:	4618      	mov	r0, r3
 8010098:	4770      	bx	lr
 801009a:	bf00      	nop
 801009c:	0000      	movs	r0, r0
	...

080100a0 <port_timer_get_time.lto_priv.341>:
static inline systime_t port_timer_get_time(void) {
 80100a0:	b508      	push	{r3, lr}
  return stGetCounter();
 80100a2:	f7ff fff5 	bl	8010090 <st_lld_get_counter.lto_priv.347>
 80100a6:	4603      	mov	r3, r0
}
 80100a8:	4618      	mov	r0, r3
 80100aa:	bd08      	pop	{r3, pc}
 80100ac:	0000      	movs	r0, r0
	...

080100b0 <list_init>:
static inline void list_init(threads_list_t *tlp) {
 80100b0:	b082      	sub	sp, #8
 80100b2:	9001      	str	r0, [sp, #4]
  tlp->next = (thread_t *)tlp;
 80100b4:	9b01      	ldr	r3, [sp, #4]
 80100b6:	9a01      	ldr	r2, [sp, #4]
 80100b8:	601a      	str	r2, [r3, #0]
}
 80100ba:	b002      	add	sp, #8
 80100bc:	4770      	bx	lr
 80100be:	bf00      	nop

080100c0 <list_notempty>:
static inline bool list_notempty(threads_list_t *tlp) {
 80100c0:	b082      	sub	sp, #8
 80100c2:	9001      	str	r0, [sp, #4]
  return (bool)(tlp->next != (thread_t *)tlp);
 80100c4:	9b01      	ldr	r3, [sp, #4]
 80100c6:	681b      	ldr	r3, [r3, #0]
 80100c8:	9a01      	ldr	r2, [sp, #4]
 80100ca:	429a      	cmp	r2, r3
 80100cc:	bf14      	ite	ne
 80100ce:	2301      	movne	r3, #1
 80100d0:	2300      	moveq	r3, #0
 80100d2:	b2db      	uxtb	r3, r3
}
 80100d4:	4618      	mov	r0, r3
 80100d6:	b002      	add	sp, #8
 80100d8:	4770      	bx	lr
 80100da:	bf00      	nop
 80100dc:	0000      	movs	r0, r0
	...

080100e0 <queue_init.lto_priv.463>:
static inline void queue_init(threads_queue_t *tqp) {
 80100e0:	b082      	sub	sp, #8
 80100e2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80100e4:	9b01      	ldr	r3, [sp, #4]
 80100e6:	9a01      	ldr	r2, [sp, #4]
 80100e8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80100ea:	9b01      	ldr	r3, [sp, #4]
 80100ec:	9a01      	ldr	r2, [sp, #4]
 80100ee:	605a      	str	r2, [r3, #4]
}
 80100f0:	b002      	add	sp, #8
 80100f2:	4770      	bx	lr
	...

08010100 <queue_notempty.lto_priv.483>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8010100:	b082      	sub	sp, #8
 8010102:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next != (const thread_t *)tqp);
 8010104:	9b01      	ldr	r3, [sp, #4]
 8010106:	681b      	ldr	r3, [r3, #0]
 8010108:	9a01      	ldr	r2, [sp, #4]
 801010a:	429a      	cmp	r2, r3
 801010c:	bf14      	ite	ne
 801010e:	2301      	movne	r3, #1
 8010110:	2300      	moveq	r3, #0
 8010112:	b2db      	uxtb	r3, r3
}
 8010114:	4618      	mov	r0, r3
 8010116:	b002      	add	sp, #8
 8010118:	4770      	bx	lr
 801011a:	bf00      	nop
 801011c:	0000      	movs	r0, r0
	...

08010120 <list_insert>:
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
 8010120:	b082      	sub	sp, #8
 8010122:	9001      	str	r0, [sp, #4]
 8010124:	9100      	str	r1, [sp, #0]
  tp->queue.next = tlp->next;
 8010126:	9b00      	ldr	r3, [sp, #0]
 8010128:	681a      	ldr	r2, [r3, #0]
 801012a:	9b01      	ldr	r3, [sp, #4]
 801012c:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
 801012e:	9b00      	ldr	r3, [sp, #0]
 8010130:	9a01      	ldr	r2, [sp, #4]
 8010132:	601a      	str	r2, [r3, #0]
}
 8010134:	b002      	add	sp, #8
 8010136:	4770      	bx	lr
	...

08010140 <list_remove>:
static inline thread_t *list_remove(threads_list_t *tlp) {
 8010140:	b084      	sub	sp, #16
 8010142:	9001      	str	r0, [sp, #4]
  thread_t *tp = tlp->next;
 8010144:	9b01      	ldr	r3, [sp, #4]
 8010146:	681b      	ldr	r3, [r3, #0]
 8010148:	9303      	str	r3, [sp, #12]
  tlp->next = tp->queue.next;
 801014a:	9b03      	ldr	r3, [sp, #12]
 801014c:	681a      	ldr	r2, [r3, #0]
 801014e:	9b01      	ldr	r3, [sp, #4]
 8010150:	601a      	str	r2, [r3, #0]
  return tp;
 8010152:	9b03      	ldr	r3, [sp, #12]
}
 8010154:	4618      	mov	r0, r3
 8010156:	b004      	add	sp, #16
 8010158:	4770      	bx	lr
 801015a:	bf00      	nop
 801015c:	0000      	movs	r0, r0
	...

08010160 <queue_insert.lto_priv.474>:
static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8010160:	b082      	sub	sp, #8
 8010162:	9001      	str	r0, [sp, #4]
 8010164:	9100      	str	r1, [sp, #0]
  tp->queue.next             = (thread_t *)tqp;
 8010166:	9b01      	ldr	r3, [sp, #4]
 8010168:	9a00      	ldr	r2, [sp, #0]
 801016a:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 801016c:	9b00      	ldr	r3, [sp, #0]
 801016e:	685a      	ldr	r2, [r3, #4]
 8010170:	9b01      	ldr	r3, [sp, #4]
 8010172:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8010174:	9b01      	ldr	r3, [sp, #4]
 8010176:	685b      	ldr	r3, [r3, #4]
 8010178:	9a01      	ldr	r2, [sp, #4]
 801017a:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 801017c:	9b00      	ldr	r3, [sp, #0]
 801017e:	9a01      	ldr	r2, [sp, #4]
 8010180:	605a      	str	r2, [r3, #4]
}
 8010182:	b002      	add	sp, #8
 8010184:	4770      	bx	lr
 8010186:	bf00      	nop
	...

08010190 <queue_fifo_remove.lto_priv.469>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8010190:	b084      	sub	sp, #16
 8010192:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8010194:	9b01      	ldr	r3, [sp, #4]
 8010196:	681b      	ldr	r3, [r3, #0]
 8010198:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 801019a:	9b03      	ldr	r3, [sp, #12]
 801019c:	681a      	ldr	r2, [r3, #0]
 801019e:	9b01      	ldr	r3, [sp, #4]
 80101a0:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80101a2:	9b01      	ldr	r3, [sp, #4]
 80101a4:	681b      	ldr	r3, [r3, #0]
 80101a6:	9a01      	ldr	r2, [sp, #4]
 80101a8:	605a      	str	r2, [r3, #4]
  return tp;
 80101aa:	9b03      	ldr	r3, [sp, #12]
}
 80101ac:	4618      	mov	r0, r3
 80101ae:	b004      	add	sp, #16
 80101b0:	4770      	bx	lr
 80101b2:	bf00      	nop
	...

080101c0 <chSchCanYieldS>:
 * @retval false        if yielding is not possible.
 * @retval true         if there is a ready thread at equal or higher priority.
 *
 * @sclass
 */
static inline bool chSchCanYieldS(void) {
 80101c0:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 80101c2:	f7ff f935 	bl	800f430 <chDbgCheckClassS>

  return firstprio(&ch.rlist.queue) >= currp->prio;
 80101c6:	4b06      	ldr	r3, [pc, #24]	; (80101e0 <chSchCanYieldS+0x20>)
 80101c8:	681b      	ldr	r3, [r3, #0]
 80101ca:	689a      	ldr	r2, [r3, #8]
 80101cc:	4b04      	ldr	r3, [pc, #16]	; (80101e0 <chSchCanYieldS+0x20>)
 80101ce:	699b      	ldr	r3, [r3, #24]
 80101d0:	689b      	ldr	r3, [r3, #8]
 80101d2:	429a      	cmp	r2, r3
 80101d4:	bf2c      	ite	cs
 80101d6:	2301      	movcs	r3, #1
 80101d8:	2300      	movcc	r3, #0
 80101da:	b2db      	uxtb	r3, r3
}
 80101dc:	4618      	mov	r0, r3
 80101de:	bd08      	pop	{r3, pc}
 80101e0:	20001090 	.word	0x20001090
	...

080101f0 <chSchDoYieldS>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal or higher priority, if any.
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {
 80101f0:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 80101f2:	f7ff f91d 	bl	800f430 <chDbgCheckClassS>

  if (chSchCanYieldS()) {
 80101f6:	f7ff ffe3 	bl	80101c0 <chSchCanYieldS>
 80101fa:	4603      	mov	r3, r0
 80101fc:	2b00      	cmp	r3, #0
 80101fe:	d001      	beq.n	8010204 <chSchDoYieldS+0x14>
    chSchDoRescheduleBehind();
 8010200:	f7ff fe7e 	bl	800ff00 <chSchDoRescheduleBehind>
  }
}
 8010204:	bd08      	pop	{r3, pc}
 8010206:	bf00      	nop
	...

08010210 <chSysLock.lto_priv.323>:
static inline void chSysLock(void) {
 8010210:	b508      	push	{r3, lr}
  port_lock();
 8010212:	f7ff ff2d 	bl	8010070 <port_lock.lto_priv.397>
  _dbg_check_lock();
 8010216:	f7ff f853 	bl	800f2c0 <_dbg_check_lock>
}
 801021a:	bd08      	pop	{r3, pc}
 801021c:	0000      	movs	r0, r0
	...

08010220 <chSysUnlock.lto_priv.299>:
static inline void chSysUnlock(void) {
 8010220:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8010222:	f7ff f865 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8010226:	4b09      	ldr	r3, [pc, #36]	; (801024c <chSysUnlock.lto_priv.299+0x2c>)
 8010228:	681b      	ldr	r3, [r3, #0]
 801022a:	4a08      	ldr	r2, [pc, #32]	; (801024c <chSysUnlock.lto_priv.299+0x2c>)
 801022c:	4293      	cmp	r3, r2
 801022e:	d00a      	beq.n	8010246 <chSysUnlock.lto_priv.299+0x26>
 8010230:	4b06      	ldr	r3, [pc, #24]	; (801024c <chSysUnlock.lto_priv.299+0x2c>)
 8010232:	699b      	ldr	r3, [r3, #24]
 8010234:	689a      	ldr	r2, [r3, #8]
 8010236:	4b05      	ldr	r3, [pc, #20]	; (801024c <chSysUnlock.lto_priv.299+0x2c>)
 8010238:	681b      	ldr	r3, [r3, #0]
 801023a:	689b      	ldr	r3, [r3, #8]
 801023c:	429a      	cmp	r2, r3
 801023e:	d202      	bcs.n	8010246 <chSysUnlock.lto_priv.299+0x26>
 8010240:	4803      	ldr	r0, [pc, #12]	; (8010250 <chSysUnlock.lto_priv.299+0x30>)
 8010242:	f7fe fecd 	bl	800efe0 <chSysHalt>
  port_unlock();
 8010246:	f7ff ff1b 	bl	8010080 <port_unlock.lto_priv.366>
}
 801024a:	bd08      	pop	{r3, pc}
 801024c:	20001090 	.word	0x20001090
 8010250:	08016c4c 	.word	0x08016c4c
	...

08010260 <chVTGetSystemTimeX.lto_priv.286>:
static inline systime_t chVTGetSystemTimeX(void) {
 8010260:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8010262:	f7ff ff1d 	bl	80100a0 <port_timer_get_time.lto_priv.341>
 8010266:	4603      	mov	r3, r0
}
 8010268:	4618      	mov	r0, r3
 801026a:	bd08      	pop	{r3, pc}
 801026c:	0000      	movs	r0, r0
	...

08010270 <chThdGetSelfX.lto_priv.416>:
  return ch.rlist.current;
 8010270:	4b01      	ldr	r3, [pc, #4]	; (8010278 <chThdGetSelfX.lto_priv.416+0x8>)
 8010272:	699b      	ldr	r3, [r3, #24]
}
 8010274:	4618      	mov	r0, r3
 8010276:	4770      	bx	lr
 8010278:	20001090 	.word	0x20001090
 801027c:	00000000 	.word	0x00000000

08010280 <chThdGetWorkingAreaX.lto_priv.496>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8010280:	b082      	sub	sp, #8
 8010282:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8010284:	9b01      	ldr	r3, [sp, #4]
 8010286:	69db      	ldr	r3, [r3, #28]
}
 8010288:	4618      	mov	r0, r3
 801028a:	b002      	add	sp, #8
 801028c:	4770      	bx	lr
 801028e:	bf00      	nop

08010290 <chThdSleepS>:
static inline void chThdSleepS(sysinterval_t ticks) {
 8010290:	b500      	push	{lr}
 8010292:	b083      	sub	sp, #12
 8010294:	9001      	str	r0, [sp, #4]
  chDbgCheck(ticks != TIME_IMMEDIATE);
 8010296:	9b01      	ldr	r3, [sp, #4]
 8010298:	2b00      	cmp	r3, #0
 801029a:	d102      	bne.n	80102a2 <chThdSleepS+0x12>
 801029c:	4804      	ldr	r0, [pc, #16]	; (80102b0 <chThdSleepS+0x20>)
 801029e:	f7fe fe9f 	bl	800efe0 <chSysHalt>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 80102a2:	9901      	ldr	r1, [sp, #4]
 80102a4:	2008      	movs	r0, #8
 80102a6:	f7ff fd73 	bl	800fd90 <chSchGoSleepTimeoutS>
}
 80102aa:	b003      	add	sp, #12
 80102ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80102b0:	08016cb4 	.word	0x08016cb4
	...

080102c0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80102c0:	b500      	push	{lr}
 80102c2:	b085      	sub	sp, #20
 80102c4:	9001      	str	r0, [sp, #4]
 80102c6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 80102c8:	9801      	ldr	r0, [sp, #4]
 80102ca:	f7ff ff19 	bl	8010100 <queue_notempty.lto_priv.483>
 80102ce:	4603      	mov	r3, r0
 80102d0:	f083 0301 	eor.w	r3, r3, #1
 80102d4:	b2db      	uxtb	r3, r3
 80102d6:	2b00      	cmp	r3, #0
 80102d8:	d002      	beq.n	80102e0 <chThdDoDequeueNextI+0x20>
 80102da:	480c      	ldr	r0, [pc, #48]	; (801030c <chThdDoDequeueNextI+0x4c>)
 80102dc:	f7fe fe80 	bl	800efe0 <chSysHalt>

  tp = queue_fifo_remove(tqp);
 80102e0:	9801      	ldr	r0, [sp, #4]
 80102e2:	f7ff ff55 	bl	8010190 <queue_fifo_remove.lto_priv.469>
 80102e6:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 80102e8:	9b03      	ldr	r3, [sp, #12]
 80102ea:	f893 3020 	ldrb.w	r3, [r3, #32]
 80102ee:	2b04      	cmp	r3, #4
 80102f0:	d002      	beq.n	80102f8 <chThdDoDequeueNextI+0x38>
 80102f2:	4806      	ldr	r0, [pc, #24]	; (801030c <chThdDoDequeueNextI+0x4c>)
 80102f4:	f7fe fe74 	bl	800efe0 <chSysHalt>

  tp->u.rdymsg = msg;
 80102f8:	9b03      	ldr	r3, [sp, #12]
 80102fa:	9a00      	ldr	r2, [sp, #0]
 80102fc:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80102fe:	9803      	ldr	r0, [sp, #12]
 8010300:	f7ff fc46 	bl	800fb90 <chSchReadyI>
}
 8010304:	b005      	add	sp, #20
 8010306:	f85d fb04 	ldr.w	pc, [sp], #4
 801030a:	bf00      	nop
 801030c:	08016cf8 	.word	0x08016cf8

08010310 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 8010310:	b500      	push	{lr}
 8010312:	b085      	sub	sp, #20
 8010314:	9003      	str	r0, [sp, #12]
 8010316:	9102      	str	r1, [sp, #8]
 8010318:	9201      	str	r2, [sp, #4]

  tp->prio      = prio;
 801031a:	9b03      	ldr	r3, [sp, #12]
 801031c:	9a01      	ldr	r2, [sp, #4]
 801031e:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 8010320:	9b03      	ldr	r3, [sp, #12]
 8010322:	2202      	movs	r2, #2
 8010324:	f883 2020 	strb.w	r2, [r3, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8010328:	9b03      	ldr	r3, [sp, #12]
 801032a:	2200      	movs	r2, #0
 801032c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8010330:	9b03      	ldr	r3, [sp, #12]
 8010332:	9a01      	ldr	r2, [sp, #4]
 8010334:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->mtxlist   = NULL;
 8010336:	9b03      	ldr	r3, [sp, #12]
 8010338:	2200      	movs	r2, #0
 801033a:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 801033c:	9b03      	ldr	r3, [sp, #12]
 801033e:	2200      	movs	r2, #0
 8010340:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8010342:	9b03      	ldr	r3, [sp, #12]
 8010344:	2201      	movs	r2, #1
 8010346:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  tp->name      = name;
 801034a:	9b03      	ldr	r3, [sp, #12]
 801034c:	9a02      	ldr	r2, [sp, #8]
 801034e:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8010350:	9b03      	ldr	r3, [sp, #12]
 8010352:	4a0e      	ldr	r2, [pc, #56]	; (801038c <_thread_init+0x7c>)
 8010354:	611a      	str	r2, [r3, #16]
 8010356:	4b0d      	ldr	r3, [pc, #52]	; (801038c <_thread_init+0x7c>)
 8010358:	695a      	ldr	r2, [r3, #20]
 801035a:	9b03      	ldr	r3, [sp, #12]
 801035c:	615a      	str	r2, [r3, #20]
 801035e:	9b03      	ldr	r3, [sp, #12]
 8010360:	695b      	ldr	r3, [r3, #20]
 8010362:	9a03      	ldr	r2, [sp, #12]
 8010364:	611a      	str	r2, [r3, #16]
 8010366:	4a09      	ldr	r2, [pc, #36]	; (801038c <_thread_init+0x7c>)
 8010368:	9b03      	ldr	r3, [sp, #12]
 801036a:	6153      	str	r3, [r2, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 801036c:	9b03      	ldr	r3, [sp, #12]
 801036e:	3328      	adds	r3, #40	; 0x28
 8010370:	4618      	mov	r0, r3
 8010372:	f7ff fe9d 	bl	80100b0 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8010376:	9b03      	ldr	r3, [sp, #12]
 8010378:	332c      	adds	r3, #44	; 0x2c
 801037a:	4618      	mov	r0, r3
 801037c:	f7ff feb0 	bl	80100e0 <queue_init.lto_priv.463>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8010380:	9b03      	ldr	r3, [sp, #12]
}
 8010382:	4618      	mov	r0, r3
 8010384:	b005      	add	sp, #20
 8010386:	f85d fb04 	ldr.w	pc, [sp], #4
 801038a:	bf00      	nop
 801038c:	20001090 	.word	0x20001090

08010390 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 8010390:	b084      	sub	sp, #16
 8010392:	9003      	str	r0, [sp, #12]
 8010394:	9102      	str	r1, [sp, #8]
 8010396:	4613      	mov	r3, r2
 8010398:	f88d 3007 	strb.w	r3, [sp, #7]
 801039c:	e005      	b.n	80103aa <_thread_memfill+0x1a>

  while (startp < endp) {
    *startp++ = v;
 801039e:	9b03      	ldr	r3, [sp, #12]
 80103a0:	1c5a      	adds	r2, r3, #1
 80103a2:	9203      	str	r2, [sp, #12]
 80103a4:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80103a8:	701a      	strb	r2, [r3, #0]
  while (startp < endp) {
 80103aa:	9a03      	ldr	r2, [sp, #12]
 80103ac:	9b02      	ldr	r3, [sp, #8]
 80103ae:	429a      	cmp	r2, r3
 80103b0:	d3f5      	bcc.n	801039e <_thread_memfill+0xe>
  }
}
 80103b2:	b004      	add	sp, #16
 80103b4:	4770      	bx	lr
 80103b6:	bf00      	nop
	...

080103c0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 80103c0:	b500      	push	{lr}
 80103c2:	b085      	sub	sp, #20
 80103c4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 80103c6:	f7ff f81b 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 80103ca:	9b01      	ldr	r3, [sp, #4]
 80103cc:	2b00      	cmp	r3, #0
 80103ce:	d102      	bne.n	80103d6 <chThdCreateSuspendedI+0x16>
 80103d0:	4829      	ldr	r0, [pc, #164]	; (8010478 <chThdCreateSuspendedI+0xb8>)
 80103d2:	f7fe fe05 	bl	800efe0 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 80103d6:	9b01      	ldr	r3, [sp, #4]
 80103d8:	685b      	ldr	r3, [r3, #4]
 80103da:	f003 0307 	and.w	r3, r3, #7
 80103de:	2b00      	cmp	r3, #0
 80103e0:	d113      	bne.n	801040a <chThdCreateSuspendedI+0x4a>
 80103e2:	9b01      	ldr	r3, [sp, #4]
 80103e4:	689b      	ldr	r3, [r3, #8]
 80103e6:	f003 0307 	and.w	r3, r3, #7
 80103ea:	2b00      	cmp	r3, #0
 80103ec:	d10d      	bne.n	801040a <chThdCreateSuspendedI+0x4a>
 80103ee:	9b01      	ldr	r3, [sp, #4]
 80103f0:	689a      	ldr	r2, [r3, #8]
 80103f2:	9b01      	ldr	r3, [sp, #4]
 80103f4:	685b      	ldr	r3, [r3, #4]
 80103f6:	429a      	cmp	r2, r3
 80103f8:	d907      	bls.n	801040a <chThdCreateSuspendedI+0x4a>
 80103fa:	9b01      	ldr	r3, [sp, #4]
 80103fc:	689b      	ldr	r3, [r3, #8]
 80103fe:	461a      	mov	r2, r3
 8010400:	9b01      	ldr	r3, [sp, #4]
 8010402:	685b      	ldr	r3, [r3, #4]
 8010404:	1ad3      	subs	r3, r2, r3
 8010406:	2bc7      	cmp	r3, #199	; 0xc7
 8010408:	d802      	bhi.n	8010410 <chThdCreateSuspendedI+0x50>
 801040a:	481b      	ldr	r0, [pc, #108]	; (8010478 <chThdCreateSuspendedI+0xb8>)
 801040c:	f7fe fde8 	bl	800efe0 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8010410:	9b01      	ldr	r3, [sp, #4]
 8010412:	68db      	ldr	r3, [r3, #12]
 8010414:	2bff      	cmp	r3, #255	; 0xff
 8010416:	d803      	bhi.n	8010420 <chThdCreateSuspendedI+0x60>
 8010418:	9b01      	ldr	r3, [sp, #4]
 801041a:	691b      	ldr	r3, [r3, #16]
 801041c:	2b00      	cmp	r3, #0
 801041e:	d102      	bne.n	8010426 <chThdCreateSuspendedI+0x66>
 8010420:	4815      	ldr	r0, [pc, #84]	; (8010478 <chThdCreateSuspendedI+0xb8>)
 8010422:	f7fe fddd 	bl	800efe0 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8010426:	9b01      	ldr	r3, [sp, #4]
 8010428:	689b      	ldr	r3, [r3, #8]
 801042a:	3b48      	subs	r3, #72	; 0x48
 801042c:	9303      	str	r3, [sp, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 801042e:	9b01      	ldr	r3, [sp, #4]
 8010430:	685a      	ldr	r2, [r3, #4]
 8010432:	9b03      	ldr	r3, [sp, #12]
 8010434:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8010436:	9b03      	ldr	r3, [sp, #12]
 8010438:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 801043c:	9b03      	ldr	r3, [sp, #12]
 801043e:	60da      	str	r2, [r3, #12]
 8010440:	9b03      	ldr	r3, [sp, #12]
 8010442:	68db      	ldr	r3, [r3, #12]
 8010444:	9a01      	ldr	r2, [sp, #4]
 8010446:	6912      	ldr	r2, [r2, #16]
 8010448:	601a      	str	r2, [r3, #0]
 801044a:	9b03      	ldr	r3, [sp, #12]
 801044c:	68db      	ldr	r3, [r3, #12]
 801044e:	9a01      	ldr	r2, [sp, #4]
 8010450:	6952      	ldr	r2, [r2, #20]
 8010452:	605a      	str	r2, [r3, #4]
 8010454:	9b03      	ldr	r3, [sp, #12]
 8010456:	68db      	ldr	r3, [r3, #12]
 8010458:	4a08      	ldr	r2, [pc, #32]	; (801047c <chThdCreateSuspendedI+0xbc>)
 801045a:	621a      	str	r2, [r3, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 801045c:	9b01      	ldr	r3, [sp, #4]
 801045e:	6819      	ldr	r1, [r3, #0]
 8010460:	9b01      	ldr	r3, [sp, #4]
 8010462:	68db      	ldr	r3, [r3, #12]
 8010464:	461a      	mov	r2, r3
 8010466:	9803      	ldr	r0, [sp, #12]
 8010468:	f7ff ff52 	bl	8010310 <_thread_init>
 801046c:	4603      	mov	r3, r0
}
 801046e:	4618      	mov	r0, r3
 8010470:	b005      	add	sp, #20
 8010472:	f85d fb04 	ldr.w	pc, [sp], #4
 8010476:	bf00      	nop
 8010478:	08016c34 	.word	0x08016c34
 801047c:	080002f1 	.word	0x080002f1

08010480 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8010480:	b500      	push	{lr}
 8010482:	b085      	sub	sp, #20
 8010484:	9001      	str	r0, [sp, #4]
  thread_t *tp;

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8010486:	9b01      	ldr	r3, [sp, #4]
 8010488:	685b      	ldr	r3, [r3, #4]
 801048a:	4618      	mov	r0, r3
 801048c:	f000 fbf8 	bl	8010c80 <chRegFindThreadByWorkingArea>
 8010490:	4603      	mov	r3, r0
 8010492:	2b00      	cmp	r3, #0
 8010494:	d002      	beq.n	801049c <chThdCreate+0x1c>
 8010496:	480e      	ldr	r0, [pc, #56]	; (80104d0 <chThdCreate+0x50>)
 8010498:	f7fe fda2 	bl	800efe0 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
 801049c:	9b01      	ldr	r3, [sp, #4]
 801049e:	6858      	ldr	r0, [r3, #4]
                  (uint8_t *)tdp->wend,
 80104a0:	9b01      	ldr	r3, [sp, #4]
 80104a2:	689b      	ldr	r3, [r3, #8]
  _thread_memfill((uint8_t *)tdp->wbase,
 80104a4:	2255      	movs	r2, #85	; 0x55
 80104a6:	4619      	mov	r1, r3
 80104a8:	f7ff ff72 	bl	8010390 <_thread_memfill>
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80104ac:	f7ff feb0 	bl	8010210 <chSysLock.lto_priv.323>
  tp = chThdCreateSuspendedI(tdp);
 80104b0:	9801      	ldr	r0, [sp, #4]
 80104b2:	f7ff ff85 	bl	80103c0 <chThdCreateSuspendedI>
 80104b6:	9003      	str	r0, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
 80104b8:	2100      	movs	r1, #0
 80104ba:	9803      	ldr	r0, [sp, #12]
 80104bc:	f7ff fca0 	bl	800fe00 <chSchWakeupS>
  chSysUnlock();
 80104c0:	f7ff feae 	bl	8010220 <chSysUnlock.lto_priv.299>

  return tp;
 80104c4:	9b03      	ldr	r3, [sp, #12]
}
 80104c6:	4618      	mov	r0, r3
 80104c8:	b005      	add	sp, #20
 80104ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80104ce:	bf00      	nop
 80104d0:	08016c58 	.word	0x08016c58
	...

080104e0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80104e0:	b500      	push	{lr}
 80104e2:	b087      	sub	sp, #28
 80104e4:	9003      	str	r0, [sp, #12]
 80104e6:	9102      	str	r1, [sp, #8]
 80104e8:	9201      	str	r2, [sp, #4]
 80104ea:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 80104ec:	9b03      	ldr	r3, [sp, #12]
 80104ee:	2b00      	cmp	r3, #0
 80104f0:	d012      	beq.n	8010518 <chThdCreateStatic+0x38>
 80104f2:	9b03      	ldr	r3, [sp, #12]
 80104f4:	f003 0307 	and.w	r3, r3, #7
 80104f8:	2b00      	cmp	r3, #0
 80104fa:	d10d      	bne.n	8010518 <chThdCreateStatic+0x38>
 80104fc:	9b02      	ldr	r3, [sp, #8]
 80104fe:	2bc7      	cmp	r3, #199	; 0xc7
 8010500:	d90a      	bls.n	8010518 <chThdCreateStatic+0x38>
 8010502:	9b02      	ldr	r3, [sp, #8]
 8010504:	f003 0307 	and.w	r3, r3, #7
 8010508:	2b00      	cmp	r3, #0
 801050a:	d105      	bne.n	8010518 <chThdCreateStatic+0x38>
 801050c:	9b01      	ldr	r3, [sp, #4]
 801050e:	2bff      	cmp	r3, #255	; 0xff
 8010510:	d802      	bhi.n	8010518 <chThdCreateStatic+0x38>
 8010512:	9b00      	ldr	r3, [sp, #0]
 8010514:	2b00      	cmp	r3, #0
 8010516:	d102      	bne.n	801051e <chThdCreateStatic+0x3e>
 8010518:	481f      	ldr	r0, [pc, #124]	; (8010598 <chThdCreateStatic+0xb8>)
 801051a:	f7fe fd61 	bl	800efe0 <chSysHalt>
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 801051e:	9803      	ldr	r0, [sp, #12]
 8010520:	f000 fbae 	bl	8010c80 <chRegFindThreadByWorkingArea>
 8010524:	4603      	mov	r3, r0
 8010526:	2b00      	cmp	r3, #0
 8010528:	d002      	beq.n	8010530 <chThdCreateStatic+0x50>
 801052a:	481b      	ldr	r0, [pc, #108]	; (8010598 <chThdCreateStatic+0xb8>)
 801052c:	f7fe fd58 	bl	800efe0 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8010530:	9a03      	ldr	r2, [sp, #12]
 8010532:	9b02      	ldr	r3, [sp, #8]
 8010534:	4413      	add	r3, r2
 8010536:	2255      	movs	r2, #85	; 0x55
 8010538:	4619      	mov	r1, r3
 801053a:	9803      	ldr	r0, [sp, #12]
 801053c:	f7ff ff28 	bl	8010390 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8010540:	f7ff fe66 	bl	8010210 <chSysLock.lto_priv.323>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8010544:	9b02      	ldr	r3, [sp, #8]
 8010546:	3b48      	subs	r3, #72	; 0x48
 8010548:	9a03      	ldr	r2, [sp, #12]
 801054a:	4413      	add	r3, r2
 801054c:	9305      	str	r3, [sp, #20]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 801054e:	9b05      	ldr	r3, [sp, #20]
 8010550:	9a03      	ldr	r2, [sp, #12]
 8010552:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8010554:	9b05      	ldr	r3, [sp, #20]
 8010556:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 801055a:	9b05      	ldr	r3, [sp, #20]
 801055c:	60da      	str	r2, [r3, #12]
 801055e:	9b05      	ldr	r3, [sp, #20]
 8010560:	68db      	ldr	r3, [r3, #12]
 8010562:	9a00      	ldr	r2, [sp, #0]
 8010564:	601a      	str	r2, [r3, #0]
 8010566:	9b05      	ldr	r3, [sp, #20]
 8010568:	68db      	ldr	r3, [r3, #12]
 801056a:	9a08      	ldr	r2, [sp, #32]
 801056c:	605a      	str	r2, [r3, #4]
 801056e:	9b05      	ldr	r3, [sp, #20]
 8010570:	68db      	ldr	r3, [r3, #12]
 8010572:	4a0a      	ldr	r2, [pc, #40]	; (801059c <chThdCreateStatic+0xbc>)
 8010574:	621a      	str	r2, [r3, #32]

  tp = _thread_init(tp, "noname", prio);
 8010576:	9a01      	ldr	r2, [sp, #4]
 8010578:	4909      	ldr	r1, [pc, #36]	; (80105a0 <chThdCreateStatic+0xc0>)
 801057a:	9805      	ldr	r0, [sp, #20]
 801057c:	f7ff fec8 	bl	8010310 <_thread_init>
 8010580:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8010582:	2100      	movs	r1, #0
 8010584:	9805      	ldr	r0, [sp, #20]
 8010586:	f7ff fc3b 	bl	800fe00 <chSchWakeupS>
  chSysUnlock();
 801058a:	f7ff fe49 	bl	8010220 <chSysUnlock.lto_priv.299>

  return tp;
 801058e:	9b05      	ldr	r3, [sp, #20]
}
 8010590:	4618      	mov	r0, r3
 8010592:	b007      	add	sp, #28
 8010594:	f85d fb04 	ldr.w	pc, [sp], #4
 8010598:	08016c64 	.word	0x08016c64
 801059c:	080002f1 	.word	0x080002f1
 80105a0:	08018e30 	.word	0x08018e30
	...

080105b0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 80105b0:	b510      	push	{r4, lr}
 80105b2:	b082      	sub	sp, #8
 80105b4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80105b6:	f7ff fe2b 	bl	8010210 <chSysLock.lto_priv.323>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80105ba:	9b01      	ldr	r3, [sp, #4]
 80105bc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80105c0:	2b00      	cmp	r3, #0
 80105c2:	d102      	bne.n	80105ca <chThdRelease+0x1a>
 80105c4:	4820      	ldr	r0, [pc, #128]	; (8010648 <chThdRelease+0x98>)
 80105c6:	f7fe fd0b 	bl	800efe0 <chSysHalt>
  tp->refs--;
 80105ca:	9b01      	ldr	r3, [sp, #4]
 80105cc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80105d0:	3b01      	subs	r3, #1
 80105d2:	b2da      	uxtb	r2, r3
 80105d4:	9b01      	ldr	r3, [sp, #4]
 80105d6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80105da:	9b01      	ldr	r3, [sp, #4]
 80105dc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80105e0:	2b00      	cmp	r3, #0
 80105e2:	d12d      	bne.n	8010640 <chThdRelease+0x90>
 80105e4:	9b01      	ldr	r3, [sp, #4]
 80105e6:	f893 3020 	ldrb.w	r3, [r3, #32]
 80105ea:	2b0f      	cmp	r3, #15
 80105ec:	d128      	bne.n	8010640 <chThdRelease+0x90>
    REG_REMOVE(tp);
 80105ee:	9b01      	ldr	r3, [sp, #4]
 80105f0:	695b      	ldr	r3, [r3, #20]
 80105f2:	9a01      	ldr	r2, [sp, #4]
 80105f4:	6912      	ldr	r2, [r2, #16]
 80105f6:	611a      	str	r2, [r3, #16]
 80105f8:	9b01      	ldr	r3, [sp, #4]
 80105fa:	691b      	ldr	r3, [r3, #16]
 80105fc:	9a01      	ldr	r2, [sp, #4]
 80105fe:	6952      	ldr	r2, [r2, #20]
 8010600:	615a      	str	r2, [r3, #20]
    chSysUnlock();
 8010602:	f7ff fe0d 	bl	8010220 <chSysUnlock.lto_priv.299>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8010606:	9b01      	ldr	r3, [sp, #4]
 8010608:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 801060c:	f003 0303 	and.w	r3, r3, #3
 8010610:	2b01      	cmp	r3, #1
 8010612:	d002      	beq.n	801061a <chThdRelease+0x6a>
 8010614:	2b02      	cmp	r3, #2
 8010616:	d008      	beq.n	801062a <chThdRelease+0x7a>
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
      break;
#endif
    default:
 8010618:	e014      	b.n	8010644 <chThdRelease+0x94>
      chHeapFree(chThdGetWorkingAreaX(tp));
 801061a:	9801      	ldr	r0, [sp, #4]
 801061c:	f7ff fe30 	bl	8010280 <chThdGetWorkingAreaX.lto_priv.496>
 8010620:	4603      	mov	r3, r0
 8010622:	4618      	mov	r0, r3
 8010624:	f002 fd54 	bl	80130d0 <chHeapFree>
    default:
 8010628:	e00c      	b.n	8010644 <chThdRelease+0x94>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 801062a:	9b01      	ldr	r3, [sp, #4]
 801062c:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 801062e:	9801      	ldr	r0, [sp, #4]
 8010630:	f7ff fe26 	bl	8010280 <chThdGetWorkingAreaX.lto_priv.496>
 8010634:	4603      	mov	r3, r0
 8010636:	4619      	mov	r1, r3
 8010638:	4620      	mov	r0, r4
 801063a:	f002 ff59 	bl	80134f0 <chPoolFree>
    default:
 801063e:	e001      	b.n	8010644 <chThdRelease+0x94>
      break;
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
 8010640:	f7ff fdee 	bl	8010220 <chSysUnlock.lto_priv.299>
}
 8010644:	b002      	add	sp, #8
 8010646:	bd10      	pop	{r4, pc}
 8010648:	08016c78 	.word	0x08016c78
 801064c:	00000000 	.word	0x00000000

08010650 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8010650:	b500      	push	{lr}
 8010652:	b083      	sub	sp, #12
 8010654:	9001      	str	r0, [sp, #4]

  chSysLock();
 8010656:	f7ff fddb 	bl	8010210 <chSysLock.lto_priv.323>
  chThdExitS(msg);
 801065a:	9801      	ldr	r0, [sp, #4]
 801065c:	f000 f808 	bl	8010670 <chThdExitS>
  /* The thread never returns here.*/
}
 8010660:	b003      	add	sp, #12
 8010662:	f85d fb04 	ldr.w	pc, [sp], #4
 8010666:	bf00      	nop
	...

08010670 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8010670:	b500      	push	{lr}
 8010672:	b085      	sub	sp, #20
 8010674:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8010676:	4b1b      	ldr	r3, [pc, #108]	; (80106e4 <chThdExitS+0x74>)
 8010678:	699b      	ldr	r3, [r3, #24]
 801067a:	9303      	str	r3, [sp, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 801067c:	9b03      	ldr	r3, [sp, #12]
 801067e:	9a01      	ldr	r2, [sp, #4]
 8010680:	625a      	str	r2, [r3, #36]	; 0x24
 8010682:	e008      	b.n	8010696 <chThdExitS+0x26>
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
 8010684:	9b03      	ldr	r3, [sp, #12]
 8010686:	3328      	adds	r3, #40	; 0x28
 8010688:	4618      	mov	r0, r3
 801068a:	f7ff fd59 	bl	8010140 <list_remove>
 801068e:	4603      	mov	r3, r0
 8010690:	4618      	mov	r0, r3
 8010692:	f7ff fa7d 	bl	800fb90 <chSchReadyI>
  while (list_notempty(&tp->waiting)) {
 8010696:	9b03      	ldr	r3, [sp, #12]
 8010698:	3328      	adds	r3, #40	; 0x28
 801069a:	4618      	mov	r0, r3
 801069c:	f7ff fd10 	bl	80100c0 <list_notempty>
 80106a0:	4603      	mov	r3, r0
 80106a2:	2b00      	cmp	r3, #0
 80106a4:	d1ee      	bne.n	8010684 <chThdExitS+0x14>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80106a6:	9b03      	ldr	r3, [sp, #12]
 80106a8:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80106ac:	2b00      	cmp	r3, #0
 80106ae:	d110      	bne.n	80106d2 <chThdExitS+0x62>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 80106b0:	9b03      	ldr	r3, [sp, #12]
 80106b2:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80106b6:	f003 0303 	and.w	r3, r3, #3
  if ((tp->refs == (trefs_t)0) &&
 80106ba:	2b00      	cmp	r3, #0
 80106bc:	d109      	bne.n	80106d2 <chThdExitS+0x62>
    REG_REMOVE(tp);
 80106be:	9b03      	ldr	r3, [sp, #12]
 80106c0:	695b      	ldr	r3, [r3, #20]
 80106c2:	9a03      	ldr	r2, [sp, #12]
 80106c4:	6912      	ldr	r2, [r2, #16]
 80106c6:	611a      	str	r2, [r3, #16]
 80106c8:	9b03      	ldr	r3, [sp, #12]
 80106ca:	691b      	ldr	r3, [r3, #16]
 80106cc:	9a03      	ldr	r2, [sp, #12]
 80106ce:	6952      	ldr	r2, [r2, #20]
 80106d0:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80106d2:	200f      	movs	r0, #15
 80106d4:	f7ff fadc 	bl	800fc90 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 80106d8:	4803      	ldr	r0, [pc, #12]	; (80106e8 <chThdExitS+0x78>)
 80106da:	f7fe fc81 	bl	800efe0 <chSysHalt>
}
 80106de:	b005      	add	sp, #20
 80106e0:	f85d fb04 	ldr.w	pc, [sp], #4
 80106e4:	20001090 	.word	0x20001090
 80106e8:	08016c88 	.word	0x08016c88
 80106ec:	00000000 	.word	0x00000000

080106f0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 80106f0:	b500      	push	{lr}
 80106f2:	b085      	sub	sp, #20
 80106f4:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);
 80106f6:	9b01      	ldr	r3, [sp, #4]
 80106f8:	2b00      	cmp	r3, #0
 80106fa:	d102      	bne.n	8010702 <chThdWait+0x12>
 80106fc:	4818      	ldr	r0, [pc, #96]	; (8010760 <chThdWait+0x70>)
 80106fe:	f7fe fc6f 	bl	800efe0 <chSysHalt>

  chSysLock();
 8010702:	f7ff fd85 	bl	8010210 <chSysLock.lto_priv.323>
  chDbgAssert(tp != currp, "waiting self");
 8010706:	4b17      	ldr	r3, [pc, #92]	; (8010764 <chThdWait+0x74>)
 8010708:	699b      	ldr	r3, [r3, #24]
 801070a:	9a01      	ldr	r2, [sp, #4]
 801070c:	429a      	cmp	r2, r3
 801070e:	d102      	bne.n	8010716 <chThdWait+0x26>
 8010710:	4813      	ldr	r0, [pc, #76]	; (8010760 <chThdWait+0x70>)
 8010712:	f7fe fc65 	bl	800efe0 <chSysHalt>
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
 8010716:	9b01      	ldr	r3, [sp, #4]
 8010718:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 801071c:	2b00      	cmp	r3, #0
 801071e:	d102      	bne.n	8010726 <chThdWait+0x36>
 8010720:	480f      	ldr	r0, [pc, #60]	; (8010760 <chThdWait+0x70>)
 8010722:	f7fe fc5d 	bl	800efe0 <chSysHalt>
#endif

  if (tp->state != CH_STATE_FINAL) {
 8010726:	9b01      	ldr	r3, [sp, #4]
 8010728:	f893 3020 	ldrb.w	r3, [r3, #32]
 801072c:	2b0f      	cmp	r3, #15
 801072e:	d00a      	beq.n	8010746 <chThdWait+0x56>
    list_insert(currp, &tp->waiting);
 8010730:	4b0c      	ldr	r3, [pc, #48]	; (8010764 <chThdWait+0x74>)
 8010732:	699a      	ldr	r2, [r3, #24]
 8010734:	9b01      	ldr	r3, [sp, #4]
 8010736:	3328      	adds	r3, #40	; 0x28
 8010738:	4619      	mov	r1, r3
 801073a:	4610      	mov	r0, r2
 801073c:	f7ff fcf0 	bl	8010120 <list_insert>
    chSchGoSleepS(CH_STATE_WTEXIT);
 8010740:	2009      	movs	r0, #9
 8010742:	f7ff faa5 	bl	800fc90 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
 8010746:	9b01      	ldr	r3, [sp, #4]
 8010748:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801074a:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 801074c:	f7ff fd68 	bl	8010220 <chSysUnlock.lto_priv.299>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
 8010750:	9801      	ldr	r0, [sp, #4]
 8010752:	f7ff ff2d 	bl	80105b0 <chThdRelease>
#endif

  return msg;
 8010756:	9b03      	ldr	r3, [sp, #12]
}
 8010758:	4618      	mov	r0, r3
 801075a:	b005      	add	sp, #20
 801075c:	f85d fb04 	ldr.w	pc, [sp], #4
 8010760:	08016c94 	.word	0x08016c94
 8010764:	20001090 	.word	0x20001090
	...

08010770 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8010770:	b500      	push	{lr}
 8010772:	b085      	sub	sp, #20
 8010774:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
 8010776:	9b01      	ldr	r3, [sp, #4]
 8010778:	2bff      	cmp	r3, #255	; 0xff
 801077a:	d902      	bls.n	8010782 <chThdSetPriority+0x12>
 801077c:	4813      	ldr	r0, [pc, #76]	; (80107cc <chThdSetPriority+0x5c>)
 801077e:	f7fe fc2f 	bl	800efe0 <chSysHalt>

  chSysLock();
 8010782:	f7ff fd45 	bl	8010210 <chSysLock.lto_priv.323>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 8010786:	4b12      	ldr	r3, [pc, #72]	; (80107d0 <chThdSetPriority+0x60>)
 8010788:	699b      	ldr	r3, [r3, #24]
 801078a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801078c:	9303      	str	r3, [sp, #12]
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 801078e:	4b10      	ldr	r3, [pc, #64]	; (80107d0 <chThdSetPriority+0x60>)
 8010790:	699b      	ldr	r3, [r3, #24]
 8010792:	689a      	ldr	r2, [r3, #8]
 8010794:	4b0e      	ldr	r3, [pc, #56]	; (80107d0 <chThdSetPriority+0x60>)
 8010796:	699b      	ldr	r3, [r3, #24]
 8010798:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801079a:	429a      	cmp	r2, r3
 801079c:	d005      	beq.n	80107aa <chThdSetPriority+0x3a>
 801079e:	4b0c      	ldr	r3, [pc, #48]	; (80107d0 <chThdSetPriority+0x60>)
 80107a0:	699b      	ldr	r3, [r3, #24]
 80107a2:	689b      	ldr	r3, [r3, #8]
 80107a4:	9a01      	ldr	r2, [sp, #4]
 80107a6:	429a      	cmp	r2, r3
 80107a8:	d903      	bls.n	80107b2 <chThdSetPriority+0x42>
    currp->prio = newprio;
 80107aa:	4b09      	ldr	r3, [pc, #36]	; (80107d0 <chThdSetPriority+0x60>)
 80107ac:	699b      	ldr	r3, [r3, #24]
 80107ae:	9a01      	ldr	r2, [sp, #4]
 80107b0:	609a      	str	r2, [r3, #8]
  }
  currp->realprio = newprio;
 80107b2:	4b07      	ldr	r3, [pc, #28]	; (80107d0 <chThdSetPriority+0x60>)
 80107b4:	699b      	ldr	r3, [r3, #24]
 80107b6:	9a01      	ldr	r2, [sp, #4]
 80107b8:	63da      	str	r2, [r3, #60]	; 0x3c
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 80107ba:	f7ff fb79 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 80107be:	f7ff fd2f 	bl	8010220 <chSysUnlock.lto_priv.299>

  return oldprio;
 80107c2:	9b03      	ldr	r3, [sp, #12]
}
 80107c4:	4618      	mov	r0, r3
 80107c6:	b005      	add	sp, #20
 80107c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80107cc:	08016ca0 	.word	0x08016ca0
 80107d0:	20001090 	.word	0x20001090
	...

080107e0 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(thread_t *tp) {
 80107e0:	b500      	push	{lr}
 80107e2:	b083      	sub	sp, #12
 80107e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80107e6:	f7ff fd13 	bl	8010210 <chSysLock.lto_priv.323>
  tp->flags |= CH_FLAG_TERMINATE;
 80107ea:	9b01      	ldr	r3, [sp, #4]
 80107ec:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80107f0:	f043 0304 	orr.w	r3, r3, #4
 80107f4:	b2da      	uxtb	r2, r3
 80107f6:	9b01      	ldr	r3, [sp, #4]
 80107f8:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  chSysUnlock();
 80107fc:	f7ff fd10 	bl	8010220 <chSysUnlock.lto_priv.299>
}
 8010800:	b003      	add	sp, #12
 8010802:	f85d fb04 	ldr.w	pc, [sp], #4
 8010806:	bf00      	nop
	...

08010810 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8010810:	b500      	push	{lr}
 8010812:	b083      	sub	sp, #12
 8010814:	9001      	str	r0, [sp, #4]

  chSysLock();
 8010816:	f7ff fcfb 	bl	8010210 <chSysLock.lto_priv.323>
  chThdSleepS(time);
 801081a:	9801      	ldr	r0, [sp, #4]
 801081c:	f7ff fd38 	bl	8010290 <chThdSleepS>
  chSysUnlock();
 8010820:	f7ff fcfe 	bl	8010220 <chSysUnlock.lto_priv.299>
}
 8010824:	b003      	add	sp, #12
 8010826:	f85d fb04 	ldr.w	pc, [sp], #4
 801082a:	bf00      	nop
 801082c:	0000      	movs	r0, r0
	...

08010830 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 8010830:	b500      	push	{lr}
 8010832:	b085      	sub	sp, #20
 8010834:	9001      	str	r0, [sp, #4]
  sysinterval_t interval;

  chSysLock();
 8010836:	f7ff fceb 	bl	8010210 <chSysLock.lto_priv.323>
  interval = chTimeDiffX(chVTGetSystemTimeX(), time);
 801083a:	f7ff fd11 	bl	8010260 <chVTGetSystemTimeX.lto_priv.286>
 801083e:	4603      	mov	r3, r0
 8010840:	9901      	ldr	r1, [sp, #4]
 8010842:	4618      	mov	r0, r3
 8010844:	f7ff fc04 	bl	8010050 <chTimeDiffX.lto_priv.516>
 8010848:	9003      	str	r0, [sp, #12]
  if (interval > (sysinterval_t)0) {
 801084a:	9b03      	ldr	r3, [sp, #12]
 801084c:	2b00      	cmp	r3, #0
 801084e:	d002      	beq.n	8010856 <chThdSleepUntil+0x26>
    chThdSleepS(interval);
 8010850:	9803      	ldr	r0, [sp, #12]
 8010852:	f7ff fd1d 	bl	8010290 <chThdSleepS>
  }
  chSysUnlock();
 8010856:	f7ff fce3 	bl	8010220 <chSysUnlock.lto_priv.299>
}
 801085a:	b005      	add	sp, #20
 801085c:	f85d fb04 	ldr.w	pc, [sp], #4

08010860 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8010860:	b508      	push	{r3, lr}

  chSysLock();
 8010862:	f7ff fcd5 	bl	8010210 <chSysLock.lto_priv.323>
  chSchDoYieldS();
 8010866:	f7ff fcc3 	bl	80101f0 <chSchDoYieldS>
  chSysUnlock();
 801086a:	f7ff fcd9 	bl	8010220 <chSysUnlock.lto_priv.299>
}
 801086e:	bd08      	pop	{r3, pc}

08010870 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8010870:	b500      	push	{lr}
 8010872:	b085      	sub	sp, #20
 8010874:	9001      	str	r0, [sp, #4]
 8010876:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8010878:	f7ff fcfa 	bl	8010270 <chThdGetSelfX.lto_priv.416>
 801087c:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 801087e:	9b01      	ldr	r3, [sp, #4]
 8010880:	681b      	ldr	r3, [r3, #0]
 8010882:	2b00      	cmp	r3, #0
 8010884:	d002      	beq.n	801088c <chThdSuspendTimeoutS+0x1c>
 8010886:	480c      	ldr	r0, [pc, #48]	; (80108b8 <chThdSuspendTimeoutS+0x48>)
 8010888:	f7fe fbaa 	bl	800efe0 <chSysHalt>

  if (TIME_IMMEDIATE == timeout) {
 801088c:	9b00      	ldr	r3, [sp, #0]
 801088e:	2b00      	cmp	r3, #0
 8010890:	d102      	bne.n	8010898 <chThdSuspendTimeoutS+0x28>
    return MSG_TIMEOUT;
 8010892:	f04f 33ff 	mov.w	r3, #4294967295
 8010896:	e00a      	b.n	80108ae <chThdSuspendTimeoutS+0x3e>
  }

  *trp = tp;
 8010898:	9b01      	ldr	r3, [sp, #4]
 801089a:	9a03      	ldr	r2, [sp, #12]
 801089c:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 801089e:	9b03      	ldr	r3, [sp, #12]
 80108a0:	9a01      	ldr	r2, [sp, #4]
 80108a2:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80108a4:	9900      	ldr	r1, [sp, #0]
 80108a6:	2003      	movs	r0, #3
 80108a8:	f7ff fa72 	bl	800fd90 <chSchGoSleepTimeoutS>
 80108ac:	4603      	mov	r3, r0
}
 80108ae:	4618      	mov	r0, r3
 80108b0:	b005      	add	sp, #20
 80108b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80108b6:	bf00      	nop
 80108b8:	08016cc0 	.word	0x08016cc0
 80108bc:	00000000 	.word	0x00000000

080108c0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 80108c0:	b500      	push	{lr}
 80108c2:	b085      	sub	sp, #20
 80108c4:	9001      	str	r0, [sp, #4]
 80108c6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80108c8:	9b01      	ldr	r3, [sp, #4]
 80108ca:	681b      	ldr	r3, [r3, #0]
 80108cc:	2b00      	cmp	r3, #0
 80108ce:	d013      	beq.n	80108f8 <chThdResumeI+0x38>
    thread_t *tp = *trp;
 80108d0:	9b01      	ldr	r3, [sp, #4]
 80108d2:	681b      	ldr	r3, [r3, #0]
 80108d4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 80108d6:	9b03      	ldr	r3, [sp, #12]
 80108d8:	f893 3020 	ldrb.w	r3, [r3, #32]
 80108dc:	2b03      	cmp	r3, #3
 80108de:	d002      	beq.n	80108e6 <chThdResumeI+0x26>
 80108e0:	4807      	ldr	r0, [pc, #28]	; (8010900 <chThdResumeI+0x40>)
 80108e2:	f7fe fb7d 	bl	800efe0 <chSysHalt>

    *trp = NULL;
 80108e6:	9b01      	ldr	r3, [sp, #4]
 80108e8:	2200      	movs	r2, #0
 80108ea:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 80108ec:	9b03      	ldr	r3, [sp, #12]
 80108ee:	9a00      	ldr	r2, [sp, #0]
 80108f0:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 80108f2:	9803      	ldr	r0, [sp, #12]
 80108f4:	f7ff f94c 	bl	800fb90 <chSchReadyI>
  }
}
 80108f8:	b005      	add	sp, #20
 80108fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80108fe:	bf00      	nop
 8010900:	08016cd8 	.word	0x08016cd8
	...

08010910 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 8010910:	b500      	push	{lr}
 8010912:	b085      	sub	sp, #20
 8010914:	9001      	str	r0, [sp, #4]
 8010916:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8010918:	9b01      	ldr	r3, [sp, #4]
 801091a:	681b      	ldr	r3, [r3, #0]
 801091c:	2b00      	cmp	r3, #0
 801091e:	d011      	beq.n	8010944 <chThdResumeS+0x34>
    thread_t *tp = *trp;
 8010920:	9b01      	ldr	r3, [sp, #4]
 8010922:	681b      	ldr	r3, [r3, #0]
 8010924:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8010926:	9b03      	ldr	r3, [sp, #12]
 8010928:	f893 3020 	ldrb.w	r3, [r3, #32]
 801092c:	2b03      	cmp	r3, #3
 801092e:	d002      	beq.n	8010936 <chThdResumeS+0x26>
 8010930:	4806      	ldr	r0, [pc, #24]	; (801094c <chThdResumeS+0x3c>)
 8010932:	f7fe fb55 	bl	800efe0 <chSysHalt>

    *trp = NULL;
 8010936:	9b01      	ldr	r3, [sp, #4]
 8010938:	2200      	movs	r2, #0
 801093a:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 801093c:	9900      	ldr	r1, [sp, #0]
 801093e:	9803      	ldr	r0, [sp, #12]
 8010940:	f7ff fa5e 	bl	800fe00 <chSchWakeupS>
  }
}
 8010944:	b005      	add	sp, #20
 8010946:	f85d fb04 	ldr.w	pc, [sp], #4
 801094a:	bf00      	nop
 801094c:	08016ce8 	.word	0x08016ce8

08010950 <chThdResume>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
 8010950:	b500      	push	{lr}
 8010952:	b083      	sub	sp, #12
 8010954:	9001      	str	r0, [sp, #4]
 8010956:	9100      	str	r1, [sp, #0]

  chSysLock();
 8010958:	f7ff fc5a 	bl	8010210 <chSysLock.lto_priv.323>
  chThdResumeS(trp, msg);
 801095c:	9900      	ldr	r1, [sp, #0]
 801095e:	9801      	ldr	r0, [sp, #4]
 8010960:	f7ff ffd6 	bl	8010910 <chThdResumeS>
  chSysUnlock();
 8010964:	f7ff fc5c 	bl	8010220 <chSysUnlock.lto_priv.299>
}
 8010968:	b003      	add	sp, #12
 801096a:	f85d fb04 	ldr.w	pc, [sp], #4
 801096e:	bf00      	nop

08010970 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8010970:	b500      	push	{lr}
 8010972:	b083      	sub	sp, #12
 8010974:	9001      	str	r0, [sp, #4]
 8010976:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8010978:	9b00      	ldr	r3, [sp, #0]
 801097a:	2b00      	cmp	r3, #0
 801097c:	d102      	bne.n	8010984 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 801097e:	f04f 33ff 	mov.w	r3, #4294967295
 8010982:	e00a      	b.n	801099a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 8010984:	4b07      	ldr	r3, [pc, #28]	; (80109a4 <chThdEnqueueTimeoutS+0x34>)
 8010986:	699b      	ldr	r3, [r3, #24]
 8010988:	9901      	ldr	r1, [sp, #4]
 801098a:	4618      	mov	r0, r3
 801098c:	f7ff fbe8 	bl	8010160 <queue_insert.lto_priv.474>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8010990:	9900      	ldr	r1, [sp, #0]
 8010992:	2004      	movs	r0, #4
 8010994:	f7ff f9fc 	bl	800fd90 <chSchGoSleepTimeoutS>
 8010998:	4603      	mov	r3, r0
}
 801099a:	4618      	mov	r0, r3
 801099c:	b003      	add	sp, #12
 801099e:	f85d fb04 	ldr.w	pc, [sp], #4
 80109a2:	bf00      	nop
 80109a4:	20001090 	.word	0x20001090
	...

080109b0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80109b0:	b500      	push	{lr}
 80109b2:	b083      	sub	sp, #12
 80109b4:	9001      	str	r0, [sp, #4]
 80109b6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 80109b8:	9801      	ldr	r0, [sp, #4]
 80109ba:	f7ff fba1 	bl	8010100 <queue_notempty.lto_priv.483>
 80109be:	4603      	mov	r3, r0
 80109c0:	2b00      	cmp	r3, #0
 80109c2:	d003      	beq.n	80109cc <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 80109c4:	9900      	ldr	r1, [sp, #0]
 80109c6:	9801      	ldr	r0, [sp, #4]
 80109c8:	f7ff fc7a 	bl	80102c0 <chThdDoDequeueNextI>
  }
}
 80109cc:	b003      	add	sp, #12
 80109ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80109d2:	bf00      	nop
	...

080109e0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80109e0:	b500      	push	{lr}
 80109e2:	b083      	sub	sp, #12
 80109e4:	9001      	str	r0, [sp, #4]
 80109e6:	9100      	str	r1, [sp, #0]
 80109e8:	e003      	b.n	80109f2 <chThdDequeueAllI+0x12>

  while (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
 80109ea:	9900      	ldr	r1, [sp, #0]
 80109ec:	9801      	ldr	r0, [sp, #4]
 80109ee:	f7ff fc67 	bl	80102c0 <chThdDoDequeueNextI>
  while (queue_notempty(tqp)) {
 80109f2:	9801      	ldr	r0, [sp, #4]
 80109f4:	f7ff fb84 	bl	8010100 <queue_notempty.lto_priv.483>
 80109f8:	4603      	mov	r3, r0
 80109fa:	2b00      	cmp	r3, #0
 80109fc:	d1f5      	bne.n	80109ea <chThdDequeueAllI+0xa>
  }
}
 80109fe:	b003      	add	sp, #12
 8010a00:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08010a10 <port_rt_get_counter_value.lto_priv.500>:
  return DWT->CYCCNT;
 8010a10:	4b01      	ldr	r3, [pc, #4]	; (8010a18 <port_rt_get_counter_value.lto_priv.500+0x8>)
 8010a12:	685b      	ldr	r3, [r3, #4]
}
 8010a14:	4618      	mov	r0, r3
 8010a16:	4770      	bx	lr
 8010a18:	e0001000 	.word	0xe0001000
 8010a1c:	00000000 	.word	0x00000000

08010a20 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8010a20:	e92d 0810 	stmdb	sp!, {r4, fp}
 8010a24:	b084      	sub	sp, #16
 8010a26:	9003      	str	r0, [sp, #12]
 8010a28:	9102      	str	r1, [sp, #8]
 8010a2a:	9201      	str	r2, [sp, #4]

  tmp->n++;
 8010a2c:	9b03      	ldr	r3, [sp, #12]
 8010a2e:	68db      	ldr	r3, [r3, #12]
 8010a30:	1c5a      	adds	r2, r3, #1
 8010a32:	9b03      	ldr	r3, [sp, #12]
 8010a34:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8010a36:	9b03      	ldr	r3, [sp, #12]
 8010a38:	689b      	ldr	r3, [r3, #8]
 8010a3a:	9a02      	ldr	r2, [sp, #8]
 8010a3c:	1ad2      	subs	r2, r2, r3
 8010a3e:	9b01      	ldr	r3, [sp, #4]
 8010a40:	1ad2      	subs	r2, r2, r3
 8010a42:	9b03      	ldr	r3, [sp, #12]
 8010a44:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8010a46:	9b03      	ldr	r3, [sp, #12]
 8010a48:	e9d3 1204 	ldrd	r1, r2, [r3, #16]
 8010a4c:	9b03      	ldr	r3, [sp, #12]
 8010a4e:	689b      	ldr	r3, [r3, #8]
 8010a50:	469b      	mov	fp, r3
 8010a52:	f04f 0c00 	mov.w	ip, #0
 8010a56:	eb1b 0301 	adds.w	r3, fp, r1
 8010a5a:	eb4c 0402 	adc.w	r4, ip, r2
 8010a5e:	9a03      	ldr	r2, [sp, #12]
 8010a60:	e9c2 3404 	strd	r3, r4, [r2, #16]
  if (tmp->last > tmp->worst) {
 8010a64:	9b03      	ldr	r3, [sp, #12]
 8010a66:	689a      	ldr	r2, [r3, #8]
 8010a68:	9b03      	ldr	r3, [sp, #12]
 8010a6a:	685b      	ldr	r3, [r3, #4]
 8010a6c:	429a      	cmp	r2, r3
 8010a6e:	d903      	bls.n	8010a78 <tm_stop+0x58>
    tmp->worst = tmp->last;
 8010a70:	9b03      	ldr	r3, [sp, #12]
 8010a72:	689a      	ldr	r2, [r3, #8]
 8010a74:	9b03      	ldr	r3, [sp, #12]
 8010a76:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8010a78:	9b03      	ldr	r3, [sp, #12]
 8010a7a:	689a      	ldr	r2, [r3, #8]
 8010a7c:	9b03      	ldr	r3, [sp, #12]
 8010a7e:	681b      	ldr	r3, [r3, #0]
 8010a80:	429a      	cmp	r2, r3
 8010a82:	d203      	bcs.n	8010a8c <tm_stop+0x6c>
    tmp->best = tmp->last;
 8010a84:	9b03      	ldr	r3, [sp, #12]
 8010a86:	689a      	ldr	r2, [r3, #8]
 8010a88:	9b03      	ldr	r3, [sp, #12]
 8010a8a:	601a      	str	r2, [r3, #0]
  }
}
 8010a8c:	b004      	add	sp, #16
 8010a8e:	e8bd 0810 	ldmia.w	sp!, {r4, fp}
 8010a92:	4770      	bx	lr
	...

08010aa0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8010aa0:	b500      	push	{lr}
 8010aa2:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8010aa4:	4b0b      	ldr	r3, [pc, #44]	; (8010ad4 <_tm_init+0x34>)
 8010aa6:	2200      	movs	r2, #0
 8010aa8:	f8c3 2884 	str.w	r2, [r3, #2180]	; 0x884
  chTMObjectInit(&tm);
 8010aac:	466b      	mov	r3, sp
 8010aae:	4618      	mov	r0, r3
 8010ab0:	f000 f816 	bl	8010ae0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8010ab4:	466b      	mov	r3, sp
 8010ab6:	4618      	mov	r0, r3
 8010ab8:	f000 f832 	bl	8010b20 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8010abc:	466b      	mov	r3, sp
 8010abe:	4618      	mov	r0, r3
 8010ac0:	f000 f83e 	bl	8010b40 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8010ac4:	9b02      	ldr	r3, [sp, #8]
 8010ac6:	4a03      	ldr	r2, [pc, #12]	; (8010ad4 <_tm_init+0x34>)
 8010ac8:	f8c2 3884 	str.w	r3, [r2, #2180]	; 0x884
}
 8010acc:	b007      	add	sp, #28
 8010ace:	f85d fb04 	ldr.w	pc, [sp], #4
 8010ad2:	bf00      	nop
 8010ad4:	20001090 	.word	0x20001090
	...

08010ae0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8010ae0:	b410      	push	{r4}
 8010ae2:	b083      	sub	sp, #12
 8010ae4:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8010ae6:	9b01      	ldr	r3, [sp, #4]
 8010ae8:	f04f 32ff 	mov.w	r2, #4294967295
 8010aec:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 8010aee:	9b01      	ldr	r3, [sp, #4]
 8010af0:	2200      	movs	r2, #0
 8010af2:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8010af4:	9b01      	ldr	r3, [sp, #4]
 8010af6:	2200      	movs	r2, #0
 8010af8:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8010afa:	9b01      	ldr	r3, [sp, #4]
 8010afc:	2200      	movs	r2, #0
 8010afe:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 8010b00:	9a01      	ldr	r2, [sp, #4]
 8010b02:	f04f 0300 	mov.w	r3, #0
 8010b06:	f04f 0400 	mov.w	r4, #0
 8010b0a:	e9c2 3404 	strd	r3, r4, [r2, #16]
}
 8010b0e:	b003      	add	sp, #12
 8010b10:	bc10      	pop	{r4}
 8010b12:	4770      	bx	lr
	...

08010b20 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8010b20:	b500      	push	{lr}
 8010b22:	b083      	sub	sp, #12
 8010b24:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8010b26:	f7ff ff73 	bl	8010a10 <port_rt_get_counter_value.lto_priv.500>
 8010b2a:	4602      	mov	r2, r0
 8010b2c:	9b01      	ldr	r3, [sp, #4]
 8010b2e:	609a      	str	r2, [r3, #8]
}
 8010b30:	b003      	add	sp, #12
 8010b32:	f85d fb04 	ldr.w	pc, [sp], #4
 8010b36:	bf00      	nop
	...

08010b40 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8010b40:	b500      	push	{lr}
 8010b42:	b083      	sub	sp, #12
 8010b44:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8010b46:	f7ff ff63 	bl	8010a10 <port_rt_get_counter_value.lto_priv.500>
 8010b4a:	4601      	mov	r1, r0
 8010b4c:	4b04      	ldr	r3, [pc, #16]	; (8010b60 <chTMStopMeasurementX+0x20>)
 8010b4e:	f8d3 3884 	ldr.w	r3, [r3, #2180]	; 0x884
 8010b52:	461a      	mov	r2, r3
 8010b54:	9801      	ldr	r0, [sp, #4]
 8010b56:	f7ff ff63 	bl	8010a20 <tm_stop>
}
 8010b5a:	b003      	add	sp, #12
 8010b5c:	f85d fb04 	ldr.w	pc, [sp], #4
 8010b60:	20001090 	.word	0x20001090
	...

08010b70 <port_lock.lto_priv.398>:
static inline void port_lock(void) {
 8010b70:	b082      	sub	sp, #8
 8010b72:	2320      	movs	r3, #32
 8010b74:	9301      	str	r3, [sp, #4]
 8010b76:	9b01      	ldr	r3, [sp, #4]
 8010b78:	f383 8811 	msr	BASEPRI, r3
}
 8010b7c:	b002      	add	sp, #8
 8010b7e:	4770      	bx	lr

08010b80 <port_unlock.lto_priv.367>:
static inline void port_unlock(void) {
 8010b80:	b082      	sub	sp, #8
 8010b82:	2300      	movs	r3, #0
 8010b84:	9301      	str	r3, [sp, #4]
 8010b86:	9b01      	ldr	r3, [sp, #4]
 8010b88:	f383 8811 	msr	BASEPRI, r3
}
 8010b8c:	b002      	add	sp, #8
 8010b8e:	4770      	bx	lr

08010b90 <chSysLock.lto_priv.324>:
static inline void chSysLock(void) {
 8010b90:	b508      	push	{r3, lr}
  port_lock();
 8010b92:	f7ff ffed 	bl	8010b70 <port_lock.lto_priv.398>
  _dbg_check_lock();
 8010b96:	f7fe fb93 	bl	800f2c0 <_dbg_check_lock>
}
 8010b9a:	bd08      	pop	{r3, pc}
 8010b9c:	0000      	movs	r0, r0
	...

08010ba0 <chSysUnlock.lto_priv.300>:
static inline void chSysUnlock(void) {
 8010ba0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8010ba2:	f7fe fba5 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8010ba6:	4b09      	ldr	r3, [pc, #36]	; (8010bcc <chSysUnlock.lto_priv.300+0x2c>)
 8010ba8:	681b      	ldr	r3, [r3, #0]
 8010baa:	4a08      	ldr	r2, [pc, #32]	; (8010bcc <chSysUnlock.lto_priv.300+0x2c>)
 8010bac:	4293      	cmp	r3, r2
 8010bae:	d00a      	beq.n	8010bc6 <chSysUnlock.lto_priv.300+0x26>
 8010bb0:	4b06      	ldr	r3, [pc, #24]	; (8010bcc <chSysUnlock.lto_priv.300+0x2c>)
 8010bb2:	699b      	ldr	r3, [r3, #24]
 8010bb4:	689a      	ldr	r2, [r3, #8]
 8010bb6:	4b05      	ldr	r3, [pc, #20]	; (8010bcc <chSysUnlock.lto_priv.300+0x2c>)
 8010bb8:	681b      	ldr	r3, [r3, #0]
 8010bba:	689b      	ldr	r3, [r3, #8]
 8010bbc:	429a      	cmp	r2, r3
 8010bbe:	d202      	bcs.n	8010bc6 <chSysUnlock.lto_priv.300+0x26>
 8010bc0:	4803      	ldr	r0, [pc, #12]	; (8010bd0 <chSysUnlock.lto_priv.300+0x30>)
 8010bc2:	f7fe fa0d 	bl	800efe0 <chSysHalt>
  port_unlock();
 8010bc6:	f7ff ffdb 	bl	8010b80 <port_unlock.lto_priv.367>
}
 8010bca:	bd08      	pop	{r3, pc}
 8010bcc:	20001090 	.word	0x20001090
 8010bd0:	08016d24 	.word	0x08016d24
	...

08010be0 <chThdGetWorkingAreaX.lto_priv.497>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8010be0:	b082      	sub	sp, #8
 8010be2:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 8010be4:	9b01      	ldr	r3, [sp, #4]
 8010be6:	69db      	ldr	r3, [r3, #28]
}
 8010be8:	4618      	mov	r0, r3
 8010bea:	b002      	add	sp, #8
 8010bec:	4770      	bx	lr
 8010bee:	bf00      	nop

08010bf0 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8010bf0:	b500      	push	{lr}
 8010bf2:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8010bf4:	f7ff ffcc 	bl	8010b90 <chSysLock.lto_priv.324>
  tp = ch.rlist.newer;
 8010bf8:	4b08      	ldr	r3, [pc, #32]	; (8010c1c <chRegFirstThread+0x2c>)
 8010bfa:	691b      	ldr	r3, [r3, #16]
 8010bfc:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8010bfe:	9b01      	ldr	r3, [sp, #4]
 8010c00:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8010c04:	3301      	adds	r3, #1
 8010c06:	b2da      	uxtb	r2, r3
 8010c08:	9b01      	ldr	r3, [sp, #4]
 8010c0a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
  chSysUnlock();
 8010c0e:	f7ff ffc7 	bl	8010ba0 <chSysUnlock.lto_priv.300>

  return tp;
 8010c12:	9b01      	ldr	r3, [sp, #4]
}
 8010c14:	4618      	mov	r0, r3
 8010c16:	b003      	add	sp, #12
 8010c18:	f85d fb04 	ldr.w	pc, [sp], #4
 8010c1c:	20001090 	.word	0x20001090

08010c20 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8010c20:	b500      	push	{lr}
 8010c22:	b085      	sub	sp, #20
 8010c24:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 8010c26:	f7ff ffb3 	bl	8010b90 <chSysLock.lto_priv.324>
  ntp = tp->newer;
 8010c2a:	9b01      	ldr	r3, [sp, #4]
 8010c2c:	691b      	ldr	r3, [r3, #16]
 8010c2e:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8010c30:	9b03      	ldr	r3, [sp, #12]
 8010c32:	4a10      	ldr	r2, [pc, #64]	; (8010c74 <chRegNextThread+0x54>)
 8010c34:	4293      	cmp	r3, r2
 8010c36:	d102      	bne.n	8010c3e <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 8010c38:	2300      	movs	r3, #0
 8010c3a:	9303      	str	r3, [sp, #12]
 8010c3c:	e00f      	b.n	8010c5e <chRegNextThread+0x3e>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8010c3e:	9b03      	ldr	r3, [sp, #12]
 8010c40:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8010c44:	2bff      	cmp	r3, #255	; 0xff
 8010c46:	d102      	bne.n	8010c4e <chRegNextThread+0x2e>
 8010c48:	480b      	ldr	r0, [pc, #44]	; (8010c78 <chRegNextThread+0x58>)
 8010c4a:	f7fe f9c9 	bl	800efe0 <chSysHalt>
    ntp->refs++;
 8010c4e:	9b03      	ldr	r3, [sp, #12]
 8010c50:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8010c54:	3301      	adds	r3, #1
 8010c56:	b2da      	uxtb	r2, r3
 8010c58:	9b03      	ldr	r3, [sp, #12]
 8010c5a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  }
#endif
  chSysUnlock();
 8010c5e:	f7ff ff9f 	bl	8010ba0 <chSysUnlock.lto_priv.300>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8010c62:	9801      	ldr	r0, [sp, #4]
 8010c64:	f7ff fca4 	bl	80105b0 <chThdRelease>
#endif

  return ntp;
 8010c68:	9b03      	ldr	r3, [sp, #12]
}
 8010c6a:	4618      	mov	r0, r3
 8010c6c:	b005      	add	sp, #20
 8010c6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8010c72:	bf00      	nop
 8010c74:	20001090 	.word	0x20001090
 8010c78:	08016d30 	.word	0x08016d30
 8010c7c:	00000000 	.word	0x00000000

08010c80 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8010c80:	b500      	push	{lr}
 8010c82:	b085      	sub	sp, #20
 8010c84:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8010c86:	f7ff ffb3 	bl	8010bf0 <chRegFirstThread>
 8010c8a:	9003      	str	r0, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8010c8c:	9803      	ldr	r0, [sp, #12]
 8010c8e:	f7ff ffa7 	bl	8010be0 <chThdGetWorkingAreaX.lto_priv.497>
 8010c92:	4602      	mov	r2, r0
 8010c94:	9b01      	ldr	r3, [sp, #4]
 8010c96:	4293      	cmp	r3, r2
 8010c98:	d101      	bne.n	8010c9e <chRegFindThreadByWorkingArea+0x1e>
      return ctp;
 8010c9a:	9b03      	ldr	r3, [sp, #12]
 8010c9c:	e007      	b.n	8010cae <chRegFindThreadByWorkingArea+0x2e>
    }
    ctp = chRegNextThread(ctp);
 8010c9e:	9803      	ldr	r0, [sp, #12]
 8010ca0:	f7ff ffbe 	bl	8010c20 <chRegNextThread>
 8010ca4:	9003      	str	r0, [sp, #12]
  } while (ctp != NULL);
 8010ca6:	9b03      	ldr	r3, [sp, #12]
 8010ca8:	2b00      	cmp	r3, #0
 8010caa:	d1ef      	bne.n	8010c8c <chRegFindThreadByWorkingArea+0xc>

  return NULL;
 8010cac:	2300      	movs	r3, #0
}
 8010cae:	4618      	mov	r0, r3
 8010cb0:	b005      	add	sp, #20
 8010cb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8010cb6:	bf00      	nop
	...

08010cc0 <port_lock.lto_priv.399>:
static inline void port_lock(void) {
 8010cc0:	b082      	sub	sp, #8
 8010cc2:	2320      	movs	r3, #32
 8010cc4:	9301      	str	r3, [sp, #4]
 8010cc6:	9b01      	ldr	r3, [sp, #4]
 8010cc8:	f383 8811 	msr	BASEPRI, r3
}
 8010ccc:	b002      	add	sp, #8
 8010cce:	4770      	bx	lr

08010cd0 <port_unlock.lto_priv.368>:
static inline void port_unlock(void) {
 8010cd0:	b082      	sub	sp, #8
 8010cd2:	2300      	movs	r3, #0
 8010cd4:	9301      	str	r3, [sp, #4]
 8010cd6:	9b01      	ldr	r3, [sp, #4]
 8010cd8:	f383 8811 	msr	BASEPRI, r3
}
 8010cdc:	b002      	add	sp, #8
 8010cde:	4770      	bx	lr

08010ce0 <queue_init.lto_priv.464>:
static inline void queue_init(threads_queue_t *tqp) {
 8010ce0:	b082      	sub	sp, #8
 8010ce2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8010ce4:	9b01      	ldr	r3, [sp, #4]
 8010ce6:	9a01      	ldr	r2, [sp, #4]
 8010ce8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8010cea:	9b01      	ldr	r3, [sp, #4]
 8010cec:	9a01      	ldr	r2, [sp, #4]
 8010cee:	605a      	str	r2, [r3, #4]
}
 8010cf0:	b002      	add	sp, #8
 8010cf2:	4770      	bx	lr
	...

08010d00 <queue_isempty>:
static inline bool queue_isempty(const threads_queue_t *tqp) {
 8010d00:	b082      	sub	sp, #8
 8010d02:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next == (const thread_t *)tqp);
 8010d04:	9b01      	ldr	r3, [sp, #4]
 8010d06:	681b      	ldr	r3, [r3, #0]
 8010d08:	9a01      	ldr	r2, [sp, #4]
 8010d0a:	429a      	cmp	r2, r3
 8010d0c:	bf0c      	ite	eq
 8010d0e:	2301      	moveq	r3, #1
 8010d10:	2300      	movne	r3, #0
 8010d12:	b2db      	uxtb	r3, r3
}
 8010d14:	4618      	mov	r0, r3
 8010d16:	b002      	add	sp, #8
 8010d18:	4770      	bx	lr
 8010d1a:	bf00      	nop
 8010d1c:	0000      	movs	r0, r0
	...

08010d20 <queue_notempty.lto_priv.484>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8010d20:	b082      	sub	sp, #8
 8010d22:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next != (const thread_t *)tqp);
 8010d24:	9b01      	ldr	r3, [sp, #4]
 8010d26:	681b      	ldr	r3, [r3, #0]
 8010d28:	9a01      	ldr	r2, [sp, #4]
 8010d2a:	429a      	cmp	r2, r3
 8010d2c:	bf14      	ite	ne
 8010d2e:	2301      	movne	r3, #1
 8010d30:	2300      	moveq	r3, #0
 8010d32:	b2db      	uxtb	r3, r3
}
 8010d34:	4618      	mov	r0, r3
 8010d36:	b002      	add	sp, #8
 8010d38:	4770      	bx	lr
 8010d3a:	bf00      	nop
 8010d3c:	0000      	movs	r0, r0
	...

08010d40 <queue_insert.lto_priv.475>:
static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8010d40:	b082      	sub	sp, #8
 8010d42:	9001      	str	r0, [sp, #4]
 8010d44:	9100      	str	r1, [sp, #0]
  tp->queue.next             = (thread_t *)tqp;
 8010d46:	9b01      	ldr	r3, [sp, #4]
 8010d48:	9a00      	ldr	r2, [sp, #0]
 8010d4a:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 8010d4c:	9b00      	ldr	r3, [sp, #0]
 8010d4e:	685a      	ldr	r2, [r3, #4]
 8010d50:	9b01      	ldr	r3, [sp, #4]
 8010d52:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8010d54:	9b01      	ldr	r3, [sp, #4]
 8010d56:	685b      	ldr	r3, [r3, #4]
 8010d58:	9a01      	ldr	r2, [sp, #4]
 8010d5a:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 8010d5c:	9b00      	ldr	r3, [sp, #0]
 8010d5e:	9a01      	ldr	r2, [sp, #4]
 8010d60:	605a      	str	r2, [r3, #4]
}
 8010d62:	b002      	add	sp, #8
 8010d64:	4770      	bx	lr
 8010d66:	bf00      	nop
	...

08010d70 <queue_fifo_remove.lto_priv.470>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8010d70:	b084      	sub	sp, #16
 8010d72:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8010d74:	9b01      	ldr	r3, [sp, #4]
 8010d76:	681b      	ldr	r3, [r3, #0]
 8010d78:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 8010d7a:	9b03      	ldr	r3, [sp, #12]
 8010d7c:	681a      	ldr	r2, [r3, #0]
 8010d7e:	9b01      	ldr	r3, [sp, #4]
 8010d80:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8010d82:	9b01      	ldr	r3, [sp, #4]
 8010d84:	681b      	ldr	r3, [r3, #0]
 8010d86:	9a01      	ldr	r2, [sp, #4]
 8010d88:	605a      	str	r2, [r3, #4]
  return tp;
 8010d8a:	9b03      	ldr	r3, [sp, #12]
}
 8010d8c:	4618      	mov	r0, r3
 8010d8e:	b004      	add	sp, #16
 8010d90:	4770      	bx	lr
 8010d92:	bf00      	nop
	...

08010da0 <queue_lifo_remove>:
static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
 8010da0:	b084      	sub	sp, #16
 8010da2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->prev;
 8010da4:	9b01      	ldr	r3, [sp, #4]
 8010da6:	685b      	ldr	r3, [r3, #4]
 8010da8:	9303      	str	r3, [sp, #12]
  tqp->prev             = tp->queue.prev;
 8010daa:	9b03      	ldr	r3, [sp, #12]
 8010dac:	685a      	ldr	r2, [r3, #4]
 8010dae:	9b01      	ldr	r3, [sp, #4]
 8010db0:	605a      	str	r2, [r3, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 8010db2:	9b01      	ldr	r3, [sp, #4]
 8010db4:	685b      	ldr	r3, [r3, #4]
 8010db6:	9a01      	ldr	r2, [sp, #4]
 8010db8:	601a      	str	r2, [r3, #0]
  return tp;
 8010dba:	9b03      	ldr	r3, [sp, #12]
}
 8010dbc:	4618      	mov	r0, r3
 8010dbe:	b004      	add	sp, #16
 8010dc0:	4770      	bx	lr
 8010dc2:	bf00      	nop
	...

08010dd0 <chSysLock.lto_priv.325>:
static inline void chSysLock(void) {
 8010dd0:	b508      	push	{r3, lr}
  port_lock();
 8010dd2:	f7ff ff75 	bl	8010cc0 <port_lock.lto_priv.399>
  _dbg_check_lock();
 8010dd6:	f7fe fa73 	bl	800f2c0 <_dbg_check_lock>
}
 8010dda:	bd08      	pop	{r3, pc}
 8010ddc:	0000      	movs	r0, r0
	...

08010de0 <chSysUnlock.lto_priv.301>:
static inline void chSysUnlock(void) {
 8010de0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8010de2:	f7fe fa85 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8010de6:	4b09      	ldr	r3, [pc, #36]	; (8010e0c <chSysUnlock.lto_priv.301+0x2c>)
 8010de8:	681b      	ldr	r3, [r3, #0]
 8010dea:	4a08      	ldr	r2, [pc, #32]	; (8010e0c <chSysUnlock.lto_priv.301+0x2c>)
 8010dec:	4293      	cmp	r3, r2
 8010dee:	d00a      	beq.n	8010e06 <chSysUnlock.lto_priv.301+0x26>
 8010df0:	4b06      	ldr	r3, [pc, #24]	; (8010e0c <chSysUnlock.lto_priv.301+0x2c>)
 8010df2:	699b      	ldr	r3, [r3, #24]
 8010df4:	689a      	ldr	r2, [r3, #8]
 8010df6:	4b05      	ldr	r3, [pc, #20]	; (8010e0c <chSysUnlock.lto_priv.301+0x2c>)
 8010df8:	681b      	ldr	r3, [r3, #0]
 8010dfa:	689b      	ldr	r3, [r3, #8]
 8010dfc:	429a      	cmp	r2, r3
 8010dfe:	d202      	bcs.n	8010e06 <chSysUnlock.lto_priv.301+0x26>
 8010e00:	4803      	ldr	r0, [pc, #12]	; (8010e10 <chSysUnlock.lto_priv.301+0x30>)
 8010e02:	f7fe f8ed 	bl	800efe0 <chSysHalt>
  port_unlock();
 8010e06:	f7ff ff63 	bl	8010cd0 <port_unlock.lto_priv.368>
}
 8010e0a:	bd08      	pop	{r3, pc}
 8010e0c:	20001090 	.word	0x20001090
 8010e10:	08016d50 	.word	0x08016d50
	...

08010e20 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
 8010e20:	b500      	push	{lr}
 8010e22:	b083      	sub	sp, #12
 8010e24:	9001      	str	r0, [sp, #4]
 8010e26:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
 8010e28:	9b01      	ldr	r3, [sp, #4]
 8010e2a:	2b00      	cmp	r3, #0
 8010e2c:	d002      	beq.n	8010e34 <chSemObjectInit+0x14>
 8010e2e:	9b00      	ldr	r3, [sp, #0]
 8010e30:	2b00      	cmp	r3, #0
 8010e32:	da02      	bge.n	8010e3a <chSemObjectInit+0x1a>
 8010e34:	4806      	ldr	r0, [pc, #24]	; (8010e50 <chSemObjectInit+0x30>)
 8010e36:	f7fe f8d3 	bl	800efe0 <chSysHalt>

  queue_init(&sp->queue);
 8010e3a:	9b01      	ldr	r3, [sp, #4]
 8010e3c:	4618      	mov	r0, r3
 8010e3e:	f7ff ff4f 	bl	8010ce0 <queue_init.lto_priv.464>
  sp->cnt = n;
 8010e42:	9b01      	ldr	r3, [sp, #4]
 8010e44:	9a00      	ldr	r2, [sp, #0]
 8010e46:	609a      	str	r2, [r3, #8]
}
 8010e48:	b003      	add	sp, #12
 8010e4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8010e4e:	bf00      	nop
 8010e50:	08016d40 	.word	0x08016d40
	...

08010e60 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8010e60:	b500      	push	{lr}
 8010e62:	b083      	sub	sp, #12
 8010e64:	9001      	str	r0, [sp, #4]
 8010e66:	9100      	str	r1, [sp, #0]

  chSysLock();
 8010e68:	f7ff ffb2 	bl	8010dd0 <chSysLock.lto_priv.325>
  chSemResetI(sp, n);
 8010e6c:	9900      	ldr	r1, [sp, #0]
 8010e6e:	9801      	ldr	r0, [sp, #4]
 8010e70:	f000 f80e 	bl	8010e90 <chSemResetI>
  chSchRescheduleS();
 8010e74:	f7ff f81c 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 8010e78:	f7ff ffb2 	bl	8010de0 <chSysUnlock.lto_priv.301>
}
 8010e7c:	b003      	add	sp, #12
 8010e7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8010e82:	bf00      	nop
	...

08010e90 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8010e90:	b500      	push	{lr}
 8010e92:	b085      	sub	sp, #20
 8010e94:	9001      	str	r0, [sp, #4]
 8010e96:	9100      	str	r1, [sp, #0]
  cnt_t cnt;

  chDbgCheckClassI();
 8010e98:	f7fe fab2 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
 8010e9c:	9b01      	ldr	r3, [sp, #4]
 8010e9e:	2b00      	cmp	r3, #0
 8010ea0:	d002      	beq.n	8010ea8 <chSemResetI+0x18>
 8010ea2:	9b00      	ldr	r3, [sp, #0]
 8010ea4:	2b00      	cmp	r3, #0
 8010ea6:	da02      	bge.n	8010eae <chSemResetI+0x1e>
 8010ea8:	481e      	ldr	r0, [pc, #120]	; (8010f24 <chSemResetI+0x94>)
 8010eaa:	f7fe f899 	bl	800efe0 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8010eae:	9b01      	ldr	r3, [sp, #4]
 8010eb0:	689b      	ldr	r3, [r3, #8]
 8010eb2:	2b00      	cmp	r3, #0
 8010eb4:	db09      	blt.n	8010eca <chSemResetI+0x3a>
 8010eb6:	9b01      	ldr	r3, [sp, #4]
 8010eb8:	4618      	mov	r0, r3
 8010eba:	f7ff ff21 	bl	8010d00 <queue_isempty>
 8010ebe:	4603      	mov	r3, r0
 8010ec0:	f083 0301 	eor.w	r3, r3, #1
 8010ec4:	b2db      	uxtb	r3, r3
 8010ec6:	2b00      	cmp	r3, #0
 8010ec8:	d010      	beq.n	8010eec <chSemResetI+0x5c>
 8010eca:	9b01      	ldr	r3, [sp, #4]
 8010ecc:	689b      	ldr	r3, [r3, #8]
 8010ece:	2b00      	cmp	r3, #0
 8010ed0:	da09      	bge.n	8010ee6 <chSemResetI+0x56>
 8010ed2:	9b01      	ldr	r3, [sp, #4]
 8010ed4:	4618      	mov	r0, r3
 8010ed6:	f7ff ff23 	bl	8010d20 <queue_notempty.lto_priv.484>
 8010eda:	4603      	mov	r3, r0
 8010edc:	f083 0301 	eor.w	r3, r3, #1
 8010ee0:	b2db      	uxtb	r3, r3
 8010ee2:	2b00      	cmp	r3, #0
 8010ee4:	d002      	beq.n	8010eec <chSemResetI+0x5c>
 8010ee6:	480f      	ldr	r0, [pc, #60]	; (8010f24 <chSemResetI+0x94>)
 8010ee8:	f7fe f87a 	bl	800efe0 <chSysHalt>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
 8010eec:	9b01      	ldr	r3, [sp, #4]
 8010eee:	689b      	ldr	r3, [r3, #8]
 8010ef0:	9303      	str	r3, [sp, #12]
  sp->cnt = n;
 8010ef2:	9b01      	ldr	r3, [sp, #4]
 8010ef4:	9a00      	ldr	r2, [sp, #0]
 8010ef6:	609a      	str	r2, [r3, #8]
 8010ef8:	e00b      	b.n	8010f12 <chSemResetI+0x82>
  while (++cnt <= (cnt_t)0) {
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 8010efa:	9b01      	ldr	r3, [sp, #4]
 8010efc:	4618      	mov	r0, r3
 8010efe:	f7ff ff4f 	bl	8010da0 <queue_lifo_remove>
 8010f02:	4603      	mov	r3, r0
 8010f04:	4618      	mov	r0, r3
 8010f06:	f7fe fe43 	bl	800fb90 <chSchReadyI>
 8010f0a:	4602      	mov	r2, r0
 8010f0c:	f06f 0301 	mvn.w	r3, #1
 8010f10:	6253      	str	r3, [r2, #36]	; 0x24
  while (++cnt <= (cnt_t)0) {
 8010f12:	9b03      	ldr	r3, [sp, #12]
 8010f14:	3301      	adds	r3, #1
 8010f16:	9303      	str	r3, [sp, #12]
 8010f18:	9b03      	ldr	r3, [sp, #12]
 8010f1a:	2b00      	cmp	r3, #0
 8010f1c:	dded      	ble.n	8010efa <chSemResetI+0x6a>
  }
}
 8010f1e:	b005      	add	sp, #20
 8010f20:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f24:	08016d5c 	.word	0x08016d5c
	...

08010f30 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8010f30:	b500      	push	{lr}
 8010f32:	b085      	sub	sp, #20
 8010f34:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8010f36:	f7ff ff4b 	bl	8010dd0 <chSysLock.lto_priv.325>
  msg = chSemWaitS(sp);
 8010f3a:	9801      	ldr	r0, [sp, #4]
 8010f3c:	f000 f808 	bl	8010f50 <chSemWaitS>
 8010f40:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8010f42:	f7ff ff4d 	bl	8010de0 <chSysUnlock.lto_priv.301>

  return msg;
 8010f46:	9b03      	ldr	r3, [sp, #12]
}
 8010f48:	4618      	mov	r0, r3
 8010f4a:	b005      	add	sp, #20
 8010f4c:	f85d fb04 	ldr.w	pc, [sp], #4

08010f50 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(semaphore_t *sp) {
 8010f50:	b500      	push	{lr}
 8010f52:	b083      	sub	sp, #12
 8010f54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8010f56:	f7fe fa6b 	bl	800f430 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 8010f5a:	9b01      	ldr	r3, [sp, #4]
 8010f5c:	2b00      	cmp	r3, #0
 8010f5e:	d102      	bne.n	8010f66 <chSemWaitS+0x16>
 8010f60:	4820      	ldr	r0, [pc, #128]	; (8010fe4 <chSemWaitS+0x94>)
 8010f62:	f7fe f83d 	bl	800efe0 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8010f66:	9b01      	ldr	r3, [sp, #4]
 8010f68:	689b      	ldr	r3, [r3, #8]
 8010f6a:	2b00      	cmp	r3, #0
 8010f6c:	db09      	blt.n	8010f82 <chSemWaitS+0x32>
 8010f6e:	9b01      	ldr	r3, [sp, #4]
 8010f70:	4618      	mov	r0, r3
 8010f72:	f7ff fec5 	bl	8010d00 <queue_isempty>
 8010f76:	4603      	mov	r3, r0
 8010f78:	f083 0301 	eor.w	r3, r3, #1
 8010f7c:	b2db      	uxtb	r3, r3
 8010f7e:	2b00      	cmp	r3, #0
 8010f80:	d010      	beq.n	8010fa4 <chSemWaitS+0x54>
 8010f82:	9b01      	ldr	r3, [sp, #4]
 8010f84:	689b      	ldr	r3, [r3, #8]
 8010f86:	2b00      	cmp	r3, #0
 8010f88:	da09      	bge.n	8010f9e <chSemWaitS+0x4e>
 8010f8a:	9b01      	ldr	r3, [sp, #4]
 8010f8c:	4618      	mov	r0, r3
 8010f8e:	f7ff fec7 	bl	8010d20 <queue_notempty.lto_priv.484>
 8010f92:	4603      	mov	r3, r0
 8010f94:	f083 0301 	eor.w	r3, r3, #1
 8010f98:	b2db      	uxtb	r3, r3
 8010f9a:	2b00      	cmp	r3, #0
 8010f9c:	d002      	beq.n	8010fa4 <chSemWaitS+0x54>
 8010f9e:	4811      	ldr	r0, [pc, #68]	; (8010fe4 <chSemWaitS+0x94>)
 8010fa0:	f7fe f81e 	bl	800efe0 <chSysHalt>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8010fa4:	9b01      	ldr	r3, [sp, #4]
 8010fa6:	689b      	ldr	r3, [r3, #8]
 8010fa8:	1e5a      	subs	r2, r3, #1
 8010faa:	9b01      	ldr	r3, [sp, #4]
 8010fac:	609a      	str	r2, [r3, #8]
 8010fae:	9b01      	ldr	r3, [sp, #4]
 8010fb0:	689b      	ldr	r3, [r3, #8]
 8010fb2:	2b00      	cmp	r3, #0
 8010fb4:	da11      	bge.n	8010fda <chSemWaitS+0x8a>
    currp->u.wtsemp = sp;
 8010fb6:	4b0c      	ldr	r3, [pc, #48]	; (8010fe8 <chSemWaitS+0x98>)
 8010fb8:	699b      	ldr	r3, [r3, #24]
 8010fba:	9a01      	ldr	r2, [sp, #4]
 8010fbc:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->queue);
 8010fbe:	4b0a      	ldr	r3, [pc, #40]	; (8010fe8 <chSemWaitS+0x98>)
 8010fc0:	699b      	ldr	r3, [r3, #24]
 8010fc2:	9a01      	ldr	r2, [sp, #4]
 8010fc4:	4611      	mov	r1, r2
 8010fc6:	4618      	mov	r0, r3
 8010fc8:	f7ff feba 	bl	8010d40 <queue_insert.lto_priv.475>
    chSchGoSleepS(CH_STATE_WTSEM);
 8010fcc:	2005      	movs	r0, #5
 8010fce:	f7fe fe5f 	bl	800fc90 <chSchGoSleepS>

    return currp->u.rdymsg;
 8010fd2:	4b05      	ldr	r3, [pc, #20]	; (8010fe8 <chSemWaitS+0x98>)
 8010fd4:	699b      	ldr	r3, [r3, #24]
 8010fd6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010fd8:	e000      	b.n	8010fdc <chSemWaitS+0x8c>
  }

  return MSG_OK;
 8010fda:	2300      	movs	r3, #0
}
 8010fdc:	4618      	mov	r0, r3
 8010fde:	b003      	add	sp, #12
 8010fe0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010fe4:	08016d68 	.word	0x08016d68
 8010fe8:	20001090 	.word	0x20001090
 8010fec:	00000000 	.word	0x00000000

08010ff0 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, sysinterval_t timeout) {
 8010ff0:	b500      	push	{lr}
 8010ff2:	b085      	sub	sp, #20
 8010ff4:	9001      	str	r0, [sp, #4]
 8010ff6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 8010ff8:	f7ff feea 	bl	8010dd0 <chSysLock.lto_priv.325>
  msg = chSemWaitTimeoutS(sp, timeout);
 8010ffc:	9900      	ldr	r1, [sp, #0]
 8010ffe:	9801      	ldr	r0, [sp, #4]
 8011000:	f000 f80e 	bl	8011020 <chSemWaitTimeoutS>
 8011004:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8011006:	f7ff feeb 	bl	8010de0 <chSysUnlock.lto_priv.301>

  return msg;
 801100a:	9b03      	ldr	r3, [sp, #12]
}
 801100c:	4618      	mov	r0, r3
 801100e:	b005      	add	sp, #20
 8011010:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08011020 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, sysinterval_t timeout) {
 8011020:	b500      	push	{lr}
 8011022:	b083      	sub	sp, #12
 8011024:	9001      	str	r0, [sp, #4]
 8011026:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 8011028:	f7fe fa02 	bl	800f430 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 801102c:	9b01      	ldr	r3, [sp, #4]
 801102e:	2b00      	cmp	r3, #0
 8011030:	d102      	bne.n	8011038 <chSemWaitTimeoutS+0x18>
 8011032:	4826      	ldr	r0, [pc, #152]	; (80110cc <chSemWaitTimeoutS+0xac>)
 8011034:	f7fd ffd4 	bl	800efe0 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8011038:	9b01      	ldr	r3, [sp, #4]
 801103a:	689b      	ldr	r3, [r3, #8]
 801103c:	2b00      	cmp	r3, #0
 801103e:	db09      	blt.n	8011054 <chSemWaitTimeoutS+0x34>
 8011040:	9b01      	ldr	r3, [sp, #4]
 8011042:	4618      	mov	r0, r3
 8011044:	f7ff fe5c 	bl	8010d00 <queue_isempty>
 8011048:	4603      	mov	r3, r0
 801104a:	f083 0301 	eor.w	r3, r3, #1
 801104e:	b2db      	uxtb	r3, r3
 8011050:	2b00      	cmp	r3, #0
 8011052:	d010      	beq.n	8011076 <chSemWaitTimeoutS+0x56>
 8011054:	9b01      	ldr	r3, [sp, #4]
 8011056:	689b      	ldr	r3, [r3, #8]
 8011058:	2b00      	cmp	r3, #0
 801105a:	da09      	bge.n	8011070 <chSemWaitTimeoutS+0x50>
 801105c:	9b01      	ldr	r3, [sp, #4]
 801105e:	4618      	mov	r0, r3
 8011060:	f7ff fe5e 	bl	8010d20 <queue_notempty.lto_priv.484>
 8011064:	4603      	mov	r3, r0
 8011066:	f083 0301 	eor.w	r3, r3, #1
 801106a:	b2db      	uxtb	r3, r3
 801106c:	2b00      	cmp	r3, #0
 801106e:	d002      	beq.n	8011076 <chSemWaitTimeoutS+0x56>
 8011070:	4816      	ldr	r0, [pc, #88]	; (80110cc <chSemWaitTimeoutS+0xac>)
 8011072:	f7fd ffb5 	bl	800efe0 <chSysHalt>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8011076:	9b01      	ldr	r3, [sp, #4]
 8011078:	689b      	ldr	r3, [r3, #8]
 801107a:	1e5a      	subs	r2, r3, #1
 801107c:	9b01      	ldr	r3, [sp, #4]
 801107e:	609a      	str	r2, [r3, #8]
 8011080:	9b01      	ldr	r3, [sp, #4]
 8011082:	689b      	ldr	r3, [r3, #8]
 8011084:	2b00      	cmp	r3, #0
 8011086:	da1b      	bge.n	80110c0 <chSemWaitTimeoutS+0xa0>
    if (TIME_IMMEDIATE == timeout) {
 8011088:	9b00      	ldr	r3, [sp, #0]
 801108a:	2b00      	cmp	r3, #0
 801108c:	d107      	bne.n	801109e <chSemWaitTimeoutS+0x7e>
      sp->cnt++;
 801108e:	9b01      	ldr	r3, [sp, #4]
 8011090:	689b      	ldr	r3, [r3, #8]
 8011092:	1c5a      	adds	r2, r3, #1
 8011094:	9b01      	ldr	r3, [sp, #4]
 8011096:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
 8011098:	f04f 33ff 	mov.w	r3, #4294967295
 801109c:	e011      	b.n	80110c2 <chSemWaitTimeoutS+0xa2>
    }
    currp->u.wtsemp = sp;
 801109e:	4b0c      	ldr	r3, [pc, #48]	; (80110d0 <chSemWaitTimeoutS+0xb0>)
 80110a0:	699b      	ldr	r3, [r3, #24]
 80110a2:	9a01      	ldr	r2, [sp, #4]
 80110a4:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->queue);
 80110a6:	4b0a      	ldr	r3, [pc, #40]	; (80110d0 <chSemWaitTimeoutS+0xb0>)
 80110a8:	699b      	ldr	r3, [r3, #24]
 80110aa:	9a01      	ldr	r2, [sp, #4]
 80110ac:	4611      	mov	r1, r2
 80110ae:	4618      	mov	r0, r3
 80110b0:	f7ff fe46 	bl	8010d40 <queue_insert.lto_priv.475>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 80110b4:	9900      	ldr	r1, [sp, #0]
 80110b6:	2005      	movs	r0, #5
 80110b8:	f7fe fe6a 	bl	800fd90 <chSchGoSleepTimeoutS>
 80110bc:	4603      	mov	r3, r0
 80110be:	e000      	b.n	80110c2 <chSemWaitTimeoutS+0xa2>
  }

  return MSG_OK;
 80110c0:	2300      	movs	r3, #0
}
 80110c2:	4618      	mov	r0, r3
 80110c4:	b003      	add	sp, #12
 80110c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80110ca:	bf00      	nop
 80110cc:	08016d74 	.word	0x08016d74
 80110d0:	20001090 	.word	0x20001090
	...

080110e0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 80110e0:	b500      	push	{lr}
 80110e2:	b083      	sub	sp, #12
 80110e4:	9001      	str	r0, [sp, #4]

  chDbgCheck(sp != NULL);
 80110e6:	9b01      	ldr	r3, [sp, #4]
 80110e8:	2b00      	cmp	r3, #0
 80110ea:	d102      	bne.n	80110f2 <chSemSignal+0x12>
 80110ec:	481d      	ldr	r0, [pc, #116]	; (8011164 <chSemSignal+0x84>)
 80110ee:	f7fd ff77 	bl	800efe0 <chSysHalt>

  chSysLock();
 80110f2:	f7ff fe6d 	bl	8010dd0 <chSysLock.lto_priv.325>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 80110f6:	9b01      	ldr	r3, [sp, #4]
 80110f8:	689b      	ldr	r3, [r3, #8]
 80110fa:	2b00      	cmp	r3, #0
 80110fc:	db09      	blt.n	8011112 <chSemSignal+0x32>
 80110fe:	9b01      	ldr	r3, [sp, #4]
 8011100:	4618      	mov	r0, r3
 8011102:	f7ff fdfd 	bl	8010d00 <queue_isempty>
 8011106:	4603      	mov	r3, r0
 8011108:	f083 0301 	eor.w	r3, r3, #1
 801110c:	b2db      	uxtb	r3, r3
 801110e:	2b00      	cmp	r3, #0
 8011110:	d010      	beq.n	8011134 <chSemSignal+0x54>
 8011112:	9b01      	ldr	r3, [sp, #4]
 8011114:	689b      	ldr	r3, [r3, #8]
 8011116:	2b00      	cmp	r3, #0
 8011118:	da09      	bge.n	801112e <chSemSignal+0x4e>
 801111a:	9b01      	ldr	r3, [sp, #4]
 801111c:	4618      	mov	r0, r3
 801111e:	f7ff fdff 	bl	8010d20 <queue_notempty.lto_priv.484>
 8011122:	4603      	mov	r3, r0
 8011124:	f083 0301 	eor.w	r3, r3, #1
 8011128:	b2db      	uxtb	r3, r3
 801112a:	2b00      	cmp	r3, #0
 801112c:	d002      	beq.n	8011134 <chSemSignal+0x54>
 801112e:	480d      	ldr	r0, [pc, #52]	; (8011164 <chSemSignal+0x84>)
 8011130:	f7fd ff56 	bl	800efe0 <chSysHalt>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");
  if (++sp->cnt <= (cnt_t)0) {
 8011134:	9b01      	ldr	r3, [sp, #4]
 8011136:	689b      	ldr	r3, [r3, #8]
 8011138:	1c5a      	adds	r2, r3, #1
 801113a:	9b01      	ldr	r3, [sp, #4]
 801113c:	609a      	str	r2, [r3, #8]
 801113e:	9b01      	ldr	r3, [sp, #4]
 8011140:	689b      	ldr	r3, [r3, #8]
 8011142:	2b00      	cmp	r3, #0
 8011144:	dc08      	bgt.n	8011158 <chSemSignal+0x78>
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 8011146:	9b01      	ldr	r3, [sp, #4]
 8011148:	4618      	mov	r0, r3
 801114a:	f7ff fe11 	bl	8010d70 <queue_fifo_remove.lto_priv.470>
 801114e:	4603      	mov	r3, r0
 8011150:	2100      	movs	r1, #0
 8011152:	4618      	mov	r0, r3
 8011154:	f7fe fe54 	bl	800fe00 <chSchWakeupS>
  }
  chSysUnlock();
 8011158:	f7ff fe42 	bl	8010de0 <chSysUnlock.lto_priv.301>
}
 801115c:	b003      	add	sp, #12
 801115e:	f85d fb04 	ldr.w	pc, [sp], #4
 8011162:	bf00      	nop
 8011164:	08016d88 	.word	0x08016d88
	...

08011170 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8011170:	b500      	push	{lr}
 8011172:	b085      	sub	sp, #20
 8011174:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8011176:	f7fe f943 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
 801117a:	9b01      	ldr	r3, [sp, #4]
 801117c:	2b00      	cmp	r3, #0
 801117e:	d102      	bne.n	8011186 <chSemSignalI+0x16>
 8011180:	481c      	ldr	r0, [pc, #112]	; (80111f4 <chSemSignalI+0x84>)
 8011182:	f7fd ff2d 	bl	800efe0 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8011186:	9b01      	ldr	r3, [sp, #4]
 8011188:	689b      	ldr	r3, [r3, #8]
 801118a:	2b00      	cmp	r3, #0
 801118c:	db09      	blt.n	80111a2 <chSemSignalI+0x32>
 801118e:	9b01      	ldr	r3, [sp, #4]
 8011190:	4618      	mov	r0, r3
 8011192:	f7ff fdb5 	bl	8010d00 <queue_isempty>
 8011196:	4603      	mov	r3, r0
 8011198:	f083 0301 	eor.w	r3, r3, #1
 801119c:	b2db      	uxtb	r3, r3
 801119e:	2b00      	cmp	r3, #0
 80111a0:	d010      	beq.n	80111c4 <chSemSignalI+0x54>
 80111a2:	9b01      	ldr	r3, [sp, #4]
 80111a4:	689b      	ldr	r3, [r3, #8]
 80111a6:	2b00      	cmp	r3, #0
 80111a8:	da09      	bge.n	80111be <chSemSignalI+0x4e>
 80111aa:	9b01      	ldr	r3, [sp, #4]
 80111ac:	4618      	mov	r0, r3
 80111ae:	f7ff fdb7 	bl	8010d20 <queue_notempty.lto_priv.484>
 80111b2:	4603      	mov	r3, r0
 80111b4:	f083 0301 	eor.w	r3, r3, #1
 80111b8:	b2db      	uxtb	r3, r3
 80111ba:	2b00      	cmp	r3, #0
 80111bc:	d002      	beq.n	80111c4 <chSemSignalI+0x54>
 80111be:	480d      	ldr	r0, [pc, #52]	; (80111f4 <chSemSignalI+0x84>)
 80111c0:	f7fd ff0e 	bl	800efe0 <chSysHalt>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 80111c4:	9b01      	ldr	r3, [sp, #4]
 80111c6:	689b      	ldr	r3, [r3, #8]
 80111c8:	1c5a      	adds	r2, r3, #1
 80111ca:	9b01      	ldr	r3, [sp, #4]
 80111cc:	609a      	str	r2, [r3, #8]
 80111ce:	9b01      	ldr	r3, [sp, #4]
 80111d0:	689b      	ldr	r3, [r3, #8]
 80111d2:	2b00      	cmp	r3, #0
 80111d4:	dc0a      	bgt.n	80111ec <chSemSignalI+0x7c>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
 80111d6:	9b01      	ldr	r3, [sp, #4]
 80111d8:	4618      	mov	r0, r3
 80111da:	f7ff fdc9 	bl	8010d70 <queue_fifo_remove.lto_priv.470>
 80111de:	9003      	str	r0, [sp, #12]
    tp->u.rdymsg = MSG_OK;
 80111e0:	9b03      	ldr	r3, [sp, #12]
 80111e2:	2200      	movs	r2, #0
 80111e4:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 80111e6:	9803      	ldr	r0, [sp, #12]
 80111e8:	f7fe fcd2 	bl	800fb90 <chSchReadyI>
  }
}
 80111ec:	b005      	add	sp, #20
 80111ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80111f2:	bf00      	nop
 80111f4:	08016d94 	.word	0x08016d94
	...

08011200 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 8011200:	b500      	push	{lr}
 8011202:	b083      	sub	sp, #12
 8011204:	9001      	str	r0, [sp, #4]
 8011206:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8011208:	f7fe f8fa 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
 801120c:	9b01      	ldr	r3, [sp, #4]
 801120e:	2b00      	cmp	r3, #0
 8011210:	d002      	beq.n	8011218 <chSemAddCounterI+0x18>
 8011212:	9b00      	ldr	r3, [sp, #0]
 8011214:	2b00      	cmp	r3, #0
 8011216:	dc02      	bgt.n	801121e <chSemAddCounterI+0x1e>
 8011218:	481f      	ldr	r0, [pc, #124]	; (8011298 <chSemAddCounterI+0x98>)
 801121a:	f7fd fee1 	bl	800efe0 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 801121e:	9b01      	ldr	r3, [sp, #4]
 8011220:	689b      	ldr	r3, [r3, #8]
 8011222:	2b00      	cmp	r3, #0
 8011224:	db09      	blt.n	801123a <chSemAddCounterI+0x3a>
 8011226:	9b01      	ldr	r3, [sp, #4]
 8011228:	4618      	mov	r0, r3
 801122a:	f7ff fd69 	bl	8010d00 <queue_isempty>
 801122e:	4603      	mov	r3, r0
 8011230:	f083 0301 	eor.w	r3, r3, #1
 8011234:	b2db      	uxtb	r3, r3
 8011236:	2b00      	cmp	r3, #0
 8011238:	d028      	beq.n	801128c <chSemAddCounterI+0x8c>
 801123a:	9b01      	ldr	r3, [sp, #4]
 801123c:	689b      	ldr	r3, [r3, #8]
 801123e:	2b00      	cmp	r3, #0
 8011240:	da09      	bge.n	8011256 <chSemAddCounterI+0x56>
 8011242:	9b01      	ldr	r3, [sp, #4]
 8011244:	4618      	mov	r0, r3
 8011246:	f7ff fd6b 	bl	8010d20 <queue_notempty.lto_priv.484>
 801124a:	4603      	mov	r3, r0
 801124c:	f083 0301 	eor.w	r3, r3, #1
 8011250:	b2db      	uxtb	r3, r3
 8011252:	2b00      	cmp	r3, #0
 8011254:	d01a      	beq.n	801128c <chSemAddCounterI+0x8c>
 8011256:	4810      	ldr	r0, [pc, #64]	; (8011298 <chSemAddCounterI+0x98>)
 8011258:	f7fd fec2 	bl	800efe0 <chSysHalt>
 801125c:	e016      	b.n	801128c <chSemAddCounterI+0x8c>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->cnt <= (cnt_t)0) {
 801125e:	9b01      	ldr	r3, [sp, #4]
 8011260:	689b      	ldr	r3, [r3, #8]
 8011262:	1c5a      	adds	r2, r3, #1
 8011264:	9b01      	ldr	r3, [sp, #4]
 8011266:	609a      	str	r2, [r3, #8]
 8011268:	9b01      	ldr	r3, [sp, #4]
 801126a:	689b      	ldr	r3, [r3, #8]
 801126c:	2b00      	cmp	r3, #0
 801126e:	dc0a      	bgt.n	8011286 <chSemAddCounterI+0x86>
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8011270:	9b01      	ldr	r3, [sp, #4]
 8011272:	4618      	mov	r0, r3
 8011274:	f7ff fd7c 	bl	8010d70 <queue_fifo_remove.lto_priv.470>
 8011278:	4603      	mov	r3, r0
 801127a:	4618      	mov	r0, r3
 801127c:	f7fe fc88 	bl	800fb90 <chSchReadyI>
 8011280:	4602      	mov	r2, r0
 8011282:	2300      	movs	r3, #0
 8011284:	6253      	str	r3, [r2, #36]	; 0x24
    }
    n--;
 8011286:	9b00      	ldr	r3, [sp, #0]
 8011288:	3b01      	subs	r3, #1
 801128a:	9300      	str	r3, [sp, #0]
  while (n > (cnt_t)0) {
 801128c:	9b00      	ldr	r3, [sp, #0]
 801128e:	2b00      	cmp	r3, #0
 8011290:	dce5      	bgt.n	801125e <chSemAddCounterI+0x5e>
  }
}
 8011292:	b003      	add	sp, #12
 8011294:	f85d fb04 	ldr.w	pc, [sp], #4
 8011298:	08016da4 	.word	0x08016da4
 801129c:	00000000 	.word	0x00000000

080112a0 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 80112a0:	b500      	push	{lr}
 80112a2:	b085      	sub	sp, #20
 80112a4:	9001      	str	r0, [sp, #4]
 80112a6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chDbgCheck((sps != NULL) && (spw != NULL));
 80112a8:	9b01      	ldr	r3, [sp, #4]
 80112aa:	2b00      	cmp	r3, #0
 80112ac:	d002      	beq.n	80112b4 <chSemSignalWait+0x14>
 80112ae:	9b00      	ldr	r3, [sp, #0]
 80112b0:	2b00      	cmp	r3, #0
 80112b2:	d102      	bne.n	80112ba <chSemSignalWait+0x1a>
 80112b4:	483e      	ldr	r0, [pc, #248]	; (80113b0 <chSemSignalWait+0x110>)
 80112b6:	f7fd fe93 	bl	800efe0 <chSysHalt>

  chSysLock();
 80112ba:	f7ff fd89 	bl	8010dd0 <chSysLock.lto_priv.325>
  chDbgAssert(((sps->cnt >= (cnt_t)0) && queue_isempty(&sps->queue)) ||
 80112be:	9b01      	ldr	r3, [sp, #4]
 80112c0:	689b      	ldr	r3, [r3, #8]
 80112c2:	2b00      	cmp	r3, #0
 80112c4:	db09      	blt.n	80112da <chSemSignalWait+0x3a>
 80112c6:	9b01      	ldr	r3, [sp, #4]
 80112c8:	4618      	mov	r0, r3
 80112ca:	f7ff fd19 	bl	8010d00 <queue_isempty>
 80112ce:	4603      	mov	r3, r0
 80112d0:	f083 0301 	eor.w	r3, r3, #1
 80112d4:	b2db      	uxtb	r3, r3
 80112d6:	2b00      	cmp	r3, #0
 80112d8:	d010      	beq.n	80112fc <chSemSignalWait+0x5c>
 80112da:	9b01      	ldr	r3, [sp, #4]
 80112dc:	689b      	ldr	r3, [r3, #8]
 80112de:	2b00      	cmp	r3, #0
 80112e0:	da09      	bge.n	80112f6 <chSemSignalWait+0x56>
 80112e2:	9b01      	ldr	r3, [sp, #4]
 80112e4:	4618      	mov	r0, r3
 80112e6:	f7ff fd1b 	bl	8010d20 <queue_notempty.lto_priv.484>
 80112ea:	4603      	mov	r3, r0
 80112ec:	f083 0301 	eor.w	r3, r3, #1
 80112f0:	b2db      	uxtb	r3, r3
 80112f2:	2b00      	cmp	r3, #0
 80112f4:	d002      	beq.n	80112fc <chSemSignalWait+0x5c>
 80112f6:	482e      	ldr	r0, [pc, #184]	; (80113b0 <chSemSignalWait+0x110>)
 80112f8:	f7fd fe72 	bl	800efe0 <chSysHalt>
              ((sps->cnt < (cnt_t)0) && queue_notempty(&sps->queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
 80112fc:	9b00      	ldr	r3, [sp, #0]
 80112fe:	689b      	ldr	r3, [r3, #8]
 8011300:	2b00      	cmp	r3, #0
 8011302:	db09      	blt.n	8011318 <chSemSignalWait+0x78>
 8011304:	9b00      	ldr	r3, [sp, #0]
 8011306:	4618      	mov	r0, r3
 8011308:	f7ff fcfa 	bl	8010d00 <queue_isempty>
 801130c:	4603      	mov	r3, r0
 801130e:	f083 0301 	eor.w	r3, r3, #1
 8011312:	b2db      	uxtb	r3, r3
 8011314:	2b00      	cmp	r3, #0
 8011316:	d010      	beq.n	801133a <chSemSignalWait+0x9a>
 8011318:	9b00      	ldr	r3, [sp, #0]
 801131a:	689b      	ldr	r3, [r3, #8]
 801131c:	2b00      	cmp	r3, #0
 801131e:	da09      	bge.n	8011334 <chSemSignalWait+0x94>
 8011320:	9b00      	ldr	r3, [sp, #0]
 8011322:	4618      	mov	r0, r3
 8011324:	f7ff fcfc 	bl	8010d20 <queue_notempty.lto_priv.484>
 8011328:	4603      	mov	r3, r0
 801132a:	f083 0301 	eor.w	r3, r3, #1
 801132e:	b2db      	uxtb	r3, r3
 8011330:	2b00      	cmp	r3, #0
 8011332:	d002      	beq.n	801133a <chSemSignalWait+0x9a>
 8011334:	481e      	ldr	r0, [pc, #120]	; (80113b0 <chSemSignalWait+0x110>)
 8011336:	f7fd fe53 	bl	800efe0 <chSysHalt>
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
 801133a:	9b01      	ldr	r3, [sp, #4]
 801133c:	689b      	ldr	r3, [r3, #8]
 801133e:	1c5a      	adds	r2, r3, #1
 8011340:	9b01      	ldr	r3, [sp, #4]
 8011342:	609a      	str	r2, [r3, #8]
 8011344:	9b01      	ldr	r3, [sp, #4]
 8011346:	689b      	ldr	r3, [r3, #8]
 8011348:	2b00      	cmp	r3, #0
 801134a:	dc0a      	bgt.n	8011362 <chSemSignalWait+0xc2>
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 801134c:	9b01      	ldr	r3, [sp, #4]
 801134e:	4618      	mov	r0, r3
 8011350:	f7ff fd0e 	bl	8010d70 <queue_fifo_remove.lto_priv.470>
 8011354:	4603      	mov	r3, r0
 8011356:	4618      	mov	r0, r3
 8011358:	f7fe fc1a 	bl	800fb90 <chSchReadyI>
 801135c:	4602      	mov	r2, r0
 801135e:	2300      	movs	r3, #0
 8011360:	6253      	str	r3, [r2, #36]	; 0x24
  }
  if (--spw->cnt < (cnt_t)0) {
 8011362:	9b00      	ldr	r3, [sp, #0]
 8011364:	689b      	ldr	r3, [r3, #8]
 8011366:	1e5a      	subs	r2, r3, #1
 8011368:	9b00      	ldr	r3, [sp, #0]
 801136a:	609a      	str	r2, [r3, #8]
 801136c:	9b00      	ldr	r3, [sp, #0]
 801136e:	689b      	ldr	r3, [r3, #8]
 8011370:	2b00      	cmp	r3, #0
 8011372:	da11      	bge.n	8011398 <chSemSignalWait+0xf8>
    thread_t *ctp = currp;
 8011374:	4b0f      	ldr	r3, [pc, #60]	; (80113b4 <chSemSignalWait+0x114>)
 8011376:	699b      	ldr	r3, [r3, #24]
 8011378:	9302      	str	r3, [sp, #8]
    sem_insert(ctp, &spw->queue);
 801137a:	9b00      	ldr	r3, [sp, #0]
 801137c:	4619      	mov	r1, r3
 801137e:	9802      	ldr	r0, [sp, #8]
 8011380:	f7ff fcde 	bl	8010d40 <queue_insert.lto_priv.475>
    ctp->u.wtsemp = spw;
 8011384:	9b02      	ldr	r3, [sp, #8]
 8011386:	9a00      	ldr	r2, [sp, #0]
 8011388:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTSEM);
 801138a:	2005      	movs	r0, #5
 801138c:	f7fe fc80 	bl	800fc90 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 8011390:	9b02      	ldr	r3, [sp, #8]
 8011392:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011394:	9303      	str	r3, [sp, #12]
 8011396:	e003      	b.n	80113a0 <chSemSignalWait+0x100>
  }
  else {
    chSchRescheduleS();
 8011398:	f7fe fd8a 	bl	800feb0 <chSchRescheduleS>
    msg = MSG_OK;
 801139c:	2300      	movs	r3, #0
 801139e:	9303      	str	r3, [sp, #12]
  }
  chSysUnlock();
 80113a0:	f7ff fd1e 	bl	8010de0 <chSysUnlock.lto_priv.301>

  return msg;
 80113a4:	9b03      	ldr	r3, [sp, #12]
}
 80113a6:	4618      	mov	r0, r3
 80113a8:	b005      	add	sp, #20
 80113aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80113ae:	bf00      	nop
 80113b0:	08016db8 	.word	0x08016db8
 80113b4:	20001090 	.word	0x20001090
	...

080113c0 <port_lock.lto_priv.400>:
static inline void port_lock(void) {
 80113c0:	b082      	sub	sp, #8
 80113c2:	2320      	movs	r3, #32
 80113c4:	9301      	str	r3, [sp, #4]
 80113c6:	9b01      	ldr	r3, [sp, #4]
 80113c8:	f383 8811 	msr	BASEPRI, r3
}
 80113cc:	b002      	add	sp, #8
 80113ce:	4770      	bx	lr

080113d0 <port_unlock.lto_priv.369>:
static inline void port_unlock(void) {
 80113d0:	b082      	sub	sp, #8
 80113d2:	2300      	movs	r3, #0
 80113d4:	9301      	str	r3, [sp, #4]
 80113d6:	9b01      	ldr	r3, [sp, #4]
 80113d8:	f383 8811 	msr	BASEPRI, r3
}
 80113dc:	b002      	add	sp, #8
 80113de:	4770      	bx	lr

080113e0 <queue_init.lto_priv.465>:
static inline void queue_init(threads_queue_t *tqp) {
 80113e0:	b082      	sub	sp, #8
 80113e2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80113e4:	9b01      	ldr	r3, [sp, #4]
 80113e6:	9a01      	ldr	r2, [sp, #4]
 80113e8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80113ea:	9b01      	ldr	r3, [sp, #4]
 80113ec:	9a01      	ldr	r2, [sp, #4]
 80113ee:	605a      	str	r2, [r3, #4]
}
 80113f0:	b002      	add	sp, #8
 80113f2:	4770      	bx	lr
	...

08011400 <queue_notempty.lto_priv.485>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8011400:	b082      	sub	sp, #8
 8011402:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next != (const thread_t *)tqp);
 8011404:	9b01      	ldr	r3, [sp, #4]
 8011406:	681b      	ldr	r3, [r3, #0]
 8011408:	9a01      	ldr	r2, [sp, #4]
 801140a:	429a      	cmp	r2, r3
 801140c:	bf14      	ite	ne
 801140e:	2301      	movne	r3, #1
 8011410:	2300      	moveq	r3, #0
 8011412:	b2db      	uxtb	r3, r3
}
 8011414:	4618      	mov	r0, r3
 8011416:	b002      	add	sp, #8
 8011418:	4770      	bx	lr
 801141a:	bf00      	nop
 801141c:	0000      	movs	r0, r0
	...

08011420 <queue_prio_insert.lto_priv.481>:
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8011420:	b084      	sub	sp, #16
 8011422:	9001      	str	r0, [sp, #4]
 8011424:	9100      	str	r1, [sp, #0]
  thread_t *cp = (thread_t *)tqp;
 8011426:	9b00      	ldr	r3, [sp, #0]
 8011428:	9303      	str	r3, [sp, #12]
    cp = cp->queue.next;
 801142a:	9b03      	ldr	r3, [sp, #12]
 801142c:	681b      	ldr	r3, [r3, #0]
 801142e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8011430:	9a03      	ldr	r2, [sp, #12]
 8011432:	9b00      	ldr	r3, [sp, #0]
 8011434:	429a      	cmp	r2, r3
 8011436:	d005      	beq.n	8011444 <queue_prio_insert.lto_priv.481+0x24>
 8011438:	9b03      	ldr	r3, [sp, #12]
 801143a:	689a      	ldr	r2, [r3, #8]
 801143c:	9b01      	ldr	r3, [sp, #4]
 801143e:	689b      	ldr	r3, [r3, #8]
 8011440:	429a      	cmp	r2, r3
 8011442:	d2f2      	bcs.n	801142a <queue_prio_insert.lto_priv.481+0xa>
  tp->queue.next             = cp;
 8011444:	9b01      	ldr	r3, [sp, #4]
 8011446:	9a03      	ldr	r2, [sp, #12]
 8011448:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 801144a:	9b03      	ldr	r3, [sp, #12]
 801144c:	685a      	ldr	r2, [r3, #4]
 801144e:	9b01      	ldr	r3, [sp, #4]
 8011450:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8011452:	9b01      	ldr	r3, [sp, #4]
 8011454:	685b      	ldr	r3, [r3, #4]
 8011456:	9a01      	ldr	r2, [sp, #4]
 8011458:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 801145a:	9b03      	ldr	r3, [sp, #12]
 801145c:	9a01      	ldr	r2, [sp, #4]
 801145e:	605a      	str	r2, [r3, #4]
}
 8011460:	b004      	add	sp, #16
 8011462:	4770      	bx	lr
	...

08011470 <queue_fifo_remove.lto_priv.471>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8011470:	b084      	sub	sp, #16
 8011472:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8011474:	9b01      	ldr	r3, [sp, #4]
 8011476:	681b      	ldr	r3, [r3, #0]
 8011478:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 801147a:	9b03      	ldr	r3, [sp, #12]
 801147c:	681a      	ldr	r2, [r3, #0]
 801147e:	9b01      	ldr	r3, [sp, #4]
 8011480:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8011482:	9b01      	ldr	r3, [sp, #4]
 8011484:	681b      	ldr	r3, [r3, #0]
 8011486:	9a01      	ldr	r2, [sp, #4]
 8011488:	605a      	str	r2, [r3, #4]
  return tp;
 801148a:	9b03      	ldr	r3, [sp, #12]
}
 801148c:	4618      	mov	r0, r3
 801148e:	b004      	add	sp, #16
 8011490:	4770      	bx	lr
 8011492:	bf00      	nop
	...

080114a0 <queue_dequeue.lto_priv.490>:
static inline thread_t *queue_dequeue(thread_t *tp) {
 80114a0:	b082      	sub	sp, #8
 80114a2:	9001      	str	r0, [sp, #4]
  tp->queue.prev->queue.next = tp->queue.next;
 80114a4:	9b01      	ldr	r3, [sp, #4]
 80114a6:	685b      	ldr	r3, [r3, #4]
 80114a8:	9a01      	ldr	r2, [sp, #4]
 80114aa:	6812      	ldr	r2, [r2, #0]
 80114ac:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80114ae:	9b01      	ldr	r3, [sp, #4]
 80114b0:	681b      	ldr	r3, [r3, #0]
 80114b2:	9a01      	ldr	r2, [sp, #4]
 80114b4:	6852      	ldr	r2, [r2, #4]
 80114b6:	605a      	str	r2, [r3, #4]
  return tp;
 80114b8:	9b01      	ldr	r3, [sp, #4]
}
 80114ba:	4618      	mov	r0, r3
 80114bc:	b002      	add	sp, #8
 80114be:	4770      	bx	lr

080114c0 <chSysLock.lto_priv.326>:
static inline void chSysLock(void) {
 80114c0:	b508      	push	{r3, lr}
  port_lock();
 80114c2:	f7ff ff7d 	bl	80113c0 <port_lock.lto_priv.400>
  _dbg_check_lock();
 80114c6:	f7fd fefb 	bl	800f2c0 <_dbg_check_lock>
}
 80114ca:	bd08      	pop	{r3, pc}
 80114cc:	0000      	movs	r0, r0
	...

080114d0 <chSysUnlock.lto_priv.302>:
static inline void chSysUnlock(void) {
 80114d0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80114d2:	f7fd ff0d 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80114d6:	4b09      	ldr	r3, [pc, #36]	; (80114fc <chSysUnlock.lto_priv.302+0x2c>)
 80114d8:	681b      	ldr	r3, [r3, #0]
 80114da:	4a08      	ldr	r2, [pc, #32]	; (80114fc <chSysUnlock.lto_priv.302+0x2c>)
 80114dc:	4293      	cmp	r3, r2
 80114de:	d00a      	beq.n	80114f6 <chSysUnlock.lto_priv.302+0x26>
 80114e0:	4b06      	ldr	r3, [pc, #24]	; (80114fc <chSysUnlock.lto_priv.302+0x2c>)
 80114e2:	699b      	ldr	r3, [r3, #24]
 80114e4:	689a      	ldr	r2, [r3, #8]
 80114e6:	4b05      	ldr	r3, [pc, #20]	; (80114fc <chSysUnlock.lto_priv.302+0x2c>)
 80114e8:	681b      	ldr	r3, [r3, #0]
 80114ea:	689b      	ldr	r3, [r3, #8]
 80114ec:	429a      	cmp	r2, r3
 80114ee:	d202      	bcs.n	80114f6 <chSysUnlock.lto_priv.302+0x26>
 80114f0:	4803      	ldr	r0, [pc, #12]	; (8011500 <chSysUnlock.lto_priv.302+0x30>)
 80114f2:	f7fd fd75 	bl	800efe0 <chSysHalt>
  port_unlock();
 80114f6:	f7ff ff6b 	bl	80113d0 <port_unlock.lto_priv.369>
}
 80114fa:	bd08      	pop	{r3, pc}
 80114fc:	20001090 	.word	0x20001090
 8011500:	08016dd8 	.word	0x08016dd8
	...

08011510 <chMtxQueueNotEmptyS>:
 * @param[out] mp       pointer to a @p mutex_t structure
 * @return              The mutex queue status.
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8011510:	b500      	push	{lr}
 8011512:	b083      	sub	sp, #12
 8011514:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8011516:	f7fd ff8b 	bl	800f430 <chDbgCheckClassS>

  return queue_notempty(&mp->queue);
 801151a:	9b01      	ldr	r3, [sp, #4]
 801151c:	4618      	mov	r0, r3
 801151e:	f7ff ff6f 	bl	8011400 <queue_notempty.lto_priv.485>
 8011522:	4603      	mov	r3, r0
}
 8011524:	4618      	mov	r0, r3
 8011526:	b003      	add	sp, #12
 8011528:	f85d fb04 	ldr.w	pc, [sp], #4
 801152c:	0000      	movs	r0, r0
	...

08011530 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8011530:	b500      	push	{lr}
 8011532:	b083      	sub	sp, #12
 8011534:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8011536:	9b01      	ldr	r3, [sp, #4]
 8011538:	2b00      	cmp	r3, #0
 801153a:	d102      	bne.n	8011542 <chMtxObjectInit+0x12>
 801153c:	4806      	ldr	r0, [pc, #24]	; (8011558 <chMtxObjectInit+0x28>)
 801153e:	f7fd fd4f 	bl	800efe0 <chSysHalt>

  queue_init(&mp->queue);
 8011542:	9b01      	ldr	r3, [sp, #4]
 8011544:	4618      	mov	r0, r3
 8011546:	f7ff ff4b 	bl	80113e0 <queue_init.lto_priv.465>
  mp->owner = NULL;
 801154a:	9b01      	ldr	r3, [sp, #4]
 801154c:	2200      	movs	r2, #0
 801154e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8011550:	b003      	add	sp, #12
 8011552:	f85d fb04 	ldr.w	pc, [sp], #4
 8011556:	bf00      	nop
 8011558:	08016dc8 	.word	0x08016dc8
 801155c:	00000000 	.word	0x00000000

08011560 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8011560:	b500      	push	{lr}
 8011562:	b083      	sub	sp, #12
 8011564:	9001      	str	r0, [sp, #4]

  chSysLock();
 8011566:	f7ff ffab 	bl	80114c0 <chSysLock.lto_priv.326>
  chMtxLockS(mp);
 801156a:	9801      	ldr	r0, [sp, #4]
 801156c:	f000 f808 	bl	8011580 <chMtxLockS>
  chSysUnlock();
 8011570:	f7ff ffae 	bl	80114d0 <chSysUnlock.lto_priv.302>
}
 8011574:	b003      	add	sp, #12
 8011576:	f85d fb04 	ldr.w	pc, [sp], #4
 801157a:	bf00      	nop
 801157c:	0000      	movs	r0, r0
	...

08011580 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8011580:	b500      	push	{lr}
 8011582:	b085      	sub	sp, #20
 8011584:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8011586:	4b3b      	ldr	r3, [pc, #236]	; (8011674 <chMtxLockS+0xf4>)
 8011588:	699b      	ldr	r3, [r3, #24]
 801158a:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 801158c:	f7fd ff50 	bl	800f430 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8011590:	9b01      	ldr	r3, [sp, #4]
 8011592:	2b00      	cmp	r3, #0
 8011594:	d102      	bne.n	801159c <chMtxLockS+0x1c>
 8011596:	4838      	ldr	r0, [pc, #224]	; (8011678 <chMtxLockS+0xf8>)
 8011598:	f7fd fd22 	bl	800efe0 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 801159c:	9b01      	ldr	r3, [sp, #4]
 801159e:	689b      	ldr	r3, [r3, #8]
 80115a0:	2b00      	cmp	r3, #0
 80115a2:	d059      	beq.n	8011658 <chMtxLockS+0xd8>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 80115a4:	9b01      	ldr	r3, [sp, #4]
 80115a6:	689b      	ldr	r3, [r3, #8]
 80115a8:	9303      	str	r3, [sp, #12]
 80115aa:	e033      	b.n	8011614 <chMtxLockS+0x94>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 80115ac:	9b02      	ldr	r3, [sp, #8]
 80115ae:	689a      	ldr	r2, [r3, #8]
 80115b0:	9b03      	ldr	r3, [sp, #12]
 80115b2:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80115b4:	9b03      	ldr	r3, [sp, #12]
 80115b6:	f893 3020 	ldrb.w	r3, [r3, #32]
 80115ba:	2b06      	cmp	r3, #6
 80115bc:	d004      	beq.n	80115c8 <chMtxLockS+0x48>
 80115be:	2b07      	cmp	r3, #7
 80115c0:	d011      	beq.n	80115e6 <chMtxLockS+0x66>
 80115c2:	2b00      	cmp	r3, #0
 80115c4:	d01a      	beq.n	80115fc <chMtxLockS+0x7c>
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
          break;
        default:
 80115c6:	e02b      	b.n	8011620 <chMtxLockS+0xa0>
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80115c8:	9803      	ldr	r0, [sp, #12]
 80115ca:	f7ff ff69 	bl	80114a0 <queue_dequeue.lto_priv.490>
 80115ce:	4602      	mov	r2, r0
 80115d0:	9b03      	ldr	r3, [sp, #12]
 80115d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80115d4:	4619      	mov	r1, r3
 80115d6:	4610      	mov	r0, r2
 80115d8:	f7ff ff22 	bl	8011420 <queue_prio_insert.lto_priv.481>
          tp = tp->u.wtmtxp->owner;
 80115dc:	9b03      	ldr	r3, [sp, #12]
 80115de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80115e0:	689b      	ldr	r3, [r3, #8]
 80115e2:	9303      	str	r3, [sp, #12]
 80115e4:	e016      	b.n	8011614 <chMtxLockS+0x94>
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80115e6:	9803      	ldr	r0, [sp, #12]
 80115e8:	f7ff ff5a 	bl	80114a0 <queue_dequeue.lto_priv.490>
 80115ec:	4602      	mov	r2, r0
 80115ee:	9b03      	ldr	r3, [sp, #12]
 80115f0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80115f2:	4619      	mov	r1, r3
 80115f4:	4610      	mov	r0, r2
 80115f6:	f7ff ff13 	bl	8011420 <queue_prio_insert.lto_priv.481>
        default:
 80115fa:	e011      	b.n	8011620 <chMtxLockS+0xa0>
          tp->state = CH_STATE_CURRENT;
 80115fc:	9b03      	ldr	r3, [sp, #12]
 80115fe:	2201      	movs	r2, #1
 8011600:	f883 2020 	strb.w	r2, [r3, #32]
          (void) chSchReadyI(queue_dequeue(tp));
 8011604:	9803      	ldr	r0, [sp, #12]
 8011606:	f7ff ff4b 	bl	80114a0 <queue_dequeue.lto_priv.490>
 801160a:	4603      	mov	r3, r0
 801160c:	4618      	mov	r0, r3
 801160e:	f7fe fabf 	bl	800fb90 <chSchReadyI>
        default:
 8011612:	e005      	b.n	8011620 <chMtxLockS+0xa0>
      while (tp->prio < ctp->prio) {
 8011614:	9b03      	ldr	r3, [sp, #12]
 8011616:	689a      	ldr	r2, [r3, #8]
 8011618:	9b02      	ldr	r3, [sp, #8]
 801161a:	689b      	ldr	r3, [r3, #8]
 801161c:	429a      	cmp	r2, r3
 801161e:	d3c5      	bcc.n	80115ac <chMtxLockS+0x2c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 8011620:	9b01      	ldr	r3, [sp, #4]
 8011622:	4619      	mov	r1, r3
 8011624:	9802      	ldr	r0, [sp, #8]
 8011626:	f7ff fefb 	bl	8011420 <queue_prio_insert.lto_priv.481>
      ctp->u.wtmtxp = mp;
 801162a:	9b02      	ldr	r3, [sp, #8]
 801162c:	9a01      	ldr	r2, [sp, #4]
 801162e:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8011630:	2006      	movs	r0, #6
 8011632:	f7fe fb2d 	bl	800fc90 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 8011636:	9b01      	ldr	r3, [sp, #4]
 8011638:	689b      	ldr	r3, [r3, #8]
 801163a:	9a02      	ldr	r2, [sp, #8]
 801163c:	429a      	cmp	r2, r3
 801163e:	d002      	beq.n	8011646 <chMtxLockS+0xc6>
 8011640:	480d      	ldr	r0, [pc, #52]	; (8011678 <chMtxLockS+0xf8>)
 8011642:	f7fd fccd 	bl	800efe0 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8011646:	9b02      	ldr	r3, [sp, #8]
 8011648:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801164a:	9a01      	ldr	r2, [sp, #4]
 801164c:	429a      	cmp	r2, r3
 801164e:	d00d      	beq.n	801166c <chMtxLockS+0xec>
 8011650:	4809      	ldr	r0, [pc, #36]	; (8011678 <chMtxLockS+0xf8>)
 8011652:	f7fd fcc5 	bl	800efe0 <chSysHalt>
 8011656:	e009      	b.n	801166c <chMtxLockS+0xec>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8011658:	9b01      	ldr	r3, [sp, #4]
 801165a:	9a02      	ldr	r2, [sp, #8]
 801165c:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 801165e:	9b02      	ldr	r3, [sp, #8]
 8011660:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8011662:	9b01      	ldr	r3, [sp, #4]
 8011664:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 8011666:	9b02      	ldr	r3, [sp, #8]
 8011668:	9a01      	ldr	r2, [sp, #4]
 801166a:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 801166c:	b005      	add	sp, #20
 801166e:	f85d fb04 	ldr.w	pc, [sp], #4
 8011672:	bf00      	nop
 8011674:	20001090 	.word	0x20001090
 8011678:	08016de4 	.word	0x08016de4
 801167c:	00000000 	.word	0x00000000

08011680 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 8011680:	b500      	push	{lr}
 8011682:	b085      	sub	sp, #20
 8011684:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 8011686:	f7ff ff1b 	bl	80114c0 <chSysLock.lto_priv.326>
  b = chMtxTryLockS(mp);
 801168a:	9801      	ldr	r0, [sp, #4]
 801168c:	f000 f810 	bl	80116b0 <chMtxTryLockS>
 8011690:	4603      	mov	r3, r0
 8011692:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 8011696:	f7ff ff1b 	bl	80114d0 <chSysUnlock.lto_priv.302>

  return b;
 801169a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 801169e:	4618      	mov	r0, r3
 80116a0:	b005      	add	sp, #20
 80116a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80116a6:	bf00      	nop
	...

080116b0 <chMtxTryLockS>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @sclass
 */
bool chMtxTryLockS(mutex_t *mp) {
 80116b0:	b500      	push	{lr}
 80116b2:	b083      	sub	sp, #12
 80116b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 80116b6:	f7fd febb 	bl	800f430 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 80116ba:	9b01      	ldr	r3, [sp, #4]
 80116bc:	2b00      	cmp	r3, #0
 80116be:	d102      	bne.n	80116c6 <chMtxTryLockS+0x16>
 80116c0:	480d      	ldr	r0, [pc, #52]	; (80116f8 <chMtxTryLockS+0x48>)
 80116c2:	f7fd fc8d 	bl	800efe0 <chSysHalt>

  if (mp->owner != NULL) {
 80116c6:	9b01      	ldr	r3, [sp, #4]
 80116c8:	689b      	ldr	r3, [r3, #8]
 80116ca:	2b00      	cmp	r3, #0
 80116cc:	d001      	beq.n	80116d2 <chMtxTryLockS+0x22>
    if (mp->owner == currp) {
      mp->cnt++;
      return true;
    }
#endif
    return false;
 80116ce:	2300      	movs	r3, #0
 80116d0:	e00d      	b.n	80116ee <chMtxTryLockS+0x3e>

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 80116d2:	4b0a      	ldr	r3, [pc, #40]	; (80116fc <chMtxTryLockS+0x4c>)
 80116d4:	699a      	ldr	r2, [r3, #24]
 80116d6:	9b01      	ldr	r3, [sp, #4]
 80116d8:	609a      	str	r2, [r3, #8]
  mp->next = currp->mtxlist;
 80116da:	4b08      	ldr	r3, [pc, #32]	; (80116fc <chMtxTryLockS+0x4c>)
 80116dc:	699b      	ldr	r3, [r3, #24]
 80116de:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80116e0:	9b01      	ldr	r3, [sp, #4]
 80116e2:	60da      	str	r2, [r3, #12]
  currp->mtxlist = mp;
 80116e4:	4b05      	ldr	r3, [pc, #20]	; (80116fc <chMtxTryLockS+0x4c>)
 80116e6:	699b      	ldr	r3, [r3, #24]
 80116e8:	9a01      	ldr	r2, [sp, #4]
 80116ea:	639a      	str	r2, [r3, #56]	; 0x38
  return true;
 80116ec:	2301      	movs	r3, #1
}
 80116ee:	4618      	mov	r0, r3
 80116f0:	b003      	add	sp, #12
 80116f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80116f6:	bf00      	nop
 80116f8:	08016df0 	.word	0x08016df0
 80116fc:	20001090 	.word	0x20001090

08011700 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8011700:	b500      	push	{lr}
 8011702:	b087      	sub	sp, #28
 8011704:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8011706:	4b35      	ldr	r3, [pc, #212]	; (80117dc <chMtxUnlock+0xdc>)
 8011708:	699b      	ldr	r3, [r3, #24]
 801170a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 801170c:	9b01      	ldr	r3, [sp, #4]
 801170e:	2b00      	cmp	r3, #0
 8011710:	d102      	bne.n	8011718 <chMtxUnlock+0x18>
 8011712:	4833      	ldr	r0, [pc, #204]	; (80117e0 <chMtxUnlock+0xe0>)
 8011714:	f7fd fc64 	bl	800efe0 <chSysHalt>

  chSysLock();
 8011718:	f7ff fed2 	bl	80114c0 <chSysLock.lto_priv.326>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 801171c:	9b03      	ldr	r3, [sp, #12]
 801171e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011720:	2b00      	cmp	r3, #0
 8011722:	d102      	bne.n	801172a <chMtxUnlock+0x2a>
 8011724:	482e      	ldr	r0, [pc, #184]	; (80117e0 <chMtxUnlock+0xe0>)
 8011726:	f7fd fc5b 	bl	800efe0 <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 801172a:	9b03      	ldr	r3, [sp, #12]
 801172c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801172e:	689b      	ldr	r3, [r3, #8]
 8011730:	9a03      	ldr	r2, [sp, #12]
 8011732:	429a      	cmp	r2, r3
 8011734:	d002      	beq.n	801173c <chMtxUnlock+0x3c>
 8011736:	482a      	ldr	r0, [pc, #168]	; (80117e0 <chMtxUnlock+0xe0>)
 8011738:	f7fd fc52 	bl	800efe0 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 801173c:	9b03      	ldr	r3, [sp, #12]
 801173e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011740:	9a01      	ldr	r2, [sp, #4]
 8011742:	429a      	cmp	r2, r3
 8011744:	d002      	beq.n	801174c <chMtxUnlock+0x4c>
 8011746:	4826      	ldr	r0, [pc, #152]	; (80117e0 <chMtxUnlock+0xe0>)
 8011748:	f7fd fc4a 	bl	800efe0 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 801174c:	9b01      	ldr	r3, [sp, #4]
 801174e:	68da      	ldr	r2, [r3, #12]
 8011750:	9b03      	ldr	r3, [sp, #12]
 8011752:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8011754:	9801      	ldr	r0, [sp, #4]
 8011756:	f7ff fedb 	bl	8011510 <chMtxQueueNotEmptyS>
 801175a:	4603      	mov	r3, r0
 801175c:	2b00      	cmp	r3, #0
 801175e:	d034      	beq.n	80117ca <chMtxUnlock+0xca>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8011760:	9b03      	ldr	r3, [sp, #12]
 8011762:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011764:	9304      	str	r3, [sp, #16]
      lmp = ctp->mtxlist;
 8011766:	9b03      	ldr	r3, [sp, #12]
 8011768:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801176a:	9305      	str	r3, [sp, #20]
 801176c:	e012      	b.n	8011794 <chMtxUnlock+0x94>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 801176e:	9805      	ldr	r0, [sp, #20]
 8011770:	f7ff fece 	bl	8011510 <chMtxQueueNotEmptyS>
 8011774:	4603      	mov	r3, r0
 8011776:	2b00      	cmp	r3, #0
 8011778:	d009      	beq.n	801178e <chMtxUnlock+0x8e>
            (lmp->queue.next->prio > newprio)) {
 801177a:	9b05      	ldr	r3, [sp, #20]
 801177c:	681b      	ldr	r3, [r3, #0]
 801177e:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8011780:	9a04      	ldr	r2, [sp, #16]
 8011782:	429a      	cmp	r2, r3
 8011784:	d203      	bcs.n	801178e <chMtxUnlock+0x8e>
          newprio = lmp->queue.next->prio;
 8011786:	9b05      	ldr	r3, [sp, #20]
 8011788:	681b      	ldr	r3, [r3, #0]
 801178a:	689b      	ldr	r3, [r3, #8]
 801178c:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 801178e:	9b05      	ldr	r3, [sp, #20]
 8011790:	68db      	ldr	r3, [r3, #12]
 8011792:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8011794:	9b05      	ldr	r3, [sp, #20]
 8011796:	2b00      	cmp	r3, #0
 8011798:	d1e9      	bne.n	801176e <chMtxUnlock+0x6e>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 801179a:	9b03      	ldr	r3, [sp, #12]
 801179c:	9a04      	ldr	r2, [sp, #16]
 801179e:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
 80117a0:	9b01      	ldr	r3, [sp, #4]
 80117a2:	4618      	mov	r0, r3
 80117a4:	f7ff fe64 	bl	8011470 <queue_fifo_remove.lto_priv.471>
 80117a8:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 80117aa:	9b01      	ldr	r3, [sp, #4]
 80117ac:	9a02      	ldr	r2, [sp, #8]
 80117ae:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 80117b0:	9b02      	ldr	r3, [sp, #8]
 80117b2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80117b4:	9b01      	ldr	r3, [sp, #4]
 80117b6:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 80117b8:	9b02      	ldr	r3, [sp, #8]
 80117ba:	9a01      	ldr	r2, [sp, #4]
 80117bc:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80117be:	9802      	ldr	r0, [sp, #8]
 80117c0:	f7fe f9e6 	bl	800fb90 <chSchReadyI>
      chSchRescheduleS();
 80117c4:	f7fe fb74 	bl	800feb0 <chSchRescheduleS>
 80117c8:	e002      	b.n	80117d0 <chMtxUnlock+0xd0>
    }
    else {
      mp->owner = NULL;
 80117ca:	9b01      	ldr	r3, [sp, #4]
 80117cc:	2200      	movs	r2, #0
 80117ce:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 80117d0:	f7ff fe7e 	bl	80114d0 <chSysUnlock.lto_priv.302>
}
 80117d4:	b007      	add	sp, #28
 80117d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80117da:	bf00      	nop
 80117dc:	20001090 	.word	0x20001090
 80117e0:	08016e00 	.word	0x08016e00
	...

080117f0 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 80117f0:	b500      	push	{lr}
 80117f2:	b087      	sub	sp, #28
 80117f4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 80117f6:	4b33      	ldr	r3, [pc, #204]	; (80118c4 <chMtxUnlockS+0xd4>)
 80117f8:	699b      	ldr	r3, [r3, #24]
 80117fa:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheckClassS();
 80117fc:	f7fd fe18 	bl	800f430 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8011800:	9b01      	ldr	r3, [sp, #4]
 8011802:	2b00      	cmp	r3, #0
 8011804:	d102      	bne.n	801180c <chMtxUnlockS+0x1c>
 8011806:	4830      	ldr	r0, [pc, #192]	; (80118c8 <chMtxUnlockS+0xd8>)
 8011808:	f7fd fbea 	bl	800efe0 <chSysHalt>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 801180c:	9b03      	ldr	r3, [sp, #12]
 801180e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011810:	2b00      	cmp	r3, #0
 8011812:	d102      	bne.n	801181a <chMtxUnlockS+0x2a>
 8011814:	482c      	ldr	r0, [pc, #176]	; (80118c8 <chMtxUnlockS+0xd8>)
 8011816:	f7fd fbe3 	bl	800efe0 <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 801181a:	9b03      	ldr	r3, [sp, #12]
 801181c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801181e:	689b      	ldr	r3, [r3, #8]
 8011820:	9a03      	ldr	r2, [sp, #12]
 8011822:	429a      	cmp	r2, r3
 8011824:	d002      	beq.n	801182c <chMtxUnlockS+0x3c>
 8011826:	4828      	ldr	r0, [pc, #160]	; (80118c8 <chMtxUnlockS+0xd8>)
 8011828:	f7fd fbda 	bl	800efe0 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 801182c:	9b03      	ldr	r3, [sp, #12]
 801182e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011830:	9a01      	ldr	r2, [sp, #4]
 8011832:	429a      	cmp	r2, r3
 8011834:	d002      	beq.n	801183c <chMtxUnlockS+0x4c>
 8011836:	4824      	ldr	r0, [pc, #144]	; (80118c8 <chMtxUnlockS+0xd8>)
 8011838:	f7fd fbd2 	bl	800efe0 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 801183c:	9b01      	ldr	r3, [sp, #4]
 801183e:	68da      	ldr	r2, [r3, #12]
 8011840:	9b03      	ldr	r3, [sp, #12]
 8011842:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8011844:	9801      	ldr	r0, [sp, #4]
 8011846:	f7ff fe63 	bl	8011510 <chMtxQueueNotEmptyS>
 801184a:	4603      	mov	r3, r0
 801184c:	2b00      	cmp	r3, #0
 801184e:	d032      	beq.n	80118b6 <chMtxUnlockS+0xc6>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8011850:	9b03      	ldr	r3, [sp, #12]
 8011852:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011854:	9304      	str	r3, [sp, #16]
      lmp = ctp->mtxlist;
 8011856:	9b03      	ldr	r3, [sp, #12]
 8011858:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801185a:	9305      	str	r3, [sp, #20]
 801185c:	e012      	b.n	8011884 <chMtxUnlockS+0x94>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 801185e:	9805      	ldr	r0, [sp, #20]
 8011860:	f7ff fe56 	bl	8011510 <chMtxQueueNotEmptyS>
 8011864:	4603      	mov	r3, r0
 8011866:	2b00      	cmp	r3, #0
 8011868:	d009      	beq.n	801187e <chMtxUnlockS+0x8e>
            (lmp->queue.next->prio > newprio)) {
 801186a:	9b05      	ldr	r3, [sp, #20]
 801186c:	681b      	ldr	r3, [r3, #0]
 801186e:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8011870:	9a04      	ldr	r2, [sp, #16]
 8011872:	429a      	cmp	r2, r3
 8011874:	d203      	bcs.n	801187e <chMtxUnlockS+0x8e>
          newprio = lmp->queue.next->prio;
 8011876:	9b05      	ldr	r3, [sp, #20]
 8011878:	681b      	ldr	r3, [r3, #0]
 801187a:	689b      	ldr	r3, [r3, #8]
 801187c:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 801187e:	9b05      	ldr	r3, [sp, #20]
 8011880:	68db      	ldr	r3, [r3, #12]
 8011882:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8011884:	9b05      	ldr	r3, [sp, #20]
 8011886:	2b00      	cmp	r3, #0
 8011888:	d1e9      	bne.n	801185e <chMtxUnlockS+0x6e>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 801188a:	9b03      	ldr	r3, [sp, #12]
 801188c:	9a04      	ldr	r2, [sp, #16]
 801188e:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
 8011890:	9b01      	ldr	r3, [sp, #4]
 8011892:	4618      	mov	r0, r3
 8011894:	f7ff fdec 	bl	8011470 <queue_fifo_remove.lto_priv.471>
 8011898:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 801189a:	9b01      	ldr	r3, [sp, #4]
 801189c:	9a02      	ldr	r2, [sp, #8]
 801189e:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 80118a0:	9b02      	ldr	r3, [sp, #8]
 80118a2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80118a4:	9b01      	ldr	r3, [sp, #4]
 80118a6:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 80118a8:	9b02      	ldr	r3, [sp, #8]
 80118aa:	9a01      	ldr	r2, [sp, #4]
 80118ac:	639a      	str	r2, [r3, #56]	; 0x38
      (void) chSchReadyI(tp);
 80118ae:	9802      	ldr	r0, [sp, #8]
 80118b0:	f7fe f96e 	bl	800fb90 <chSchReadyI>
 80118b4:	e002      	b.n	80118bc <chMtxUnlockS+0xcc>
    }
    else {
      mp->owner = NULL;
 80118b6:	9b01      	ldr	r3, [sp, #4]
 80118b8:	2200      	movs	r2, #0
 80118ba:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 80118bc:	b007      	add	sp, #28
 80118be:	f85d fb04 	ldr.w	pc, [sp], #4
 80118c2:	bf00      	nop
 80118c4:	20001090 	.word	0x20001090
 80118c8:	08016e0c 	.word	0x08016e0c
 80118cc:	00000000 	.word	0x00000000

080118d0 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 80118d0:	b500      	push	{lr}
 80118d2:	b085      	sub	sp, #20
  thread_t *ctp = currp;
 80118d4:	4b1d      	ldr	r3, [pc, #116]	; (801194c <chMtxUnlockAll+0x7c>)
 80118d6:	699b      	ldr	r3, [r3, #24]
 80118d8:	9303      	str	r3, [sp, #12]

  chSysLock();
 80118da:	f7ff fdf1 	bl	80114c0 <chSysLock.lto_priv.326>
  if (ctp->mtxlist != NULL) {
 80118de:	9b03      	ldr	r3, [sp, #12]
 80118e0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80118e2:	2b00      	cmp	r3, #0
 80118e4:	d02c      	beq.n	8011940 <chMtxUnlockAll+0x70>
    do {
      mutex_t *mp = ctp->mtxlist;
 80118e6:	9b03      	ldr	r3, [sp, #12]
 80118e8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80118ea:	9302      	str	r3, [sp, #8]
      ctp->mtxlist = mp->next;
 80118ec:	9b02      	ldr	r3, [sp, #8]
 80118ee:	68da      	ldr	r2, [r3, #12]
 80118f0:	9b03      	ldr	r3, [sp, #12]
 80118f2:	639a      	str	r2, [r3, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 80118f4:	9802      	ldr	r0, [sp, #8]
 80118f6:	f7ff fe0b 	bl	8011510 <chMtxQueueNotEmptyS>
 80118fa:	4603      	mov	r3, r0
 80118fc:	2b00      	cmp	r3, #0
 80118fe:	d012      	beq.n	8011926 <chMtxUnlockAll+0x56>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
 8011900:	9b02      	ldr	r3, [sp, #8]
 8011902:	4618      	mov	r0, r3
 8011904:	f7ff fdb4 	bl	8011470 <queue_fifo_remove.lto_priv.471>
 8011908:	9001      	str	r0, [sp, #4]
        mp->owner = tp;
 801190a:	9b02      	ldr	r3, [sp, #8]
 801190c:	9a01      	ldr	r2, [sp, #4]
 801190e:	609a      	str	r2, [r3, #8]
        mp->next = tp->mtxlist;
 8011910:	9b01      	ldr	r3, [sp, #4]
 8011912:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8011914:	9b02      	ldr	r3, [sp, #8]
 8011916:	60da      	str	r2, [r3, #12]
        tp->mtxlist = mp;
 8011918:	9b01      	ldr	r3, [sp, #4]
 801191a:	9a02      	ldr	r2, [sp, #8]
 801191c:	639a      	str	r2, [r3, #56]	; 0x38
        (void) chSchReadyI(tp);
 801191e:	9801      	ldr	r0, [sp, #4]
 8011920:	f7fe f936 	bl	800fb90 <chSchReadyI>
 8011924:	e002      	b.n	801192c <chMtxUnlockAll+0x5c>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 8011926:	9b02      	ldr	r3, [sp, #8]
 8011928:	2200      	movs	r2, #0
 801192a:	609a      	str	r2, [r3, #8]
      }
    } while (ctp->mtxlist != NULL);
 801192c:	9b03      	ldr	r3, [sp, #12]
 801192e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011930:	2b00      	cmp	r3, #0
 8011932:	d1d8      	bne.n	80118e6 <chMtxUnlockAll+0x16>
    ctp->prio = ctp->realprio;
 8011934:	9b03      	ldr	r3, [sp, #12]
 8011936:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8011938:	9b03      	ldr	r3, [sp, #12]
 801193a:	609a      	str	r2, [r3, #8]
    chSchRescheduleS();
 801193c:	f7fe fab8 	bl	800feb0 <chSchRescheduleS>
  }
  chSysUnlock();
 8011940:	f7ff fdc6 	bl	80114d0 <chSysUnlock.lto_priv.302>
}
 8011944:	b005      	add	sp, #20
 8011946:	f85d fb04 	ldr.w	pc, [sp], #4
 801194a:	bf00      	nop
 801194c:	20001090 	.word	0x20001090

08011950 <port_lock.lto_priv.401>:
static inline void port_lock(void) {
 8011950:	b082      	sub	sp, #8
 8011952:	2320      	movs	r3, #32
 8011954:	9301      	str	r3, [sp, #4]
 8011956:	9b01      	ldr	r3, [sp, #4]
 8011958:	f383 8811 	msr	BASEPRI, r3
}
 801195c:	b002      	add	sp, #8
 801195e:	4770      	bx	lr

08011960 <port_unlock.lto_priv.370>:
static inline void port_unlock(void) {
 8011960:	b082      	sub	sp, #8
 8011962:	2300      	movs	r3, #0
 8011964:	9301      	str	r3, [sp, #4]
 8011966:	9b01      	ldr	r3, [sp, #4]
 8011968:	f383 8811 	msr	BASEPRI, r3
}
 801196c:	b002      	add	sp, #8
 801196e:	4770      	bx	lr

08011970 <queue_init.lto_priv.466>:
static inline void queue_init(threads_queue_t *tqp) {
 8011970:	b082      	sub	sp, #8
 8011972:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8011974:	9b01      	ldr	r3, [sp, #4]
 8011976:	9a01      	ldr	r2, [sp, #4]
 8011978:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 801197a:	9b01      	ldr	r3, [sp, #4]
 801197c:	9a01      	ldr	r2, [sp, #4]
 801197e:	605a      	str	r2, [r3, #4]
}
 8011980:	b002      	add	sp, #8
 8011982:	4770      	bx	lr
	...

08011990 <queue_notempty.lto_priv.486>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8011990:	b082      	sub	sp, #8
 8011992:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next != (const thread_t *)tqp);
 8011994:	9b01      	ldr	r3, [sp, #4]
 8011996:	681b      	ldr	r3, [r3, #0]
 8011998:	9a01      	ldr	r2, [sp, #4]
 801199a:	429a      	cmp	r2, r3
 801199c:	bf14      	ite	ne
 801199e:	2301      	movne	r3, #1
 80119a0:	2300      	moveq	r3, #0
 80119a2:	b2db      	uxtb	r3, r3
}
 80119a4:	4618      	mov	r0, r3
 80119a6:	b002      	add	sp, #8
 80119a8:	4770      	bx	lr
 80119aa:	bf00      	nop
 80119ac:	0000      	movs	r0, r0
	...

080119b0 <queue_prio_insert.lto_priv.482>:
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 80119b0:	b084      	sub	sp, #16
 80119b2:	9001      	str	r0, [sp, #4]
 80119b4:	9100      	str	r1, [sp, #0]
  thread_t *cp = (thread_t *)tqp;
 80119b6:	9b00      	ldr	r3, [sp, #0]
 80119b8:	9303      	str	r3, [sp, #12]
    cp = cp->queue.next;
 80119ba:	9b03      	ldr	r3, [sp, #12]
 80119bc:	681b      	ldr	r3, [r3, #0]
 80119be:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80119c0:	9a03      	ldr	r2, [sp, #12]
 80119c2:	9b00      	ldr	r3, [sp, #0]
 80119c4:	429a      	cmp	r2, r3
 80119c6:	d005      	beq.n	80119d4 <queue_prio_insert.lto_priv.482+0x24>
 80119c8:	9b03      	ldr	r3, [sp, #12]
 80119ca:	689a      	ldr	r2, [r3, #8]
 80119cc:	9b01      	ldr	r3, [sp, #4]
 80119ce:	689b      	ldr	r3, [r3, #8]
 80119d0:	429a      	cmp	r2, r3
 80119d2:	d2f2      	bcs.n	80119ba <queue_prio_insert.lto_priv.482+0xa>
  tp->queue.next             = cp;
 80119d4:	9b01      	ldr	r3, [sp, #4]
 80119d6:	9a03      	ldr	r2, [sp, #12]
 80119d8:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 80119da:	9b03      	ldr	r3, [sp, #12]
 80119dc:	685a      	ldr	r2, [r3, #4]
 80119de:	9b01      	ldr	r3, [sp, #4]
 80119e0:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 80119e2:	9b01      	ldr	r3, [sp, #4]
 80119e4:	685b      	ldr	r3, [r3, #4]
 80119e6:	9a01      	ldr	r2, [sp, #4]
 80119e8:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 80119ea:	9b03      	ldr	r3, [sp, #12]
 80119ec:	9a01      	ldr	r2, [sp, #4]
 80119ee:	605a      	str	r2, [r3, #4]
}
 80119f0:	b004      	add	sp, #16
 80119f2:	4770      	bx	lr
	...

08011a00 <queue_fifo_remove.lto_priv.472>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8011a00:	b084      	sub	sp, #16
 8011a02:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8011a04:	9b01      	ldr	r3, [sp, #4]
 8011a06:	681b      	ldr	r3, [r3, #0]
 8011a08:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 8011a0a:	9b03      	ldr	r3, [sp, #12]
 8011a0c:	681a      	ldr	r2, [r3, #0]
 8011a0e:	9b01      	ldr	r3, [sp, #4]
 8011a10:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8011a12:	9b01      	ldr	r3, [sp, #4]
 8011a14:	681b      	ldr	r3, [r3, #0]
 8011a16:	9a01      	ldr	r2, [sp, #4]
 8011a18:	605a      	str	r2, [r3, #4]
  return tp;
 8011a1a:	9b03      	ldr	r3, [sp, #12]
}
 8011a1c:	4618      	mov	r0, r3
 8011a1e:	b004      	add	sp, #16
 8011a20:	4770      	bx	lr
 8011a22:	bf00      	nop
	...

08011a30 <chSysLock.lto_priv.327>:
static inline void chSysLock(void) {
 8011a30:	b508      	push	{r3, lr}
  port_lock();
 8011a32:	f7ff ff8d 	bl	8011950 <port_lock.lto_priv.401>
  _dbg_check_lock();
 8011a36:	f7fd fc43 	bl	800f2c0 <_dbg_check_lock>
}
 8011a3a:	bd08      	pop	{r3, pc}
 8011a3c:	0000      	movs	r0, r0
	...

08011a40 <chSysUnlock.lto_priv.303>:
static inline void chSysUnlock(void) {
 8011a40:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8011a42:	f7fd fc55 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8011a46:	4b09      	ldr	r3, [pc, #36]	; (8011a6c <chSysUnlock.lto_priv.303+0x2c>)
 8011a48:	681b      	ldr	r3, [r3, #0]
 8011a4a:	4a08      	ldr	r2, [pc, #32]	; (8011a6c <chSysUnlock.lto_priv.303+0x2c>)
 8011a4c:	4293      	cmp	r3, r2
 8011a4e:	d00a      	beq.n	8011a66 <chSysUnlock.lto_priv.303+0x26>
 8011a50:	4b06      	ldr	r3, [pc, #24]	; (8011a6c <chSysUnlock.lto_priv.303+0x2c>)
 8011a52:	699b      	ldr	r3, [r3, #24]
 8011a54:	689a      	ldr	r2, [r3, #8]
 8011a56:	4b05      	ldr	r3, [pc, #20]	; (8011a6c <chSysUnlock.lto_priv.303+0x2c>)
 8011a58:	681b      	ldr	r3, [r3, #0]
 8011a5a:	689b      	ldr	r3, [r3, #8]
 8011a5c:	429a      	cmp	r2, r3
 8011a5e:	d202      	bcs.n	8011a66 <chSysUnlock.lto_priv.303+0x26>
 8011a60:	4803      	ldr	r0, [pc, #12]	; (8011a70 <chSysUnlock.lto_priv.303+0x30>)
 8011a62:	f7fd fabd 	bl	800efe0 <chSysHalt>
  port_unlock();
 8011a66:	f7ff ff7b 	bl	8011960 <port_unlock.lto_priv.370>
}
 8011a6a:	bd08      	pop	{r3, pc}
 8011a6c:	20001090 	.word	0x20001090
 8011a70:	08016e40 	.word	0x08016e40
	...

08011a80 <chThdGetSelfX.lto_priv.417>:
  return ch.rlist.current;
 8011a80:	4b01      	ldr	r3, [pc, #4]	; (8011a88 <chThdGetSelfX.lto_priv.417+0x8>)
 8011a82:	699b      	ldr	r3, [r3, #24]
}
 8011a84:	4618      	mov	r0, r3
 8011a86:	4770      	bx	lr
 8011a88:	20001090 	.word	0x20001090
 8011a8c:	00000000 	.word	0x00000000

08011a90 <chMtxGetNextMutexX>:
 * @return              A pointer to the next mutex in the stack.
 * @retval NULL         if the stack is empty.
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {
 8011a90:	b508      	push	{r3, lr}

  return chThdGetSelfX()->mtxlist;
 8011a92:	f7ff fff5 	bl	8011a80 <chThdGetSelfX.lto_priv.417>
 8011a96:	4603      	mov	r3, r0
 8011a98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 8011a9a:	4618      	mov	r0, r3
 8011a9c:	bd08      	pop	{r3, pc}
 8011a9e:	bf00      	nop

08011aa0 <chCondObjectInit>:
 *
 * @param[out] cp       pointer to a @p condition_variable_t structure
 *
 * @init
 */
void chCondObjectInit(condition_variable_t *cp) {
 8011aa0:	b500      	push	{lr}
 8011aa2:	b083      	sub	sp, #12
 8011aa4:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);
 8011aa6:	9b01      	ldr	r3, [sp, #4]
 8011aa8:	2b00      	cmp	r3, #0
 8011aaa:	d102      	bne.n	8011ab2 <chCondObjectInit+0x12>
 8011aac:	4804      	ldr	r0, [pc, #16]	; (8011ac0 <chCondObjectInit+0x20>)
 8011aae:	f7fd fa97 	bl	800efe0 <chSysHalt>

  queue_init(&cp->queue);
 8011ab2:	9b01      	ldr	r3, [sp, #4]
 8011ab4:	4618      	mov	r0, r3
 8011ab6:	f7ff ff5b 	bl	8011970 <queue_init.lto_priv.466>
}
 8011aba:	b003      	add	sp, #12
 8011abc:	f85d fb04 	ldr.w	pc, [sp], #4
 8011ac0:	08016e1c 	.word	0x08016e1c
	...

08011ad0 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8011ad0:	b500      	push	{lr}
 8011ad2:	b083      	sub	sp, #12
 8011ad4:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);
 8011ad6:	9b01      	ldr	r3, [sp, #4]
 8011ad8:	2b00      	cmp	r3, #0
 8011ada:	d102      	bne.n	8011ae2 <chCondSignal+0x12>
 8011adc:	480c      	ldr	r0, [pc, #48]	; (8011b10 <chCondSignal+0x40>)
 8011ade:	f7fd fa7f 	bl	800efe0 <chSysHalt>

  chSysLock();
 8011ae2:	f7ff ffa5 	bl	8011a30 <chSysLock.lto_priv.327>
  if (queue_notempty(&cp->queue)) {
 8011ae6:	9b01      	ldr	r3, [sp, #4]
 8011ae8:	4618      	mov	r0, r3
 8011aea:	f7ff ff51 	bl	8011990 <queue_notempty.lto_priv.486>
 8011aee:	4603      	mov	r3, r0
 8011af0:	2b00      	cmp	r3, #0
 8011af2:	d008      	beq.n	8011b06 <chCondSignal+0x36>
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 8011af4:	9b01      	ldr	r3, [sp, #4]
 8011af6:	4618      	mov	r0, r3
 8011af8:	f7ff ff82 	bl	8011a00 <queue_fifo_remove.lto_priv.472>
 8011afc:	4603      	mov	r3, r0
 8011afe:	2100      	movs	r1, #0
 8011b00:	4618      	mov	r0, r3
 8011b02:	f7fe f97d 	bl	800fe00 <chSchWakeupS>
  }
  chSysUnlock();
 8011b06:	f7ff ff9b 	bl	8011a40 <chSysUnlock.lto_priv.303>
}
 8011b0a:	b003      	add	sp, #12
 8011b0c:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b10:	08016e30 	.word	0x08016e30
	...

08011b20 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8011b20:	b500      	push	{lr}
 8011b22:	b085      	sub	sp, #20
 8011b24:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8011b26:	f7fd fc6b 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(cp != NULL);
 8011b2a:	9b01      	ldr	r3, [sp, #4]
 8011b2c:	2b00      	cmp	r3, #0
 8011b2e:	d102      	bne.n	8011b36 <chCondSignalI+0x16>
 8011b30:	480b      	ldr	r0, [pc, #44]	; (8011b60 <chCondSignalI+0x40>)
 8011b32:	f7fd fa55 	bl	800efe0 <chSysHalt>

  if (queue_notempty(&cp->queue)) {
 8011b36:	9b01      	ldr	r3, [sp, #4]
 8011b38:	4618      	mov	r0, r3
 8011b3a:	f7ff ff29 	bl	8011990 <queue_notempty.lto_priv.486>
 8011b3e:	4603      	mov	r3, r0
 8011b40:	2b00      	cmp	r3, #0
 8011b42:	d00a      	beq.n	8011b5a <chCondSignalI+0x3a>
    thread_t *tp = queue_fifo_remove(&cp->queue);
 8011b44:	9b01      	ldr	r3, [sp, #4]
 8011b46:	4618      	mov	r0, r3
 8011b48:	f7ff ff5a 	bl	8011a00 <queue_fifo_remove.lto_priv.472>
 8011b4c:	9003      	str	r0, [sp, #12]
    tp->u.rdymsg = MSG_OK;
 8011b4e:	9b03      	ldr	r3, [sp, #12]
 8011b50:	2200      	movs	r2, #0
 8011b52:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8011b54:	9803      	ldr	r0, [sp, #12]
 8011b56:	f7fe f81b 	bl	800fb90 <chSchReadyI>
  }
}
 8011b5a:	b005      	add	sp, #20
 8011b5c:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b60:	08016e4c 	.word	0x08016e4c
	...

08011b70 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 8011b70:	b500      	push	{lr}
 8011b72:	b083      	sub	sp, #12
 8011b74:	9001      	str	r0, [sp, #4]

  chSysLock();
 8011b76:	f7ff ff5b 	bl	8011a30 <chSysLock.lto_priv.327>
  chCondBroadcastI(cp);
 8011b7a:	9801      	ldr	r0, [sp, #4]
 8011b7c:	f000 f808 	bl	8011b90 <chCondBroadcastI>
  chSchRescheduleS();
 8011b80:	f7fe f996 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 8011b84:	f7ff ff5c 	bl	8011a40 <chSysUnlock.lto_priv.303>
}
 8011b88:	b003      	add	sp, #12
 8011b8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b8e:	bf00      	nop

08011b90 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 8011b90:	b500      	push	{lr}
 8011b92:	b083      	sub	sp, #12
 8011b94:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8011b96:	f7fd fc33 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(cp != NULL);
 8011b9a:	9b01      	ldr	r3, [sp, #4]
 8011b9c:	2b00      	cmp	r3, #0
 8011b9e:	d10f      	bne.n	8011bc0 <chCondBroadcastI+0x30>
 8011ba0:	480c      	ldr	r0, [pc, #48]	; (8011bd4 <chCondBroadcastI+0x44>)
 8011ba2:	f7fd fa1d 	bl	800efe0 <chSysHalt>
 8011ba6:	e00b      	b.n	8011bc0 <chCondBroadcastI+0x30>

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8011ba8:	9b01      	ldr	r3, [sp, #4]
 8011baa:	4618      	mov	r0, r3
 8011bac:	f7ff ff28 	bl	8011a00 <queue_fifo_remove.lto_priv.472>
 8011bb0:	4603      	mov	r3, r0
 8011bb2:	4618      	mov	r0, r3
 8011bb4:	f7fd ffec 	bl	800fb90 <chSchReadyI>
 8011bb8:	4602      	mov	r2, r0
 8011bba:	f06f 0301 	mvn.w	r3, #1
 8011bbe:	6253      	str	r3, [r2, #36]	; 0x24
  while (queue_notempty(&cp->queue)) {
 8011bc0:	9b01      	ldr	r3, [sp, #4]
 8011bc2:	4618      	mov	r0, r3
 8011bc4:	f7ff fee4 	bl	8011990 <queue_notempty.lto_priv.486>
 8011bc8:	4603      	mov	r3, r0
 8011bca:	2b00      	cmp	r3, #0
 8011bcc:	d1ec      	bne.n	8011ba8 <chCondBroadcastI+0x18>
  }
}
 8011bce:	b003      	add	sp, #12
 8011bd0:	f85d fb04 	ldr.w	pc, [sp], #4
 8011bd4:	08016e5c 	.word	0x08016e5c
	...

08011be0 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 8011be0:	b500      	push	{lr}
 8011be2:	b085      	sub	sp, #20
 8011be4:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8011be6:	f7ff ff23 	bl	8011a30 <chSysLock.lto_priv.327>
  msg = chCondWaitS(cp);
 8011bea:	9801      	ldr	r0, [sp, #4]
 8011bec:	f000 f808 	bl	8011c00 <chCondWaitS>
 8011bf0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8011bf2:	f7ff ff25 	bl	8011a40 <chSysUnlock.lto_priv.303>
  return msg;
 8011bf6:	9b03      	ldr	r3, [sp, #12]
}
 8011bf8:	4618      	mov	r0, r3
 8011bfa:	b005      	add	sp, #20
 8011bfc:	f85d fb04 	ldr.w	pc, [sp], #4

08011c00 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 8011c00:	b500      	push	{lr}
 8011c02:	b087      	sub	sp, #28
 8011c04:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8011c06:	4b16      	ldr	r3, [pc, #88]	; (8011c60 <chCondWaitS+0x60>)
 8011c08:	699b      	ldr	r3, [r3, #24]
 8011c0a:	9305      	str	r3, [sp, #20]
  mutex_t *mp = chMtxGetNextMutexX();
 8011c0c:	f7ff ff40 	bl	8011a90 <chMtxGetNextMutexX>
 8011c10:	9004      	str	r0, [sp, #16]
  msg_t msg;

  chDbgCheckClassS();
 8011c12:	f7fd fc0d 	bl	800f430 <chDbgCheckClassS>
  chDbgCheck(cp != NULL);
 8011c16:	9b01      	ldr	r3, [sp, #4]
 8011c18:	2b00      	cmp	r3, #0
 8011c1a:	d102      	bne.n	8011c22 <chCondWaitS+0x22>
 8011c1c:	4811      	ldr	r0, [pc, #68]	; (8011c64 <chCondWaitS+0x64>)
 8011c1e:	f7fd f9df 	bl	800efe0 <chSysHalt>
  chDbgAssert(mp != NULL, "not owning a mutex");
 8011c22:	9b04      	ldr	r3, [sp, #16]
 8011c24:	2b00      	cmp	r3, #0
 8011c26:	d102      	bne.n	8011c2e <chCondWaitS+0x2e>
 8011c28:	480e      	ldr	r0, [pc, #56]	; (8011c64 <chCondWaitS+0x64>)
 8011c2a:	f7fd f9d9 	bl	800efe0 <chSysHalt>

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
 8011c2e:	9804      	ldr	r0, [sp, #16]
 8011c30:	f7ff fdde 	bl	80117f0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->u.wtobjp = cp;
 8011c34:	9b05      	ldr	r3, [sp, #20]
 8011c36:	9a01      	ldr	r2, [sp, #4]
 8011c38:	625a      	str	r2, [r3, #36]	; 0x24
  queue_prio_insert(ctp, &cp->queue);
 8011c3a:	9b01      	ldr	r3, [sp, #4]
 8011c3c:	4619      	mov	r1, r3
 8011c3e:	9805      	ldr	r0, [sp, #20]
 8011c40:	f7ff feb6 	bl	80119b0 <queue_prio_insert.lto_priv.482>
  chSchGoSleepS(CH_STATE_WTCOND);
 8011c44:	2007      	movs	r0, #7
 8011c46:	f7fe f823 	bl	800fc90 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 8011c4a:	9b05      	ldr	r3, [sp, #20]
 8011c4c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011c4e:	9303      	str	r3, [sp, #12]
  chMtxLockS(mp);
 8011c50:	9804      	ldr	r0, [sp, #16]
 8011c52:	f7ff fc95 	bl	8011580 <chMtxLockS>

  return msg;
 8011c56:	9b03      	ldr	r3, [sp, #12]
}
 8011c58:	4618      	mov	r0, r3
 8011c5a:	b007      	add	sp, #28
 8011c5c:	f85d fb04 	ldr.w	pc, [sp], #4
 8011c60:	20001090 	.word	0x20001090
 8011c64:	08016e70 	.word	0x08016e70
	...

08011c70 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, sysinterval_t timeout) {
 8011c70:	b500      	push	{lr}
 8011c72:	b085      	sub	sp, #20
 8011c74:	9001      	str	r0, [sp, #4]
 8011c76:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 8011c78:	f7ff feda 	bl	8011a30 <chSysLock.lto_priv.327>
  msg = chCondWaitTimeoutS(cp, timeout);
 8011c7c:	9900      	ldr	r1, [sp, #0]
 8011c7e:	9801      	ldr	r0, [sp, #4]
 8011c80:	f000 f80e 	bl	8011ca0 <chCondWaitTimeoutS>
 8011c84:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8011c86:	f7ff fedb 	bl	8011a40 <chSysUnlock.lto_priv.303>

  return msg;
 8011c8a:	9b03      	ldr	r3, [sp, #12]
}
 8011c8c:	4618      	mov	r0, r3
 8011c8e:	b005      	add	sp, #20
 8011c90:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08011ca0 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, sysinterval_t timeout) {
 8011ca0:	b500      	push	{lr}
 8011ca2:	b085      	sub	sp, #20
 8011ca4:	9001      	str	r0, [sp, #4]
 8011ca6:	9100      	str	r1, [sp, #0]
  mutex_t *mp = chMtxGetNextMutexX();
 8011ca8:	f7ff fef2 	bl	8011a90 <chMtxGetNextMutexX>
 8011cac:	9003      	str	r0, [sp, #12]
  msg_t msg;

  chDbgCheckClassS();
 8011cae:	f7fd fbbf 	bl	800f430 <chDbgCheckClassS>
  chDbgCheck((cp != NULL) && (timeout != TIME_IMMEDIATE));
 8011cb2:	9b01      	ldr	r3, [sp, #4]
 8011cb4:	2b00      	cmp	r3, #0
 8011cb6:	d002      	beq.n	8011cbe <chCondWaitTimeoutS+0x1e>
 8011cb8:	9b00      	ldr	r3, [sp, #0]
 8011cba:	2b00      	cmp	r3, #0
 8011cbc:	d102      	bne.n	8011cc4 <chCondWaitTimeoutS+0x24>
 8011cbe:	4814      	ldr	r0, [pc, #80]	; (8011d10 <chCondWaitTimeoutS+0x70>)
 8011cc0:	f7fd f98e 	bl	800efe0 <chSysHalt>
  chDbgAssert(mp != NULL, "not owning a mutex");
 8011cc4:	9b03      	ldr	r3, [sp, #12]
 8011cc6:	2b00      	cmp	r3, #0
 8011cc8:	d102      	bne.n	8011cd0 <chCondWaitTimeoutS+0x30>
 8011cca:	4811      	ldr	r0, [pc, #68]	; (8011d10 <chCondWaitTimeoutS+0x70>)
 8011ccc:	f7fd f988 	bl	800efe0 <chSysHalt>

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
 8011cd0:	9803      	ldr	r0, [sp, #12]
 8011cd2:	f7ff fd8d 	bl	80117f0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 8011cd6:	4b0f      	ldr	r3, [pc, #60]	; (8011d14 <chCondWaitTimeoutS+0x74>)
 8011cd8:	699b      	ldr	r3, [r3, #24]
 8011cda:	9a01      	ldr	r2, [sp, #4]
 8011cdc:	625a      	str	r2, [r3, #36]	; 0x24
  queue_prio_insert(currp, &cp->queue);
 8011cde:	4b0d      	ldr	r3, [pc, #52]	; (8011d14 <chCondWaitTimeoutS+0x74>)
 8011ce0:	699b      	ldr	r3, [r3, #24]
 8011ce2:	9a01      	ldr	r2, [sp, #4]
 8011ce4:	4611      	mov	r1, r2
 8011ce6:	4618      	mov	r0, r3
 8011ce8:	f7ff fe62 	bl	80119b0 <queue_prio_insert.lto_priv.482>
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, timeout);
 8011cec:	9900      	ldr	r1, [sp, #0]
 8011cee:	2007      	movs	r0, #7
 8011cf0:	f7fe f84e 	bl	800fd90 <chSchGoSleepTimeoutS>
 8011cf4:	9002      	str	r0, [sp, #8]
  if (msg != MSG_TIMEOUT) {
 8011cf6:	9b02      	ldr	r3, [sp, #8]
 8011cf8:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011cfc:	d002      	beq.n	8011d04 <chCondWaitTimeoutS+0x64>
    chMtxLockS(mp);
 8011cfe:	9803      	ldr	r0, [sp, #12]
 8011d00:	f7ff fc3e 	bl	8011580 <chMtxLockS>
  }

  return msg;
 8011d04:	9b02      	ldr	r3, [sp, #8]
}
 8011d06:	4618      	mov	r0, r3
 8011d08:	b005      	add	sp, #20
 8011d0a:	f85d fb04 	ldr.w	pc, [sp], #4
 8011d0e:	bf00      	nop
 8011d10:	08016e7c 	.word	0x08016e7c
 8011d14:	20001090 	.word	0x20001090
	...

08011d20 <port_lock.lto_priv.402>:
static inline void port_lock(void) {
 8011d20:	b082      	sub	sp, #8
 8011d22:	2320      	movs	r3, #32
 8011d24:	9301      	str	r3, [sp, #4]
 8011d26:	9b01      	ldr	r3, [sp, #4]
 8011d28:	f383 8811 	msr	BASEPRI, r3
}
 8011d2c:	b002      	add	sp, #8
 8011d2e:	4770      	bx	lr

08011d30 <port_unlock.lto_priv.371>:
static inline void port_unlock(void) {
 8011d30:	b082      	sub	sp, #8
 8011d32:	2300      	movs	r3, #0
 8011d34:	9301      	str	r3, [sp, #4]
 8011d36:	9b01      	ldr	r3, [sp, #4]
 8011d38:	f383 8811 	msr	BASEPRI, r3
}
 8011d3c:	b002      	add	sp, #8
 8011d3e:	4770      	bx	lr

08011d40 <chSysLock.lto_priv.328>:
static inline void chSysLock(void) {
 8011d40:	b508      	push	{r3, lr}
  port_lock();
 8011d42:	f7ff ffed 	bl	8011d20 <port_lock.lto_priv.402>
  _dbg_check_lock();
 8011d46:	f7fd fabb 	bl	800f2c0 <_dbg_check_lock>
}
 8011d4a:	bd08      	pop	{r3, pc}
 8011d4c:	0000      	movs	r0, r0
	...

08011d50 <chSysUnlock.lto_priv.304>:
static inline void chSysUnlock(void) {
 8011d50:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8011d52:	f7fd facd 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8011d56:	4b09      	ldr	r3, [pc, #36]	; (8011d7c <chSysUnlock.lto_priv.304+0x2c>)
 8011d58:	681b      	ldr	r3, [r3, #0]
 8011d5a:	4a08      	ldr	r2, [pc, #32]	; (8011d7c <chSysUnlock.lto_priv.304+0x2c>)
 8011d5c:	4293      	cmp	r3, r2
 8011d5e:	d00a      	beq.n	8011d76 <chSysUnlock.lto_priv.304+0x26>
 8011d60:	4b06      	ldr	r3, [pc, #24]	; (8011d7c <chSysUnlock.lto_priv.304+0x2c>)
 8011d62:	699b      	ldr	r3, [r3, #24]
 8011d64:	689a      	ldr	r2, [r3, #8]
 8011d66:	4b05      	ldr	r3, [pc, #20]	; (8011d7c <chSysUnlock.lto_priv.304+0x2c>)
 8011d68:	681b      	ldr	r3, [r3, #0]
 8011d6a:	689b      	ldr	r3, [r3, #8]
 8011d6c:	429a      	cmp	r2, r3
 8011d6e:	d202      	bcs.n	8011d76 <chSysUnlock.lto_priv.304+0x26>
 8011d70:	4803      	ldr	r0, [pc, #12]	; (8011d80 <chSysUnlock.lto_priv.304+0x30>)
 8011d72:	f7fd f935 	bl	800efe0 <chSysHalt>
  port_unlock();
 8011d76:	f7ff ffdb 	bl	8011d30 <port_unlock.lto_priv.371>
}
 8011d7a:	bd08      	pop	{r3, pc}
 8011d7c:	20001090 	.word	0x20001090
 8011d80:	08016eac 	.word	0x08016eac
	...

08011d90 <chEvtAddEventsI>:
 * @param[in] events    the events to be added
 * @return              The mask of currently pending events.
 *
 * @iclass
 */
static inline eventmask_t chEvtAddEventsI(eventmask_t events) {
 8011d90:	b082      	sub	sp, #8
 8011d92:	9001      	str	r0, [sp, #4]

  return currp->epending |= events;
 8011d94:	4b05      	ldr	r3, [pc, #20]	; (8011dac <chEvtAddEventsI+0x1c>)
 8011d96:	699b      	ldr	r3, [r3, #24]
 8011d98:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8011d9a:	4b04      	ldr	r3, [pc, #16]	; (8011dac <chEvtAddEventsI+0x1c>)
 8011d9c:	699b      	ldr	r3, [r3, #24]
 8011d9e:	9a01      	ldr	r2, [sp, #4]
 8011da0:	430a      	orrs	r2, r1
 8011da2:	635a      	str	r2, [r3, #52]	; 0x34
 8011da4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 8011da6:	4618      	mov	r0, r3
 8011da8:	b002      	add	sp, #8
 8011daa:	4770      	bx	lr
 8011dac:	20001090 	.word	0x20001090

08011db0 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8011db0:	b500      	push	{lr}
 8011db2:	b085      	sub	sp, #20
 8011db4:	9003      	str	r0, [sp, #12]
 8011db6:	9102      	str	r1, [sp, #8]
 8011db8:	9201      	str	r2, [sp, #4]
 8011dba:	9300      	str	r3, [sp, #0]

  chDbgCheck((esp != NULL) && (elp != NULL));
 8011dbc:	9b03      	ldr	r3, [sp, #12]
 8011dbe:	2b00      	cmp	r3, #0
 8011dc0:	d002      	beq.n	8011dc8 <chEvtRegisterMaskWithFlags+0x18>
 8011dc2:	9b02      	ldr	r3, [sp, #8]
 8011dc4:	2b00      	cmp	r3, #0
 8011dc6:	d102      	bne.n	8011dce <chEvtRegisterMaskWithFlags+0x1e>
 8011dc8:	480e      	ldr	r0, [pc, #56]	; (8011e04 <chEvtRegisterMaskWithFlags+0x54>)
 8011dca:	f7fd f909 	bl	800efe0 <chSysHalt>

  chSysLock();
 8011dce:	f7ff ffb7 	bl	8011d40 <chSysLock.lto_priv.328>
  elp->next     = esp->next;
 8011dd2:	9b03      	ldr	r3, [sp, #12]
 8011dd4:	681a      	ldr	r2, [r3, #0]
 8011dd6:	9b02      	ldr	r3, [sp, #8]
 8011dd8:	601a      	str	r2, [r3, #0]
  esp->next     = elp;
 8011dda:	9b03      	ldr	r3, [sp, #12]
 8011ddc:	9a02      	ldr	r2, [sp, #8]
 8011dde:	601a      	str	r2, [r3, #0]
  elp->listener = currp;
 8011de0:	4b09      	ldr	r3, [pc, #36]	; (8011e08 <chEvtRegisterMaskWithFlags+0x58>)
 8011de2:	699a      	ldr	r2, [r3, #24]
 8011de4:	9b02      	ldr	r3, [sp, #8]
 8011de6:	605a      	str	r2, [r3, #4]
  elp->events   = events;
 8011de8:	9b02      	ldr	r3, [sp, #8]
 8011dea:	9a01      	ldr	r2, [sp, #4]
 8011dec:	609a      	str	r2, [r3, #8]
  elp->flags    = (eventflags_t)0;
 8011dee:	9b02      	ldr	r3, [sp, #8]
 8011df0:	2200      	movs	r2, #0
 8011df2:	60da      	str	r2, [r3, #12]
  elp->wflags   = wflags;
 8011df4:	9b02      	ldr	r3, [sp, #8]
 8011df6:	9a00      	ldr	r2, [sp, #0]
 8011df8:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 8011dfa:	f7ff ffa9 	bl	8011d50 <chSysUnlock.lto_priv.304>
}
 8011dfe:	b005      	add	sp, #20
 8011e00:	f85d fb04 	ldr.w	pc, [sp], #4
 8011e04:	08016e90 	.word	0x08016e90
 8011e08:	20001090 	.word	0x20001090
 8011e0c:	00000000 	.word	0x00000000

08011e10 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p event_source_t structure
 * @param[in] elp       pointer to the @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 8011e10:	b500      	push	{lr}
 8011e12:	b085      	sub	sp, #20
 8011e14:	9001      	str	r0, [sp, #4]
 8011e16:	9100      	str	r1, [sp, #0]
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));
 8011e18:	9b01      	ldr	r3, [sp, #4]
 8011e1a:	2b00      	cmp	r3, #0
 8011e1c:	d002      	beq.n	8011e24 <chEvtUnregister+0x14>
 8011e1e:	9b00      	ldr	r3, [sp, #0]
 8011e20:	2b00      	cmp	r3, #0
 8011e22:	d102      	bne.n	8011e2a <chEvtUnregister+0x1a>
 8011e24:	480f      	ldr	r0, [pc, #60]	; (8011e64 <chEvtUnregister+0x54>)
 8011e26:	f7fd f8db 	bl	800efe0 <chSysHalt>

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 8011e2a:	9b01      	ldr	r3, [sp, #4]
 8011e2c:	9303      	str	r3, [sp, #12]
  /*lint -restore*/
  chSysLock();
 8011e2e:	f7ff ff87 	bl	8011d40 <chSysLock.lto_priv.328>
 8011e32:	e00c      	b.n	8011e4e <chEvtUnregister+0x3e>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->next == elp) {
 8011e34:	9b03      	ldr	r3, [sp, #12]
 8011e36:	681b      	ldr	r3, [r3, #0]
 8011e38:	9a00      	ldr	r2, [sp, #0]
 8011e3a:	429a      	cmp	r2, r3
 8011e3c:	d104      	bne.n	8011e48 <chEvtUnregister+0x38>
      p->next = elp->next;
 8011e3e:	9b00      	ldr	r3, [sp, #0]
 8011e40:	681a      	ldr	r2, [r3, #0]
 8011e42:	9b03      	ldr	r3, [sp, #12]
 8011e44:	601a      	str	r2, [r3, #0]
 8011e46:	e007      	b.n	8011e58 <chEvtUnregister+0x48>
      break;
    }
    p = p->next;
 8011e48:	9b03      	ldr	r3, [sp, #12]
 8011e4a:	681b      	ldr	r3, [r3, #0]
 8011e4c:	9303      	str	r3, [sp, #12]
  while (p->next != (event_listener_t *)esp) {
 8011e4e:	9b03      	ldr	r3, [sp, #12]
 8011e50:	681b      	ldr	r3, [r3, #0]
 8011e52:	9a01      	ldr	r2, [sp, #4]
 8011e54:	429a      	cmp	r2, r3
 8011e56:	d1ed      	bne.n	8011e34 <chEvtUnregister+0x24>
  }
  chSysUnlock();
 8011e58:	f7ff ff7a 	bl	8011d50 <chSysUnlock.lto_priv.304>
}
 8011e5c:	b005      	add	sp, #20
 8011e5e:	f85d fb04 	ldr.w	pc, [sp], #4
 8011e62:	bf00      	nop
 8011e64:	08016eb8 	.word	0x08016eb8
	...

08011e70 <chEvtGetAndClearEventsI>:
 * @param[in] events    the events to be cleared
 * @return              The mask of pending events that were cleared.
 *
 * @iclass
 */
eventmask_t chEvtGetAndClearEventsI(eventmask_t events) {
 8011e70:	b084      	sub	sp, #16
 8011e72:	9001      	str	r0, [sp, #4]
  eventmask_t m;

  m = currp->epending & events;
 8011e74:	4b09      	ldr	r3, [pc, #36]	; (8011e9c <chEvtGetAndClearEventsI+0x2c>)
 8011e76:	699b      	ldr	r3, [r3, #24]
 8011e78:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011e7a:	9a01      	ldr	r2, [sp, #4]
 8011e7c:	4013      	ands	r3, r2
 8011e7e:	9303      	str	r3, [sp, #12]
  currp->epending &= ~events;
 8011e80:	4b06      	ldr	r3, [pc, #24]	; (8011e9c <chEvtGetAndClearEventsI+0x2c>)
 8011e82:	699b      	ldr	r3, [r3, #24]
 8011e84:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8011e86:	9b01      	ldr	r3, [sp, #4]
 8011e88:	43da      	mvns	r2, r3
 8011e8a:	4b04      	ldr	r3, [pc, #16]	; (8011e9c <chEvtGetAndClearEventsI+0x2c>)
 8011e8c:	699b      	ldr	r3, [r3, #24]
 8011e8e:	400a      	ands	r2, r1
 8011e90:	635a      	str	r2, [r3, #52]	; 0x34

  return m;
 8011e92:	9b03      	ldr	r3, [sp, #12]
}
 8011e94:	4618      	mov	r0, r3
 8011e96:	b004      	add	sp, #16
 8011e98:	4770      	bx	lr
 8011e9a:	bf00      	nop
 8011e9c:	20001090 	.word	0x20001090

08011ea0 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The mask of pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 8011ea0:	b500      	push	{lr}
 8011ea2:	b085      	sub	sp, #20
 8011ea4:	9001      	str	r0, [sp, #4]
  eventmask_t m;

  chSysLock();
 8011ea6:	f7ff ff4b 	bl	8011d40 <chSysLock.lto_priv.328>
  m = chEvtGetAndClearEventsI(events);
 8011eaa:	9801      	ldr	r0, [sp, #4]
 8011eac:	f7ff ffe0 	bl	8011e70 <chEvtGetAndClearEventsI>
 8011eb0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8011eb2:	f7ff ff4d 	bl	8011d50 <chSysUnlock.lto_priv.304>

  return m;
 8011eb6:	9b03      	ldr	r3, [sp, #12]
}
 8011eb8:	4618      	mov	r0, r3
 8011eba:	b005      	add	sp, #20
 8011ebc:	f85d fb04 	ldr.w	pc, [sp], #4

08011ec0 <chEvtAddEvents>:
 * @param[in] events    the events to be added
 * @return              The mask of currently pending events.
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {
 8011ec0:	b500      	push	{lr}
 8011ec2:	b085      	sub	sp, #20
 8011ec4:	9001      	str	r0, [sp, #4]
  eventmask_t newevt;

  chSysLock();
 8011ec6:	f7ff ff3b 	bl	8011d40 <chSysLock.lto_priv.328>
  newevt = chEvtAddEventsI(events);
 8011eca:	9801      	ldr	r0, [sp, #4]
 8011ecc:	f7ff ff60 	bl	8011d90 <chEvtAddEventsI>
 8011ed0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8011ed2:	f7ff ff3d 	bl	8011d50 <chSysUnlock.lto_priv.304>

  return newevt;
 8011ed6:	9b03      	ldr	r3, [sp, #12]
}
 8011ed8:	4618      	mov	r0, r3
 8011eda:	b005      	add	sp, #20
 8011edc:	f85d fb04 	ldr.w	pc, [sp], #4

08011ee0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8011ee0:	b500      	push	{lr}
 8011ee2:	b085      	sub	sp, #20
 8011ee4:	9001      	str	r0, [sp, #4]
 8011ee6:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
 8011ee8:	f7fd fa8a 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8011eec:	9b01      	ldr	r3, [sp, #4]
 8011eee:	2b00      	cmp	r3, #0
 8011ef0:	d102      	bne.n	8011ef8 <chEvtBroadcastFlagsI+0x18>
 8011ef2:	4814      	ldr	r0, [pc, #80]	; (8011f44 <chEvtBroadcastFlagsI+0x64>)
 8011ef4:	f7fd f874 	bl	800efe0 <chSysHalt>

  elp = esp->next;
 8011ef8:	9b01      	ldr	r3, [sp, #4]
 8011efa:	681b      	ldr	r3, [r3, #0]
 8011efc:	9303      	str	r3, [sp, #12]
 8011efe:	e019      	b.n	8011f34 <chEvtBroadcastFlagsI+0x54>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
 8011f00:	9b03      	ldr	r3, [sp, #12]
 8011f02:	68da      	ldr	r2, [r3, #12]
 8011f04:	9b00      	ldr	r3, [sp, #0]
 8011f06:	431a      	orrs	r2, r3
 8011f08:	9b03      	ldr	r3, [sp, #12]
 8011f0a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8011f0c:	9b00      	ldr	r3, [sp, #0]
 8011f0e:	2b00      	cmp	r3, #0
 8011f10:	d005      	beq.n	8011f1e <chEvtBroadcastFlagsI+0x3e>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 8011f12:	9b03      	ldr	r3, [sp, #12]
 8011f14:	691a      	ldr	r2, [r3, #16]
 8011f16:	9b00      	ldr	r3, [sp, #0]
 8011f18:	4013      	ands	r3, r2
    if ((flags == (eventflags_t)0) ||
 8011f1a:	2b00      	cmp	r3, #0
 8011f1c:	d007      	beq.n	8011f2e <chEvtBroadcastFlagsI+0x4e>
      chEvtSignalI(elp->listener, elp->events);
 8011f1e:	9b03      	ldr	r3, [sp, #12]
 8011f20:	685a      	ldr	r2, [r3, #4]
 8011f22:	9b03      	ldr	r3, [sp, #12]
 8011f24:	689b      	ldr	r3, [r3, #8]
 8011f26:	4619      	mov	r1, r3
 8011f28:	4610      	mov	r0, r2
 8011f2a:	f000 f831 	bl	8011f90 <chEvtSignalI>
    }
    elp = elp->next;
 8011f2e:	9b03      	ldr	r3, [sp, #12]
 8011f30:	681b      	ldr	r3, [r3, #0]
 8011f32:	9303      	str	r3, [sp, #12]
  while (elp != (event_listener_t *)esp) {
 8011f34:	9a03      	ldr	r2, [sp, #12]
 8011f36:	9b01      	ldr	r3, [sp, #4]
 8011f38:	429a      	cmp	r2, r3
 8011f3a:	d1e1      	bne.n	8011f00 <chEvtBroadcastFlagsI+0x20>
  }
}
 8011f3c:	b005      	add	sp, #20
 8011f3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8011f42:	bf00      	nop
 8011f44:	08016ec8 	.word	0x08016ec8
	...

08011f50 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 8011f50:	b500      	push	{lr}
 8011f52:	b083      	sub	sp, #12
 8011f54:	9001      	str	r0, [sp, #4]
 8011f56:	9100      	str	r1, [sp, #0]

  chDbgCheck(tp != NULL);
 8011f58:	9b01      	ldr	r3, [sp, #4]
 8011f5a:	2b00      	cmp	r3, #0
 8011f5c:	d102      	bne.n	8011f64 <chEvtSignal+0x14>
 8011f5e:	4808      	ldr	r0, [pc, #32]	; (8011f80 <chEvtSignal+0x30>)
 8011f60:	f7fd f83e 	bl	800efe0 <chSysHalt>

  chSysLock();
 8011f64:	f7ff feec 	bl	8011d40 <chSysLock.lto_priv.328>
  chEvtSignalI(tp, events);
 8011f68:	9900      	ldr	r1, [sp, #0]
 8011f6a:	9801      	ldr	r0, [sp, #4]
 8011f6c:	f000 f810 	bl	8011f90 <chEvtSignalI>
  chSchRescheduleS();
 8011f70:	f7fd ff9e 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 8011f74:	f7ff feec 	bl	8011d50 <chSysUnlock.lto_priv.304>
}
 8011f78:	b003      	add	sp, #12
 8011f7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8011f7e:	bf00      	nop
 8011f80:	08016ee0 	.word	0x08016ee0
	...

08011f90 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8011f90:	b500      	push	{lr}
 8011f92:	b083      	sub	sp, #12
 8011f94:	9001      	str	r0, [sp, #4]
 8011f96:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8011f98:	f7fd fa32 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8011f9c:	9b01      	ldr	r3, [sp, #4]
 8011f9e:	2b00      	cmp	r3, #0
 8011fa0:	d102      	bne.n	8011fa8 <chEvtSignalI+0x18>
 8011fa2:	4816      	ldr	r0, [pc, #88]	; (8011ffc <chEvtSignalI+0x6c>)
 8011fa4:	f7fd f81c 	bl	800efe0 <chSysHalt>

  tp->epending |= events;
 8011fa8:	9b01      	ldr	r3, [sp, #4]
 8011faa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8011fac:	9b00      	ldr	r3, [sp, #0]
 8011fae:	431a      	orrs	r2, r3
 8011fb0:	9b01      	ldr	r3, [sp, #4]
 8011fb2:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8011fb4:	9b01      	ldr	r3, [sp, #4]
 8011fb6:	f893 3020 	ldrb.w	r3, [r3, #32]
 8011fba:	2b0a      	cmp	r3, #10
 8011fbc:	d106      	bne.n	8011fcc <chEvtSignalI+0x3c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8011fbe:	9b01      	ldr	r3, [sp, #4]
 8011fc0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8011fc2:	9b01      	ldr	r3, [sp, #4]
 8011fc4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011fc6:	4013      	ands	r3, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
 8011fc8:	2b00      	cmp	r3, #0
 8011fca:	d10d      	bne.n	8011fe8 <chEvtSignalI+0x58>
      ((tp->state == CH_STATE_WTANDEVT) &&
 8011fcc:	9b01      	ldr	r3, [sp, #4]
 8011fce:	f893 3020 	ldrb.w	r3, [r3, #32]
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8011fd2:	2b0b      	cmp	r3, #11
 8011fd4:	d10e      	bne.n	8011ff4 <chEvtSignalI+0x64>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8011fd6:	9b01      	ldr	r3, [sp, #4]
 8011fd8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8011fda:	9b01      	ldr	r3, [sp, #4]
 8011fdc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011fde:	401a      	ands	r2, r3
 8011fe0:	9b01      	ldr	r3, [sp, #4]
 8011fe2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8011fe4:	429a      	cmp	r2, r3
 8011fe6:	d105      	bne.n	8011ff4 <chEvtSignalI+0x64>
    tp->u.rdymsg = MSG_OK;
 8011fe8:	9b01      	ldr	r3, [sp, #4]
 8011fea:	2200      	movs	r2, #0
 8011fec:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8011fee:	9801      	ldr	r0, [sp, #4]
 8011ff0:	f7fd fdce 	bl	800fb90 <chSchReadyI>
  }
}
 8011ff4:	b003      	add	sp, #12
 8011ff6:	f85d fb04 	ldr.w	pc, [sp], #4
 8011ffa:	bf00      	nop
 8011ffc:	08016eec 	.word	0x08016eec

08012000 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 8012000:	b500      	push	{lr}
 8012002:	b083      	sub	sp, #12
 8012004:	9001      	str	r0, [sp, #4]
 8012006:	9100      	str	r1, [sp, #0]

  chSysLock();
 8012008:	f7ff fe9a 	bl	8011d40 <chSysLock.lto_priv.328>
  chEvtBroadcastFlagsI(esp, flags);
 801200c:	9900      	ldr	r1, [sp, #0]
 801200e:	9801      	ldr	r0, [sp, #4]
 8012010:	f7ff ff66 	bl	8011ee0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 8012014:	f7fd ff4c 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 8012018:	f7ff fe9a 	bl	8011d50 <chSysUnlock.lto_priv.304>
}
 801201c:	b003      	add	sp, #12
 801201e:	f85d fb04 	ldr.w	pc, [sp], #4
 8012022:	bf00      	nop
	...

08012030 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 8012030:	b500      	push	{lr}
 8012032:	b085      	sub	sp, #20
 8012034:	9001      	str	r0, [sp, #4]
 8012036:	9100      	str	r1, [sp, #0]
  eventid_t eid;

  chDbgCheck(handlers != NULL);
 8012038:	9b01      	ldr	r3, [sp, #4]
 801203a:	2b00      	cmp	r3, #0
 801203c:	d102      	bne.n	8012044 <chEvtDispatch+0x14>
 801203e:	4818      	ldr	r0, [pc, #96]	; (80120a0 <chEvtDispatch+0x70>)
 8012040:	f7fc ffce 	bl	800efe0 <chSysHalt>

  eid = (eventid_t)0;
 8012044:	2300      	movs	r3, #0
 8012046:	9303      	str	r3, [sp, #12]
 8012048:	e023      	b.n	8012092 <chEvtDispatch+0x62>
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 801204a:	9b03      	ldr	r3, [sp, #12]
 801204c:	9a00      	ldr	r2, [sp, #0]
 801204e:	fa22 f303 	lsr.w	r3, r2, r3
 8012052:	f003 0301 	and.w	r3, r3, #1
 8012056:	2b00      	cmp	r3, #0
 8012058:	d018      	beq.n	801208c <chEvtDispatch+0x5c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
 801205a:	9b03      	ldr	r3, [sp, #12]
 801205c:	009b      	lsls	r3, r3, #2
 801205e:	9a01      	ldr	r2, [sp, #4]
 8012060:	4413      	add	r3, r2
 8012062:	681b      	ldr	r3, [r3, #0]
 8012064:	2b00      	cmp	r3, #0
 8012066:	d102      	bne.n	801206e <chEvtDispatch+0x3e>
 8012068:	480d      	ldr	r0, [pc, #52]	; (80120a0 <chEvtDispatch+0x70>)
 801206a:	f7fc ffb9 	bl	800efe0 <chSysHalt>
      events &= ~EVENT_MASK(eid);
 801206e:	9b03      	ldr	r3, [sp, #12]
 8012070:	2201      	movs	r2, #1
 8012072:	fa02 f303 	lsl.w	r3, r2, r3
 8012076:	43db      	mvns	r3, r3
 8012078:	9a00      	ldr	r2, [sp, #0]
 801207a:	4013      	ands	r3, r2
 801207c:	9300      	str	r3, [sp, #0]
      handlers[eid](eid);
 801207e:	9b03      	ldr	r3, [sp, #12]
 8012080:	009b      	lsls	r3, r3, #2
 8012082:	9a01      	ldr	r2, [sp, #4]
 8012084:	4413      	add	r3, r2
 8012086:	681b      	ldr	r3, [r3, #0]
 8012088:	9803      	ldr	r0, [sp, #12]
 801208a:	4798      	blx	r3
    }
    eid++;
 801208c:	9b03      	ldr	r3, [sp, #12]
 801208e:	3301      	adds	r3, #1
 8012090:	9303      	str	r3, [sp, #12]
  while (events != (eventmask_t)0) {
 8012092:	9b00      	ldr	r3, [sp, #0]
 8012094:	2b00      	cmp	r3, #0
 8012096:	d1d8      	bne.n	801204a <chEvtDispatch+0x1a>
  }
}
 8012098:	b005      	add	sp, #20
 801209a:	f85d fb04 	ldr.w	pc, [sp], #4
 801209e:	bf00      	nop
 80120a0:	08016efc 	.word	0x08016efc
	...

080120b0 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 80120b0:	b500      	push	{lr}
 80120b2:	b085      	sub	sp, #20
 80120b4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 80120b6:	4b15      	ldr	r3, [pc, #84]	; (801210c <chEvtWaitOne+0x5c>)
 80120b8:	699b      	ldr	r3, [r3, #24]
 80120ba:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80120bc:	f7ff fe40 	bl	8011d40 <chSysLock.lto_priv.328>
  m = ctp->epending & events;
 80120c0:	9b02      	ldr	r3, [sp, #8]
 80120c2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80120c4:	9a01      	ldr	r2, [sp, #4]
 80120c6:	4013      	ands	r3, r2
 80120c8:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80120ca:	9b03      	ldr	r3, [sp, #12]
 80120cc:	2b00      	cmp	r3, #0
 80120ce:	d10a      	bne.n	80120e6 <chEvtWaitOne+0x36>
    ctp->u.ewmask = events;
 80120d0:	9b02      	ldr	r3, [sp, #8]
 80120d2:	9a01      	ldr	r2, [sp, #4]
 80120d4:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 80120d6:	200a      	movs	r0, #10
 80120d8:	f7fd fdda 	bl	800fc90 <chSchGoSleepS>
    m = ctp->epending & events;
 80120dc:	9b02      	ldr	r3, [sp, #8]
 80120de:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80120e0:	9a01      	ldr	r2, [sp, #4]
 80120e2:	4013      	ands	r3, r2
 80120e4:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 80120e6:	9b03      	ldr	r3, [sp, #12]
 80120e8:	425b      	negs	r3, r3
 80120ea:	9a03      	ldr	r2, [sp, #12]
 80120ec:	4013      	ands	r3, r2
 80120ee:	9303      	str	r3, [sp, #12]
  ctp->epending &= ~m;
 80120f0:	9b02      	ldr	r3, [sp, #8]
 80120f2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80120f4:	9b03      	ldr	r3, [sp, #12]
 80120f6:	43db      	mvns	r3, r3
 80120f8:	401a      	ands	r2, r3
 80120fa:	9b02      	ldr	r3, [sp, #8]
 80120fc:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80120fe:	f7ff fe27 	bl	8011d50 <chSysUnlock.lto_priv.304>

  return m;
 8012102:	9b03      	ldr	r3, [sp, #12]
}
 8012104:	4618      	mov	r0, r3
 8012106:	b005      	add	sp, #20
 8012108:	f85d fb04 	ldr.w	pc, [sp], #4
 801210c:	20001090 	.word	0x20001090

08012110 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8012110:	b500      	push	{lr}
 8012112:	b085      	sub	sp, #20
 8012114:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8012116:	4b13      	ldr	r3, [pc, #76]	; (8012164 <chEvtWaitAny+0x54>)
 8012118:	699b      	ldr	r3, [r3, #24]
 801211a:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 801211c:	f7ff fe10 	bl	8011d40 <chSysLock.lto_priv.328>
  m = ctp->epending & events;
 8012120:	9b02      	ldr	r3, [sp, #8]
 8012122:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012124:	9a01      	ldr	r2, [sp, #4]
 8012126:	4013      	ands	r3, r2
 8012128:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 801212a:	9b03      	ldr	r3, [sp, #12]
 801212c:	2b00      	cmp	r3, #0
 801212e:	d10a      	bne.n	8012146 <chEvtWaitAny+0x36>
    ctp->u.ewmask = events;
 8012130:	9b02      	ldr	r3, [sp, #8]
 8012132:	9a01      	ldr	r2, [sp, #4]
 8012134:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8012136:	200a      	movs	r0, #10
 8012138:	f7fd fdaa 	bl	800fc90 <chSchGoSleepS>
    m = ctp->epending & events;
 801213c:	9b02      	ldr	r3, [sp, #8]
 801213e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012140:	9a01      	ldr	r2, [sp, #4]
 8012142:	4013      	ands	r3, r2
 8012144:	9303      	str	r3, [sp, #12]
  }
  ctp->epending &= ~m;
 8012146:	9b02      	ldr	r3, [sp, #8]
 8012148:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801214a:	9b03      	ldr	r3, [sp, #12]
 801214c:	43db      	mvns	r3, r3
 801214e:	401a      	ands	r2, r3
 8012150:	9b02      	ldr	r3, [sp, #8]
 8012152:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8012154:	f7ff fdfc 	bl	8011d50 <chSysUnlock.lto_priv.304>

  return m;
 8012158:	9b03      	ldr	r3, [sp, #12]
}
 801215a:	4618      	mov	r0, r3
 801215c:	b005      	add	sp, #20
 801215e:	f85d fb04 	ldr.w	pc, [sp], #4
 8012162:	bf00      	nop
 8012164:	20001090 	.word	0x20001090
	...

08012170 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8012170:	b500      	push	{lr}
 8012172:	b085      	sub	sp, #20
 8012174:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8012176:	4b10      	ldr	r3, [pc, #64]	; (80121b8 <chEvtWaitAll+0x48>)
 8012178:	699b      	ldr	r3, [r3, #24]
 801217a:	9303      	str	r3, [sp, #12]

  chSysLock();
 801217c:	f7ff fde0 	bl	8011d40 <chSysLock.lto_priv.328>
  if ((ctp->epending & events) != events) {
 8012180:	9b03      	ldr	r3, [sp, #12]
 8012182:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8012184:	9b01      	ldr	r3, [sp, #4]
 8012186:	4013      	ands	r3, r2
 8012188:	9a01      	ldr	r2, [sp, #4]
 801218a:	429a      	cmp	r2, r3
 801218c:	d005      	beq.n	801219a <chEvtWaitAll+0x2a>
    ctp->u.ewmask = events;
 801218e:	9b03      	ldr	r3, [sp, #12]
 8012190:	9a01      	ldr	r2, [sp, #4]
 8012192:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8012194:	200b      	movs	r0, #11
 8012196:	f7fd fd7b 	bl	800fc90 <chSchGoSleepS>
  }
  ctp->epending &= ~events;
 801219a:	9b03      	ldr	r3, [sp, #12]
 801219c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801219e:	9b01      	ldr	r3, [sp, #4]
 80121a0:	43db      	mvns	r3, r3
 80121a2:	401a      	ands	r2, r3
 80121a4:	9b03      	ldr	r3, [sp, #12]
 80121a6:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80121a8:	f7ff fdd2 	bl	8011d50 <chSysUnlock.lto_priv.304>

  return events;
 80121ac:	9b01      	ldr	r3, [sp, #4]
}
 80121ae:	4618      	mov	r0, r3
 80121b0:	b005      	add	sp, #20
 80121b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80121b6:	bf00      	nop
 80121b8:	20001090 	.word	0x20001090
 80121bc:	00000000 	.word	0x00000000

080121c0 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
 80121c0:	b500      	push	{lr}
 80121c2:	b085      	sub	sp, #20
 80121c4:	9001      	str	r0, [sp, #4]
 80121c6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 80121c8:	4b1c      	ldr	r3, [pc, #112]	; (801223c <chEvtWaitOneTimeout+0x7c>)
 80121ca:	699b      	ldr	r3, [r3, #24]
 80121cc:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80121ce:	f7ff fdb7 	bl	8011d40 <chSysLock.lto_priv.328>
  m = ctp->epending & events;
 80121d2:	9b02      	ldr	r3, [sp, #8]
 80121d4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80121d6:	9a01      	ldr	r2, [sp, #4]
 80121d8:	4013      	ands	r3, r2
 80121da:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80121dc:	9b03      	ldr	r3, [sp, #12]
 80121de:	2b00      	cmp	r3, #0
 80121e0:	d119      	bne.n	8012216 <chEvtWaitOneTimeout+0x56>
    if (TIME_IMMEDIATE == timeout) {
 80121e2:	9b00      	ldr	r3, [sp, #0]
 80121e4:	2b00      	cmp	r3, #0
 80121e6:	d103      	bne.n	80121f0 <chEvtWaitOneTimeout+0x30>
      chSysUnlock();
 80121e8:	f7ff fdb2 	bl	8011d50 <chSysUnlock.lto_priv.304>
      return (eventmask_t)0;
 80121ec:	2300      	movs	r3, #0
 80121ee:	e021      	b.n	8012234 <chEvtWaitOneTimeout+0x74>
    }
    ctp->u.ewmask = events;
 80121f0:	9b02      	ldr	r3, [sp, #8]
 80121f2:	9a01      	ldr	r2, [sp, #4]
 80121f4:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 80121f6:	9900      	ldr	r1, [sp, #0]
 80121f8:	200a      	movs	r0, #10
 80121fa:	f7fd fdc9 	bl	800fd90 <chSchGoSleepTimeoutS>
 80121fe:	4603      	mov	r3, r0
 8012200:	2b00      	cmp	r3, #0
 8012202:	da03      	bge.n	801220c <chEvtWaitOneTimeout+0x4c>
      chSysUnlock();
 8012204:	f7ff fda4 	bl	8011d50 <chSysUnlock.lto_priv.304>
      return (eventmask_t)0;
 8012208:	2300      	movs	r3, #0
 801220a:	e013      	b.n	8012234 <chEvtWaitOneTimeout+0x74>
    }
    m = ctp->epending & events;
 801220c:	9b02      	ldr	r3, [sp, #8]
 801220e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012210:	9a01      	ldr	r2, [sp, #4]
 8012212:	4013      	ands	r3, r2
 8012214:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 8012216:	9b03      	ldr	r3, [sp, #12]
 8012218:	425b      	negs	r3, r3
 801221a:	9a03      	ldr	r2, [sp, #12]
 801221c:	4013      	ands	r3, r2
 801221e:	9303      	str	r3, [sp, #12]
  ctp->epending &= ~m;
 8012220:	9b02      	ldr	r3, [sp, #8]
 8012222:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8012224:	9b03      	ldr	r3, [sp, #12]
 8012226:	43db      	mvns	r3, r3
 8012228:	401a      	ands	r2, r3
 801222a:	9b02      	ldr	r3, [sp, #8]
 801222c:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 801222e:	f7ff fd8f 	bl	8011d50 <chSysUnlock.lto_priv.304>

  return m;
 8012232:	9b03      	ldr	r3, [sp, #12]
}
 8012234:	4618      	mov	r0, r3
 8012236:	b005      	add	sp, #20
 8012238:	f85d fb04 	ldr.w	pc, [sp], #4
 801223c:	20001090 	.word	0x20001090

08012240 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, sysinterval_t timeout) {
 8012240:	b500      	push	{lr}
 8012242:	b085      	sub	sp, #20
 8012244:	9001      	str	r0, [sp, #4]
 8012246:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8012248:	4b1a      	ldr	r3, [pc, #104]	; (80122b4 <chEvtWaitAnyTimeout+0x74>)
 801224a:	699b      	ldr	r3, [r3, #24]
 801224c:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 801224e:	f7ff fd77 	bl	8011d40 <chSysLock.lto_priv.328>
  m = ctp->epending & events;
 8012252:	9b02      	ldr	r3, [sp, #8]
 8012254:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012256:	9a01      	ldr	r2, [sp, #4]
 8012258:	4013      	ands	r3, r2
 801225a:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 801225c:	9b03      	ldr	r3, [sp, #12]
 801225e:	2b00      	cmp	r3, #0
 8012260:	d119      	bne.n	8012296 <chEvtWaitAnyTimeout+0x56>
    if (TIME_IMMEDIATE == timeout) {
 8012262:	9b00      	ldr	r3, [sp, #0]
 8012264:	2b00      	cmp	r3, #0
 8012266:	d103      	bne.n	8012270 <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
 8012268:	f7ff fd72 	bl	8011d50 <chSysUnlock.lto_priv.304>
      return (eventmask_t)0;
 801226c:	2300      	movs	r3, #0
 801226e:	e01c      	b.n	80122aa <chEvtWaitAnyTimeout+0x6a>
    }
    ctp->u.ewmask = events;
 8012270:	9b02      	ldr	r3, [sp, #8]
 8012272:	9a01      	ldr	r2, [sp, #4]
 8012274:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8012276:	9900      	ldr	r1, [sp, #0]
 8012278:	200a      	movs	r0, #10
 801227a:	f7fd fd89 	bl	800fd90 <chSchGoSleepTimeoutS>
 801227e:	4603      	mov	r3, r0
 8012280:	2b00      	cmp	r3, #0
 8012282:	da03      	bge.n	801228c <chEvtWaitAnyTimeout+0x4c>
      chSysUnlock();
 8012284:	f7ff fd64 	bl	8011d50 <chSysUnlock.lto_priv.304>
      return (eventmask_t)0;
 8012288:	2300      	movs	r3, #0
 801228a:	e00e      	b.n	80122aa <chEvtWaitAnyTimeout+0x6a>
    }
    m = ctp->epending & events;
 801228c:	9b02      	ldr	r3, [sp, #8]
 801228e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012290:	9a01      	ldr	r2, [sp, #4]
 8012292:	4013      	ands	r3, r2
 8012294:	9303      	str	r3, [sp, #12]
  }
  ctp->epending &= ~m;
 8012296:	9b02      	ldr	r3, [sp, #8]
 8012298:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801229a:	9b03      	ldr	r3, [sp, #12]
 801229c:	43db      	mvns	r3, r3
 801229e:	401a      	ands	r2, r3
 80122a0:	9b02      	ldr	r3, [sp, #8]
 80122a2:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80122a4:	f7ff fd54 	bl	8011d50 <chSysUnlock.lto_priv.304>

  return m;
 80122a8:	9b03      	ldr	r3, [sp, #12]
}
 80122aa:	4618      	mov	r0, r3
 80122ac:	b005      	add	sp, #20
 80122ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80122b2:	bf00      	nop
 80122b4:	20001090 	.word	0x20001090
	...

080122c0 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, sysinterval_t timeout) {
 80122c0:	b500      	push	{lr}
 80122c2:	b085      	sub	sp, #20
 80122c4:	9001      	str	r0, [sp, #4]
 80122c6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 80122c8:	4b17      	ldr	r3, [pc, #92]	; (8012328 <chEvtWaitAllTimeout+0x68>)
 80122ca:	699b      	ldr	r3, [r3, #24]
 80122cc:	9303      	str	r3, [sp, #12]

  chSysLock();
 80122ce:	f7ff fd37 	bl	8011d40 <chSysLock.lto_priv.328>
  if ((ctp->epending & events) != events) {
 80122d2:	9b03      	ldr	r3, [sp, #12]
 80122d4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80122d6:	9b01      	ldr	r3, [sp, #4]
 80122d8:	4013      	ands	r3, r2
 80122da:	9a01      	ldr	r2, [sp, #4]
 80122dc:	429a      	cmp	r2, r3
 80122de:	d014      	beq.n	801230a <chEvtWaitAllTimeout+0x4a>
    if (TIME_IMMEDIATE == timeout) {
 80122e0:	9b00      	ldr	r3, [sp, #0]
 80122e2:	2b00      	cmp	r3, #0
 80122e4:	d103      	bne.n	80122ee <chEvtWaitAllTimeout+0x2e>
      chSysUnlock();
 80122e6:	f7ff fd33 	bl	8011d50 <chSysUnlock.lto_priv.304>
      return (eventmask_t)0;
 80122ea:	2300      	movs	r3, #0
 80122ec:	e017      	b.n	801231e <chEvtWaitAllTimeout+0x5e>
    }
    ctp->u.ewmask = events;
 80122ee:	9b03      	ldr	r3, [sp, #12]
 80122f0:	9a01      	ldr	r2, [sp, #4]
 80122f2:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
 80122f4:	9900      	ldr	r1, [sp, #0]
 80122f6:	200b      	movs	r0, #11
 80122f8:	f7fd fd4a 	bl	800fd90 <chSchGoSleepTimeoutS>
 80122fc:	4603      	mov	r3, r0
 80122fe:	2b00      	cmp	r3, #0
 8012300:	da03      	bge.n	801230a <chEvtWaitAllTimeout+0x4a>
      chSysUnlock();
 8012302:	f7ff fd25 	bl	8011d50 <chSysUnlock.lto_priv.304>
      return (eventmask_t)0;
 8012306:	2300      	movs	r3, #0
 8012308:	e009      	b.n	801231e <chEvtWaitAllTimeout+0x5e>
    }
  }
  ctp->epending &= ~events;
 801230a:	9b03      	ldr	r3, [sp, #12]
 801230c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801230e:	9b01      	ldr	r3, [sp, #4]
 8012310:	43db      	mvns	r3, r3
 8012312:	401a      	ands	r2, r3
 8012314:	9b03      	ldr	r3, [sp, #12]
 8012316:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8012318:	f7ff fd1a 	bl	8011d50 <chSysUnlock.lto_priv.304>

  return events;
 801231c:	9b01      	ldr	r3, [sp, #4]
}
 801231e:	4618      	mov	r0, r3
 8012320:	b005      	add	sp, #20
 8012322:	f85d fb04 	ldr.w	pc, [sp], #4
 8012326:	bf00      	nop
 8012328:	20001090 	.word	0x20001090
 801232c:	00000000 	.word	0x00000000

08012330 <port_lock.lto_priv.403>:
static inline void port_lock(void) {
 8012330:	b082      	sub	sp, #8
 8012332:	2320      	movs	r3, #32
 8012334:	9301      	str	r3, [sp, #4]
 8012336:	9b01      	ldr	r3, [sp, #4]
 8012338:	f383 8811 	msr	BASEPRI, r3
}
 801233c:	b002      	add	sp, #8
 801233e:	4770      	bx	lr

08012340 <port_unlock.lto_priv.372>:
static inline void port_unlock(void) {
 8012340:	b082      	sub	sp, #8
 8012342:	2300      	movs	r3, #0
 8012344:	9301      	str	r3, [sp, #4]
 8012346:	9b01      	ldr	r3, [sp, #4]
 8012348:	f383 8811 	msr	BASEPRI, r3
}
 801234c:	b002      	add	sp, #8
 801234e:	4770      	bx	lr

08012350 <queue_insert.lto_priv.476>:
static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8012350:	b082      	sub	sp, #8
 8012352:	9001      	str	r0, [sp, #4]
 8012354:	9100      	str	r1, [sp, #0]
  tp->queue.next             = (thread_t *)tqp;
 8012356:	9b01      	ldr	r3, [sp, #4]
 8012358:	9a00      	ldr	r2, [sp, #0]
 801235a:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 801235c:	9b00      	ldr	r3, [sp, #0]
 801235e:	685a      	ldr	r2, [r3, #4]
 8012360:	9b01      	ldr	r3, [sp, #4]
 8012362:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8012364:	9b01      	ldr	r3, [sp, #4]
 8012366:	685b      	ldr	r3, [r3, #4]
 8012368:	9a01      	ldr	r2, [sp, #4]
 801236a:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 801236c:	9b00      	ldr	r3, [sp, #0]
 801236e:	9a01      	ldr	r2, [sp, #4]
 8012370:	605a      	str	r2, [r3, #4]
}
 8012372:	b002      	add	sp, #8
 8012374:	4770      	bx	lr
 8012376:	bf00      	nop
	...

08012380 <queue_fifo_remove.lto_priv.473>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8012380:	b084      	sub	sp, #16
 8012382:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8012384:	9b01      	ldr	r3, [sp, #4]
 8012386:	681b      	ldr	r3, [r3, #0]
 8012388:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 801238a:	9b03      	ldr	r3, [sp, #12]
 801238c:	681a      	ldr	r2, [r3, #0]
 801238e:	9b01      	ldr	r3, [sp, #4]
 8012390:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8012392:	9b01      	ldr	r3, [sp, #4]
 8012394:	681b      	ldr	r3, [r3, #0]
 8012396:	9a01      	ldr	r2, [sp, #4]
 8012398:	605a      	str	r2, [r3, #4]
  return tp;
 801239a:	9b03      	ldr	r3, [sp, #12]
}
 801239c:	4618      	mov	r0, r3
 801239e:	b004      	add	sp, #16
 80123a0:	4770      	bx	lr
 80123a2:	bf00      	nop
	...

080123b0 <chSysLock.lto_priv.329>:
static inline void chSysLock(void) {
 80123b0:	b508      	push	{r3, lr}
  port_lock();
 80123b2:	f7ff ffbd 	bl	8012330 <port_lock.lto_priv.403>
  _dbg_check_lock();
 80123b6:	f7fc ff83 	bl	800f2c0 <_dbg_check_lock>
}
 80123ba:	bd08      	pop	{r3, pc}
 80123bc:	0000      	movs	r0, r0
	...

080123c0 <chSysUnlock.lto_priv.305>:
static inline void chSysUnlock(void) {
 80123c0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80123c2:	f7fc ff95 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80123c6:	4b09      	ldr	r3, [pc, #36]	; (80123ec <chSysUnlock.lto_priv.305+0x2c>)
 80123c8:	681b      	ldr	r3, [r3, #0]
 80123ca:	4a08      	ldr	r2, [pc, #32]	; (80123ec <chSysUnlock.lto_priv.305+0x2c>)
 80123cc:	4293      	cmp	r3, r2
 80123ce:	d00a      	beq.n	80123e6 <chSysUnlock.lto_priv.305+0x26>
 80123d0:	4b06      	ldr	r3, [pc, #24]	; (80123ec <chSysUnlock.lto_priv.305+0x2c>)
 80123d2:	699b      	ldr	r3, [r3, #24]
 80123d4:	689a      	ldr	r2, [r3, #8]
 80123d6:	4b05      	ldr	r3, [pc, #20]	; (80123ec <chSysUnlock.lto_priv.305+0x2c>)
 80123d8:	681b      	ldr	r3, [r3, #0]
 80123da:	689b      	ldr	r3, [r3, #8]
 80123dc:	429a      	cmp	r2, r3
 80123de:	d202      	bcs.n	80123e6 <chSysUnlock.lto_priv.305+0x26>
 80123e0:	4803      	ldr	r0, [pc, #12]	; (80123f0 <chSysUnlock.lto_priv.305+0x30>)
 80123e2:	f7fc fdfd 	bl	800efe0 <chSysHalt>
  port_unlock();
 80123e6:	f7ff ffab 	bl	8012340 <port_unlock.lto_priv.372>
}
 80123ea:	bd08      	pop	{r3, pc}
 80123ec:	20001090 	.word	0x20001090
 80123f0:	08016f18 	.word	0x08016f18
	...

08012400 <chMsgIsPendingI>:
static inline bool chMsgIsPendingI(thread_t *tp) {
 8012400:	b500      	push	{lr}
 8012402:	b083      	sub	sp, #12
 8012404:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8012406:	f7fc fffb 	bl	800f400 <chDbgCheckClassI>
  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 801240a:	9b01      	ldr	r3, [sp, #4]
 801240c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801240e:	9b01      	ldr	r3, [sp, #4]
 8012410:	332c      	adds	r3, #44	; 0x2c
 8012412:	429a      	cmp	r2, r3
 8012414:	bf14      	ite	ne
 8012416:	2301      	movne	r3, #1
 8012418:	2300      	moveq	r3, #0
 801241a:	b2db      	uxtb	r3, r3
}
 801241c:	4618      	mov	r0, r3
 801241e:	b003      	add	sp, #12
 8012420:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08012430 <chMsgReleaseS>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {
 8012430:	b500      	push	{lr}
 8012432:	b083      	sub	sp, #12
 8012434:	9001      	str	r0, [sp, #4]
 8012436:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 8012438:	f7fc fffa 	bl	800f430 <chDbgCheckClassS>

  chSchWakeupS(tp, msg);
 801243c:	9900      	ldr	r1, [sp, #0]
 801243e:	9801      	ldr	r0, [sp, #4]
 8012440:	f7fd fcde 	bl	800fe00 <chSchWakeupS>
}
 8012444:	b003      	add	sp, #12
 8012446:	f85d fb04 	ldr.w	pc, [sp], #4
 801244a:	bf00      	nop
 801244c:	0000      	movs	r0, r0
	...

08012450 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8012450:	b500      	push	{lr}
 8012452:	b085      	sub	sp, #20
 8012454:	9001      	str	r0, [sp, #4]
 8012456:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8012458:	4b14      	ldr	r3, [pc, #80]	; (80124ac <chMsgSend+0x5c>)
 801245a:	699b      	ldr	r3, [r3, #24]
 801245c:	9303      	str	r3, [sp, #12]

  chDbgCheck(tp != NULL);
 801245e:	9b01      	ldr	r3, [sp, #4]
 8012460:	2b00      	cmp	r3, #0
 8012462:	d102      	bne.n	801246a <chMsgSend+0x1a>
 8012464:	4812      	ldr	r0, [pc, #72]	; (80124b0 <chMsgSend+0x60>)
 8012466:	f7fc fdbb 	bl	800efe0 <chSysHalt>

  chSysLock();
 801246a:	f7ff ffa1 	bl	80123b0 <chSysLock.lto_priv.329>
  ctp->u.sentmsg = msg;
 801246e:	9b03      	ldr	r3, [sp, #12]
 8012470:	9a00      	ldr	r2, [sp, #0]
 8012472:	625a      	str	r2, [r3, #36]	; 0x24
  msg_insert(ctp, &tp->msgqueue);
 8012474:	9b01      	ldr	r3, [sp, #4]
 8012476:	332c      	adds	r3, #44	; 0x2c
 8012478:	4619      	mov	r1, r3
 801247a:	9803      	ldr	r0, [sp, #12]
 801247c:	f7ff ff68 	bl	8012350 <queue_insert.lto_priv.476>
  if (tp->state == CH_STATE_WTMSG) {
 8012480:	9b01      	ldr	r3, [sp, #4]
 8012482:	f893 3020 	ldrb.w	r3, [r3, #32]
 8012486:	2b0e      	cmp	r3, #14
 8012488:	d102      	bne.n	8012490 <chMsgSend+0x40>
    (void) chSchReadyI(tp);
 801248a:	9801      	ldr	r0, [sp, #4]
 801248c:	f7fd fb80 	bl	800fb90 <chSchReadyI>
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8012490:	200c      	movs	r0, #12
 8012492:	f7fd fbfd 	bl	800fc90 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 8012496:	9b03      	ldr	r3, [sp, #12]
 8012498:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801249a:	9300      	str	r3, [sp, #0]
  chSysUnlock();
 801249c:	f7ff ff90 	bl	80123c0 <chSysUnlock.lto_priv.305>

  return msg;
 80124a0:	9b00      	ldr	r3, [sp, #0]
}
 80124a2:	4618      	mov	r0, r3
 80124a4:	b005      	add	sp, #20
 80124a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80124aa:	bf00      	nop
 80124ac:	20001090 	.word	0x20001090
 80124b0:	08016f0c 	.word	0x08016f0c
	...

080124c0 <chMsgWait>:
 *
 * @return              A pointer to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 80124c0:	b500      	push	{lr}
 80124c2:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 80124c4:	f7ff ff74 	bl	80123b0 <chSysLock.lto_priv.329>
  if (!chMsgIsPendingI(currp)) {
 80124c8:	4b0f      	ldr	r3, [pc, #60]	; (8012508 <chMsgWait+0x48>)
 80124ca:	699b      	ldr	r3, [r3, #24]
 80124cc:	4618      	mov	r0, r3
 80124ce:	f7ff ff97 	bl	8012400 <chMsgIsPendingI>
 80124d2:	4603      	mov	r3, r0
 80124d4:	f083 0301 	eor.w	r3, r3, #1
 80124d8:	b2db      	uxtb	r3, r3
 80124da:	2b00      	cmp	r3, #0
 80124dc:	d002      	beq.n	80124e4 <chMsgWait+0x24>
    chSchGoSleepS(CH_STATE_WTMSG);
 80124de:	200e      	movs	r0, #14
 80124e0:	f7fd fbd6 	bl	800fc90 <chSchGoSleepS>
  }
  tp = queue_fifo_remove(&currp->msgqueue);
 80124e4:	4b08      	ldr	r3, [pc, #32]	; (8012508 <chMsgWait+0x48>)
 80124e6:	699b      	ldr	r3, [r3, #24]
 80124e8:	332c      	adds	r3, #44	; 0x2c
 80124ea:	4618      	mov	r0, r3
 80124ec:	f7ff ff48 	bl	8012380 <queue_fifo_remove.lto_priv.473>
 80124f0:	9001      	str	r0, [sp, #4]
  tp->state = CH_STATE_SNDMSG;
 80124f2:	9b01      	ldr	r3, [sp, #4]
 80124f4:	220d      	movs	r2, #13
 80124f6:	f883 2020 	strb.w	r2, [r3, #32]
  chSysUnlock();
 80124fa:	f7ff ff61 	bl	80123c0 <chSysUnlock.lto_priv.305>

  return tp;
 80124fe:	9b01      	ldr	r3, [sp, #4]
}
 8012500:	4618      	mov	r0, r3
 8012502:	b003      	add	sp, #12
 8012504:	f85d fb04 	ldr.w	pc, [sp], #4
 8012508:	20001090 	.word	0x20001090
 801250c:	00000000 	.word	0x00000000

08012510 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8012510:	b500      	push	{lr}
 8012512:	b083      	sub	sp, #12
 8012514:	9001      	str	r0, [sp, #4]
 8012516:	9100      	str	r1, [sp, #0]

  chSysLock();
 8012518:	f7ff ff4a 	bl	80123b0 <chSysLock.lto_priv.329>
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
 801251c:	9b01      	ldr	r3, [sp, #4]
 801251e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8012522:	2b0d      	cmp	r3, #13
 8012524:	d002      	beq.n	801252c <chMsgRelease+0x1c>
 8012526:	4806      	ldr	r0, [pc, #24]	; (8012540 <chMsgRelease+0x30>)
 8012528:	f7fc fd5a 	bl	800efe0 <chSysHalt>
  chMsgReleaseS(tp, msg);
 801252c:	9900      	ldr	r1, [sp, #0]
 801252e:	9801      	ldr	r0, [sp, #4]
 8012530:	f7ff ff7e 	bl	8012430 <chMsgReleaseS>
  chSysUnlock();
 8012534:	f7ff ff44 	bl	80123c0 <chSysUnlock.lto_priv.305>
}
 8012538:	b003      	add	sp, #12
 801253a:	f85d fb04 	ldr.w	pc, [sp], #4
 801253e:	bf00      	nop
 8012540:	08016f24 	.word	0x08016f24
	...

08012550 <port_lock.lto_priv.404>:
static inline void port_lock(void) {
 8012550:	b082      	sub	sp, #8
 8012552:	2320      	movs	r3, #32
 8012554:	9301      	str	r3, [sp, #4]
 8012556:	9b01      	ldr	r3, [sp, #4]
 8012558:	f383 8811 	msr	BASEPRI, r3
}
 801255c:	b002      	add	sp, #8
 801255e:	4770      	bx	lr

08012560 <port_unlock.lto_priv.373>:
static inline void port_unlock(void) {
 8012560:	b082      	sub	sp, #8
 8012562:	2300      	movs	r3, #0
 8012564:	9301      	str	r3, [sp, #4]
 8012566:	9b01      	ldr	r3, [sp, #4]
 8012568:	f383 8811 	msr	BASEPRI, r3
}
 801256c:	b002      	add	sp, #8
 801256e:	4770      	bx	lr

08012570 <chSysLock.lto_priv.330>:
static inline void chSysLock(void) {
 8012570:	b508      	push	{r3, lr}
  port_lock();
 8012572:	f7ff ffed 	bl	8012550 <port_lock.lto_priv.404>
  _dbg_check_lock();
 8012576:	f7fc fea3 	bl	800f2c0 <_dbg_check_lock>
}
 801257a:	bd08      	pop	{r3, pc}
 801257c:	0000      	movs	r0, r0
	...

08012580 <chSysUnlock.lto_priv.306>:
static inline void chSysUnlock(void) {
 8012580:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8012582:	f7fc feb5 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8012586:	4b09      	ldr	r3, [pc, #36]	; (80125ac <chSysUnlock.lto_priv.306+0x2c>)
 8012588:	681b      	ldr	r3, [r3, #0]
 801258a:	4a08      	ldr	r2, [pc, #32]	; (80125ac <chSysUnlock.lto_priv.306+0x2c>)
 801258c:	4293      	cmp	r3, r2
 801258e:	d00a      	beq.n	80125a6 <chSysUnlock.lto_priv.306+0x26>
 8012590:	4b06      	ldr	r3, [pc, #24]	; (80125ac <chSysUnlock.lto_priv.306+0x2c>)
 8012592:	699b      	ldr	r3, [r3, #24]
 8012594:	689a      	ldr	r2, [r3, #8]
 8012596:	4b05      	ldr	r3, [pc, #20]	; (80125ac <chSysUnlock.lto_priv.306+0x2c>)
 8012598:	681b      	ldr	r3, [r3, #0]
 801259a:	689b      	ldr	r3, [r3, #8]
 801259c:	429a      	cmp	r2, r3
 801259e:	d202      	bcs.n	80125a6 <chSysUnlock.lto_priv.306+0x26>
 80125a0:	4803      	ldr	r0, [pc, #12]	; (80125b0 <chSysUnlock.lto_priv.306+0x30>)
 80125a2:	f7fc fd1d 	bl	800efe0 <chSysHalt>
  port_unlock();
 80125a6:	f7ff ffdb 	bl	8012560 <port_unlock.lto_priv.373>
}
 80125aa:	bd08      	pop	{r3, pc}
 80125ac:	20001090 	.word	0x20001090
 80125b0:	08016f34 	.word	0x08016f34
	...

080125c0 <chThdCreateFromHeap>:
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
 80125c0:	b500      	push	{lr}
 80125c2:	b08d      	sub	sp, #52	; 0x34
 80125c4:	9003      	str	r0, [sp, #12]
 80125c6:	9102      	str	r1, [sp, #8]
 80125c8:	9201      	str	r2, [sp, #4]
 80125ca:	9300      	str	r3, [sp, #0]
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 80125cc:	2208      	movs	r2, #8
 80125ce:	9902      	ldr	r1, [sp, #8]
 80125d0:	9803      	ldr	r0, [sp, #12]
 80125d2:	f000 fc95 	bl	8012f00 <chHeapAllocAligned>
 80125d6:	900b      	str	r0, [sp, #44]	; 0x2c
  if (wsp == NULL) {
 80125d8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80125da:	2b00      	cmp	r3, #0
 80125dc:	d101      	bne.n	80125e2 <chThdCreateFromHeap+0x22>
    return NULL;
 80125de:	2300      	movs	r3, #0
 80125e0:	e027      	b.n	8012632 <chThdCreateFromHeap+0x72>
  }

  thread_descriptor_t td = {
 80125e2:	9b01      	ldr	r3, [sp, #4]
 80125e4:	9304      	str	r3, [sp, #16]
 80125e6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80125e8:	9305      	str	r3, [sp, #20]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
 80125ea:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80125ec:	9b02      	ldr	r3, [sp, #8]
 80125ee:	4413      	add	r3, r2
  thread_descriptor_t td = {
 80125f0:	9306      	str	r3, [sp, #24]
 80125f2:	9b00      	ldr	r3, [sp, #0]
 80125f4:	9307      	str	r3, [sp, #28]
 80125f6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80125f8:	9308      	str	r3, [sp, #32]
 80125fa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80125fc:	9309      	str	r3, [sp, #36]	; 0x24
    pf,
    arg
  };

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 80125fe:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8012600:	9b02      	ldr	r3, [sp, #8]
 8012602:	4413      	add	r3, r2
 8012604:	2255      	movs	r2, #85	; 0x55
 8012606:	4619      	mov	r1, r3
 8012608:	980b      	ldr	r0, [sp, #44]	; 0x2c
 801260a:	f7fd fec1 	bl	8010390 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 801260e:	f7ff ffaf 	bl	8012570 <chSysLock.lto_priv.330>
  tp = chThdCreateSuspendedI(&td);
 8012612:	ab04      	add	r3, sp, #16
 8012614:	4618      	mov	r0, r3
 8012616:	f7fd fed3 	bl	80103c0 <chThdCreateSuspendedI>
 801261a:	900a      	str	r0, [sp, #40]	; 0x28
  tp->flags = CH_FLAG_MODE_HEAP;
 801261c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801261e:	2201      	movs	r2, #1
 8012620:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 8012624:	2100      	movs	r1, #0
 8012626:	980a      	ldr	r0, [sp, #40]	; 0x28
 8012628:	f7fd fbea 	bl	800fe00 <chSchWakeupS>
  chSysUnlock();
 801262c:	f7ff ffa8 	bl	8012580 <chSysUnlock.lto_priv.306>

  return tp;
 8012630:	9b0a      	ldr	r3, [sp, #40]	; 0x28
}
 8012632:	4618      	mov	r0, r3
 8012634:	b00d      	add	sp, #52	; 0x34
 8012636:	f85d fb04 	ldr.w	pc, [sp], #4
 801263a:	bf00      	nop
 801263c:	0000      	movs	r0, r0
	...

08012640 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
                                    tprio_t prio, tfunc_t pf, void *arg) {
 8012640:	b500      	push	{lr}
 8012642:	b08d      	sub	sp, #52	; 0x34
 8012644:	9003      	str	r0, [sp, #12]
 8012646:	9102      	str	r1, [sp, #8]
 8012648:	9201      	str	r2, [sp, #4]
 801264a:	9300      	str	r3, [sp, #0]
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);
 801264c:	9b03      	ldr	r3, [sp, #12]
 801264e:	2b00      	cmp	r3, #0
 8012650:	d102      	bne.n	8012658 <chThdCreateFromMemoryPool+0x18>
 8012652:	481e      	ldr	r0, [pc, #120]	; (80126cc <chThdCreateFromMemoryPool+0x8c>)
 8012654:	f7fc fcc4 	bl	800efe0 <chSysHalt>

  wsp = chPoolAlloc(mp);
 8012658:	9803      	ldr	r0, [sp, #12]
 801265a:	f000 ff11 	bl	8013480 <chPoolAlloc>
 801265e:	900b      	str	r0, [sp, #44]	; 0x2c
  if (wsp == NULL) {
 8012660:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012662:	2b00      	cmp	r3, #0
 8012664:	d101      	bne.n	801266a <chThdCreateFromMemoryPool+0x2a>
    return NULL;
 8012666:	2300      	movs	r3, #0
 8012668:	e02c      	b.n	80126c4 <chThdCreateFromMemoryPool+0x84>
  }

  thread_descriptor_t td = {
 801266a:	9b02      	ldr	r3, [sp, #8]
 801266c:	9304      	str	r3, [sp, #16]
 801266e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012670:	9305      	str	r3, [sp, #20]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8012672:	9b03      	ldr	r3, [sp, #12]
 8012674:	685b      	ldr	r3, [r3, #4]
 8012676:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8012678:	4413      	add	r3, r2
  thread_descriptor_t td = {
 801267a:	9306      	str	r3, [sp, #24]
 801267c:	9b01      	ldr	r3, [sp, #4]
 801267e:	9307      	str	r3, [sp, #28]
 8012680:	9b00      	ldr	r3, [sp, #0]
 8012682:	9308      	str	r3, [sp, #32]
 8012684:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012686:	9309      	str	r3, [sp, #36]	; 0x24
    arg
  };

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + mp->object_size,
 8012688:	9b03      	ldr	r3, [sp, #12]
 801268a:	685b      	ldr	r3, [r3, #4]
  _thread_memfill((uint8_t *)wsp,
 801268c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801268e:	4413      	add	r3, r2
 8012690:	2255      	movs	r2, #85	; 0x55
 8012692:	4619      	mov	r1, r3
 8012694:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8012696:	f7fd fe7b 	bl	8010390 <_thread_memfill>
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 801269a:	f7ff ff69 	bl	8012570 <chSysLock.lto_priv.330>
  tp = chThdCreateSuspendedI(&td);
 801269e:	ab04      	add	r3, sp, #16
 80126a0:	4618      	mov	r0, r3
 80126a2:	f7fd fe8d 	bl	80103c0 <chThdCreateSuspendedI>
 80126a6:	900a      	str	r0, [sp, #40]	; 0x28
  tp->flags = CH_FLAG_MODE_MPOOL;
 80126a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80126aa:	2202      	movs	r2, #2
 80126ac:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  tp->mpool = mp;
 80126b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80126b2:	9a03      	ldr	r2, [sp, #12]
 80126b4:	641a      	str	r2, [r3, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 80126b6:	2100      	movs	r1, #0
 80126b8:	980a      	ldr	r0, [sp, #40]	; 0x28
 80126ba:	f7fd fba1 	bl	800fe00 <chSchWakeupS>
  chSysUnlock();
 80126be:	f7ff ff5f 	bl	8012580 <chSysUnlock.lto_priv.306>

  return tp;
 80126c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
}
 80126c4:	4618      	mov	r0, r3
 80126c6:	b00d      	add	sp, #52	; 0x34
 80126c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80126cc:	08016f40 	.word	0x08016f40

080126d0 <port_lock.lto_priv.405>:
static inline void port_lock(void) {
 80126d0:	b082      	sub	sp, #8
 80126d2:	2320      	movs	r3, #32
 80126d4:	9301      	str	r3, [sp, #4]
 80126d6:	9b01      	ldr	r3, [sp, #4]
 80126d8:	f383 8811 	msr	BASEPRI, r3
}
 80126dc:	b002      	add	sp, #8
 80126de:	4770      	bx	lr

080126e0 <port_unlock.lto_priv.374>:
static inline void port_unlock(void) {
 80126e0:	b082      	sub	sp, #8
 80126e2:	2300      	movs	r3, #0
 80126e4:	9301      	str	r3, [sp, #4]
 80126e6:	9b01      	ldr	r3, [sp, #4]
 80126e8:	f383 8811 	msr	BASEPRI, r3
}
 80126ec:	b002      	add	sp, #8
 80126ee:	4770      	bx	lr

080126f0 <queue_init.lto_priv.467>:
static inline void queue_init(threads_queue_t *tqp) {
 80126f0:	b082      	sub	sp, #8
 80126f2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80126f4:	9b01      	ldr	r3, [sp, #4]
 80126f6:	9a01      	ldr	r2, [sp, #4]
 80126f8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80126fa:	9b01      	ldr	r3, [sp, #4]
 80126fc:	9a01      	ldr	r2, [sp, #4]
 80126fe:	605a      	str	r2, [r3, #4]
}
 8012700:	b002      	add	sp, #8
 8012702:	4770      	bx	lr
	...

08012710 <chSysLock.lto_priv.331>:
static inline void chSysLock(void) {
 8012710:	b508      	push	{r3, lr}
  port_lock();
 8012712:	f7ff ffdd 	bl	80126d0 <port_lock.lto_priv.405>
  _dbg_check_lock();
 8012716:	f7fc fdd3 	bl	800f2c0 <_dbg_check_lock>
}
 801271a:	bd08      	pop	{r3, pc}
 801271c:	0000      	movs	r0, r0
	...

08012720 <chSysUnlock.lto_priv.307>:
static inline void chSysUnlock(void) {
 8012720:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8012722:	f7fc fde5 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8012726:	4b09      	ldr	r3, [pc, #36]	; (801274c <chSysUnlock.lto_priv.307+0x2c>)
 8012728:	681b      	ldr	r3, [r3, #0]
 801272a:	4a08      	ldr	r2, [pc, #32]	; (801274c <chSysUnlock.lto_priv.307+0x2c>)
 801272c:	4293      	cmp	r3, r2
 801272e:	d00a      	beq.n	8012746 <chSysUnlock.lto_priv.307+0x26>
 8012730:	4b06      	ldr	r3, [pc, #24]	; (801274c <chSysUnlock.lto_priv.307+0x2c>)
 8012732:	699b      	ldr	r3, [r3, #24]
 8012734:	689a      	ldr	r2, [r3, #8]
 8012736:	4b05      	ldr	r3, [pc, #20]	; (801274c <chSysUnlock.lto_priv.307+0x2c>)
 8012738:	681b      	ldr	r3, [r3, #0]
 801273a:	689b      	ldr	r3, [r3, #8]
 801273c:	429a      	cmp	r2, r3
 801273e:	d202      	bcs.n	8012746 <chSysUnlock.lto_priv.307+0x26>
 8012740:	4803      	ldr	r0, [pc, #12]	; (8012750 <chSysUnlock.lto_priv.307+0x30>)
 8012742:	f7fc fc4d 	bl	800efe0 <chSysHalt>
  port_unlock();
 8012746:	f7ff ffcb 	bl	80126e0 <port_unlock.lto_priv.374>
}
 801274a:	bd08      	pop	{r3, pc}
 801274c:	20001090 	.word	0x20001090
 8012750:	08016f6c 	.word	0x08016f6c
	...

08012760 <chThdQueueObjectInit.lto_priv.459>:
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8012760:	b500      	push	{lr}
 8012762:	b083      	sub	sp, #12
 8012764:	9001      	str	r0, [sp, #4]
  queue_init(tqp);
 8012766:	9801      	ldr	r0, [sp, #4]
 8012768:	f7ff ffc2 	bl	80126f0 <queue_init.lto_priv.467>
}
 801276c:	b003      	add	sp, #12
 801276e:	f85d fb04 	ldr.w	pc, [sp], #4
 8012772:	bf00      	nop
	...

08012780 <chMBGetSizeI>:
static inline size_t chMBGetSizeI(const mailbox_t *mbp) {
 8012780:	b082      	sub	sp, #8
 8012782:	9001      	str	r0, [sp, #4]
  return (size_t)(mbp->top - mbp->buffer);
 8012784:	9b01      	ldr	r3, [sp, #4]
 8012786:	685b      	ldr	r3, [r3, #4]
 8012788:	461a      	mov	r2, r3
 801278a:	9b01      	ldr	r3, [sp, #4]
 801278c:	681b      	ldr	r3, [r3, #0]
 801278e:	1ad3      	subs	r3, r2, r3
 8012790:	109b      	asrs	r3, r3, #2
}
 8012792:	4618      	mov	r0, r3
 8012794:	b002      	add	sp, #8
 8012796:	4770      	bx	lr
	...

080127a0 <chMBGetUsedCountI>:
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {
 80127a0:	b500      	push	{lr}
 80127a2:	b083      	sub	sp, #12
 80127a4:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 80127a6:	f7fc fe2b 	bl	800f400 <chDbgCheckClassI>
  return mbp->cnt;
 80127aa:	9b01      	ldr	r3, [sp, #4]
 80127ac:	691b      	ldr	r3, [r3, #16]
}
 80127ae:	4618      	mov	r0, r3
 80127b0:	b003      	add	sp, #12
 80127b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80127b6:	bf00      	nop
	...

080127c0 <chMBGetFreeCountI>:
static inline size_t chMBGetFreeCountI(const mailbox_t *mbp) {
 80127c0:	b510      	push	{r4, lr}
 80127c2:	b082      	sub	sp, #8
 80127c4:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 80127c6:	f7fc fe1b 	bl	800f400 <chDbgCheckClassI>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80127ca:	9801      	ldr	r0, [sp, #4]
 80127cc:	f7ff ffd8 	bl	8012780 <chMBGetSizeI>
 80127d0:	4604      	mov	r4, r0
 80127d2:	9801      	ldr	r0, [sp, #4]
 80127d4:	f7ff ffe4 	bl	80127a0 <chMBGetUsedCountI>
 80127d8:	4603      	mov	r3, r0
 80127da:	1ae3      	subs	r3, r4, r3
}
 80127dc:	4618      	mov	r0, r3
 80127de:	b002      	add	sp, #8
 80127e0:	bd10      	pop	{r4, pc}
 80127e2:	bf00      	nop
	...

080127f0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, size_t n) {
 80127f0:	b500      	push	{lr}
 80127f2:	b085      	sub	sp, #20
 80127f4:	9003      	str	r0, [sp, #12]
 80127f6:	9102      	str	r1, [sp, #8]
 80127f8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (size_t)0));
 80127fa:	9b03      	ldr	r3, [sp, #12]
 80127fc:	2b00      	cmp	r3, #0
 80127fe:	d005      	beq.n	801280c <chMBObjectInit+0x1c>
 8012800:	9b02      	ldr	r3, [sp, #8]
 8012802:	2b00      	cmp	r3, #0
 8012804:	d002      	beq.n	801280c <chMBObjectInit+0x1c>
 8012806:	9b01      	ldr	r3, [sp, #4]
 8012808:	2b00      	cmp	r3, #0
 801280a:	d102      	bne.n	8012812 <chMBObjectInit+0x22>
 801280c:	4812      	ldr	r0, [pc, #72]	; (8012858 <chMBObjectInit+0x68>)
 801280e:	f7fc fbe7 	bl	800efe0 <chSysHalt>

  mbp->buffer = buf;
 8012812:	9b03      	ldr	r3, [sp, #12]
 8012814:	9a02      	ldr	r2, [sp, #8]
 8012816:	601a      	str	r2, [r3, #0]
  mbp->rdptr  = buf;
 8012818:	9b03      	ldr	r3, [sp, #12]
 801281a:	9a02      	ldr	r2, [sp, #8]
 801281c:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
 801281e:	9b03      	ldr	r3, [sp, #12]
 8012820:	9a02      	ldr	r2, [sp, #8]
 8012822:	609a      	str	r2, [r3, #8]
  mbp->top    = &buf[n];
 8012824:	9b01      	ldr	r3, [sp, #4]
 8012826:	009b      	lsls	r3, r3, #2
 8012828:	9a02      	ldr	r2, [sp, #8]
 801282a:	441a      	add	r2, r3
 801282c:	9b03      	ldr	r3, [sp, #12]
 801282e:	605a      	str	r2, [r3, #4]
  mbp->cnt    = (size_t)0;
 8012830:	9b03      	ldr	r3, [sp, #12]
 8012832:	2200      	movs	r2, #0
 8012834:	611a      	str	r2, [r3, #16]
  mbp->reset  = false;
 8012836:	9b03      	ldr	r3, [sp, #12]
 8012838:	2200      	movs	r2, #0
 801283a:	751a      	strb	r2, [r3, #20]
  chThdQueueObjectInit(&mbp->qw);
 801283c:	9b03      	ldr	r3, [sp, #12]
 801283e:	3318      	adds	r3, #24
 8012840:	4618      	mov	r0, r3
 8012842:	f7ff ff8d 	bl	8012760 <chThdQueueObjectInit.lto_priv.459>
  chThdQueueObjectInit(&mbp->qr);
 8012846:	9b03      	ldr	r3, [sp, #12]
 8012848:	3320      	adds	r3, #32
 801284a:	4618      	mov	r0, r3
 801284c:	f7ff ff88 	bl	8012760 <chThdQueueObjectInit.lto_priv.459>
}
 8012850:	b005      	add	sp, #20
 8012852:	f85d fb04 	ldr.w	pc, [sp], #4
 8012856:	bf00      	nop
 8012858:	08016f5c 	.word	0x08016f5c
 801285c:	00000000 	.word	0x00000000

08012860 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8012860:	b500      	push	{lr}
 8012862:	b083      	sub	sp, #12
 8012864:	9001      	str	r0, [sp, #4]

  chSysLock();
 8012866:	f7ff ff53 	bl	8012710 <chSysLock.lto_priv.331>
  chMBResetI(mbp);
 801286a:	9801      	ldr	r0, [sp, #4]
 801286c:	f000 f808 	bl	8012880 <chMBResetI>
  chSchRescheduleS();
 8012870:	f7fd fb1e 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 8012874:	f7ff ff54 	bl	8012720 <chSysUnlock.lto_priv.307>
}
 8012878:	b003      	add	sp, #12
 801287a:	f85d fb04 	ldr.w	pc, [sp], #4
 801287e:	bf00      	nop

08012880 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8012880:	b500      	push	{lr}
 8012882:	b083      	sub	sp, #12
 8012884:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8012886:	f7fc fdbb 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 801288a:	9b01      	ldr	r3, [sp, #4]
 801288c:	2b00      	cmp	r3, #0
 801288e:	d102      	bne.n	8012896 <chMBResetI+0x16>
 8012890:	4810      	ldr	r0, [pc, #64]	; (80128d4 <chMBResetI+0x54>)
 8012892:	f7fc fba5 	bl	800efe0 <chSysHalt>

  mbp->wrptr = mbp->buffer;
 8012896:	9b01      	ldr	r3, [sp, #4]
 8012898:	681a      	ldr	r2, [r3, #0]
 801289a:	9b01      	ldr	r3, [sp, #4]
 801289c:	609a      	str	r2, [r3, #8]
  mbp->rdptr = mbp->buffer;
 801289e:	9b01      	ldr	r3, [sp, #4]
 80128a0:	681a      	ldr	r2, [r3, #0]
 80128a2:	9b01      	ldr	r3, [sp, #4]
 80128a4:	60da      	str	r2, [r3, #12]
  mbp->cnt   = (size_t)0;
 80128a6:	9b01      	ldr	r3, [sp, #4]
 80128a8:	2200      	movs	r2, #0
 80128aa:	611a      	str	r2, [r3, #16]
  mbp->reset = true;
 80128ac:	9b01      	ldr	r3, [sp, #4]
 80128ae:	2201      	movs	r2, #1
 80128b0:	751a      	strb	r2, [r3, #20]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 80128b2:	9b01      	ldr	r3, [sp, #4]
 80128b4:	3318      	adds	r3, #24
 80128b6:	f06f 0101 	mvn.w	r1, #1
 80128ba:	4618      	mov	r0, r3
 80128bc:	f7fe f890 	bl	80109e0 <chThdDequeueAllI>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 80128c0:	9b01      	ldr	r3, [sp, #4]
 80128c2:	3320      	adds	r3, #32
 80128c4:	f06f 0101 	mvn.w	r1, #1
 80128c8:	4618      	mov	r0, r3
 80128ca:	f7fe f889 	bl	80109e0 <chThdDequeueAllI>
}
 80128ce:	b003      	add	sp, #12
 80128d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80128d4:	08016f78 	.word	0x08016f78
	...

080128e0 <chMBPostTimeout>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 80128e0:	b500      	push	{lr}
 80128e2:	b087      	sub	sp, #28
 80128e4:	9003      	str	r0, [sp, #12]
 80128e6:	9102      	str	r1, [sp, #8]
 80128e8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 80128ea:	f7ff ff11 	bl	8012710 <chSysLock.lto_priv.331>
  rdymsg = chMBPostTimeoutS(mbp, msg, timeout);
 80128ee:	9a01      	ldr	r2, [sp, #4]
 80128f0:	9902      	ldr	r1, [sp, #8]
 80128f2:	9803      	ldr	r0, [sp, #12]
 80128f4:	f000 f80c 	bl	8012910 <chMBPostTimeoutS>
 80128f8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 80128fa:	f7ff ff11 	bl	8012720 <chSysUnlock.lto_priv.307>

  return rdymsg;
 80128fe:	9b05      	ldr	r3, [sp, #20]
}
 8012900:	4618      	mov	r0, r3
 8012902:	b007      	add	sp, #28
 8012904:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08012910 <chMBPostTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostTimeoutS(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8012910:	b500      	push	{lr}
 8012912:	b087      	sub	sp, #28
 8012914:	9003      	str	r0, [sp, #12]
 8012916:	9102      	str	r1, [sp, #8]
 8012918:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 801291a:	f7fc fd89 	bl	800f430 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);
 801291e:	9b03      	ldr	r3, [sp, #12]
 8012920:	2b00      	cmp	r3, #0
 8012922:	d102      	bne.n	801292a <chMBPostTimeoutS+0x1a>
 8012924:	481f      	ldr	r0, [pc, #124]	; (80129a4 <chMBPostTimeoutS+0x94>)
 8012926:	f7fc fb5b 	bl	800efe0 <chSysHalt>

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 801292a:	9b03      	ldr	r3, [sp, #12]
 801292c:	7d1b      	ldrb	r3, [r3, #20]
 801292e:	2b00      	cmp	r3, #0
 8012930:	d002      	beq.n	8012938 <chMBPostTimeoutS+0x28>
      return MSG_RESET;
 8012932:	f06f 0301 	mvn.w	r3, #1
 8012936:	e030      	b.n	801299a <chMBPostTimeoutS+0x8a>
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8012938:	9803      	ldr	r0, [sp, #12]
 801293a:	f7ff ff41 	bl	80127c0 <chMBGetFreeCountI>
 801293e:	4603      	mov	r3, r0
 8012940:	2b00      	cmp	r3, #0
 8012942:	d01f      	beq.n	8012984 <chMBPostTimeoutS+0x74>
      *mbp->wrptr++ = msg;
 8012944:	9b03      	ldr	r3, [sp, #12]
 8012946:	689b      	ldr	r3, [r3, #8]
 8012948:	1d19      	adds	r1, r3, #4
 801294a:	9a03      	ldr	r2, [sp, #12]
 801294c:	6091      	str	r1, [r2, #8]
 801294e:	9a02      	ldr	r2, [sp, #8]
 8012950:	601a      	str	r2, [r3, #0]
      if (mbp->wrptr >= mbp->top) {
 8012952:	9b03      	ldr	r3, [sp, #12]
 8012954:	689a      	ldr	r2, [r3, #8]
 8012956:	9b03      	ldr	r3, [sp, #12]
 8012958:	685b      	ldr	r3, [r3, #4]
 801295a:	429a      	cmp	r2, r3
 801295c:	d303      	bcc.n	8012966 <chMBPostTimeoutS+0x56>
        mbp->wrptr = mbp->buffer;
 801295e:	9b03      	ldr	r3, [sp, #12]
 8012960:	681a      	ldr	r2, [r3, #0]
 8012962:	9b03      	ldr	r3, [sp, #12]
 8012964:	609a      	str	r2, [r3, #8]
      }
      mbp->cnt++;
 8012966:	9b03      	ldr	r3, [sp, #12]
 8012968:	691b      	ldr	r3, [r3, #16]
 801296a:	1c5a      	adds	r2, r3, #1
 801296c:	9b03      	ldr	r3, [sp, #12]
 801296e:	611a      	str	r2, [r3, #16]

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8012970:	9b03      	ldr	r3, [sp, #12]
 8012972:	3320      	adds	r3, #32
 8012974:	2100      	movs	r1, #0
 8012976:	4618      	mov	r0, r3
 8012978:	f7fe f81a 	bl	80109b0 <chThdDequeueNextI>
      chSchRescheduleS();
 801297c:	f7fd fa98 	bl	800feb0 <chSchRescheduleS>

      return MSG_OK;
 8012980:	2300      	movs	r3, #0
 8012982:	e00a      	b.n	801299a <chMBPostTimeoutS+0x8a>
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8012984:	9b03      	ldr	r3, [sp, #12]
 8012986:	3318      	adds	r3, #24
 8012988:	9901      	ldr	r1, [sp, #4]
 801298a:	4618      	mov	r0, r3
 801298c:	f7fd fff0 	bl	8010970 <chThdEnqueueTimeoutS>
 8012990:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
 8012992:	9b05      	ldr	r3, [sp, #20]
 8012994:	2b00      	cmp	r3, #0
 8012996:	d0c8      	beq.n	801292a <chMBPostTimeoutS+0x1a>

  return rdymsg;
 8012998:	9b05      	ldr	r3, [sp, #20]
}
 801299a:	4618      	mov	r0, r3
 801299c:	b007      	add	sp, #28
 801299e:	f85d fb04 	ldr.w	pc, [sp], #4
 80129a2:	bf00      	nop
 80129a4:	08016f84 	.word	0x08016f84
	...

080129b0 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 80129b0:	b500      	push	{lr}
 80129b2:	b083      	sub	sp, #12
 80129b4:	9001      	str	r0, [sp, #4]
 80129b6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 80129b8:	f7fc fd22 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 80129bc:	9b01      	ldr	r3, [sp, #4]
 80129be:	2b00      	cmp	r3, #0
 80129c0:	d102      	bne.n	80129c8 <chMBPostI+0x18>
 80129c2:	481a      	ldr	r0, [pc, #104]	; (8012a2c <chMBPostI+0x7c>)
 80129c4:	f7fc fb0c 	bl	800efe0 <chSysHalt>

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 80129c8:	9b01      	ldr	r3, [sp, #4]
 80129ca:	7d1b      	ldrb	r3, [r3, #20]
 80129cc:	2b00      	cmp	r3, #0
 80129ce:	d002      	beq.n	80129d6 <chMBPostI+0x26>
    return MSG_RESET;
 80129d0:	f06f 0301 	mvn.w	r3, #1
 80129d4:	e025      	b.n	8012a22 <chMBPostI+0x72>
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 80129d6:	9801      	ldr	r0, [sp, #4]
 80129d8:	f7ff fef2 	bl	80127c0 <chMBGetFreeCountI>
 80129dc:	4603      	mov	r3, r0
 80129de:	2b00      	cmp	r3, #0
 80129e0:	d01d      	beq.n	8012a1e <chMBPostI+0x6e>
    *mbp->wrptr++ = msg;
 80129e2:	9b01      	ldr	r3, [sp, #4]
 80129e4:	689b      	ldr	r3, [r3, #8]
 80129e6:	1d19      	adds	r1, r3, #4
 80129e8:	9a01      	ldr	r2, [sp, #4]
 80129ea:	6091      	str	r1, [r2, #8]
 80129ec:	9a00      	ldr	r2, [sp, #0]
 80129ee:	601a      	str	r2, [r3, #0]
    if (mbp->wrptr >= mbp->top) {
 80129f0:	9b01      	ldr	r3, [sp, #4]
 80129f2:	689a      	ldr	r2, [r3, #8]
 80129f4:	9b01      	ldr	r3, [sp, #4]
 80129f6:	685b      	ldr	r3, [r3, #4]
 80129f8:	429a      	cmp	r2, r3
 80129fa:	d303      	bcc.n	8012a04 <chMBPostI+0x54>
      mbp->wrptr = mbp->buffer;
 80129fc:	9b01      	ldr	r3, [sp, #4]
 80129fe:	681a      	ldr	r2, [r3, #0]
 8012a00:	9b01      	ldr	r3, [sp, #4]
 8012a02:	609a      	str	r2, [r3, #8]
    }
    mbp->cnt++;
 8012a04:	9b01      	ldr	r3, [sp, #4]
 8012a06:	691b      	ldr	r3, [r3, #16]
 8012a08:	1c5a      	adds	r2, r3, #1
 8012a0a:	9b01      	ldr	r3, [sp, #4]
 8012a0c:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8012a0e:	9b01      	ldr	r3, [sp, #4]
 8012a10:	3320      	adds	r3, #32
 8012a12:	2100      	movs	r1, #0
 8012a14:	4618      	mov	r0, r3
 8012a16:	f7fd ffcb 	bl	80109b0 <chThdDequeueNextI>

    return MSG_OK;
 8012a1a:	2300      	movs	r3, #0
 8012a1c:	e001      	b.n	8012a22 <chMBPostI+0x72>
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
 8012a1e:	f04f 33ff 	mov.w	r3, #4294967295
}
 8012a22:	4618      	mov	r0, r3
 8012a24:	b003      	add	sp, #12
 8012a26:	f85d fb04 	ldr.w	pc, [sp], #4
 8012a2a:	bf00      	nop
 8012a2c:	08016f98 	.word	0x08016f98

08012a30 <chMBPostAheadTimeout>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAheadTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8012a30:	b500      	push	{lr}
 8012a32:	b087      	sub	sp, #28
 8012a34:	9003      	str	r0, [sp, #12]
 8012a36:	9102      	str	r1, [sp, #8]
 8012a38:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8012a3a:	f7ff fe69 	bl	8012710 <chSysLock.lto_priv.331>
  rdymsg = chMBPostAheadTimeoutS(mbp, msg, timeout);
 8012a3e:	9a01      	ldr	r2, [sp, #4]
 8012a40:	9902      	ldr	r1, [sp, #8]
 8012a42:	9803      	ldr	r0, [sp, #12]
 8012a44:	f000 f80c 	bl	8012a60 <chMBPostAheadTimeoutS>
 8012a48:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8012a4a:	f7ff fe69 	bl	8012720 <chSysUnlock.lto_priv.307>

  return rdymsg;
 8012a4e:	9b05      	ldr	r3, [sp, #20]
}
 8012a50:	4618      	mov	r0, r3
 8012a52:	b007      	add	sp, #28
 8012a54:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08012a60 <chMBPostAheadTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadTimeoutS(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8012a60:	b500      	push	{lr}
 8012a62:	b087      	sub	sp, #28
 8012a64:	9003      	str	r0, [sp, #12]
 8012a66:	9102      	str	r1, [sp, #8]
 8012a68:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 8012a6a:	f7fc fce1 	bl	800f430 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);
 8012a6e:	9b03      	ldr	r3, [sp, #12]
 8012a70:	2b00      	cmp	r3, #0
 8012a72:	d102      	bne.n	8012a7a <chMBPostAheadTimeoutS+0x1a>
 8012a74:	4820      	ldr	r0, [pc, #128]	; (8012af8 <chMBPostAheadTimeoutS+0x98>)
 8012a76:	f7fc fab3 	bl	800efe0 <chSysHalt>

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8012a7a:	9b03      	ldr	r3, [sp, #12]
 8012a7c:	7d1b      	ldrb	r3, [r3, #20]
 8012a7e:	2b00      	cmp	r3, #0
 8012a80:	d002      	beq.n	8012a88 <chMBPostAheadTimeoutS+0x28>
      return MSG_RESET;
 8012a82:	f06f 0301 	mvn.w	r3, #1
 8012a86:	e033      	b.n	8012af0 <chMBPostAheadTimeoutS+0x90>
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8012a88:	9803      	ldr	r0, [sp, #12]
 8012a8a:	f7ff fe99 	bl	80127c0 <chMBGetFreeCountI>
 8012a8e:	4603      	mov	r3, r0
 8012a90:	2b00      	cmp	r3, #0
 8012a92:	d022      	beq.n	8012ada <chMBPostAheadTimeoutS+0x7a>
      if (--mbp->rdptr < mbp->buffer) {
 8012a94:	9b03      	ldr	r3, [sp, #12]
 8012a96:	68db      	ldr	r3, [r3, #12]
 8012a98:	1f1a      	subs	r2, r3, #4
 8012a9a:	9b03      	ldr	r3, [sp, #12]
 8012a9c:	60da      	str	r2, [r3, #12]
 8012a9e:	9b03      	ldr	r3, [sp, #12]
 8012aa0:	68da      	ldr	r2, [r3, #12]
 8012aa2:	9b03      	ldr	r3, [sp, #12]
 8012aa4:	681b      	ldr	r3, [r3, #0]
 8012aa6:	429a      	cmp	r2, r3
 8012aa8:	d204      	bcs.n	8012ab4 <chMBPostAheadTimeoutS+0x54>
        mbp->rdptr = mbp->top - 1;
 8012aaa:	9b03      	ldr	r3, [sp, #12]
 8012aac:	685b      	ldr	r3, [r3, #4]
 8012aae:	1f1a      	subs	r2, r3, #4
 8012ab0:	9b03      	ldr	r3, [sp, #12]
 8012ab2:	60da      	str	r2, [r3, #12]
      }
      *mbp->rdptr = msg;
 8012ab4:	9b03      	ldr	r3, [sp, #12]
 8012ab6:	68db      	ldr	r3, [r3, #12]
 8012ab8:	9a02      	ldr	r2, [sp, #8]
 8012aba:	601a      	str	r2, [r3, #0]
      mbp->cnt++;
 8012abc:	9b03      	ldr	r3, [sp, #12]
 8012abe:	691b      	ldr	r3, [r3, #16]
 8012ac0:	1c5a      	adds	r2, r3, #1
 8012ac2:	9b03      	ldr	r3, [sp, #12]
 8012ac4:	611a      	str	r2, [r3, #16]

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8012ac6:	9b03      	ldr	r3, [sp, #12]
 8012ac8:	3320      	adds	r3, #32
 8012aca:	2100      	movs	r1, #0
 8012acc:	4618      	mov	r0, r3
 8012ace:	f7fd ff6f 	bl	80109b0 <chThdDequeueNextI>
      chSchRescheduleS();
 8012ad2:	f7fd f9ed 	bl	800feb0 <chSchRescheduleS>

      return MSG_OK;
 8012ad6:	2300      	movs	r3, #0
 8012ad8:	e00a      	b.n	8012af0 <chMBPostAheadTimeoutS+0x90>
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8012ada:	9b03      	ldr	r3, [sp, #12]
 8012adc:	3318      	adds	r3, #24
 8012ade:	9901      	ldr	r1, [sp, #4]
 8012ae0:	4618      	mov	r0, r3
 8012ae2:	f7fd ff45 	bl	8010970 <chThdEnqueueTimeoutS>
 8012ae6:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
 8012ae8:	9b05      	ldr	r3, [sp, #20]
 8012aea:	2b00      	cmp	r3, #0
 8012aec:	d0c5      	beq.n	8012a7a <chMBPostAheadTimeoutS+0x1a>

  return rdymsg;
 8012aee:	9b05      	ldr	r3, [sp, #20]
}
 8012af0:	4618      	mov	r0, r3
 8012af2:	b007      	add	sp, #28
 8012af4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012af8:	08016fa4 	.word	0x08016fa4
 8012afc:	00000000 	.word	0x00000000

08012b00 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8012b00:	b500      	push	{lr}
 8012b02:	b083      	sub	sp, #12
 8012b04:	9001      	str	r0, [sp, #4]
 8012b06:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8012b08:	f7fc fc7a 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 8012b0c:	9b01      	ldr	r3, [sp, #4]
 8012b0e:	2b00      	cmp	r3, #0
 8012b10:	d102      	bne.n	8012b18 <chMBPostAheadI+0x18>
 8012b12:	481b      	ldr	r0, [pc, #108]	; (8012b80 <chMBPostAheadI+0x80>)
 8012b14:	f7fc fa64 	bl	800efe0 <chSysHalt>

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8012b18:	9b01      	ldr	r3, [sp, #4]
 8012b1a:	7d1b      	ldrb	r3, [r3, #20]
 8012b1c:	2b00      	cmp	r3, #0
 8012b1e:	d002      	beq.n	8012b26 <chMBPostAheadI+0x26>
    return MSG_RESET;
 8012b20:	f06f 0301 	mvn.w	r3, #1
 8012b24:	e028      	b.n	8012b78 <chMBPostAheadI+0x78>
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8012b26:	9801      	ldr	r0, [sp, #4]
 8012b28:	f7ff fe4a 	bl	80127c0 <chMBGetFreeCountI>
 8012b2c:	4603      	mov	r3, r0
 8012b2e:	2b00      	cmp	r3, #0
 8012b30:	d020      	beq.n	8012b74 <chMBPostAheadI+0x74>
    if (--mbp->rdptr < mbp->buffer) {
 8012b32:	9b01      	ldr	r3, [sp, #4]
 8012b34:	68db      	ldr	r3, [r3, #12]
 8012b36:	1f1a      	subs	r2, r3, #4
 8012b38:	9b01      	ldr	r3, [sp, #4]
 8012b3a:	60da      	str	r2, [r3, #12]
 8012b3c:	9b01      	ldr	r3, [sp, #4]
 8012b3e:	68da      	ldr	r2, [r3, #12]
 8012b40:	9b01      	ldr	r3, [sp, #4]
 8012b42:	681b      	ldr	r3, [r3, #0]
 8012b44:	429a      	cmp	r2, r3
 8012b46:	d204      	bcs.n	8012b52 <chMBPostAheadI+0x52>
      mbp->rdptr = mbp->top - 1;
 8012b48:	9b01      	ldr	r3, [sp, #4]
 8012b4a:	685b      	ldr	r3, [r3, #4]
 8012b4c:	1f1a      	subs	r2, r3, #4
 8012b4e:	9b01      	ldr	r3, [sp, #4]
 8012b50:	60da      	str	r2, [r3, #12]
    }
    *mbp->rdptr = msg;
 8012b52:	9b01      	ldr	r3, [sp, #4]
 8012b54:	68db      	ldr	r3, [r3, #12]
 8012b56:	9a00      	ldr	r2, [sp, #0]
 8012b58:	601a      	str	r2, [r3, #0]
    mbp->cnt++;
 8012b5a:	9b01      	ldr	r3, [sp, #4]
 8012b5c:	691b      	ldr	r3, [r3, #16]
 8012b5e:	1c5a      	adds	r2, r3, #1
 8012b60:	9b01      	ldr	r3, [sp, #4]
 8012b62:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8012b64:	9b01      	ldr	r3, [sp, #4]
 8012b66:	3320      	adds	r3, #32
 8012b68:	2100      	movs	r1, #0
 8012b6a:	4618      	mov	r0, r3
 8012b6c:	f7fd ff20 	bl	80109b0 <chThdDequeueNextI>

    return MSG_OK;
 8012b70:	2300      	movs	r3, #0
 8012b72:	e001      	b.n	8012b78 <chMBPostAheadI+0x78>
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
 8012b74:	f04f 33ff 	mov.w	r3, #4294967295
}
 8012b78:	4618      	mov	r0, r3
 8012b7a:	b003      	add	sp, #12
 8012b7c:	f85d fb04 	ldr.w	pc, [sp], #4
 8012b80:	08016fbc 	.word	0x08016fbc
	...

08012b90 <chMBFetchTimeout>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetchTimeout(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 8012b90:	b500      	push	{lr}
 8012b92:	b087      	sub	sp, #28
 8012b94:	9003      	str	r0, [sp, #12]
 8012b96:	9102      	str	r1, [sp, #8]
 8012b98:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8012b9a:	f7ff fdb9 	bl	8012710 <chSysLock.lto_priv.331>
  rdymsg = chMBFetchTimeoutS(mbp, msgp, timeout);
 8012b9e:	9a01      	ldr	r2, [sp, #4]
 8012ba0:	9902      	ldr	r1, [sp, #8]
 8012ba2:	9803      	ldr	r0, [sp, #12]
 8012ba4:	f000 f80c 	bl	8012bc0 <chMBFetchTimeoutS>
 8012ba8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8012baa:	f7ff fdb9 	bl	8012720 <chSysUnlock.lto_priv.307>

  return rdymsg;
 8012bae:	9b05      	ldr	r3, [sp, #20]
}
 8012bb0:	4618      	mov	r0, r3
 8012bb2:	b007      	add	sp, #28
 8012bb4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08012bc0 <chMBFetchTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchTimeoutS(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 8012bc0:	b500      	push	{lr}
 8012bc2:	b087      	sub	sp, #28
 8012bc4:	9003      	str	r0, [sp, #12]
 8012bc6:	9102      	str	r1, [sp, #8]
 8012bc8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 8012bca:	f7fc fc31 	bl	800f430 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8012bce:	9b03      	ldr	r3, [sp, #12]
 8012bd0:	2b00      	cmp	r3, #0
 8012bd2:	d002      	beq.n	8012bda <chMBFetchTimeoutS+0x1a>
 8012bd4:	9b02      	ldr	r3, [sp, #8]
 8012bd6:	2b00      	cmp	r3, #0
 8012bd8:	d102      	bne.n	8012be0 <chMBFetchTimeoutS+0x20>
 8012bda:	4820      	ldr	r0, [pc, #128]	; (8012c5c <chMBFetchTimeoutS+0x9c>)
 8012bdc:	f7fc fa00 	bl	800efe0 <chSysHalt>

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8012be0:	9b03      	ldr	r3, [sp, #12]
 8012be2:	7d1b      	ldrb	r3, [r3, #20]
 8012be4:	2b00      	cmp	r3, #0
 8012be6:	d002      	beq.n	8012bee <chMBFetchTimeoutS+0x2e>
      return MSG_RESET;
 8012be8:	f06f 0301 	mvn.w	r3, #1
 8012bec:	e031      	b.n	8012c52 <chMBFetchTimeoutS+0x92>
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8012bee:	9803      	ldr	r0, [sp, #12]
 8012bf0:	f7ff fdd6 	bl	80127a0 <chMBGetUsedCountI>
 8012bf4:	4603      	mov	r3, r0
 8012bf6:	2b00      	cmp	r3, #0
 8012bf8:	d020      	beq.n	8012c3c <chMBFetchTimeoutS+0x7c>
      *msgp = *mbp->rdptr++;
 8012bfa:	9b03      	ldr	r3, [sp, #12]
 8012bfc:	68db      	ldr	r3, [r3, #12]
 8012bfe:	1d19      	adds	r1, r3, #4
 8012c00:	9a03      	ldr	r2, [sp, #12]
 8012c02:	60d1      	str	r1, [r2, #12]
 8012c04:	681a      	ldr	r2, [r3, #0]
 8012c06:	9b02      	ldr	r3, [sp, #8]
 8012c08:	601a      	str	r2, [r3, #0]
      if (mbp->rdptr >= mbp->top) {
 8012c0a:	9b03      	ldr	r3, [sp, #12]
 8012c0c:	68da      	ldr	r2, [r3, #12]
 8012c0e:	9b03      	ldr	r3, [sp, #12]
 8012c10:	685b      	ldr	r3, [r3, #4]
 8012c12:	429a      	cmp	r2, r3
 8012c14:	d303      	bcc.n	8012c1e <chMBFetchTimeoutS+0x5e>
        mbp->rdptr = mbp->buffer;
 8012c16:	9b03      	ldr	r3, [sp, #12]
 8012c18:	681a      	ldr	r2, [r3, #0]
 8012c1a:	9b03      	ldr	r3, [sp, #12]
 8012c1c:	60da      	str	r2, [r3, #12]
      }
      mbp->cnt--;
 8012c1e:	9b03      	ldr	r3, [sp, #12]
 8012c20:	691b      	ldr	r3, [r3, #16]
 8012c22:	1e5a      	subs	r2, r3, #1
 8012c24:	9b03      	ldr	r3, [sp, #12]
 8012c26:	611a      	str	r2, [r3, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8012c28:	9b03      	ldr	r3, [sp, #12]
 8012c2a:	3318      	adds	r3, #24
 8012c2c:	2100      	movs	r1, #0
 8012c2e:	4618      	mov	r0, r3
 8012c30:	f7fd febe 	bl	80109b0 <chThdDequeueNextI>
      chSchRescheduleS();
 8012c34:	f7fd f93c 	bl	800feb0 <chSchRescheduleS>

      return MSG_OK;
 8012c38:	2300      	movs	r3, #0
 8012c3a:	e00a      	b.n	8012c52 <chMBFetchTimeoutS+0x92>
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8012c3c:	9b03      	ldr	r3, [sp, #12]
 8012c3e:	3320      	adds	r3, #32
 8012c40:	9901      	ldr	r1, [sp, #4]
 8012c42:	4618      	mov	r0, r3
 8012c44:	f7fd fe94 	bl	8010970 <chThdEnqueueTimeoutS>
 8012c48:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
 8012c4a:	9b05      	ldr	r3, [sp, #20]
 8012c4c:	2b00      	cmp	r3, #0
 8012c4e:	d0c7      	beq.n	8012be0 <chMBFetchTimeoutS+0x20>

  return rdymsg;
 8012c50:	9b05      	ldr	r3, [sp, #20]
}
 8012c52:	4618      	mov	r0, r3
 8012c54:	b007      	add	sp, #28
 8012c56:	f85d fb04 	ldr.w	pc, [sp], #4
 8012c5a:	bf00      	nop
 8012c5c:	08016fcc 	.word	0x08016fcc

08012c60 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8012c60:	b500      	push	{lr}
 8012c62:	b083      	sub	sp, #12
 8012c64:	9001      	str	r0, [sp, #4]
 8012c66:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8012c68:	f7fc fbca 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8012c6c:	9b01      	ldr	r3, [sp, #4]
 8012c6e:	2b00      	cmp	r3, #0
 8012c70:	d002      	beq.n	8012c78 <chMBFetchI+0x18>
 8012c72:	9b00      	ldr	r3, [sp, #0]
 8012c74:	2b00      	cmp	r3, #0
 8012c76:	d102      	bne.n	8012c7e <chMBFetchI+0x1e>
 8012c78:	481a      	ldr	r0, [pc, #104]	; (8012ce4 <chMBFetchI+0x84>)
 8012c7a:	f7fc f9b1 	bl	800efe0 <chSysHalt>

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8012c7e:	9b01      	ldr	r3, [sp, #4]
 8012c80:	7d1b      	ldrb	r3, [r3, #20]
 8012c82:	2b00      	cmp	r3, #0
 8012c84:	d002      	beq.n	8012c8c <chMBFetchI+0x2c>
    return MSG_RESET;
 8012c86:	f06f 0301 	mvn.w	r3, #1
 8012c8a:	e026      	b.n	8012cda <chMBFetchI+0x7a>
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8012c8c:	9801      	ldr	r0, [sp, #4]
 8012c8e:	f7ff fd87 	bl	80127a0 <chMBGetUsedCountI>
 8012c92:	4603      	mov	r3, r0
 8012c94:	2b00      	cmp	r3, #0
 8012c96:	d01e      	beq.n	8012cd6 <chMBFetchI+0x76>
    *msgp = *mbp->rdptr++;
 8012c98:	9b01      	ldr	r3, [sp, #4]
 8012c9a:	68db      	ldr	r3, [r3, #12]
 8012c9c:	1d19      	adds	r1, r3, #4
 8012c9e:	9a01      	ldr	r2, [sp, #4]
 8012ca0:	60d1      	str	r1, [r2, #12]
 8012ca2:	681a      	ldr	r2, [r3, #0]
 8012ca4:	9b00      	ldr	r3, [sp, #0]
 8012ca6:	601a      	str	r2, [r3, #0]
    if (mbp->rdptr >= mbp->top) {
 8012ca8:	9b01      	ldr	r3, [sp, #4]
 8012caa:	68da      	ldr	r2, [r3, #12]
 8012cac:	9b01      	ldr	r3, [sp, #4]
 8012cae:	685b      	ldr	r3, [r3, #4]
 8012cb0:	429a      	cmp	r2, r3
 8012cb2:	d303      	bcc.n	8012cbc <chMBFetchI+0x5c>
      mbp->rdptr = mbp->buffer;
 8012cb4:	9b01      	ldr	r3, [sp, #4]
 8012cb6:	681a      	ldr	r2, [r3, #0]
 8012cb8:	9b01      	ldr	r3, [sp, #4]
 8012cba:	60da      	str	r2, [r3, #12]
    }
    mbp->cnt--;
 8012cbc:	9b01      	ldr	r3, [sp, #4]
 8012cbe:	691b      	ldr	r3, [r3, #16]
 8012cc0:	1e5a      	subs	r2, r3, #1
 8012cc2:	9b01      	ldr	r3, [sp, #4]
 8012cc4:	611a      	str	r2, [r3, #16]

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8012cc6:	9b01      	ldr	r3, [sp, #4]
 8012cc8:	3318      	adds	r3, #24
 8012cca:	2100      	movs	r1, #0
 8012ccc:	4618      	mov	r0, r3
 8012cce:	f7fd fe6f 	bl	80109b0 <chThdDequeueNextI>

    return MSG_OK;
 8012cd2:	2300      	movs	r3, #0
 8012cd4:	e001      	b.n	8012cda <chMBFetchI+0x7a>
  }

  /* No message, immediate timeout.*/
  return MSG_TIMEOUT;
 8012cd6:	f04f 33ff 	mov.w	r3, #4294967295
}
 8012cda:	4618      	mov	r0, r3
 8012cdc:	b003      	add	sp, #12
 8012cde:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ce2:	bf00      	nop
 8012ce4:	08016fe0 	.word	0x08016fe0
	...

08012cf0 <port_lock.lto_priv.406>:
static inline void port_lock(void) {
 8012cf0:	b082      	sub	sp, #8
 8012cf2:	2320      	movs	r3, #32
 8012cf4:	9301      	str	r3, [sp, #4]
 8012cf6:	9b01      	ldr	r3, [sp, #4]
 8012cf8:	f383 8811 	msr	BASEPRI, r3
}
 8012cfc:	b002      	add	sp, #8
 8012cfe:	4770      	bx	lr

08012d00 <port_unlock.lto_priv.375>:
static inline void port_unlock(void) {
 8012d00:	b082      	sub	sp, #8
 8012d02:	2300      	movs	r3, #0
 8012d04:	9301      	str	r3, [sp, #4]
 8012d06:	9b01      	ldr	r3, [sp, #4]
 8012d08:	f383 8811 	msr	BASEPRI, r3
}
 8012d0c:	b002      	add	sp, #8
 8012d0e:	4770      	bx	lr

08012d10 <chSysLock.lto_priv.332>:
static inline void chSysLock(void) {
 8012d10:	b508      	push	{r3, lr}
  port_lock();
 8012d12:	f7ff ffed 	bl	8012cf0 <port_lock.lto_priv.406>
  _dbg_check_lock();
 8012d16:	f7fc fad3 	bl	800f2c0 <_dbg_check_lock>
}
 8012d1a:	bd08      	pop	{r3, pc}
 8012d1c:	0000      	movs	r0, r0
	...

08012d20 <chSysUnlock.lto_priv.308>:
static inline void chSysUnlock(void) {
 8012d20:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8012d22:	f7fc fae5 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8012d26:	4b09      	ldr	r3, [pc, #36]	; (8012d4c <chSysUnlock.lto_priv.308+0x2c>)
 8012d28:	681b      	ldr	r3, [r3, #0]
 8012d2a:	4a08      	ldr	r2, [pc, #32]	; (8012d4c <chSysUnlock.lto_priv.308+0x2c>)
 8012d2c:	4293      	cmp	r3, r2
 8012d2e:	d00a      	beq.n	8012d46 <chSysUnlock.lto_priv.308+0x26>
 8012d30:	4b06      	ldr	r3, [pc, #24]	; (8012d4c <chSysUnlock.lto_priv.308+0x2c>)
 8012d32:	699b      	ldr	r3, [r3, #24]
 8012d34:	689a      	ldr	r2, [r3, #8]
 8012d36:	4b05      	ldr	r3, [pc, #20]	; (8012d4c <chSysUnlock.lto_priv.308+0x2c>)
 8012d38:	681b      	ldr	r3, [r3, #0]
 8012d3a:	689b      	ldr	r3, [r3, #8]
 8012d3c:	429a      	cmp	r2, r3
 8012d3e:	d202      	bcs.n	8012d46 <chSysUnlock.lto_priv.308+0x26>
 8012d40:	4803      	ldr	r0, [pc, #12]	; (8012d50 <chSysUnlock.lto_priv.308+0x30>)
 8012d42:	f7fc f94d 	bl	800efe0 <chSysHalt>
  port_unlock();
 8012d46:	f7ff ffdb 	bl	8012d00 <port_unlock.lto_priv.375>
}
 8012d4a:	bd08      	pop	{r3, pc}
 8012d4c:	20001090 	.word	0x20001090
 8012d50:	0801700c 	.word	0x0801700c
	...

08012d60 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 8012d60:	4b03      	ldr	r3, [pc, #12]	; (8012d70 <_core_init+0x10>)
 8012d62:	4a04      	ldr	r2, [pc, #16]	; (8012d74 <_core_init+0x14>)
 8012d64:	601a      	str	r2, [r3, #0]
  ch_memcore.endmem  = __heap_end__;
 8012d66:	4b02      	ldr	r3, [pc, #8]	; (8012d70 <_core_init+0x10>)
 8012d68:	4a03      	ldr	r2, [pc, #12]	; (8012d78 <_core_init+0x18>)
 8012d6a:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8012d6c:	4770      	bx	lr
 8012d6e:	bf00      	nop
 8012d70:	20001918 	.word	0x20001918
 8012d74:	200032c8 	.word	0x200032c8
 8012d78:	20020000 	.word	0x20020000
 8012d7c:	00000000 	.word	0x00000000

08012d80 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
 8012d80:	b500      	push	{lr}
 8012d82:	b087      	sub	sp, #28
 8012d84:	9003      	str	r0, [sp, #12]
 8012d86:	9102      	str	r1, [sp, #8]
 8012d88:	9201      	str	r2, [sp, #4]
  uint8_t *p, *next;

  chDbgCheckClassI();
 8012d8a:	f7fc fb39 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8012d8e:	9b02      	ldr	r3, [sp, #8]
 8012d90:	2b00      	cmp	r3, #0
 8012d92:	d005      	beq.n	8012da0 <chCoreAllocAlignedWithOffsetI+0x20>
 8012d94:	9b02      	ldr	r3, [sp, #8]
 8012d96:	1e5a      	subs	r2, r3, #1
 8012d98:	9b02      	ldr	r3, [sp, #8]
 8012d9a:	4013      	ands	r3, r2
 8012d9c:	2b00      	cmp	r3, #0
 8012d9e:	d002      	beq.n	8012da6 <chCoreAllocAlignedWithOffsetI+0x26>
 8012da0:	4817      	ldr	r0, [pc, #92]	; (8012e00 <chCoreAllocAlignedWithOffsetI+0x80>)
 8012da2:	f7fc f91d 	bl	800efe0 <chSysHalt>

  size = MEM_ALIGN_NEXT(size, align);
 8012da6:	9a02      	ldr	r2, [sp, #8]
 8012da8:	9b03      	ldr	r3, [sp, #12]
 8012daa:	4413      	add	r3, r2
 8012dac:	1e5a      	subs	r2, r3, #1
 8012dae:	9b02      	ldr	r3, [sp, #8]
 8012db0:	425b      	negs	r3, r3
 8012db2:	4013      	ands	r3, r2
 8012db4:	9303      	str	r3, [sp, #12]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8012db6:	4b13      	ldr	r3, [pc, #76]	; (8012e04 <chCoreAllocAlignedWithOffsetI+0x84>)
 8012db8:	681a      	ldr	r2, [r3, #0]
 8012dba:	9b01      	ldr	r3, [sp, #4]
 8012dbc:	4413      	add	r3, r2
 8012dbe:	461a      	mov	r2, r3
 8012dc0:	9b02      	ldr	r3, [sp, #8]
 8012dc2:	4413      	add	r3, r2
 8012dc4:	1e5a      	subs	r2, r3, #1
 8012dc6:	9b02      	ldr	r3, [sp, #8]
 8012dc8:	425b      	negs	r3, r3
 8012dca:	4013      	ands	r3, r2
 8012dcc:	9305      	str	r3, [sp, #20]
  next = p + size;
 8012dce:	9a05      	ldr	r2, [sp, #20]
 8012dd0:	9b03      	ldr	r3, [sp, #12]
 8012dd2:	4413      	add	r3, r2
 8012dd4:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8012dd6:	4b0b      	ldr	r3, [pc, #44]	; (8012e04 <chCoreAllocAlignedWithOffsetI+0x84>)
 8012dd8:	685b      	ldr	r3, [r3, #4]
 8012dda:	9a04      	ldr	r2, [sp, #16]
 8012ddc:	429a      	cmp	r2, r3
 8012dde:	d804      	bhi.n	8012dea <chCoreAllocAlignedWithOffsetI+0x6a>
 8012de0:	4b08      	ldr	r3, [pc, #32]	; (8012e04 <chCoreAllocAlignedWithOffsetI+0x84>)
 8012de2:	681b      	ldr	r3, [r3, #0]
 8012de4:	9a04      	ldr	r2, [sp, #16]
 8012de6:	429a      	cmp	r2, r3
 8012de8:	d201      	bcs.n	8012dee <chCoreAllocAlignedWithOffsetI+0x6e>
    return NULL;
 8012dea:	2300      	movs	r3, #0
 8012dec:	e003      	b.n	8012df6 <chCoreAllocAlignedWithOffsetI+0x76>
  }

  ch_memcore.nextmem = next;
 8012dee:	4a05      	ldr	r2, [pc, #20]	; (8012e04 <chCoreAllocAlignedWithOffsetI+0x84>)
 8012df0:	9b04      	ldr	r3, [sp, #16]
 8012df2:	6013      	str	r3, [r2, #0]

  return p;
 8012df4:	9b05      	ldr	r3, [sp, #20]
}
 8012df6:	4618      	mov	r0, r3
 8012df8:	b007      	add	sp, #28
 8012dfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8012dfe:	bf00      	nop
 8012e00:	08016fec 	.word	0x08016fec
 8012e04:	20001918 	.word	0x20001918
	...

08012e10 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8012e10:	b500      	push	{lr}
 8012e12:	b087      	sub	sp, #28
 8012e14:	9003      	str	r0, [sp, #12]
 8012e16:	9102      	str	r1, [sp, #8]
 8012e18:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 8012e1a:	f7ff ff79 	bl	8012d10 <chSysLock.lto_priv.332>
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 8012e1e:	9a01      	ldr	r2, [sp, #4]
 8012e20:	9902      	ldr	r1, [sp, #8]
 8012e22:	9803      	ldr	r0, [sp, #12]
 8012e24:	f7ff ffac 	bl	8012d80 <chCoreAllocAlignedWithOffsetI>
 8012e28:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8012e2a:	f7ff ff79 	bl	8012d20 <chSysUnlock.lto_priv.308>

  return p;
 8012e2e:	9b05      	ldr	r3, [sp, #20]
}
 8012e30:	4618      	mov	r0, r3
 8012e32:	b007      	add	sp, #28
 8012e34:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08012e40 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.endmem - ch_memcore.nextmem);
 8012e40:	4b03      	ldr	r3, [pc, #12]	; (8012e50 <chCoreGetStatusX+0x10>)
 8012e42:	685b      	ldr	r3, [r3, #4]
 8012e44:	461a      	mov	r2, r3
 8012e46:	4b02      	ldr	r3, [pc, #8]	; (8012e50 <chCoreGetStatusX+0x10>)
 8012e48:	681b      	ldr	r3, [r3, #0]
 8012e4a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8012e4c:	4618      	mov	r0, r3
 8012e4e:	4770      	bx	lr
 8012e50:	20001918 	.word	0x20001918
	...

08012e60 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8012e60:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8012e62:	4b06      	ldr	r3, [pc, #24]	; (8012e7c <_heap_init+0x1c>)
 8012e64:	4a06      	ldr	r2, [pc, #24]	; (8012e80 <_heap_init+0x20>)
 8012e66:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8012e68:	4b04      	ldr	r3, [pc, #16]	; (8012e7c <_heap_init+0x1c>)
 8012e6a:	2200      	movs	r2, #0
 8012e6c:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 8012e6e:	4b03      	ldr	r3, [pc, #12]	; (8012e7c <_heap_init+0x1c>)
 8012e70:	2200      	movs	r2, #0
 8012e72:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8012e74:	4803      	ldr	r0, [pc, #12]	; (8012e84 <_heap_init+0x24>)
 8012e76:	f7fe fb5b 	bl	8011530 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 8012e7a:	bd08      	pop	{r3, pc}
 8012e7c:	20001920 	.word	0x20001920
 8012e80:	08012e11 	.word	0x08012e11
 8012e84:	2000192c 	.word	0x2000192c
	...

08012e90 <chHeapObjectInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
 8012e90:	b500      	push	{lr}
 8012e92:	b087      	sub	sp, #28
 8012e94:	9003      	str	r0, [sp, #12]
 8012e96:	9102      	str	r1, [sp, #8]
 8012e98:	9201      	str	r2, [sp, #4]
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 8012e9a:	9b02      	ldr	r3, [sp, #8]
 8012e9c:	3307      	adds	r3, #7
 8012e9e:	f023 0307 	bic.w	r3, r3, #7
 8012ea2:	9305      	str	r3, [sp, #20]

  chDbgCheck((heapp != NULL) && (size > 0U));
 8012ea4:	9b03      	ldr	r3, [sp, #12]
 8012ea6:	2b00      	cmp	r3, #0
 8012ea8:	d002      	beq.n	8012eb0 <chHeapObjectInit+0x20>
 8012eaa:	9b01      	ldr	r3, [sp, #4]
 8012eac:	2b00      	cmp	r3, #0
 8012eae:	d102      	bne.n	8012eb6 <chHeapObjectInit+0x26>
 8012eb0:	4811      	ldr	r0, [pc, #68]	; (8012ef8 <chHeapObjectInit+0x68>)
 8012eb2:	f7fc f895 	bl	800efe0 <chSysHalt>

  /* Adjusting the size in case the initial block was not correctly
     aligned.*/
  /*lint -save -e9033 [10.8] Required cast operations.*/
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
 8012eb6:	9a05      	ldr	r2, [sp, #20]
 8012eb8:	9b02      	ldr	r3, [sp, #8]
 8012eba:	1ad3      	subs	r3, r2, r3
 8012ebc:	461a      	mov	r2, r3
 8012ebe:	9b01      	ldr	r3, [sp, #4]
 8012ec0:	1a9b      	subs	r3, r3, r2
 8012ec2:	9301      	str	r3, [sp, #4]
  /*lint restore*/

  /* Initializing the heap header.*/
  heapp->provider = NULL;
 8012ec4:	9b03      	ldr	r3, [sp, #12]
 8012ec6:	2200      	movs	r2, #0
 8012ec8:	601a      	str	r2, [r3, #0]
  H_NEXT(&heapp->header) = hp;
 8012eca:	9b03      	ldr	r3, [sp, #12]
 8012ecc:	9a05      	ldr	r2, [sp, #20]
 8012ece:	605a      	str	r2, [r3, #4]
  H_PAGES(&heapp->header) = 0;
 8012ed0:	9b03      	ldr	r3, [sp, #12]
 8012ed2:	2200      	movs	r2, #0
 8012ed4:	609a      	str	r2, [r3, #8]
  H_NEXT(hp) = NULL;
 8012ed6:	9b05      	ldr	r3, [sp, #20]
 8012ed8:	2200      	movs	r2, #0
 8012eda:	601a      	str	r2, [r3, #0]
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8012edc:	9b01      	ldr	r3, [sp, #4]
 8012ede:	3b08      	subs	r3, #8
 8012ee0:	08da      	lsrs	r2, r3, #3
 8012ee2:	9b05      	ldr	r3, [sp, #20]
 8012ee4:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->mtx);
 8012ee6:	9b03      	ldr	r3, [sp, #12]
 8012ee8:	330c      	adds	r3, #12
 8012eea:	4618      	mov	r0, r3
 8012eec:	f7fe fb20 	bl	8011530 <chMtxObjectInit>
#else
  chSemObjectInit(&heapp->sem, (cnt_t)1);
#endif
}
 8012ef0:	b007      	add	sp, #28
 8012ef2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ef6:	bf00      	nop
 8012ef8:	08017018 	.word	0x08017018
 8012efc:	00000000 	.word	0x00000000

08012f00 <chHeapAllocAligned>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8012f00:	b500      	push	{lr}
 8012f02:	b08d      	sub	sp, #52	; 0x34
 8012f04:	9003      	str	r0, [sp, #12]
 8012f06:	9102      	str	r1, [sp, #8]
 8012f08:	9201      	str	r2, [sp, #4]
  heap_header_t *qp, *hp, *ahp;
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
 8012f0a:	9b02      	ldr	r3, [sp, #8]
 8012f0c:	2b00      	cmp	r3, #0
 8012f0e:	d008      	beq.n	8012f22 <chHeapAllocAligned+0x22>
 8012f10:	9b01      	ldr	r3, [sp, #4]
 8012f12:	2b00      	cmp	r3, #0
 8012f14:	d005      	beq.n	8012f22 <chHeapAllocAligned+0x22>
 8012f16:	9b01      	ldr	r3, [sp, #4]
 8012f18:	1e5a      	subs	r2, r3, #1
 8012f1a:	9b01      	ldr	r3, [sp, #4]
 8012f1c:	4013      	ands	r3, r2
 8012f1e:	2b00      	cmp	r3, #0
 8012f20:	d002      	beq.n	8012f28 <chHeapAllocAligned+0x28>
 8012f22:	4868      	ldr	r0, [pc, #416]	; (80130c4 <chHeapAllocAligned+0x1c4>)
 8012f24:	f7fc f85c 	bl	800efe0 <chSysHalt>

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
 8012f28:	9b03      	ldr	r3, [sp, #12]
 8012f2a:	2b00      	cmp	r3, #0
 8012f2c:	d101      	bne.n	8012f32 <chHeapAllocAligned+0x32>
    heapp = &default_heap;
 8012f2e:	4b66      	ldr	r3, [pc, #408]	; (80130c8 <chHeapAllocAligned+0x1c8>)
 8012f30:	9303      	str	r3, [sp, #12]
  }

  /* Minimum alignment is constrained by the heap header structure size.*/
  if (align < CH_HEAP_ALIGNMENT) {
 8012f32:	9b01      	ldr	r3, [sp, #4]
 8012f34:	2b07      	cmp	r3, #7
 8012f36:	d801      	bhi.n	8012f3c <chHeapAllocAligned+0x3c>
    align = CH_HEAP_ALIGNMENT;
 8012f38:	2308      	movs	r3, #8
 8012f3a:	9301      	str	r3, [sp, #4]
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8012f3c:	9b02      	ldr	r3, [sp, #8]
 8012f3e:	3307      	adds	r3, #7
 8012f40:	08db      	lsrs	r3, r3, #3
 8012f42:	9309      	str	r3, [sp, #36]	; 0x24

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8012f44:	9b03      	ldr	r3, [sp, #12]
 8012f46:	330c      	adds	r3, #12
 8012f48:	4618      	mov	r0, r3
 8012f4a:	f7fe fb09 	bl	8011560 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 8012f4e:	9b03      	ldr	r3, [sp, #12]
 8012f50:	3304      	adds	r3, #4
 8012f52:	930b      	str	r3, [sp, #44]	; 0x2c
 8012f54:	e08c      	b.n	8013070 <chHeapAllocAligned+0x170>
  while (H_NEXT(qp) != NULL) {

    /* Next free block.*/
    hp = H_NEXT(qp);
 8012f56:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012f58:	681b      	ldr	r3, [r3, #0]
 8012f5a:	930a      	str	r3, [sp, #40]	; 0x28

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8012f5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012f5e:	3308      	adds	r3, #8
 8012f60:	461a      	mov	r2, r3
 8012f62:	9b01      	ldr	r3, [sp, #4]
 8012f64:	4413      	add	r3, r2
 8012f66:	1e5a      	subs	r2, r3, #1
 8012f68:	9b01      	ldr	r3, [sp, #4]
 8012f6a:	425b      	negs	r3, r3
 8012f6c:	4013      	ands	r3, r2
 8012f6e:	3b08      	subs	r3, #8
 8012f70:	9308      	str	r3, [sp, #32]

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8012f72:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012f74:	685b      	ldr	r3, [r3, #4]
 8012f76:	3301      	adds	r3, #1
 8012f78:	00db      	lsls	r3, r3, #3
 8012f7a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8012f7c:	4413      	add	r3, r2
 8012f7e:	9a08      	ldr	r2, [sp, #32]
 8012f80:	429a      	cmp	r2, r3
 8012f82:	d273      	bcs.n	801306c <chHeapAllocAligned+0x16c>
 8012f84:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012f86:	685b      	ldr	r3, [r3, #4]
 8012f88:	3301      	adds	r3, #1
 8012f8a:	00db      	lsls	r3, r3, #3
 8012f8c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8012f8e:	4413      	add	r3, r2
 8012f90:	461a      	mov	r2, r3
 8012f92:	9b08      	ldr	r3, [sp, #32]
 8012f94:	3308      	adds	r3, #8
 8012f96:	1ad3      	subs	r3, r2, r3
 8012f98:	10db      	asrs	r3, r3, #3
 8012f9a:	461a      	mov	r2, r3
 8012f9c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012f9e:	4293      	cmp	r3, r2
 8012fa0:	d864      	bhi.n	801306c <chHeapAllocAligned+0x16c>
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 8012fa2:	9a08      	ldr	r2, [sp, #32]
 8012fa4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012fa6:	429a      	cmp	r2, r3
 8012fa8:	d92d      	bls.n	8013006 <chHeapAllocAligned+0x106>
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
 8012faa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012fac:	685b      	ldr	r3, [r3, #4]
 8012fae:	3301      	adds	r3, #1
 8012fb0:	00db      	lsls	r3, r3, #3
 8012fb2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8012fb4:	4413      	add	r3, r2
 8012fb6:	461a      	mov	r2, r3
 8012fb8:	9b08      	ldr	r3, [sp, #32]
 8012fba:	3308      	adds	r3, #8
 8012fbc:	1ad3      	subs	r3, r2, r3
 8012fbe:	10db      	asrs	r3, r3, #3
 8012fc0:	9306      	str	r3, [sp, #24]
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8012fc2:	9b08      	ldr	r3, [sp, #32]
 8012fc4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8012fc6:	3208      	adds	r2, #8
 8012fc8:	1a9b      	subs	r3, r3, r2
 8012fca:	10db      	asrs	r3, r3, #3
 8012fcc:	461a      	mov	r2, r3
 8012fce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012fd0:	605a      	str	r2, [r3, #4]
        if (bpages > pages) {
 8012fd2:	9a06      	ldr	r2, [sp, #24]
 8012fd4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012fd6:	429a      	cmp	r2, r3
 8012fd8:	d912      	bls.n	8013000 <chHeapAllocAligned+0x100>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 8012fda:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012fdc:	3301      	adds	r3, #1
 8012fde:	00db      	lsls	r3, r3, #3
 8012fe0:	9a08      	ldr	r2, [sp, #32]
 8012fe2:	4413      	add	r3, r2
 8012fe4:	9305      	str	r3, [sp, #20]
          H_PAGES(fp) = (bpages - pages) - 1U;
 8012fe6:	9a06      	ldr	r2, [sp, #24]
 8012fe8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012fea:	1ad3      	subs	r3, r2, r3
 8012fec:	1e5a      	subs	r2, r3, #1
 8012fee:	9b05      	ldr	r3, [sp, #20]
 8012ff0:	605a      	str	r2, [r3, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 8012ff2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012ff4:	681a      	ldr	r2, [r3, #0]
 8012ff6:	9b05      	ldr	r3, [sp, #20]
 8012ff8:	601a      	str	r2, [r3, #0]
          H_NEXT(hp) = fp;
 8012ffa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012ffc:	9a05      	ldr	r2, [sp, #20]
 8012ffe:	601a      	str	r2, [r3, #0]
        }

        hp = ahp;
 8013000:	9b08      	ldr	r3, [sp, #32]
 8013002:	930a      	str	r3, [sp, #40]	; 0x28
 8013004:	e024      	b.n	8013050 <chHeapAllocAligned+0x150>
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 8013006:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013008:	685b      	ldr	r3, [r3, #4]
 801300a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801300c:	429a      	cmp	r2, r3
 801300e:	d104      	bne.n	801301a <chHeapAllocAligned+0x11a>
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 8013010:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013012:	681a      	ldr	r2, [r3, #0]
 8013014:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8013016:	601a      	str	r2, [r3, #0]
 8013018:	e01a      	b.n	8013050 <chHeapAllocAligned+0x150>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 801301a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801301c:	3301      	adds	r3, #1
 801301e:	00db      	lsls	r3, r3, #3
 8013020:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013022:	4413      	add	r3, r2
 8013024:	9307      	str	r3, [sp, #28]
          H_NEXT(fp) = H_NEXT(hp);
 8013026:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013028:	681a      	ldr	r2, [r3, #0]
 801302a:	9b07      	ldr	r3, [sp, #28]
 801302c:	601a      	str	r2, [r3, #0]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 801302e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013030:	685b      	ldr	r3, [r3, #4]
 8013032:	3301      	adds	r3, #1
 8013034:	00db      	lsls	r3, r3, #3
 8013036:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013038:	4413      	add	r3, r2
 801303a:	461a      	mov	r2, r3
 801303c:	9b07      	ldr	r3, [sp, #28]
 801303e:	3308      	adds	r3, #8
 8013040:	1ad3      	subs	r3, r2, r3
 8013042:	10db      	asrs	r3, r3, #3
 8013044:	461a      	mov	r2, r3
 8013046:	9b07      	ldr	r3, [sp, #28]
 8013048:	605a      	str	r2, [r3, #4]
          H_NEXT(qp) = fp;
 801304a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801304c:	9a07      	ldr	r2, [sp, #28]
 801304e:	601a      	str	r2, [r3, #0]
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 8013050:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013052:	9a02      	ldr	r2, [sp, #8]
 8013054:	605a      	str	r2, [r3, #4]
      H_HEAP(hp) = heapp;
 8013056:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013058:	9a03      	ldr	r2, [sp, #12]
 801305a:	601a      	str	r2, [r3, #0]

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 801305c:	9b03      	ldr	r3, [sp, #12]
 801305e:	330c      	adds	r3, #12
 8013060:	4618      	mov	r0, r3
 8013062:	f7fe fb4d 	bl	8011700 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 8013066:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013068:	3308      	adds	r3, #8
 801306a:	e026      	b.n	80130ba <chHeapAllocAligned+0x1ba>
      /*lint -restore*/
    }

    /* Next in the free blocks list.*/
    qp = hp;
 801306c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801306e:	930b      	str	r3, [sp, #44]	; 0x2c
  while (H_NEXT(qp) != NULL) {
 8013070:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8013072:	681b      	ldr	r3, [r3, #0]
 8013074:	2b00      	cmp	r3, #0
 8013076:	f47f af6e 	bne.w	8012f56 <chHeapAllocAligned+0x56>
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 801307a:	9b03      	ldr	r3, [sp, #12]
 801307c:	330c      	adds	r3, #12
 801307e:	4618      	mov	r0, r3
 8013080:	f7fe fb3e 	bl	8011700 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 8013084:	9b03      	ldr	r3, [sp, #12]
 8013086:	681b      	ldr	r3, [r3, #0]
 8013088:	2b00      	cmp	r3, #0
 801308a:	d015      	beq.n	80130b8 <chHeapAllocAligned+0x1b8>
    ahp = heapp->provider(pages * CH_HEAP_ALIGNMENT,
 801308c:	9b03      	ldr	r3, [sp, #12]
 801308e:	681b      	ldr	r3, [r3, #0]
 8013090:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8013092:	00d0      	lsls	r0, r2, #3
 8013094:	2208      	movs	r2, #8
 8013096:	9901      	ldr	r1, [sp, #4]
 8013098:	4798      	blx	r3
 801309a:	9008      	str	r0, [sp, #32]
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
 801309c:	9b08      	ldr	r3, [sp, #32]
 801309e:	2b00      	cmp	r3, #0
 80130a0:	d00a      	beq.n	80130b8 <chHeapAllocAligned+0x1b8>
      hp = ahp - 1U;
 80130a2:	9b08      	ldr	r3, [sp, #32]
 80130a4:	3b08      	subs	r3, #8
 80130a6:	930a      	str	r3, [sp, #40]	; 0x28
      H_HEAP(hp) = heapp;
 80130a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80130aa:	9a03      	ldr	r2, [sp, #12]
 80130ac:	601a      	str	r2, [r3, #0]
      H_SIZE(hp) = size;
 80130ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80130b0:	9a02      	ldr	r2, [sp, #8]
 80130b2:	605a      	str	r2, [r3, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)ahp;
 80130b4:	9b08      	ldr	r3, [sp, #32]
 80130b6:	e000      	b.n	80130ba <chHeapAllocAligned+0x1ba>
      /*lint -restore*/
    }
  }

  return NULL;
 80130b8:	2300      	movs	r3, #0
}
 80130ba:	4618      	mov	r0, r3
 80130bc:	b00d      	add	sp, #52	; 0x34
 80130be:	f85d fb04 	ldr.w	pc, [sp], #4
 80130c2:	bf00      	nop
 80130c4:	0801702c 	.word	0x0801702c
 80130c8:	20001920 	.word	0x20001920
 80130cc:	00000000 	.word	0x00000000

080130d0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80130d0:	b500      	push	{lr}
 80130d2:	b087      	sub	sp, #28
 80130d4:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 80130d6:	9b01      	ldr	r3, [sp, #4]
 80130d8:	2b00      	cmp	r3, #0
 80130da:	d004      	beq.n	80130e6 <chHeapFree+0x16>
 80130dc:	9b01      	ldr	r3, [sp, #4]
 80130de:	f003 0307 	and.w	r3, r3, #7
 80130e2:	2b00      	cmp	r3, #0
 80130e4:	d002      	beq.n	80130ec <chHeapFree+0x1c>
 80130e6:	483d      	ldr	r0, [pc, #244]	; (80131dc <chHeapFree+0x10c>)
 80130e8:	f7fb ff7a 	bl	800efe0 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 80130ec:	9b01      	ldr	r3, [sp, #4]
 80130ee:	3b08      	subs	r3, #8
 80130f0:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 80130f2:	9b04      	ldr	r3, [sp, #16]
 80130f4:	681b      	ldr	r3, [r3, #0]
 80130f6:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 80130f8:	9b03      	ldr	r3, [sp, #12]
 80130fa:	3304      	adds	r3, #4
 80130fc:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80130fe:	9b04      	ldr	r3, [sp, #16]
 8013100:	685b      	ldr	r3, [r3, #4]
 8013102:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8013104:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8013106:	9b04      	ldr	r3, [sp, #16]
 8013108:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 801310a:	9b03      	ldr	r3, [sp, #12]
 801310c:	330c      	adds	r3, #12
 801310e:	4618      	mov	r0, r3
 8013110:	f7fe fa26 	bl	8011560 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8013114:	9a04      	ldr	r2, [sp, #16]
 8013116:	9b05      	ldr	r3, [sp, #20]
 8013118:	429a      	cmp	r2, r3
 801311a:	d30b      	bcc.n	8013134 <chHeapFree+0x64>
 801311c:	9b05      	ldr	r3, [sp, #20]
 801311e:	685b      	ldr	r3, [r3, #4]
 8013120:	3301      	adds	r3, #1
 8013122:	00db      	lsls	r3, r3, #3
 8013124:	9a05      	ldr	r2, [sp, #20]
 8013126:	4413      	add	r3, r2
 8013128:	9a04      	ldr	r2, [sp, #16]
 801312a:	429a      	cmp	r2, r3
 801312c:	d202      	bcs.n	8013134 <chHeapFree+0x64>
 801312e:	482b      	ldr	r0, [pc, #172]	; (80131dc <chHeapFree+0x10c>)
 8013130:	f7fb ff56 	bl	800efe0 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8013134:	9b03      	ldr	r3, [sp, #12]
 8013136:	3304      	adds	r3, #4
 8013138:	9a05      	ldr	r2, [sp, #20]
 801313a:	429a      	cmp	r2, r3
 801313c:	d003      	beq.n	8013146 <chHeapFree+0x76>
 801313e:	9a04      	ldr	r2, [sp, #16]
 8013140:	9b05      	ldr	r3, [sp, #20]
 8013142:	429a      	cmp	r2, r3
 8013144:	d942      	bls.n	80131cc <chHeapFree+0xfc>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8013146:	9b05      	ldr	r3, [sp, #20]
 8013148:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 801314a:	2b00      	cmp	r3, #0
 801314c:	d004      	beq.n	8013158 <chHeapFree+0x88>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 801314e:	9b05      	ldr	r3, [sp, #20]
 8013150:	681b      	ldr	r3, [r3, #0]
 8013152:	9a04      	ldr	r2, [sp, #16]
 8013154:	429a      	cmp	r2, r3
 8013156:	d239      	bcs.n	80131cc <chHeapFree+0xfc>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8013158:	9b05      	ldr	r3, [sp, #20]
 801315a:	681a      	ldr	r2, [r3, #0]
 801315c:	9b04      	ldr	r3, [sp, #16]
 801315e:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 8013160:	9b05      	ldr	r3, [sp, #20]
 8013162:	9a04      	ldr	r2, [sp, #16]
 8013164:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8013166:	9b04      	ldr	r3, [sp, #16]
 8013168:	685b      	ldr	r3, [r3, #4]
 801316a:	3301      	adds	r3, #1
 801316c:	00db      	lsls	r3, r3, #3
 801316e:	9a04      	ldr	r2, [sp, #16]
 8013170:	441a      	add	r2, r3
 8013172:	9b04      	ldr	r3, [sp, #16]
 8013174:	681b      	ldr	r3, [r3, #0]
 8013176:	429a      	cmp	r2, r3
 8013178:	d10d      	bne.n	8013196 <chHeapFree+0xc6>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 801317a:	9b04      	ldr	r3, [sp, #16]
 801317c:	685a      	ldr	r2, [r3, #4]
 801317e:	9b04      	ldr	r3, [sp, #16]
 8013180:	681b      	ldr	r3, [r3, #0]
 8013182:	685b      	ldr	r3, [r3, #4]
 8013184:	4413      	add	r3, r2
 8013186:	1c5a      	adds	r2, r3, #1
 8013188:	9b04      	ldr	r3, [sp, #16]
 801318a:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 801318c:	9b04      	ldr	r3, [sp, #16]
 801318e:	681b      	ldr	r3, [r3, #0]
 8013190:	681a      	ldr	r2, [r3, #0]
 8013192:	9b04      	ldr	r3, [sp, #16]
 8013194:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 8013196:	9b05      	ldr	r3, [sp, #20]
 8013198:	685b      	ldr	r3, [r3, #4]
 801319a:	3301      	adds	r3, #1
 801319c:	00db      	lsls	r3, r3, #3
 801319e:	9a05      	ldr	r2, [sp, #20]
 80131a0:	4413      	add	r3, r2
 80131a2:	9a04      	ldr	r2, [sp, #16]
 80131a4:	429a      	cmp	r2, r3
 80131a6:	d10b      	bne.n	80131c0 <chHeapFree+0xf0>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80131a8:	9b05      	ldr	r3, [sp, #20]
 80131aa:	685a      	ldr	r2, [r3, #4]
 80131ac:	9b04      	ldr	r3, [sp, #16]
 80131ae:	685b      	ldr	r3, [r3, #4]
 80131b0:	4413      	add	r3, r2
 80131b2:	1c5a      	adds	r2, r3, #1
 80131b4:	9b05      	ldr	r3, [sp, #20]
 80131b6:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 80131b8:	9b04      	ldr	r3, [sp, #16]
 80131ba:	681a      	ldr	r2, [r3, #0]
 80131bc:	9b05      	ldr	r3, [sp, #20]
 80131be:	601a      	str	r2, [r3, #0]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80131c0:	9b03      	ldr	r3, [sp, #12]
 80131c2:	330c      	adds	r3, #12
 80131c4:	4618      	mov	r0, r3
 80131c6:	f7fe fa9b 	bl	8011700 <chMtxUnlock>
 80131ca:	e003      	b.n	80131d4 <chHeapFree+0x104>
    qp = H_NEXT(qp);
 80131cc:	9b05      	ldr	r3, [sp, #20]
 80131ce:	681b      	ldr	r3, [r3, #0]
 80131d0:	9305      	str	r3, [sp, #20]
 80131d2:	e79f      	b.n	8013114 <chHeapFree+0x44>

  return;
}
 80131d4:	b007      	add	sp, #28
 80131d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80131da:	bf00      	nop
 80131dc:	08017040 	.word	0x08017040

080131e0 <chHeapStatus>:
 *                      free free block found space or @p NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 80131e0:	b500      	push	{lr}
 80131e2:	b08b      	sub	sp, #44	; 0x2c
 80131e4:	9003      	str	r0, [sp, #12]
 80131e6:	9102      	str	r1, [sp, #8]
 80131e8:	9201      	str	r2, [sp, #4]
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
 80131ea:	9b03      	ldr	r3, [sp, #12]
 80131ec:	2b00      	cmp	r3, #0
 80131ee:	d101      	bne.n	80131f4 <chHeapStatus+0x14>
    heapp = &default_heap;
 80131f0:	4b20      	ldr	r3, [pc, #128]	; (8013274 <chHeapStatus+0x94>)
 80131f2:	9303      	str	r3, [sp, #12]
  }

  H_LOCK(heapp);
 80131f4:	9b03      	ldr	r3, [sp, #12]
 80131f6:	330c      	adds	r3, #12
 80131f8:	4618      	mov	r0, r3
 80131fa:	f7fe f9b1 	bl	8011560 <chMtxLock>
  tpages = 0U;
 80131fe:	2300      	movs	r3, #0
 8013200:	9307      	str	r3, [sp, #28]
  lpages = 0U;
 8013202:	2300      	movs	r3, #0
 8013204:	9306      	str	r3, [sp, #24]
  n = 0U;
 8013206:	2300      	movs	r3, #0
 8013208:	9308      	str	r3, [sp, #32]
  qp = &heapp->header;
 801320a:	9b03      	ldr	r3, [sp, #12]
 801320c:	3304      	adds	r3, #4
 801320e:	9309      	str	r3, [sp, #36]	; 0x24
 8013210:	e013      	b.n	801323a <chHeapStatus+0x5a>
  while (H_NEXT(qp) != NULL) {
    size_t pages = H_PAGES(H_NEXT(qp));
 8013212:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013214:	681b      	ldr	r3, [r3, #0]
 8013216:	685b      	ldr	r3, [r3, #4]
 8013218:	9305      	str	r3, [sp, #20]

    /* Updating counters.*/
    n++;
 801321a:	9b08      	ldr	r3, [sp, #32]
 801321c:	3301      	adds	r3, #1
 801321e:	9308      	str	r3, [sp, #32]
    tpages += pages;
 8013220:	9a07      	ldr	r2, [sp, #28]
 8013222:	9b05      	ldr	r3, [sp, #20]
 8013224:	4413      	add	r3, r2
 8013226:	9307      	str	r3, [sp, #28]
    if (pages > lpages) {
 8013228:	9a05      	ldr	r2, [sp, #20]
 801322a:	9b06      	ldr	r3, [sp, #24]
 801322c:	429a      	cmp	r2, r3
 801322e:	d901      	bls.n	8013234 <chHeapStatus+0x54>
      lpages = pages;
 8013230:	9b05      	ldr	r3, [sp, #20]
 8013232:	9306      	str	r3, [sp, #24]
    }

    qp = H_NEXT(qp);
 8013234:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013236:	681b      	ldr	r3, [r3, #0]
 8013238:	9309      	str	r3, [sp, #36]	; 0x24
  while (H_NEXT(qp) != NULL) {
 801323a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801323c:	681b      	ldr	r3, [r3, #0]
 801323e:	2b00      	cmp	r3, #0
 8013240:	d1e7      	bne.n	8013212 <chHeapStatus+0x32>
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 8013242:	9b02      	ldr	r3, [sp, #8]
 8013244:	2b00      	cmp	r3, #0
 8013246:	d003      	beq.n	8013250 <chHeapStatus+0x70>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 8013248:	9b07      	ldr	r3, [sp, #28]
 801324a:	00da      	lsls	r2, r3, #3
 801324c:	9b02      	ldr	r3, [sp, #8]
 801324e:	601a      	str	r2, [r3, #0]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 8013250:	9b01      	ldr	r3, [sp, #4]
 8013252:	2b00      	cmp	r3, #0
 8013254:	d003      	beq.n	801325e <chHeapStatus+0x7e>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 8013256:	9b06      	ldr	r3, [sp, #24]
 8013258:	00da      	lsls	r2, r3, #3
 801325a:	9b01      	ldr	r3, [sp, #4]
 801325c:	601a      	str	r2, [r3, #0]
  }
  H_UNLOCK(heapp);
 801325e:	9b03      	ldr	r3, [sp, #12]
 8013260:	330c      	adds	r3, #12
 8013262:	4618      	mov	r0, r3
 8013264:	f7fe fa4c 	bl	8011700 <chMtxUnlock>

  return n;
 8013268:	9b08      	ldr	r3, [sp, #32]
}
 801326a:	4618      	mov	r0, r3
 801326c:	b00b      	add	sp, #44	; 0x2c
 801326e:	f85d fb04 	ldr.w	pc, [sp], #4
 8013272:	bf00      	nop
 8013274:	20001920 	.word	0x20001920
	...

08013280 <port_lock.lto_priv.407>:
static inline void port_lock(void) {
 8013280:	b082      	sub	sp, #8
 8013282:	2320      	movs	r3, #32
 8013284:	9301      	str	r3, [sp, #4]
 8013286:	9b01      	ldr	r3, [sp, #4]
 8013288:	f383 8811 	msr	BASEPRI, r3
}
 801328c:	b002      	add	sp, #8
 801328e:	4770      	bx	lr

08013290 <port_unlock.lto_priv.376>:
static inline void port_unlock(void) {
 8013290:	b082      	sub	sp, #8
 8013292:	2300      	movs	r3, #0
 8013294:	9301      	str	r3, [sp, #4]
 8013296:	9b01      	ldr	r3, [sp, #4]
 8013298:	f383 8811 	msr	BASEPRI, r3
}
 801329c:	b002      	add	sp, #8
 801329e:	4770      	bx	lr

080132a0 <chSysLock.lto_priv.333>:
static inline void chSysLock(void) {
 80132a0:	b508      	push	{r3, lr}
  port_lock();
 80132a2:	f7ff ffed 	bl	8013280 <port_lock.lto_priv.407>
  _dbg_check_lock();
 80132a6:	f7fc f80b 	bl	800f2c0 <_dbg_check_lock>
}
 80132aa:	bd08      	pop	{r3, pc}
 80132ac:	0000      	movs	r0, r0
	...

080132b0 <chSysUnlock.lto_priv.309>:
static inline void chSysUnlock(void) {
 80132b0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80132b2:	f7fc f81d 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80132b6:	4b09      	ldr	r3, [pc, #36]	; (80132dc <chSysUnlock.lto_priv.309+0x2c>)
 80132b8:	681b      	ldr	r3, [r3, #0]
 80132ba:	4a08      	ldr	r2, [pc, #32]	; (80132dc <chSysUnlock.lto_priv.309+0x2c>)
 80132bc:	4293      	cmp	r3, r2
 80132be:	d00a      	beq.n	80132d6 <chSysUnlock.lto_priv.309+0x26>
 80132c0:	4b06      	ldr	r3, [pc, #24]	; (80132dc <chSysUnlock.lto_priv.309+0x2c>)
 80132c2:	699b      	ldr	r3, [r3, #24]
 80132c4:	689a      	ldr	r2, [r3, #8]
 80132c6:	4b05      	ldr	r3, [pc, #20]	; (80132dc <chSysUnlock.lto_priv.309+0x2c>)
 80132c8:	681b      	ldr	r3, [r3, #0]
 80132ca:	689b      	ldr	r3, [r3, #8]
 80132cc:	429a      	cmp	r2, r3
 80132ce:	d202      	bcs.n	80132d6 <chSysUnlock.lto_priv.309+0x26>
 80132d0:	4803      	ldr	r0, [pc, #12]	; (80132e0 <chSysUnlock.lto_priv.309+0x30>)
 80132d2:	f7fb fe85 	bl	800efe0 <chSysHalt>
  port_unlock();
 80132d6:	f7ff ffdb 	bl	8013290 <port_unlock.lto_priv.376>
}
 80132da:	bd08      	pop	{r3, pc}
 80132dc:	20001090 	.word	0x20001090
 80132e0:	08017084 	.word	0x08017084
	...

080132f0 <chPoolAdd>:
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 80132f0:	b500      	push	{lr}
 80132f2:	b083      	sub	sp, #12
 80132f4:	9001      	str	r0, [sp, #4]
 80132f6:	9100      	str	r1, [sp, #0]
  chPoolFree(mp, objp);
 80132f8:	9900      	ldr	r1, [sp, #0]
 80132fa:	9801      	ldr	r0, [sp, #4]
 80132fc:	f000 f8f8 	bl	80134f0 <chPoolFree>
}
 8013300:	b003      	add	sp, #12
 8013302:	f85d fb04 	ldr.w	pc, [sp], #4
 8013306:	bf00      	nop
	...

08013310 <chGuardedPoolFreeI>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
static inline void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {
 8013310:	b500      	push	{lr}
 8013312:	b083      	sub	sp, #12
 8013314:	9001      	str	r0, [sp, #4]
 8013316:	9100      	str	r1, [sp, #0]

  chPoolFreeI(&gmp->pool, objp);
 8013318:	9b01      	ldr	r3, [sp, #4]
 801331a:	330c      	adds	r3, #12
 801331c:	9900      	ldr	r1, [sp, #0]
 801331e:	4618      	mov	r0, r3
 8013320:	f000 f8be 	bl	80134a0 <chPoolFreeI>
  chSemSignalI(&gmp->sem);
 8013324:	9b01      	ldr	r3, [sp, #4]
 8013326:	4618      	mov	r0, r3
 8013328:	f7fd ff22 	bl	8011170 <chSemSignalI>
}
 801332c:	b003      	add	sp, #12
 801332e:	f85d fb04 	ldr.w	pc, [sp], #4
 8013332:	bf00      	nop
	...

08013340 <chGuardedPoolAdd>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chGuardedPoolAdd(guarded_memory_pool_t *gmp, void *objp) {
 8013340:	b500      	push	{lr}
 8013342:	b083      	sub	sp, #12
 8013344:	9001      	str	r0, [sp, #4]
 8013346:	9100      	str	r1, [sp, #0]

  chGuardedPoolFree(gmp, objp);
 8013348:	9900      	ldr	r1, [sp, #0]
 801334a:	9801      	ldr	r0, [sp, #4]
 801334c:	f000 f958 	bl	8013600 <chGuardedPoolFree>
}
 8013350:	b003      	add	sp, #12
 8013352:	f85d fb04 	ldr.w	pc, [sp], #4
 8013356:	bf00      	nop
	...

08013360 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8013360:	b500      	push	{lr}
 8013362:	b085      	sub	sp, #20
 8013364:	9003      	str	r0, [sp, #12]
 8013366:	9102      	str	r1, [sp, #8]
 8013368:	9201      	str	r2, [sp, #4]
 801336a:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 801336c:	9b03      	ldr	r3, [sp, #12]
 801336e:	2b00      	cmp	r3, #0
 8013370:	d00e      	beq.n	8013390 <chPoolObjectInitAligned+0x30>
 8013372:	9b02      	ldr	r3, [sp, #8]
 8013374:	2b03      	cmp	r3, #3
 8013376:	d90b      	bls.n	8013390 <chPoolObjectInitAligned+0x30>
 8013378:	9b01      	ldr	r3, [sp, #4]
 801337a:	2b03      	cmp	r3, #3
 801337c:	d908      	bls.n	8013390 <chPoolObjectInitAligned+0x30>
 801337e:	9b01      	ldr	r3, [sp, #4]
 8013380:	2b00      	cmp	r3, #0
 8013382:	d005      	beq.n	8013390 <chPoolObjectInitAligned+0x30>
 8013384:	9b01      	ldr	r3, [sp, #4]
 8013386:	1e5a      	subs	r2, r3, #1
 8013388:	9b01      	ldr	r3, [sp, #4]
 801338a:	4013      	ands	r3, r2
 801338c:	2b00      	cmp	r3, #0
 801338e:	d002      	beq.n	8013396 <chPoolObjectInitAligned+0x36>
 8013390:	4808      	ldr	r0, [pc, #32]	; (80133b4 <chPoolObjectInitAligned+0x54>)
 8013392:	f7fb fe25 	bl	800efe0 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8013396:	9b03      	ldr	r3, [sp, #12]
 8013398:	2200      	movs	r2, #0
 801339a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 801339c:	9b03      	ldr	r3, [sp, #12]
 801339e:	9a02      	ldr	r2, [sp, #8]
 80133a0:	605a      	str	r2, [r3, #4]
  mp->align = align;
 80133a2:	9b03      	ldr	r3, [sp, #12]
 80133a4:	9a01      	ldr	r2, [sp, #4]
 80133a6:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 80133a8:	9b03      	ldr	r3, [sp, #12]
 80133aa:	9a00      	ldr	r2, [sp, #0]
 80133ac:	60da      	str	r2, [r3, #12]
}
 80133ae:	b005      	add	sp, #20
 80133b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80133b4:	0801704c 	.word	0x0801704c
	...

080133c0 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 80133c0:	b500      	push	{lr}
 80133c2:	b085      	sub	sp, #20
 80133c4:	9003      	str	r0, [sp, #12]
 80133c6:	9102      	str	r1, [sp, #8]
 80133c8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));
 80133ca:	9b03      	ldr	r3, [sp, #12]
 80133cc:	2b00      	cmp	r3, #0
 80133ce:	d002      	beq.n	80133d6 <chPoolLoadArray+0x16>
 80133d0:	9b01      	ldr	r3, [sp, #4]
 80133d2:	2b00      	cmp	r3, #0
 80133d4:	d10f      	bne.n	80133f6 <chPoolLoadArray+0x36>
 80133d6:	480b      	ldr	r0, [pc, #44]	; (8013404 <chPoolLoadArray+0x44>)
 80133d8:	f7fb fe02 	bl	800efe0 <chSysHalt>
 80133dc:	e00b      	b.n	80133f6 <chPoolLoadArray+0x36>

  while (n != 0U) {
    chPoolAdd(mp, p);
 80133de:	9902      	ldr	r1, [sp, #8]
 80133e0:	9803      	ldr	r0, [sp, #12]
 80133e2:	f7ff ff85 	bl	80132f0 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 80133e6:	9b03      	ldr	r3, [sp, #12]
 80133e8:	685b      	ldr	r3, [r3, #4]
 80133ea:	9a02      	ldr	r2, [sp, #8]
 80133ec:	4413      	add	r3, r2
 80133ee:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 80133f0:	9b01      	ldr	r3, [sp, #4]
 80133f2:	3b01      	subs	r3, #1
 80133f4:	9301      	str	r3, [sp, #4]
  while (n != 0U) {
 80133f6:	9b01      	ldr	r3, [sp, #4]
 80133f8:	2b00      	cmp	r3, #0
 80133fa:	d1f0      	bne.n	80133de <chPoolLoadArray+0x1e>
  }
}
 80133fc:	b005      	add	sp, #20
 80133fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8013402:	bf00      	nop
 8013404:	08017064 	.word	0x08017064
	...

08013410 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 8013410:	b500      	push	{lr}
 8013412:	b085      	sub	sp, #20
 8013414:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
 8013416:	f7fb fff3 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 801341a:	9b01      	ldr	r3, [sp, #4]
 801341c:	2b00      	cmp	r3, #0
 801341e:	d102      	bne.n	8013426 <chPoolAllocI+0x16>
 8013420:	4815      	ldr	r0, [pc, #84]	; (8013478 <chPoolAllocI+0x68>)
 8013422:	f7fb fddd 	bl	800efe0 <chSysHalt>

  objp = mp->next;
 8013426:	9b01      	ldr	r3, [sp, #4]
 8013428:	681b      	ldr	r3, [r3, #0]
 801342a:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 801342c:	9b03      	ldr	r3, [sp, #12]
 801342e:	2b00      	cmp	r3, #0
 8013430:	d005      	beq.n	801343e <chPoolAllocI+0x2e>
    mp->next = mp->next->next;
 8013432:	9b01      	ldr	r3, [sp, #4]
 8013434:	681b      	ldr	r3, [r3, #0]
 8013436:	681a      	ldr	r2, [r3, #0]
 8013438:	9b01      	ldr	r3, [sp, #4]
 801343a:	601a      	str	r2, [r3, #0]
 801343c:	e016      	b.n	801346c <chPoolAllocI+0x5c>
  }
  else if (mp->provider != NULL) {
 801343e:	9b01      	ldr	r3, [sp, #4]
 8013440:	68db      	ldr	r3, [r3, #12]
 8013442:	2b00      	cmp	r3, #0
 8013444:	d012      	beq.n	801346c <chPoolAllocI+0x5c>
    objp = mp->provider(mp->object_size, mp->align);
 8013446:	9b01      	ldr	r3, [sp, #4]
 8013448:	68db      	ldr	r3, [r3, #12]
 801344a:	9a01      	ldr	r2, [sp, #4]
 801344c:	6850      	ldr	r0, [r2, #4]
 801344e:	9a01      	ldr	r2, [sp, #4]
 8013450:	6892      	ldr	r2, [r2, #8]
 8013452:	4611      	mov	r1, r2
 8013454:	4798      	blx	r3
 8013456:	9003      	str	r0, [sp, #12]

    chDbgAssert(MEM_IS_ALIGNED(objp, mp->align),
 8013458:	9b01      	ldr	r3, [sp, #4]
 801345a:	689b      	ldr	r3, [r3, #8]
 801345c:	1e5a      	subs	r2, r3, #1
 801345e:	9b03      	ldr	r3, [sp, #12]
 8013460:	4013      	ands	r3, r2
 8013462:	2b00      	cmp	r3, #0
 8013464:	d002      	beq.n	801346c <chPoolAllocI+0x5c>
 8013466:	4804      	ldr	r0, [pc, #16]	; (8013478 <chPoolAllocI+0x68>)
 8013468:	f7fb fdba 	bl	800efe0 <chSysHalt>
                "returned object not aligned");
  }
  /*lint -restore*/

  return objp;
 801346c:	9b03      	ldr	r3, [sp, #12]
}
 801346e:	4618      	mov	r0, r3
 8013470:	b005      	add	sp, #20
 8013472:	f85d fb04 	ldr.w	pc, [sp], #4
 8013476:	bf00      	nop
 8013478:	08017074 	.word	0x08017074
 801347c:	00000000 	.word	0x00000000

08013480 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8013480:	b500      	push	{lr}
 8013482:	b085      	sub	sp, #20
 8013484:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
 8013486:	f7ff ff0b 	bl	80132a0 <chSysLock.lto_priv.333>
  objp = chPoolAllocI(mp);
 801348a:	9801      	ldr	r0, [sp, #4]
 801348c:	f7ff ffc0 	bl	8013410 <chPoolAllocI>
 8013490:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8013492:	f7ff ff0d 	bl	80132b0 <chSysUnlock.lto_priv.309>

  return objp;
 8013496:	9b03      	ldr	r3, [sp, #12]
}
 8013498:	4618      	mov	r0, r3
 801349a:	b005      	add	sp, #20
 801349c:	f85d fb04 	ldr.w	pc, [sp], #4

080134a0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 80134a0:	b500      	push	{lr}
 80134a2:	b085      	sub	sp, #20
 80134a4:	9001      	str	r0, [sp, #4]
 80134a6:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 80134a8:	9b00      	ldr	r3, [sp, #0]
 80134aa:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 80134ac:	f7fb ffa8 	bl	800f400 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 80134b0:	9b01      	ldr	r3, [sp, #4]
 80134b2:	2b00      	cmp	r3, #0
 80134b4:	d009      	beq.n	80134ca <chPoolFreeI+0x2a>
 80134b6:	9b00      	ldr	r3, [sp, #0]
 80134b8:	2b00      	cmp	r3, #0
 80134ba:	d006      	beq.n	80134ca <chPoolFreeI+0x2a>
 80134bc:	9b01      	ldr	r3, [sp, #4]
 80134be:	689b      	ldr	r3, [r3, #8]
 80134c0:	1e5a      	subs	r2, r3, #1
 80134c2:	9b00      	ldr	r3, [sp, #0]
 80134c4:	4013      	ands	r3, r2
 80134c6:	2b00      	cmp	r3, #0
 80134c8:	d002      	beq.n	80134d0 <chPoolFreeI+0x30>
 80134ca:	4806      	ldr	r0, [pc, #24]	; (80134e4 <chPoolFreeI+0x44>)
 80134cc:	f7fb fd88 	bl	800efe0 <chSysHalt>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 80134d0:	9b01      	ldr	r3, [sp, #4]
 80134d2:	681a      	ldr	r2, [r3, #0]
 80134d4:	9b03      	ldr	r3, [sp, #12]
 80134d6:	601a      	str	r2, [r3, #0]
  mp->next = php;
 80134d8:	9b01      	ldr	r3, [sp, #4]
 80134da:	9a03      	ldr	r2, [sp, #12]
 80134dc:	601a      	str	r2, [r3, #0]
}
 80134de:	b005      	add	sp, #20
 80134e0:	f85d fb04 	ldr.w	pc, [sp], #4
 80134e4:	08017090 	.word	0x08017090
	...

080134f0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 80134f0:	b500      	push	{lr}
 80134f2:	b083      	sub	sp, #12
 80134f4:	9001      	str	r0, [sp, #4]
 80134f6:	9100      	str	r1, [sp, #0]

  chSysLock();
 80134f8:	f7ff fed2 	bl	80132a0 <chSysLock.lto_priv.333>
  chPoolFreeI(mp, objp);
 80134fc:	9900      	ldr	r1, [sp, #0]
 80134fe:	9801      	ldr	r0, [sp, #4]
 8013500:	f7ff ffce 	bl	80134a0 <chPoolFreeI>
  chSysUnlock();
 8013504:	f7ff fed4 	bl	80132b0 <chSysUnlock.lto_priv.309>
}
 8013508:	b003      	add	sp, #12
 801350a:	f85d fb04 	ldr.w	pc, [sp], #4
 801350e:	bf00      	nop

08013510 <chGuardedPoolObjectInitAligned>:
 *
 * @init
 */
void chGuardedPoolObjectInitAligned(guarded_memory_pool_t *gmp,
                                    size_t size,
                                    unsigned align) {
 8013510:	b500      	push	{lr}
 8013512:	b085      	sub	sp, #20
 8013514:	9003      	str	r0, [sp, #12]
 8013516:	9102      	str	r1, [sp, #8]
 8013518:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(&gmp->pool, size, align, NULL);
 801351a:	9b03      	ldr	r3, [sp, #12]
 801351c:	f103 000c 	add.w	r0, r3, #12
 8013520:	2300      	movs	r3, #0
 8013522:	9a01      	ldr	r2, [sp, #4]
 8013524:	9902      	ldr	r1, [sp, #8]
 8013526:	f7ff ff1b 	bl	8013360 <chPoolObjectInitAligned>
  chSemObjectInit(&gmp->sem, (cnt_t)0);
 801352a:	9b03      	ldr	r3, [sp, #12]
 801352c:	2100      	movs	r1, #0
 801352e:	4618      	mov	r0, r3
 8013530:	f7fd fc76 	bl	8010e20 <chSemObjectInit>
}
 8013534:	b005      	add	sp, #20
 8013536:	f85d fb04 	ldr.w	pc, [sp], #4
 801353a:	bf00      	nop
 801353c:	0000      	movs	r0, r0
	...

08013540 <chGuardedPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
 8013540:	b500      	push	{lr}
 8013542:	b085      	sub	sp, #20
 8013544:	9003      	str	r0, [sp, #12]
 8013546:	9102      	str	r1, [sp, #8]
 8013548:	9201      	str	r2, [sp, #4]

  chDbgCheck((gmp != NULL) && (n != 0U));
 801354a:	9b03      	ldr	r3, [sp, #12]
 801354c:	2b00      	cmp	r3, #0
 801354e:	d002      	beq.n	8013556 <chGuardedPoolLoadArray+0x16>
 8013550:	9b01      	ldr	r3, [sp, #4]
 8013552:	2b00      	cmp	r3, #0
 8013554:	d10f      	bne.n	8013576 <chGuardedPoolLoadArray+0x36>
 8013556:	480b      	ldr	r0, [pc, #44]	; (8013584 <chGuardedPoolLoadArray+0x44>)
 8013558:	f7fb fd42 	bl	800efe0 <chSysHalt>
 801355c:	e00b      	b.n	8013576 <chGuardedPoolLoadArray+0x36>

  while (n != 0U) {
    chGuardedPoolAdd(gmp, p);
 801355e:	9902      	ldr	r1, [sp, #8]
 8013560:	9803      	ldr	r0, [sp, #12]
 8013562:	f7ff feed 	bl	8013340 <chGuardedPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8013566:	9b03      	ldr	r3, [sp, #12]
 8013568:	691b      	ldr	r3, [r3, #16]
 801356a:	9a02      	ldr	r2, [sp, #8]
 801356c:	4413      	add	r3, r2
 801356e:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 8013570:	9b01      	ldr	r3, [sp, #4]
 8013572:	3b01      	subs	r3, #1
 8013574:	9301      	str	r3, [sp, #4]
  while (n != 0U) {
 8013576:	9b01      	ldr	r3, [sp, #4]
 8013578:	2b00      	cmp	r3, #0
 801357a:	d1f0      	bne.n	801355e <chGuardedPoolLoadArray+0x1e>
  }
}
 801357c:	b005      	add	sp, #20
 801357e:	f85d fb04 	ldr.w	pc, [sp], #4
 8013582:	bf00      	nop
 8013584:	0801709c 	.word	0x0801709c
	...

08013590 <chGuardedPoolAllocTimeoutS>:
 * @retval NULL         if the operation timed out.
 *
 * @sclass
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 sysinterval_t timeout) {
 8013590:	b500      	push	{lr}
 8013592:	b085      	sub	sp, #20
 8013594:	9001      	str	r0, [sp, #4]
 8013596:	9100      	str	r1, [sp, #0]
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
 8013598:	9b01      	ldr	r3, [sp, #4]
 801359a:	9900      	ldr	r1, [sp, #0]
 801359c:	4618      	mov	r0, r3
 801359e:	f7fd fd3f 	bl	8011020 <chSemWaitTimeoutS>
 80135a2:	9003      	str	r0, [sp, #12]
  if (msg != MSG_OK) {
 80135a4:	9b03      	ldr	r3, [sp, #12]
 80135a6:	2b00      	cmp	r3, #0
 80135a8:	d001      	beq.n	80135ae <chGuardedPoolAllocTimeoutS+0x1e>
    return NULL;
 80135aa:	2300      	movs	r3, #0
 80135ac:	e005      	b.n	80135ba <chGuardedPoolAllocTimeoutS+0x2a>
  }

  return chPoolAllocI(&gmp->pool);
 80135ae:	9b01      	ldr	r3, [sp, #4]
 80135b0:	330c      	adds	r3, #12
 80135b2:	4618      	mov	r0, r3
 80135b4:	f7ff ff2c 	bl	8013410 <chPoolAllocI>
 80135b8:	4603      	mov	r3, r0
}
 80135ba:	4618      	mov	r0, r3
 80135bc:	b005      	add	sp, #20
 80135be:	f85d fb04 	ldr.w	pc, [sp], #4
 80135c2:	bf00      	nop
	...

080135d0 <chGuardedPoolAllocTimeout>:
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
                                sysinterval_t timeout) {
 80135d0:	b500      	push	{lr}
 80135d2:	b085      	sub	sp, #20
 80135d4:	9001      	str	r0, [sp, #4]
 80135d6:	9100      	str	r1, [sp, #0]
  void *p;

  chSysLock();
 80135d8:	f7ff fe62 	bl	80132a0 <chSysLock.lto_priv.333>
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
 80135dc:	9900      	ldr	r1, [sp, #0]
 80135de:	9801      	ldr	r0, [sp, #4]
 80135e0:	f7ff ffd6 	bl	8013590 <chGuardedPoolAllocTimeoutS>
 80135e4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 80135e6:	f7ff fe63 	bl	80132b0 <chSysUnlock.lto_priv.309>

  return p;
 80135ea:	9b03      	ldr	r3, [sp, #12]
}
 80135ec:	4618      	mov	r0, r3
 80135ee:	b005      	add	sp, #20
 80135f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08013600 <chGuardedPoolFree>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {
 8013600:	b500      	push	{lr}
 8013602:	b083      	sub	sp, #12
 8013604:	9001      	str	r0, [sp, #4]
 8013606:	9100      	str	r1, [sp, #0]

  chSysLock();
 8013608:	f7ff fe4a 	bl	80132a0 <chSysLock.lto_priv.333>
  chGuardedPoolFreeI(gmp, objp);
 801360c:	9900      	ldr	r1, [sp, #0]
 801360e:	9801      	ldr	r0, [sp, #4]
 8013610:	f7ff fe7e 	bl	8013310 <chGuardedPoolFreeI>
  chSchRescheduleS();
 8013614:	f7fc fc4c 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 8013618:	f7ff fe4a 	bl	80132b0 <chSysUnlock.lto_priv.309>
}
 801361c:	b003      	add	sp, #12
 801361e:	f85d fb04 	ldr.w	pc, [sp], #4
 8013622:	bf00      	nop
	...

08013630 <port_lock.lto_priv.408>:
static inline void port_lock(void) {
 8013630:	b082      	sub	sp, #8
 8013632:	2320      	movs	r3, #32
 8013634:	9301      	str	r3, [sp, #4]
 8013636:	9b01      	ldr	r3, [sp, #4]
 8013638:	f383 8811 	msr	BASEPRI, r3
}
 801363c:	b002      	add	sp, #8
 801363e:	4770      	bx	lr

08013640 <port_unlock.lto_priv.377>:
static inline void port_unlock(void) {
 8013640:	b082      	sub	sp, #8
 8013642:	2300      	movs	r3, #0
 8013644:	9301      	str	r3, [sp, #4]
 8013646:	9b01      	ldr	r3, [sp, #4]
 8013648:	f383 8811 	msr	BASEPRI, r3
}
 801364c:	b002      	add	sp, #8
 801364e:	4770      	bx	lr

08013650 <chSysLock.lto_priv.334>:
static inline void chSysLock(void) {
 8013650:	b508      	push	{r3, lr}
  port_lock();
 8013652:	f7ff ffed 	bl	8013630 <port_lock.lto_priv.408>
  _dbg_check_lock();
 8013656:	f7fb fe33 	bl	800f2c0 <_dbg_check_lock>
}
 801365a:	bd08      	pop	{r3, pc}
 801365c:	0000      	movs	r0, r0
	...

08013660 <chSysUnlock.lto_priv.310>:
static inline void chSysUnlock(void) {
 8013660:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8013662:	f7fb fe45 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8013666:	4b09      	ldr	r3, [pc, #36]	; (801368c <chSysUnlock.lto_priv.310+0x2c>)
 8013668:	681b      	ldr	r3, [r3, #0]
 801366a:	4a08      	ldr	r2, [pc, #32]	; (801368c <chSysUnlock.lto_priv.310+0x2c>)
 801366c:	4293      	cmp	r3, r2
 801366e:	d00a      	beq.n	8013686 <chSysUnlock.lto_priv.310+0x26>
 8013670:	4b06      	ldr	r3, [pc, #24]	; (801368c <chSysUnlock.lto_priv.310+0x2c>)
 8013672:	699b      	ldr	r3, [r3, #24]
 8013674:	689a      	ldr	r2, [r3, #8]
 8013676:	4b05      	ldr	r3, [pc, #20]	; (801368c <chSysUnlock.lto_priv.310+0x2c>)
 8013678:	681b      	ldr	r3, [r3, #0]
 801367a:	689b      	ldr	r3, [r3, #8]
 801367c:	429a      	cmp	r2, r3
 801367e:	d202      	bcs.n	8013686 <chSysUnlock.lto_priv.310+0x26>
 8013680:	4803      	ldr	r0, [pc, #12]	; (8013690 <chSysUnlock.lto_priv.310+0x30>)
 8013682:	f7fb fcad 	bl	800efe0 <chSysHalt>
  port_unlock();
 8013686:	f7ff ffdb 	bl	8013640 <port_unlock.lto_priv.377>
}
 801368a:	bd08      	pop	{r3, pc}
 801368c:	20001090 	.word	0x20001090
 8013690:	080170d4 	.word	0x080170d4
	...

080136a0 <chPipeGetSize>:
static inline size_t chPipeGetSize(const pipe_t *pp) {
 80136a0:	b082      	sub	sp, #8
 80136a2:	9001      	str	r0, [sp, #4]
  return (size_t)(pp->top - pp->buffer);
 80136a4:	9b01      	ldr	r3, [sp, #4]
 80136a6:	685b      	ldr	r3, [r3, #4]
 80136a8:	461a      	mov	r2, r3
 80136aa:	9b01      	ldr	r3, [sp, #4]
 80136ac:	681b      	ldr	r3, [r3, #0]
 80136ae:	1ad3      	subs	r3, r2, r3
}
 80136b0:	4618      	mov	r0, r3
 80136b2:	b002      	add	sp, #8
 80136b4:	4770      	bx	lr
 80136b6:	bf00      	nop
	...

080136c0 <chPipeGetUsedCount>:
static inline size_t chPipeGetUsedCount(const pipe_t *pp) {
 80136c0:	b082      	sub	sp, #8
 80136c2:	9001      	str	r0, [sp, #4]
  return pp->cnt;
 80136c4:	9b01      	ldr	r3, [sp, #4]
 80136c6:	691b      	ldr	r3, [r3, #16]
}
 80136c8:	4618      	mov	r0, r3
 80136ca:	b002      	add	sp, #8
 80136cc:	4770      	bx	lr
 80136ce:	bf00      	nop

080136d0 <chPipeGetFreeCount>:
static inline size_t chPipeGetFreeCount(const pipe_t *pp) {
 80136d0:	b510      	push	{r4, lr}
 80136d2:	b082      	sub	sp, #8
 80136d4:	9001      	str	r0, [sp, #4]
  return chPipeGetSize(pp) - chPipeGetUsedCount(pp);
 80136d6:	9801      	ldr	r0, [sp, #4]
 80136d8:	f7ff ffe2 	bl	80136a0 <chPipeGetSize>
 80136dc:	4604      	mov	r4, r0
 80136de:	9801      	ldr	r0, [sp, #4]
 80136e0:	f7ff ffee 	bl	80136c0 <chPipeGetUsedCount>
 80136e4:	4603      	mov	r3, r0
 80136e6:	1ae3      	subs	r3, r4, r3
}
 80136e8:	4618      	mov	r0, r3
 80136ea:	b002      	add	sp, #8
 80136ec:	bd10      	pop	{r4, pc}
 80136ee:	bf00      	nop

080136f0 <pipe_write>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t pipe_write(pipe_t *pp, const uint8_t *bp, size_t n) {
 80136f0:	b500      	push	{lr}
 80136f2:	b087      	sub	sp, #28
 80136f4:	9003      	str	r0, [sp, #12]
 80136f6:	9102      	str	r1, [sp, #8]
 80136f8:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  PC_LOCK(pp);
 80136fa:	9b03      	ldr	r3, [sp, #12]
 80136fc:	3320      	adds	r3, #32
 80136fe:	4618      	mov	r0, r3
 8013700:	f7fd ff2e 	bl	8011560 <chMtxLock>

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > chPipeGetFreeCount(pp)) {
 8013704:	9803      	ldr	r0, [sp, #12]
 8013706:	f7ff ffe3 	bl	80136d0 <chPipeGetFreeCount>
 801370a:	4602      	mov	r2, r0
 801370c:	9b01      	ldr	r3, [sp, #4]
 801370e:	4293      	cmp	r3, r2
 8013710:	d903      	bls.n	801371a <pipe_write+0x2a>
    n = chPipeGetFreeCount(pp);
 8013712:	9803      	ldr	r0, [sp, #12]
 8013714:	f7ff ffdc 	bl	80136d0 <chPipeGetFreeCount>
 8013718:	9001      	str	r0, [sp, #4]
  }
  pp->cnt += n;
 801371a:	9b03      	ldr	r3, [sp, #12]
 801371c:	691a      	ldr	r2, [r3, #16]
 801371e:	9b01      	ldr	r3, [sp, #4]
 8013720:	441a      	add	r2, r3
 8013722:	9b03      	ldr	r3, [sp, #12]
 8013724:	611a      	str	r2, [r3, #16]

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(pp->top - pp->wrptr);
 8013726:	9b03      	ldr	r3, [sp, #12]
 8013728:	685b      	ldr	r3, [r3, #4]
 801372a:	461a      	mov	r2, r3
 801372c:	9b03      	ldr	r3, [sp, #12]
 801372e:	689b      	ldr	r3, [r3, #8]
 8013730:	1ad3      	subs	r3, r2, r3
 8013732:	9305      	str	r3, [sp, #20]
  /*lint -restore*/

  if (n < s1) {
 8013734:	9a01      	ldr	r2, [sp, #4]
 8013736:	9b05      	ldr	r3, [sp, #20]
 8013738:	429a      	cmp	r2, r3
 801373a:	d20d      	bcs.n	8013758 <pipe_write+0x68>
    memcpy((void *)pp->wrptr, (const void *)bp, n);
 801373c:	9b03      	ldr	r3, [sp, #12]
 801373e:	689b      	ldr	r3, [r3, #8]
 8013740:	9a01      	ldr	r2, [sp, #4]
 8013742:	9902      	ldr	r1, [sp, #8]
 8013744:	4618      	mov	r0, r3
 8013746:	f7ec fde5 	bl	8000314 <memcpy>
    pp->wrptr += n;
 801374a:	9b03      	ldr	r3, [sp, #12]
 801374c:	689a      	ldr	r2, [r3, #8]
 801374e:	9b01      	ldr	r3, [sp, #4]
 8013750:	441a      	add	r2, r3
 8013752:	9b03      	ldr	r3, [sp, #12]
 8013754:	609a      	str	r2, [r3, #8]
 8013756:	e02b      	b.n	80137b0 <pipe_write+0xc0>
  }
  else if (n > s1) {
 8013758:	9a01      	ldr	r2, [sp, #4]
 801375a:	9b05      	ldr	r3, [sp, #20]
 801375c:	429a      	cmp	r2, r3
 801375e:	d91c      	bls.n	801379a <pipe_write+0xaa>
    memcpy((void *)pp->wrptr, (const void *)bp, s1);
 8013760:	9b03      	ldr	r3, [sp, #12]
 8013762:	689b      	ldr	r3, [r3, #8]
 8013764:	9a05      	ldr	r2, [sp, #20]
 8013766:	9902      	ldr	r1, [sp, #8]
 8013768:	4618      	mov	r0, r3
 801376a:	f7ec fdd3 	bl	8000314 <memcpy>
    bp += s1;
 801376e:	9a02      	ldr	r2, [sp, #8]
 8013770:	9b05      	ldr	r3, [sp, #20]
 8013772:	4413      	add	r3, r2
 8013774:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 8013776:	9a01      	ldr	r2, [sp, #4]
 8013778:	9b05      	ldr	r3, [sp, #20]
 801377a:	1ad3      	subs	r3, r2, r3
 801377c:	9304      	str	r3, [sp, #16]
    memcpy((void *)pp->buffer, (const void *)bp, s2);
 801377e:	9b03      	ldr	r3, [sp, #12]
 8013780:	681b      	ldr	r3, [r3, #0]
 8013782:	9a04      	ldr	r2, [sp, #16]
 8013784:	9902      	ldr	r1, [sp, #8]
 8013786:	4618      	mov	r0, r3
 8013788:	f7ec fdc4 	bl	8000314 <memcpy>
    pp->wrptr = pp->buffer + s2;
 801378c:	9b03      	ldr	r3, [sp, #12]
 801378e:	681a      	ldr	r2, [r3, #0]
 8013790:	9b04      	ldr	r3, [sp, #16]
 8013792:	441a      	add	r2, r3
 8013794:	9b03      	ldr	r3, [sp, #12]
 8013796:	609a      	str	r2, [r3, #8]
 8013798:	e00a      	b.n	80137b0 <pipe_write+0xc0>
  }
  else { /* n == s1 */
    memcpy((void *)pp->wrptr, (const void *)bp, n);
 801379a:	9b03      	ldr	r3, [sp, #12]
 801379c:	689b      	ldr	r3, [r3, #8]
 801379e:	9a01      	ldr	r2, [sp, #4]
 80137a0:	9902      	ldr	r1, [sp, #8]
 80137a2:	4618      	mov	r0, r3
 80137a4:	f7ec fdb6 	bl	8000314 <memcpy>
    pp->wrptr = pp->buffer;
 80137a8:	9b03      	ldr	r3, [sp, #12]
 80137aa:	681a      	ldr	r2, [r3, #0]
 80137ac:	9b03      	ldr	r3, [sp, #12]
 80137ae:	609a      	str	r2, [r3, #8]
  }

  PC_UNLOCK(pp);
 80137b0:	9b03      	ldr	r3, [sp, #12]
 80137b2:	3320      	adds	r3, #32
 80137b4:	4618      	mov	r0, r3
 80137b6:	f7fd ffa3 	bl	8011700 <chMtxUnlock>

  return n;
 80137ba:	9b01      	ldr	r3, [sp, #4]
}
 80137bc:	4618      	mov	r0, r3
 80137be:	b007      	add	sp, #28
 80137c0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080137d0 <pipe_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t pipe_read(pipe_t *pp, uint8_t *bp, size_t n) {
 80137d0:	b500      	push	{lr}
 80137d2:	b087      	sub	sp, #28
 80137d4:	9003      	str	r0, [sp, #12]
 80137d6:	9102      	str	r1, [sp, #8]
 80137d8:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  PC_LOCK(pp);
 80137da:	9b03      	ldr	r3, [sp, #12]
 80137dc:	3320      	adds	r3, #32
 80137de:	4618      	mov	r0, r3
 80137e0:	f7fd febe 	bl	8011560 <chMtxLock>

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > chPipeGetUsedCount(pp)) {
 80137e4:	9803      	ldr	r0, [sp, #12]
 80137e6:	f7ff ff6b 	bl	80136c0 <chPipeGetUsedCount>
 80137ea:	4602      	mov	r2, r0
 80137ec:	9b01      	ldr	r3, [sp, #4]
 80137ee:	4293      	cmp	r3, r2
 80137f0:	d903      	bls.n	80137fa <pipe_read+0x2a>
    n = chPipeGetUsedCount(pp);
 80137f2:	9803      	ldr	r0, [sp, #12]
 80137f4:	f7ff ff64 	bl	80136c0 <chPipeGetUsedCount>
 80137f8:	9001      	str	r0, [sp, #4]
  }
  pp->cnt -= n;
 80137fa:	9b03      	ldr	r3, [sp, #12]
 80137fc:	691a      	ldr	r2, [r3, #16]
 80137fe:	9b01      	ldr	r3, [sp, #4]
 8013800:	1ad2      	subs	r2, r2, r3
 8013802:	9b03      	ldr	r3, [sp, #12]
 8013804:	611a      	str	r2, [r3, #16]

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(pp->top - pp->rdptr);
 8013806:	9b03      	ldr	r3, [sp, #12]
 8013808:	685b      	ldr	r3, [r3, #4]
 801380a:	461a      	mov	r2, r3
 801380c:	9b03      	ldr	r3, [sp, #12]
 801380e:	68db      	ldr	r3, [r3, #12]
 8013810:	1ad3      	subs	r3, r2, r3
 8013812:	9305      	str	r3, [sp, #20]
  /*lint -restore*/

  if (n < s1) {
 8013814:	9a01      	ldr	r2, [sp, #4]
 8013816:	9b05      	ldr	r3, [sp, #20]
 8013818:	429a      	cmp	r2, r3
 801381a:	d20d      	bcs.n	8013838 <pipe_read+0x68>
    memcpy((void *)bp, (void *)pp->rdptr, n);
 801381c:	9b03      	ldr	r3, [sp, #12]
 801381e:	68db      	ldr	r3, [r3, #12]
 8013820:	9a01      	ldr	r2, [sp, #4]
 8013822:	4619      	mov	r1, r3
 8013824:	9802      	ldr	r0, [sp, #8]
 8013826:	f7ec fd75 	bl	8000314 <memcpy>
    pp->rdptr += n;
 801382a:	9b03      	ldr	r3, [sp, #12]
 801382c:	68da      	ldr	r2, [r3, #12]
 801382e:	9b01      	ldr	r3, [sp, #4]
 8013830:	441a      	add	r2, r3
 8013832:	9b03      	ldr	r3, [sp, #12]
 8013834:	60da      	str	r2, [r3, #12]
 8013836:	e02b      	b.n	8013890 <pipe_read+0xc0>
  }
  else if (n > s1) {
 8013838:	9a01      	ldr	r2, [sp, #4]
 801383a:	9b05      	ldr	r3, [sp, #20]
 801383c:	429a      	cmp	r2, r3
 801383e:	d91c      	bls.n	801387a <pipe_read+0xaa>
    memcpy((void *)bp, (void *)pp->rdptr, s1);
 8013840:	9b03      	ldr	r3, [sp, #12]
 8013842:	68db      	ldr	r3, [r3, #12]
 8013844:	9a05      	ldr	r2, [sp, #20]
 8013846:	4619      	mov	r1, r3
 8013848:	9802      	ldr	r0, [sp, #8]
 801384a:	f7ec fd63 	bl	8000314 <memcpy>
    bp += s1;
 801384e:	9a02      	ldr	r2, [sp, #8]
 8013850:	9b05      	ldr	r3, [sp, #20]
 8013852:	4413      	add	r3, r2
 8013854:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 8013856:	9a01      	ldr	r2, [sp, #4]
 8013858:	9b05      	ldr	r3, [sp, #20]
 801385a:	1ad3      	subs	r3, r2, r3
 801385c:	9304      	str	r3, [sp, #16]
    memcpy((void *)bp, (void *)pp->buffer, s2);
 801385e:	9b03      	ldr	r3, [sp, #12]
 8013860:	681b      	ldr	r3, [r3, #0]
 8013862:	9a04      	ldr	r2, [sp, #16]
 8013864:	4619      	mov	r1, r3
 8013866:	9802      	ldr	r0, [sp, #8]
 8013868:	f7ec fd54 	bl	8000314 <memcpy>
    pp->rdptr = pp->buffer + s2;
 801386c:	9b03      	ldr	r3, [sp, #12]
 801386e:	681a      	ldr	r2, [r3, #0]
 8013870:	9b04      	ldr	r3, [sp, #16]
 8013872:	441a      	add	r2, r3
 8013874:	9b03      	ldr	r3, [sp, #12]
 8013876:	60da      	str	r2, [r3, #12]
 8013878:	e00a      	b.n	8013890 <pipe_read+0xc0>
  }
  else { /* n == s1 */
    memcpy((void *)bp, (void *)pp->rdptr, n);
 801387a:	9b03      	ldr	r3, [sp, #12]
 801387c:	68db      	ldr	r3, [r3, #12]
 801387e:	9a01      	ldr	r2, [sp, #4]
 8013880:	4619      	mov	r1, r3
 8013882:	9802      	ldr	r0, [sp, #8]
 8013884:	f7ec fd46 	bl	8000314 <memcpy>
    pp->rdptr = pp->buffer;
 8013888:	9b03      	ldr	r3, [sp, #12]
 801388a:	681a      	ldr	r2, [r3, #0]
 801388c:	9b03      	ldr	r3, [sp, #12]
 801388e:	60da      	str	r2, [r3, #12]
  }

  PC_UNLOCK(pp);
 8013890:	9b03      	ldr	r3, [sp, #12]
 8013892:	3320      	adds	r3, #32
 8013894:	4618      	mov	r0, r3
 8013896:	f7fd ff33 	bl	8011700 <chMtxUnlock>

  return n;
 801389a:	9b01      	ldr	r3, [sp, #4]
}
 801389c:	4618      	mov	r0, r3
 801389e:	b007      	add	sp, #28
 80138a0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080138b0 <chPipeObjectInit>:
 * @param[in] buf       pointer to the pipe buffer as an array of @p uint8_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chPipeObjectInit(pipe_t *pp, uint8_t *buf, size_t n) {
 80138b0:	b500      	push	{lr}
 80138b2:	b085      	sub	sp, #20
 80138b4:	9003      	str	r0, [sp, #12]
 80138b6:	9102      	str	r1, [sp, #8]
 80138b8:	9201      	str	r2, [sp, #4]

  chDbgCheck((pp != NULL) && (buf != NULL) && (n > (size_t)0));
 80138ba:	9b03      	ldr	r3, [sp, #12]
 80138bc:	2b00      	cmp	r3, #0
 80138be:	d005      	beq.n	80138cc <chPipeObjectInit+0x1c>
 80138c0:	9b02      	ldr	r3, [sp, #8]
 80138c2:	2b00      	cmp	r3, #0
 80138c4:	d002      	beq.n	80138cc <chPipeObjectInit+0x1c>
 80138c6:	9b01      	ldr	r3, [sp, #4]
 80138c8:	2b00      	cmp	r3, #0
 80138ca:	d102      	bne.n	80138d2 <chPipeObjectInit+0x22>
 80138cc:	4817      	ldr	r0, [pc, #92]	; (801392c <chPipeObjectInit+0x7c>)
 80138ce:	f7fb fb87 	bl	800efe0 <chSysHalt>

  pp->buffer = buf;
 80138d2:	9b03      	ldr	r3, [sp, #12]
 80138d4:	9a02      	ldr	r2, [sp, #8]
 80138d6:	601a      	str	r2, [r3, #0]
  pp->rdptr  = buf;
 80138d8:	9b03      	ldr	r3, [sp, #12]
 80138da:	9a02      	ldr	r2, [sp, #8]
 80138dc:	60da      	str	r2, [r3, #12]
  pp->wrptr  = buf;
 80138de:	9b03      	ldr	r3, [sp, #12]
 80138e0:	9a02      	ldr	r2, [sp, #8]
 80138e2:	609a      	str	r2, [r3, #8]
  pp->top    = &buf[n];
 80138e4:	9a02      	ldr	r2, [sp, #8]
 80138e6:	9b01      	ldr	r3, [sp, #4]
 80138e8:	441a      	add	r2, r3
 80138ea:	9b03      	ldr	r3, [sp, #12]
 80138ec:	605a      	str	r2, [r3, #4]
  pp->cnt    = (size_t)0;
 80138ee:	9b03      	ldr	r3, [sp, #12]
 80138f0:	2200      	movs	r2, #0
 80138f2:	611a      	str	r2, [r3, #16]
  pp->reset  = false;
 80138f4:	9b03      	ldr	r3, [sp, #12]
 80138f6:	2200      	movs	r2, #0
 80138f8:	751a      	strb	r2, [r3, #20]
  pp->wtr    = NULL;
 80138fa:	9b03      	ldr	r3, [sp, #12]
 80138fc:	2200      	movs	r2, #0
 80138fe:	619a      	str	r2, [r3, #24]
  pp->rtr    = NULL;
 8013900:	9b03      	ldr	r3, [sp, #12]
 8013902:	2200      	movs	r2, #0
 8013904:	61da      	str	r2, [r3, #28]
  PC_INIT(pp);
 8013906:	9b03      	ldr	r3, [sp, #12]
 8013908:	3320      	adds	r3, #32
 801390a:	4618      	mov	r0, r3
 801390c:	f7fd fe10 	bl	8011530 <chMtxObjectInit>
  PW_INIT(pp);
 8013910:	9b03      	ldr	r3, [sp, #12]
 8013912:	3330      	adds	r3, #48	; 0x30
 8013914:	4618      	mov	r0, r3
 8013916:	f7fd fe0b 	bl	8011530 <chMtxObjectInit>
  PR_INIT(pp);
 801391a:	9b03      	ldr	r3, [sp, #12]
 801391c:	3340      	adds	r3, #64	; 0x40
 801391e:	4618      	mov	r0, r3
 8013920:	f7fd fe06 	bl	8011530 <chMtxObjectInit>
}
 8013924:	b005      	add	sp, #20
 8013926:	f85d fb04 	ldr.w	pc, [sp], #4
 801392a:	bf00      	nop
 801392c:	080170b4 	.word	0x080170b4

08013930 <chPipeReset>:
 *
 * @param[in] pp        the pointer to an initialized @p pipe_t object
 *
 * @api
 */
void chPipeReset(pipe_t *pp) {
 8013930:	b500      	push	{lr}
 8013932:	b083      	sub	sp, #12
 8013934:	9001      	str	r0, [sp, #4]

  chDbgCheck(pp != NULL);
 8013936:	9b01      	ldr	r3, [sp, #4]
 8013938:	2b00      	cmp	r3, #0
 801393a:	d102      	bne.n	8013942 <chPipeReset+0x12>
 801393c:	4818      	ldr	r0, [pc, #96]	; (80139a0 <chPipeReset+0x70>)
 801393e:	f7fb fb4f 	bl	800efe0 <chSysHalt>

  PC_LOCK(pp);
 8013942:	9b01      	ldr	r3, [sp, #4]
 8013944:	3320      	adds	r3, #32
 8013946:	4618      	mov	r0, r3
 8013948:	f7fd fe0a 	bl	8011560 <chMtxLock>

  pp->wrptr = pp->buffer;
 801394c:	9b01      	ldr	r3, [sp, #4]
 801394e:	681a      	ldr	r2, [r3, #0]
 8013950:	9b01      	ldr	r3, [sp, #4]
 8013952:	609a      	str	r2, [r3, #8]
  pp->rdptr = pp->buffer;
 8013954:	9b01      	ldr	r3, [sp, #4]
 8013956:	681a      	ldr	r2, [r3, #0]
 8013958:	9b01      	ldr	r3, [sp, #4]
 801395a:	60da      	str	r2, [r3, #12]
  pp->cnt   = (size_t)0;
 801395c:	9b01      	ldr	r3, [sp, #4]
 801395e:	2200      	movs	r2, #0
 8013960:	611a      	str	r2, [r3, #16]
  pp->reset = true;
 8013962:	9b01      	ldr	r3, [sp, #4]
 8013964:	2201      	movs	r2, #1
 8013966:	751a      	strb	r2, [r3, #20]

  chSysLock();
 8013968:	f7ff fe72 	bl	8013650 <chSysLock.lto_priv.334>
  chThdResumeI(&pp->wtr, MSG_RESET);
 801396c:	9b01      	ldr	r3, [sp, #4]
 801396e:	3318      	adds	r3, #24
 8013970:	f06f 0101 	mvn.w	r1, #1
 8013974:	4618      	mov	r0, r3
 8013976:	f7fc ffa3 	bl	80108c0 <chThdResumeI>
  chThdResumeI(&pp->rtr, MSG_RESET);
 801397a:	9b01      	ldr	r3, [sp, #4]
 801397c:	331c      	adds	r3, #28
 801397e:	f06f 0101 	mvn.w	r1, #1
 8013982:	4618      	mov	r0, r3
 8013984:	f7fc ff9c 	bl	80108c0 <chThdResumeI>
  chSchRescheduleS();
 8013988:	f7fc fa92 	bl	800feb0 <chSchRescheduleS>
  chSysUnlock();
 801398c:	f7ff fe68 	bl	8013660 <chSysUnlock.lto_priv.310>

  PC_UNLOCK(pp);
 8013990:	9b01      	ldr	r3, [sp, #4]
 8013992:	3320      	adds	r3, #32
 8013994:	4618      	mov	r0, r3
 8013996:	f7fd feb3 	bl	8011700 <chMtxUnlock>
}
 801399a:	b003      	add	sp, #12
 801399c:	f85d fb04 	ldr.w	pc, [sp], #4
 80139a0:	080170c8 	.word	0x080170c8
	...

080139b0 <chPipeWriteTimeout>:
 *                      pipe went in reset state.
 *
 * @api
 */
size_t chPipeWriteTimeout(pipe_t *pp, const uint8_t *bp,
                          size_t n, sysinterval_t timeout) {
 80139b0:	b500      	push	{lr}
 80139b2:	b089      	sub	sp, #36	; 0x24
 80139b4:	9003      	str	r0, [sp, #12]
 80139b6:	9102      	str	r1, [sp, #8]
 80139b8:	9201      	str	r2, [sp, #4]
 80139ba:	9300      	str	r3, [sp, #0]
  size_t max = n;
 80139bc:	9b01      	ldr	r3, [sp, #4]
 80139be:	9307      	str	r3, [sp, #28]

  chDbgCheck(n > 0U);
 80139c0:	9b01      	ldr	r3, [sp, #4]
 80139c2:	2b00      	cmp	r3, #0
 80139c4:	d102      	bne.n	80139cc <chPipeWriteTimeout+0x1c>
 80139c6:	4822      	ldr	r0, [pc, #136]	; (8013a50 <chPipeWriteTimeout+0xa0>)
 80139c8:	f7fb fb0a 	bl	800efe0 <chSysHalt>

  /* If the pipe is in reset state then returns immediately.*/
  if (pp->reset) {
 80139cc:	9b03      	ldr	r3, [sp, #12]
 80139ce:	7d1b      	ldrb	r3, [r3, #20]
 80139d0:	2b00      	cmp	r3, #0
 80139d2:	d001      	beq.n	80139d8 <chPipeWriteTimeout+0x28>
    return (size_t)0;
 80139d4:	2300      	movs	r3, #0
 80139d6:	e036      	b.n	8013a46 <chPipeWriteTimeout+0x96>
  }

  PW_LOCK(pp);
 80139d8:	9b03      	ldr	r3, [sp, #12]
 80139da:	3330      	adds	r3, #48	; 0x30
 80139dc:	4618      	mov	r0, r3
 80139de:	f7fd fdbf 	bl	8011560 <chMtxLock>
 80139e2:	e025      	b.n	8013a30 <chPipeWriteTimeout+0x80>

  while (n > 0U) {
    size_t done;

    done = pipe_write(pp, bp, n);
 80139e4:	9a01      	ldr	r2, [sp, #4]
 80139e6:	9902      	ldr	r1, [sp, #8]
 80139e8:	9803      	ldr	r0, [sp, #12]
 80139ea:	f7ff fe81 	bl	80136f0 <pipe_write>
 80139ee:	9006      	str	r0, [sp, #24]
    if (done == (size_t)0) {
 80139f0:	9b06      	ldr	r3, [sp, #24]
 80139f2:	2b00      	cmp	r3, #0
 80139f4:	d10e      	bne.n	8013a14 <chPipeWriteTimeout+0x64>
      msg_t msg;

      chSysLock();
 80139f6:	f7ff fe2b 	bl	8013650 <chSysLock.lto_priv.334>
      msg = chThdSuspendTimeoutS(&pp->wtr, timeout);
 80139fa:	9b03      	ldr	r3, [sp, #12]
 80139fc:	3318      	adds	r3, #24
 80139fe:	9900      	ldr	r1, [sp, #0]
 8013a00:	4618      	mov	r0, r3
 8013a02:	f7fc ff35 	bl	8010870 <chThdSuspendTimeoutS>
 8013a06:	9005      	str	r0, [sp, #20]
      chSysUnlock();
 8013a08:	f7ff fe2a 	bl	8013660 <chSysUnlock.lto_priv.310>

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8013a0c:	9b05      	ldr	r3, [sp, #20]
 8013a0e:	2b00      	cmp	r3, #0
 8013a10:	d111      	bne.n	8013a36 <chPipeWriteTimeout+0x86>
 8013a12:	e00d      	b.n	8013a30 <chPipeWriteTimeout+0x80>
        break;
      }
    }
    else {
      n  -= done;
 8013a14:	9a01      	ldr	r2, [sp, #4]
 8013a16:	9b06      	ldr	r3, [sp, #24]
 8013a18:	1ad3      	subs	r3, r2, r3
 8013a1a:	9301      	str	r3, [sp, #4]
      bp += done;
 8013a1c:	9a02      	ldr	r2, [sp, #8]
 8013a1e:	9b06      	ldr	r3, [sp, #24]
 8013a20:	4413      	add	r3, r2
 8013a22:	9302      	str	r3, [sp, #8]

      /* Resuming the reader, if present.*/
      chThdResume(&pp->rtr, MSG_OK);
 8013a24:	9b03      	ldr	r3, [sp, #12]
 8013a26:	331c      	adds	r3, #28
 8013a28:	2100      	movs	r1, #0
 8013a2a:	4618      	mov	r0, r3
 8013a2c:	f7fc ff90 	bl	8010950 <chThdResume>
  while (n > 0U) {
 8013a30:	9b01      	ldr	r3, [sp, #4]
 8013a32:	2b00      	cmp	r3, #0
 8013a34:	d1d6      	bne.n	80139e4 <chPipeWriteTimeout+0x34>
    }
  }

  PW_UNLOCK(pp);
 8013a36:	9b03      	ldr	r3, [sp, #12]
 8013a38:	3330      	adds	r3, #48	; 0x30
 8013a3a:	4618      	mov	r0, r3
 8013a3c:	f7fd fe60 	bl	8011700 <chMtxUnlock>

  return max - n;
 8013a40:	9a07      	ldr	r2, [sp, #28]
 8013a42:	9b01      	ldr	r3, [sp, #4]
 8013a44:	1ad3      	subs	r3, r2, r3
}
 8013a46:	4618      	mov	r0, r3
 8013a48:	b009      	add	sp, #36	; 0x24
 8013a4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8013a4e:	bf00      	nop
 8013a50:	080170e0 	.word	0x080170e0
	...

08013a60 <chPipeReadTimeout>:
 *                      pipe went in reset state.
 *
 * @api
 */
size_t chPipeReadTimeout(pipe_t *pp, uint8_t *bp,
                         size_t n, sysinterval_t timeout) {
 8013a60:	b500      	push	{lr}
 8013a62:	b089      	sub	sp, #36	; 0x24
 8013a64:	9003      	str	r0, [sp, #12]
 8013a66:	9102      	str	r1, [sp, #8]
 8013a68:	9201      	str	r2, [sp, #4]
 8013a6a:	9300      	str	r3, [sp, #0]
  size_t max = n;
 8013a6c:	9b01      	ldr	r3, [sp, #4]
 8013a6e:	9307      	str	r3, [sp, #28]

  chDbgCheck(n > 0U);
 8013a70:	9b01      	ldr	r3, [sp, #4]
 8013a72:	2b00      	cmp	r3, #0
 8013a74:	d102      	bne.n	8013a7c <chPipeReadTimeout+0x1c>
 8013a76:	4822      	ldr	r0, [pc, #136]	; (8013b00 <chPipeReadTimeout+0xa0>)
 8013a78:	f7fb fab2 	bl	800efe0 <chSysHalt>

  /* If the pipe is in reset state then returns immediately.*/
  if (pp->reset) {
 8013a7c:	9b03      	ldr	r3, [sp, #12]
 8013a7e:	7d1b      	ldrb	r3, [r3, #20]
 8013a80:	2b00      	cmp	r3, #0
 8013a82:	d001      	beq.n	8013a88 <chPipeReadTimeout+0x28>
    return (size_t)0;
 8013a84:	2300      	movs	r3, #0
 8013a86:	e036      	b.n	8013af6 <chPipeReadTimeout+0x96>
  }

  PR_LOCK(pp);
 8013a88:	9b03      	ldr	r3, [sp, #12]
 8013a8a:	3340      	adds	r3, #64	; 0x40
 8013a8c:	4618      	mov	r0, r3
 8013a8e:	f7fd fd67 	bl	8011560 <chMtxLock>
 8013a92:	e025      	b.n	8013ae0 <chPipeReadTimeout+0x80>

  while (n > 0U) {
    size_t done;

    done = pipe_read(pp, bp, n);
 8013a94:	9a01      	ldr	r2, [sp, #4]
 8013a96:	9902      	ldr	r1, [sp, #8]
 8013a98:	9803      	ldr	r0, [sp, #12]
 8013a9a:	f7ff fe99 	bl	80137d0 <pipe_read>
 8013a9e:	9006      	str	r0, [sp, #24]
    if (done == (size_t)0) {
 8013aa0:	9b06      	ldr	r3, [sp, #24]
 8013aa2:	2b00      	cmp	r3, #0
 8013aa4:	d10e      	bne.n	8013ac4 <chPipeReadTimeout+0x64>
      msg_t msg;

      chSysLock();
 8013aa6:	f7ff fdd3 	bl	8013650 <chSysLock.lto_priv.334>
      msg = chThdSuspendTimeoutS(&pp->rtr, timeout);
 8013aaa:	9b03      	ldr	r3, [sp, #12]
 8013aac:	331c      	adds	r3, #28
 8013aae:	9900      	ldr	r1, [sp, #0]
 8013ab0:	4618      	mov	r0, r3
 8013ab2:	f7fc fedd 	bl	8010870 <chThdSuspendTimeoutS>
 8013ab6:	9005      	str	r0, [sp, #20]
      chSysUnlock();
 8013ab8:	f7ff fdd2 	bl	8013660 <chSysUnlock.lto_priv.310>

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8013abc:	9b05      	ldr	r3, [sp, #20]
 8013abe:	2b00      	cmp	r3, #0
 8013ac0:	d111      	bne.n	8013ae6 <chPipeReadTimeout+0x86>
 8013ac2:	e00d      	b.n	8013ae0 <chPipeReadTimeout+0x80>
        break;
      }
    }
    else {
      n  -= done;
 8013ac4:	9a01      	ldr	r2, [sp, #4]
 8013ac6:	9b06      	ldr	r3, [sp, #24]
 8013ac8:	1ad3      	subs	r3, r2, r3
 8013aca:	9301      	str	r3, [sp, #4]
      bp += done;
 8013acc:	9a02      	ldr	r2, [sp, #8]
 8013ace:	9b06      	ldr	r3, [sp, #24]
 8013ad0:	4413      	add	r3, r2
 8013ad2:	9302      	str	r3, [sp, #8]

      /* Resuming the writer, if present.*/
      chThdResume(&pp->wtr, MSG_OK);
 8013ad4:	9b03      	ldr	r3, [sp, #12]
 8013ad6:	3318      	adds	r3, #24
 8013ad8:	2100      	movs	r1, #0
 8013ada:	4618      	mov	r0, r3
 8013adc:	f7fc ff38 	bl	8010950 <chThdResume>
  while (n > 0U) {
 8013ae0:	9b01      	ldr	r3, [sp, #4]
 8013ae2:	2b00      	cmp	r3, #0
 8013ae4:	d1d6      	bne.n	8013a94 <chPipeReadTimeout+0x34>
    }
  }

  PR_UNLOCK(pp);
 8013ae6:	9b03      	ldr	r3, [sp, #12]
 8013ae8:	3340      	adds	r3, #64	; 0x40
 8013aea:	4618      	mov	r0, r3
 8013aec:	f7fd fe08 	bl	8011700 <chMtxUnlock>

  return max - n;
 8013af0:	9a07      	ldr	r2, [sp, #28]
 8013af2:	9b01      	ldr	r3, [sp, #4]
 8013af4:	1ad3      	subs	r3, r2, r3
}
 8013af6:	4618      	mov	r0, r3
 8013af8:	b009      	add	sp, #36	; 0x24
 8013afa:	f85d fb04 	ldr.w	pc, [sp], #4
 8013afe:	bf00      	nop
 8013b00:	080170f4 	.word	0x080170f4
	...

08013b10 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8013b10:	b500      	push	{lr}
 8013b12:	b083      	sub	sp, #12
 8013b14:	9001      	str	r0, [sp, #4]
 8013b16:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8013b18:	2200      	movs	r2, #0
 8013b1a:	9900      	ldr	r1, [sp, #0]
 8013b1c:	9801      	ldr	r0, [sp, #4]
 8013b1e:	f7ff f92f 	bl	8012d80 <chCoreAllocAlignedWithOffsetI>
 8013b22:	4603      	mov	r3, r0
}
 8013b24:	4618      	mov	r0, r3
 8013b26:	b003      	add	sp, #12
 8013b28:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b2c:	0000      	movs	r0, r0
	...

08013b30 <chHeapAlloc>:
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8013b30:	b500      	push	{lr}
 8013b32:	b083      	sub	sp, #12
 8013b34:	9001      	str	r0, [sp, #4]
 8013b36:	9100      	str	r1, [sp, #0]
  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 8013b38:	2208      	movs	r2, #8
 8013b3a:	9900      	ldr	r1, [sp, #0]
 8013b3c:	9801      	ldr	r0, [sp, #4]
 8013b3e:	f7ff f9df 	bl	8012f00 <chHeapAllocAligned>
 8013b42:	4603      	mov	r3, r0
}
 8013b44:	4618      	mov	r0, r3
 8013b46:	b003      	add	sp, #12
 8013b48:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b4c:	0000      	movs	r0, r0
	...

08013b50 <chPoolObjectInit>:
                                    memgetfunc_t provider) {
 8013b50:	b500      	push	{lr}
 8013b52:	b085      	sub	sp, #20
 8013b54:	9003      	str	r0, [sp, #12]
 8013b56:	9102      	str	r1, [sp, #8]
 8013b58:	9201      	str	r2, [sp, #4]
  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8013b5a:	9b01      	ldr	r3, [sp, #4]
 8013b5c:	2204      	movs	r2, #4
 8013b5e:	9902      	ldr	r1, [sp, #8]
 8013b60:	9803      	ldr	r0, [sp, #12]
 8013b62:	f7ff fbfd 	bl	8013360 <chPoolObjectInitAligned>
}
 8013b66:	b005      	add	sp, #20
 8013b68:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b6c:	0000      	movs	r0, r0
	...

08013b70 <chFifoObjectInitAligned>:
 *
 * @init
 */
static inline void chFifoObjectInitAligned(objects_fifo_t *ofp, size_t objsize,
                                           size_t objn, unsigned objalign,
                                           void *objbuf, msg_t *msgbuf) {
 8013b70:	b500      	push	{lr}
 8013b72:	b085      	sub	sp, #20
 8013b74:	9003      	str	r0, [sp, #12]
 8013b76:	9102      	str	r1, [sp, #8]
 8013b78:	9201      	str	r2, [sp, #4]
 8013b7a:	9300      	str	r3, [sp, #0]

  chDbgCheck((objsize >= objalign) && ((objsize % objalign) == 0U));
 8013b7c:	9a02      	ldr	r2, [sp, #8]
 8013b7e:	9b00      	ldr	r3, [sp, #0]
 8013b80:	429a      	cmp	r2, r3
 8013b82:	d309      	bcc.n	8013b98 <chFifoObjectInitAligned+0x28>
 8013b84:	9b02      	ldr	r3, [sp, #8]
 8013b86:	9a00      	ldr	r2, [sp, #0]
 8013b88:	fbb3 f2f2 	udiv	r2, r3, r2
 8013b8c:	9900      	ldr	r1, [sp, #0]
 8013b8e:	fb01 f202 	mul.w	r2, r1, r2
 8013b92:	1a9b      	subs	r3, r3, r2
 8013b94:	2b00      	cmp	r3, #0
 8013b96:	d002      	beq.n	8013b9e <chFifoObjectInitAligned+0x2e>
 8013b98:	480c      	ldr	r0, [pc, #48]	; (8013bcc <chFifoObjectInitAligned+0x5c>)
 8013b9a:	f7fb fa21 	bl	800efe0 <chSysHalt>

  chGuardedPoolObjectInitAligned(&ofp->free, objsize, objalign);
 8013b9e:	9b03      	ldr	r3, [sp, #12]
 8013ba0:	9a00      	ldr	r2, [sp, #0]
 8013ba2:	9902      	ldr	r1, [sp, #8]
 8013ba4:	4618      	mov	r0, r3
 8013ba6:	f7ff fcb3 	bl	8013510 <chGuardedPoolObjectInitAligned>
  chGuardedPoolLoadArray(&ofp->free, objbuf, objn);
 8013baa:	9b03      	ldr	r3, [sp, #12]
 8013bac:	9a01      	ldr	r2, [sp, #4]
 8013bae:	9906      	ldr	r1, [sp, #24]
 8013bb0:	4618      	mov	r0, r3
 8013bb2:	f7ff fcc5 	bl	8013540 <chGuardedPoolLoadArray>
  chMBObjectInit(&ofp->mbx, msgbuf, objn);
 8013bb6:	9b03      	ldr	r3, [sp, #12]
 8013bb8:	331c      	adds	r3, #28
 8013bba:	9a01      	ldr	r2, [sp, #4]
 8013bbc:	9907      	ldr	r1, [sp, #28]
 8013bbe:	4618      	mov	r0, r3
 8013bc0:	f7fe fe16 	bl	80127f0 <chMBObjectInit>
}
 8013bc4:	b005      	add	sp, #20
 8013bc6:	f85d fb04 	ldr.w	pc, [sp], #4
 8013bca:	bf00      	nop
 8013bcc:	08017178 	.word	0x08017178

08013bd0 <dyn_list_init>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {
 8013bd0:	b082      	sub	sp, #8
 8013bd2:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8013bd4:	9b01      	ldr	r3, [sp, #4]
 8013bd6:	9a01      	ldr	r2, [sp, #4]
 8013bd8:	601a      	str	r2, [r3, #0]
}
 8013bda:	b002      	add	sp, #8
 8013bdc:	4770      	bx	lr
 8013bde:	bf00      	nop

08013be0 <dyn_list_find>:

static dyn_element_t *dyn_list_find(const char *name, dyn_list_t *dlp) {
 8013be0:	b500      	push	{lr}
 8013be2:	b085      	sub	sp, #20
 8013be4:	9001      	str	r0, [sp, #4]
 8013be6:	9100      	str	r1, [sp, #0]
  dyn_element_t *p = dlp->next;
 8013be8:	9b00      	ldr	r3, [sp, #0]
 8013bea:	681b      	ldr	r3, [r3, #0]
 8013bec:	9303      	str	r3, [sp, #12]
 8013bee:	e00e      	b.n	8013c0e <dyn_list_find+0x2e>

  while (p != (dyn_element_t *)dlp) {
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8013bf0:	9b03      	ldr	r3, [sp, #12]
 8013bf2:	3308      	adds	r3, #8
 8013bf4:	2208      	movs	r2, #8
 8013bf6:	9901      	ldr	r1, [sp, #4]
 8013bf8:	4618      	mov	r0, r3
 8013bfa:	f001 fe2f 	bl	801585c <strncmp>
 8013bfe:	4603      	mov	r3, r0
 8013c00:	2b00      	cmp	r3, #0
 8013c02:	d101      	bne.n	8013c08 <dyn_list_find+0x28>
      return p;
 8013c04:	9b03      	ldr	r3, [sp, #12]
 8013c06:	e007      	b.n	8013c18 <dyn_list_find+0x38>
    }
    p = p->next;
 8013c08:	9b03      	ldr	r3, [sp, #12]
 8013c0a:	681b      	ldr	r3, [r3, #0]
 8013c0c:	9303      	str	r3, [sp, #12]
  while (p != (dyn_element_t *)dlp) {
 8013c0e:	9a03      	ldr	r2, [sp, #12]
 8013c10:	9b00      	ldr	r3, [sp, #0]
 8013c12:	429a      	cmp	r2, r3
 8013c14:	d1ec      	bne.n	8013bf0 <dyn_list_find+0x10>
  }

  return NULL;
 8013c16:	2300      	movs	r3, #0
}
 8013c18:	4618      	mov	r0, r3
 8013c1a:	b005      	add	sp, #20
 8013c1c:	f85d fb04 	ldr.w	pc, [sp], #4

08013c20 <dyn_list_unlink>:

static dyn_element_t *dyn_list_unlink(dyn_element_t *element,
                                      dyn_list_t *dlp) {
 8013c20:	b084      	sub	sp, #16
 8013c22:	9001      	str	r0, [sp, #4]
 8013c24:	9100      	str	r1, [sp, #0]
  dyn_element_t *prev = (dyn_element_t *)dlp;
 8013c26:	9b00      	ldr	r3, [sp, #0]
 8013c28:	9303      	str	r3, [sp, #12]
 8013c2a:	e00d      	b.n	8013c48 <dyn_list_unlink+0x28>

  /* Scanning the list.*/
  while (prev->next != (dyn_element_t *)dlp) {
    if (prev->next == element) {
 8013c2c:	9b03      	ldr	r3, [sp, #12]
 8013c2e:	681b      	ldr	r3, [r3, #0]
 8013c30:	9a01      	ldr	r2, [sp, #4]
 8013c32:	429a      	cmp	r2, r3
 8013c34:	d105      	bne.n	8013c42 <dyn_list_unlink+0x22>
      /* Found.*/
      prev->next = element->next;
 8013c36:	9b01      	ldr	r3, [sp, #4]
 8013c38:	681a      	ldr	r2, [r3, #0]
 8013c3a:	9b03      	ldr	r3, [sp, #12]
 8013c3c:	601a      	str	r2, [r3, #0]
      return element;
 8013c3e:	9b01      	ldr	r3, [sp, #4]
 8013c40:	e008      	b.n	8013c54 <dyn_list_unlink+0x34>
    }

    /* Next element in the list.*/
    prev = prev->next;
 8013c42:	9b03      	ldr	r3, [sp, #12]
 8013c44:	681b      	ldr	r3, [r3, #0]
 8013c46:	9303      	str	r3, [sp, #12]
  while (prev->next != (dyn_element_t *)dlp) {
 8013c48:	9b03      	ldr	r3, [sp, #12]
 8013c4a:	681b      	ldr	r3, [r3, #0]
 8013c4c:	9a00      	ldr	r2, [sp, #0]
 8013c4e:	429a      	cmp	r2, r3
 8013c50:	d1ec      	bne.n	8013c2c <dyn_list_unlink+0xc>
  }

  return NULL;
 8013c52:	2300      	movs	r3, #0
}
 8013c54:	4618      	mov	r0, r3
 8013c56:	b004      	add	sp, #16
 8013c58:	4770      	bx	lr
 8013c5a:	bf00      	nop
 8013c5c:	0000      	movs	r0, r0
	...

08013c60 <dyn_create_object_heap>:

#if CH_FACTORY_REQUIRES_HEAP || defined(__DOXYGEN__)
static dyn_element_t *dyn_create_object_heap(const char *name,
                                             dyn_list_t *dlp,
                                             size_t size) {
 8013c60:	b500      	push	{lr}
 8013c62:	b087      	sub	sp, #28
 8013c64:	9003      	str	r0, [sp, #12]
 8013c66:	9102      	str	r1, [sp, #8]
 8013c68:	9201      	str	r2, [sp, #4]
  dyn_element_t *dep;

  chDbgCheck(name != NULL);
 8013c6a:	9b03      	ldr	r3, [sp, #12]
 8013c6c:	2b00      	cmp	r3, #0
 8013c6e:	d102      	bne.n	8013c76 <dyn_create_object_heap+0x16>
 8013c70:	4816      	ldr	r0, [pc, #88]	; (8013ccc <dyn_create_object_heap+0x6c>)
 8013c72:	f7fb f9b5 	bl	800efe0 <chSysHalt>

  /* Checking if an object with this name has already been created.*/
  dep = dyn_list_find(name, dlp);
 8013c76:	9902      	ldr	r1, [sp, #8]
 8013c78:	9803      	ldr	r0, [sp, #12]
 8013c7a:	f7ff ffb1 	bl	8013be0 <dyn_list_find>
 8013c7e:	9005      	str	r0, [sp, #20]
  if (dep != NULL) {
 8013c80:	9b05      	ldr	r3, [sp, #20]
 8013c82:	2b00      	cmp	r3, #0
 8013c84:	d001      	beq.n	8013c8a <dyn_create_object_heap+0x2a>
    return NULL;
 8013c86:	2300      	movs	r3, #0
 8013c88:	e01b      	b.n	8013cc2 <dyn_create_object_heap+0x62>
  }

  /* Allocating space for the new buffer object.*/
  /*lint -save -e668 [] Lint is confused by the above chDbgCheck() and
    incorrectly assumes that strncpy() could receive a NULL pointer.*/
  dep = (dyn_element_t *)chHeapAlloc(NULL, size);
 8013c8a:	9901      	ldr	r1, [sp, #4]
 8013c8c:	2000      	movs	r0, #0
 8013c8e:	f7ff ff4f 	bl	8013b30 <chHeapAlloc>
 8013c92:	9005      	str	r0, [sp, #20]
  if (dep == NULL) {
 8013c94:	9b05      	ldr	r3, [sp, #20]
 8013c96:	2b00      	cmp	r3, #0
 8013c98:	d101      	bne.n	8013c9e <dyn_create_object_heap+0x3e>
    return NULL;
 8013c9a:	2300      	movs	r3, #0
 8013c9c:	e011      	b.n	8013cc2 <dyn_create_object_heap+0x62>
  }

  /* Initializing object list element.*/
  strncpy(dep->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 8013c9e:	9b05      	ldr	r3, [sp, #20]
 8013ca0:	3308      	adds	r3, #8
 8013ca2:	2208      	movs	r2, #8
 8013ca4:	9903      	ldr	r1, [sp, #12]
 8013ca6:	4618      	mov	r0, r3
 8013ca8:	f001 fe24 	bl	80158f4 <strncpy>
  /*lint -restore*/
  dep->refs = (ucnt_t)1;
 8013cac:	9b05      	ldr	r3, [sp, #20]
 8013cae:	2201      	movs	r2, #1
 8013cb0:	605a      	str	r2, [r3, #4]
  dep->next = dlp->next;
 8013cb2:	9b02      	ldr	r3, [sp, #8]
 8013cb4:	681a      	ldr	r2, [r3, #0]
 8013cb6:	9b05      	ldr	r3, [sp, #20]
 8013cb8:	601a      	str	r2, [r3, #0]

  /* Updating factory list.*/
  dlp->next = dep;
 8013cba:	9b02      	ldr	r3, [sp, #8]
 8013cbc:	9a05      	ldr	r2, [sp, #20]
 8013cbe:	601a      	str	r2, [r3, #0]

  return dep;
 8013cc0:	9b05      	ldr	r3, [sp, #20]
}
 8013cc2:	4618      	mov	r0, r3
 8013cc4:	b007      	add	sp, #28
 8013cc6:	f85d fb04 	ldr.w	pc, [sp], #4
 8013cca:	bf00      	nop
 8013ccc:	08017108 	.word	0x08017108

08013cd0 <dyn_release_object_heap>:

static void dyn_release_object_heap(dyn_element_t *dep,
                                    dyn_list_t *dlp) {
 8013cd0:	b500      	push	{lr}
 8013cd2:	b083      	sub	sp, #12
 8013cd4:	9001      	str	r0, [sp, #4]
 8013cd6:	9100      	str	r1, [sp, #0]

  chDbgCheck(dep != NULL);
 8013cd8:	9b01      	ldr	r3, [sp, #4]
 8013cda:	2b00      	cmp	r3, #0
 8013cdc:	d102      	bne.n	8013ce4 <dyn_release_object_heap+0x14>
 8013cde:	480f      	ldr	r0, [pc, #60]	; (8013d1c <dyn_release_object_heap+0x4c>)
 8013ce0:	f7fb f97e 	bl	800efe0 <chSysHalt>
  chDbgAssert(dep->refs > (ucnt_t)0, "invalid references number");
 8013ce4:	9b01      	ldr	r3, [sp, #4]
 8013ce6:	685b      	ldr	r3, [r3, #4]
 8013ce8:	2b00      	cmp	r3, #0
 8013cea:	d102      	bne.n	8013cf2 <dyn_release_object_heap+0x22>
 8013cec:	480b      	ldr	r0, [pc, #44]	; (8013d1c <dyn_release_object_heap+0x4c>)
 8013cee:	f7fb f977 	bl	800efe0 <chSysHalt>


  dep->refs--;
 8013cf2:	9b01      	ldr	r3, [sp, #4]
 8013cf4:	685b      	ldr	r3, [r3, #4]
 8013cf6:	1e5a      	subs	r2, r3, #1
 8013cf8:	9b01      	ldr	r3, [sp, #4]
 8013cfa:	605a      	str	r2, [r3, #4]
  if (dep->refs == (ucnt_t)0) {
 8013cfc:	9b01      	ldr	r3, [sp, #4]
 8013cfe:	685b      	ldr	r3, [r3, #4]
 8013d00:	2b00      	cmp	r3, #0
 8013d02:	d107      	bne.n	8013d14 <dyn_release_object_heap+0x44>
    dep = dyn_list_unlink(dep, dlp);
 8013d04:	9900      	ldr	r1, [sp, #0]
 8013d06:	9801      	ldr	r0, [sp, #4]
 8013d08:	f7ff ff8a 	bl	8013c20 <dyn_list_unlink>
 8013d0c:	9001      	str	r0, [sp, #4]
    chHeapFree((void *)dep);
 8013d0e:	9801      	ldr	r0, [sp, #4]
 8013d10:	f7ff f9de 	bl	80130d0 <chHeapFree>
  }
}
 8013d14:	b003      	add	sp, #12
 8013d16:	f85d fb04 	ldr.w	pc, [sp], #4
 8013d1a:	bf00      	nop
 8013d1c:	08017120 	.word	0x08017120

08013d20 <dyn_create_object_pool>:
#endif /* CH_FACTORY_REQUIRES_HEAP */

#if CH_FACTORY_REQUIRES_POOLS || defined(__DOXYGEN__)
static dyn_element_t *dyn_create_object_pool(const char *name,
                                             dyn_list_t *dlp,
                                             memory_pool_t *mp) {
 8013d20:	b500      	push	{lr}
 8013d22:	b087      	sub	sp, #28
 8013d24:	9003      	str	r0, [sp, #12]
 8013d26:	9102      	str	r1, [sp, #8]
 8013d28:	9201      	str	r2, [sp, #4]
  dyn_element_t *dep;

  chDbgCheck(name != NULL);
 8013d2a:	9b03      	ldr	r3, [sp, #12]
 8013d2c:	2b00      	cmp	r3, #0
 8013d2e:	d102      	bne.n	8013d36 <dyn_create_object_pool+0x16>
 8013d30:	4815      	ldr	r0, [pc, #84]	; (8013d88 <dyn_create_object_pool+0x68>)
 8013d32:	f7fb f955 	bl	800efe0 <chSysHalt>

  /* Checking if an object object with this name has already been created.*/
  dep = dyn_list_find(name, dlp);
 8013d36:	9902      	ldr	r1, [sp, #8]
 8013d38:	9803      	ldr	r0, [sp, #12]
 8013d3a:	f7ff ff51 	bl	8013be0 <dyn_list_find>
 8013d3e:	9005      	str	r0, [sp, #20]
  if (dep != NULL) {
 8013d40:	9b05      	ldr	r3, [sp, #20]
 8013d42:	2b00      	cmp	r3, #0
 8013d44:	d001      	beq.n	8013d4a <dyn_create_object_pool+0x2a>
    return NULL;
 8013d46:	2300      	movs	r3, #0
 8013d48:	e01a      	b.n	8013d80 <dyn_create_object_pool+0x60>
  }

  /* Allocating space for the new object.*/
  dep = (dyn_element_t *)chPoolAlloc(mp);
 8013d4a:	9801      	ldr	r0, [sp, #4]
 8013d4c:	f7ff fb98 	bl	8013480 <chPoolAlloc>
 8013d50:	9005      	str	r0, [sp, #20]
  if (dep == NULL) {
 8013d52:	9b05      	ldr	r3, [sp, #20]
 8013d54:	2b00      	cmp	r3, #0
 8013d56:	d101      	bne.n	8013d5c <dyn_create_object_pool+0x3c>
    return NULL;
 8013d58:	2300      	movs	r3, #0
 8013d5a:	e011      	b.n	8013d80 <dyn_create_object_pool+0x60>
  }

  /* Initializing object list element.*/
  /*lint -save -e668 [] Lint is confused by the above chDbgCheck() and
    incorrectly assumes that strncpy() could receive a NULL pointer.*/
  strncpy(dep->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 8013d5c:	9b05      	ldr	r3, [sp, #20]
 8013d5e:	3308      	adds	r3, #8
 8013d60:	2208      	movs	r2, #8
 8013d62:	9903      	ldr	r1, [sp, #12]
 8013d64:	4618      	mov	r0, r3
 8013d66:	f001 fdc5 	bl	80158f4 <strncpy>
  /*lint -restore*/
  dep->refs = (ucnt_t)1;
 8013d6a:	9b05      	ldr	r3, [sp, #20]
 8013d6c:	2201      	movs	r2, #1
 8013d6e:	605a      	str	r2, [r3, #4]
  dep->next = dlp->next;
 8013d70:	9b02      	ldr	r3, [sp, #8]
 8013d72:	681a      	ldr	r2, [r3, #0]
 8013d74:	9b05      	ldr	r3, [sp, #20]
 8013d76:	601a      	str	r2, [r3, #0]

  /* Updating factory list.*/
  dlp->next = (dyn_element_t *)dep;
 8013d78:	9b02      	ldr	r3, [sp, #8]
 8013d7a:	9a05      	ldr	r2, [sp, #20]
 8013d7c:	601a      	str	r2, [r3, #0]

  return dep;
 8013d7e:	9b05      	ldr	r3, [sp, #20]
}
 8013d80:	4618      	mov	r0, r3
 8013d82:	b007      	add	sp, #28
 8013d84:	f85d fb04 	ldr.w	pc, [sp], #4
 8013d88:	08017138 	.word	0x08017138
 8013d8c:	00000000 	.word	0x00000000

08013d90 <dyn_release_object_pool>:

static void dyn_release_object_pool(dyn_element_t *dep,
                                    dyn_list_t *dlp,
                                    memory_pool_t *mp) {
 8013d90:	b500      	push	{lr}
 8013d92:	b085      	sub	sp, #20
 8013d94:	9003      	str	r0, [sp, #12]
 8013d96:	9102      	str	r1, [sp, #8]
 8013d98:	9201      	str	r2, [sp, #4]

  chDbgCheck(dep != NULL);
 8013d9a:	9b03      	ldr	r3, [sp, #12]
 8013d9c:	2b00      	cmp	r3, #0
 8013d9e:	d102      	bne.n	8013da6 <dyn_release_object_pool+0x16>
 8013da0:	480f      	ldr	r0, [pc, #60]	; (8013de0 <dyn_release_object_pool+0x50>)
 8013da2:	f7fb f91d 	bl	800efe0 <chSysHalt>
  chDbgAssert(dep->refs > (ucnt_t)0, "invalid references number");
 8013da6:	9b03      	ldr	r3, [sp, #12]
 8013da8:	685b      	ldr	r3, [r3, #4]
 8013daa:	2b00      	cmp	r3, #0
 8013dac:	d102      	bne.n	8013db4 <dyn_release_object_pool+0x24>
 8013dae:	480c      	ldr	r0, [pc, #48]	; (8013de0 <dyn_release_object_pool+0x50>)
 8013db0:	f7fb f916 	bl	800efe0 <chSysHalt>

  dep->refs--;
 8013db4:	9b03      	ldr	r3, [sp, #12]
 8013db6:	685b      	ldr	r3, [r3, #4]
 8013db8:	1e5a      	subs	r2, r3, #1
 8013dba:	9b03      	ldr	r3, [sp, #12]
 8013dbc:	605a      	str	r2, [r3, #4]
  if (dep->refs == (ucnt_t)0) {
 8013dbe:	9b03      	ldr	r3, [sp, #12]
 8013dc0:	685b      	ldr	r3, [r3, #4]
 8013dc2:	2b00      	cmp	r3, #0
 8013dc4:	d108      	bne.n	8013dd8 <dyn_release_object_pool+0x48>
    dep = dyn_list_unlink(dep, dlp);
 8013dc6:	9902      	ldr	r1, [sp, #8]
 8013dc8:	9803      	ldr	r0, [sp, #12]
 8013dca:	f7ff ff29 	bl	8013c20 <dyn_list_unlink>
 8013dce:	9003      	str	r0, [sp, #12]
    chPoolFree(mp, (void *)dep);
 8013dd0:	9903      	ldr	r1, [sp, #12]
 8013dd2:	9801      	ldr	r0, [sp, #4]
 8013dd4:	f7ff fb8c 	bl	80134f0 <chPoolFree>
  }
}
 8013dd8:	b005      	add	sp, #20
 8013dda:	f85d fb04 	ldr.w	pc, [sp], #4
 8013dde:	bf00      	nop
 8013de0:	08017150 	.word	0x08017150
	...

08013df0 <dyn_find_object>:
#endif /* CH_FACTORY_REQUIRES_POOLS */

static dyn_element_t *dyn_find_object(const char *name, dyn_list_t *dlp) {
 8013df0:	b500      	push	{lr}
 8013df2:	b085      	sub	sp, #20
 8013df4:	9001      	str	r0, [sp, #4]
 8013df6:	9100      	str	r1, [sp, #0]
  dyn_element_t *dep;

  chDbgCheck(name != NULL);
 8013df8:	9b01      	ldr	r3, [sp, #4]
 8013dfa:	2b00      	cmp	r3, #0
 8013dfc:	d102      	bne.n	8013e04 <dyn_find_object+0x14>
 8013dfe:	480a      	ldr	r0, [pc, #40]	; (8013e28 <dyn_find_object+0x38>)
 8013e00:	f7fb f8ee 	bl	800efe0 <chSysHalt>

  /* Checking if an object with this name has already been created.*/
  dep = dyn_list_find(name, dlp);
 8013e04:	9900      	ldr	r1, [sp, #0]
 8013e06:	9801      	ldr	r0, [sp, #4]
 8013e08:	f7ff feea 	bl	8013be0 <dyn_list_find>
 8013e0c:	9003      	str	r0, [sp, #12]
  if (dep != NULL) {
 8013e0e:	9b03      	ldr	r3, [sp, #12]
 8013e10:	2b00      	cmp	r3, #0
 8013e12:	d004      	beq.n	8013e1e <dyn_find_object+0x2e>
    /* Increasing references counter.*/
    dep->refs++;
 8013e14:	9b03      	ldr	r3, [sp, #12]
 8013e16:	685b      	ldr	r3, [r3, #4]
 8013e18:	1c5a      	adds	r2, r3, #1
 8013e1a:	9b03      	ldr	r3, [sp, #12]
 8013e1c:	605a      	str	r2, [r3, #4]
  }

  return dep;
 8013e1e:	9b03      	ldr	r3, [sp, #12]
}
 8013e20:	4618      	mov	r0, r3
 8013e22:	b005      	add	sp, #20
 8013e24:	f85d fb04 	ldr.w	pc, [sp], #4
 8013e28:	08017168 	.word	0x08017168
 8013e2c:	00000000 	.word	0x00000000

08013e30 <_factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void _factory_init(void) {
 8013e30:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8013e32:	4810      	ldr	r0, [pc, #64]	; (8013e74 <_factory_init+0x44>)
 8013e34:	f7fd fb7c 	bl	8011530 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 8013e38:	480f      	ldr	r0, [pc, #60]	; (8013e78 <_factory_init+0x48>)
 8013e3a:	f7ff fec9 	bl	8013bd0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 8013e3e:	4a0f      	ldr	r2, [pc, #60]	; (8013e7c <_factory_init+0x4c>)
 8013e40:	2114      	movs	r1, #20
 8013e42:	480f      	ldr	r0, [pc, #60]	; (8013e80 <_factory_init+0x50>)
 8013e44:	f7ff fe84 	bl	8013b50 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8013e48:	480e      	ldr	r0, [pc, #56]	; (8013e84 <_factory_init+0x54>)
 8013e4a:	f7ff fec1 	bl	8013bd0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 8013e4e:	480e      	ldr	r0, [pc, #56]	; (8013e88 <_factory_init+0x58>)
 8013e50:	f7ff febe 	bl	8013bd0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8013e54:	4a09      	ldr	r2, [pc, #36]	; (8013e7c <_factory_init+0x4c>)
 8013e56:	211c      	movs	r1, #28
 8013e58:	480c      	ldr	r0, [pc, #48]	; (8013e8c <_factory_init+0x5c>)
 8013e5a:	f7ff fe79 	bl	8013b50 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 8013e5e:	480c      	ldr	r0, [pc, #48]	; (8013e90 <_factory_init+0x60>)
 8013e60:	f7ff feb6 	bl	8013bd0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8013e64:	480b      	ldr	r0, [pc, #44]	; (8013e94 <_factory_init+0x64>)
 8013e66:	f7ff feb3 	bl	8013bd0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 8013e6a:	480b      	ldr	r0, [pc, #44]	; (8013e98 <_factory_init+0x68>)
 8013e6c:	f7ff feb0 	bl	8013bd0 <dyn_list_init>
#endif
}
 8013e70:	bd08      	pop	{r3, pc}
 8013e72:	bf00      	nop
 8013e74:	2000193c 	.word	0x2000193c
 8013e78:	2000194c 	.word	0x2000194c
 8013e7c:	08013b11 	.word	0x08013b11
 8013e80:	20001950 	.word	0x20001950
 8013e84:	20001960 	.word	0x20001960
 8013e88:	20001964 	.word	0x20001964
 8013e8c:	20001968 	.word	0x20001968
 8013e90:	20001978 	.word	0x20001978
 8013e94:	2000197c 	.word	0x2000197c
 8013e98:	20001980 	.word	0x20001980
 8013e9c:	00000000 	.word	0x00000000

08013ea0 <chFactoryRegisterObject>:
 *                      a registered object with the same name exists.
 *
 * @api
 */
registered_object_t *chFactoryRegisterObject(const char *name,
                                             void *objp) {
 8013ea0:	b500      	push	{lr}
 8013ea2:	b085      	sub	sp, #20
 8013ea4:	9001      	str	r0, [sp, #4]
 8013ea6:	9100      	str	r1, [sp, #0]
  registered_object_t *rop;

  F_LOCK();
 8013ea8:	480b      	ldr	r0, [pc, #44]	; (8013ed8 <chFactoryRegisterObject+0x38>)
 8013eaa:	f7fd fb59 	bl	8011560 <chMtxLock>

  rop = (registered_object_t *)dyn_create_object_pool(name,
 8013eae:	4a0b      	ldr	r2, [pc, #44]	; (8013edc <chFactoryRegisterObject+0x3c>)
 8013eb0:	490b      	ldr	r1, [pc, #44]	; (8013ee0 <chFactoryRegisterObject+0x40>)
 8013eb2:	9801      	ldr	r0, [sp, #4]
 8013eb4:	f7ff ff34 	bl	8013d20 <dyn_create_object_pool>
 8013eb8:	9003      	str	r0, [sp, #12]
                                                      &ch_factory.obj_list,
                                                      &ch_factory.obj_pool);
  if (rop != NULL) {
 8013eba:	9b03      	ldr	r3, [sp, #12]
 8013ebc:	2b00      	cmp	r3, #0
 8013ebe:	d002      	beq.n	8013ec6 <chFactoryRegisterObject+0x26>
    /* Initializing registered object data.*/
    rop->objp = objp;
 8013ec0:	9b03      	ldr	r3, [sp, #12]
 8013ec2:	9a00      	ldr	r2, [sp, #0]
 8013ec4:	611a      	str	r2, [r3, #16]
  }

  F_UNLOCK();
 8013ec6:	4804      	ldr	r0, [pc, #16]	; (8013ed8 <chFactoryRegisterObject+0x38>)
 8013ec8:	f7fd fc1a 	bl	8011700 <chMtxUnlock>

  return rop;
 8013ecc:	9b03      	ldr	r3, [sp, #12]
}
 8013ece:	4618      	mov	r0, r3
 8013ed0:	b005      	add	sp, #20
 8013ed2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013ed6:	bf00      	nop
 8013ed8:	2000193c 	.word	0x2000193c
 8013edc:	20001950 	.word	0x20001950
 8013ee0:	2000194c 	.word	0x2000194c
	...

08013ef0 <chFactoryFindObject>:
 * @retval NULL         if a registered object with the specified name
 *                      does not exist.
 *
 * @api
 */
registered_object_t *chFactoryFindObject(const char *name) {
 8013ef0:	b500      	push	{lr}
 8013ef2:	b085      	sub	sp, #20
 8013ef4:	9001      	str	r0, [sp, #4]
  registered_object_t *rop;

  F_LOCK();
 8013ef6:	4808      	ldr	r0, [pc, #32]	; (8013f18 <chFactoryFindObject+0x28>)
 8013ef8:	f7fd fb32 	bl	8011560 <chMtxLock>

  rop = (registered_object_t *)dyn_find_object(name, &ch_factory.obj_list);
 8013efc:	4907      	ldr	r1, [pc, #28]	; (8013f1c <chFactoryFindObject+0x2c>)
 8013efe:	9801      	ldr	r0, [sp, #4]
 8013f00:	f7ff ff76 	bl	8013df0 <dyn_find_object>
 8013f04:	9003      	str	r0, [sp, #12]

  F_UNLOCK();
 8013f06:	4804      	ldr	r0, [pc, #16]	; (8013f18 <chFactoryFindObject+0x28>)
 8013f08:	f7fd fbfa 	bl	8011700 <chMtxUnlock>

  return rop;
 8013f0c:	9b03      	ldr	r3, [sp, #12]
}
 8013f0e:	4618      	mov	r0, r3
 8013f10:	b005      	add	sp, #20
 8013f12:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f16:	bf00      	nop
 8013f18:	2000193c 	.word	0x2000193c
 8013f1c:	2000194c 	.word	0x2000194c

08013f20 <chFactoryReleaseObject>:
 *
 * @param[in] rop       registered object reference
 *
 * @api
 */
void chFactoryReleaseObject(registered_object_t *rop){
 8013f20:	b500      	push	{lr}
 8013f22:	b083      	sub	sp, #12
 8013f24:	9001      	str	r0, [sp, #4]

  F_LOCK();
 8013f26:	4807      	ldr	r0, [pc, #28]	; (8013f44 <chFactoryReleaseObject+0x24>)
 8013f28:	f7fd fb1a 	bl	8011560 <chMtxLock>

  dyn_release_object_pool(&rop->element,
 8013f2c:	9b01      	ldr	r3, [sp, #4]
 8013f2e:	4a06      	ldr	r2, [pc, #24]	; (8013f48 <chFactoryReleaseObject+0x28>)
 8013f30:	4906      	ldr	r1, [pc, #24]	; (8013f4c <chFactoryReleaseObject+0x2c>)
 8013f32:	4618      	mov	r0, r3
 8013f34:	f7ff ff2c 	bl	8013d90 <dyn_release_object_pool>
                          &ch_factory.obj_list,
                          &ch_factory.obj_pool);

  F_UNLOCK();
 8013f38:	4802      	ldr	r0, [pc, #8]	; (8013f44 <chFactoryReleaseObject+0x24>)
 8013f3a:	f7fd fbe1 	bl	8011700 <chMtxUnlock>
}
 8013f3e:	b003      	add	sp, #12
 8013f40:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f44:	2000193c 	.word	0x2000193c
 8013f48:	20001950 	.word	0x20001950
 8013f4c:	2000194c 	.word	0x2000194c

08013f50 <chFactoryCreateBuffer>:
 * @retval NULL         if the dynamic buffer object cannot be allocated or
 *                      a dynamic buffer object with the same name exists.
 *
 * @api
 */
dyn_buffer_t *chFactoryCreateBuffer(const char *name, size_t size) {
 8013f50:	b500      	push	{lr}
 8013f52:	b085      	sub	sp, #20
 8013f54:	9001      	str	r0, [sp, #4]
 8013f56:	9100      	str	r1, [sp, #0]
  dyn_buffer_t *dbp;

  F_LOCK();
 8013f58:	480d      	ldr	r0, [pc, #52]	; (8013f90 <chFactoryCreateBuffer+0x40>)
 8013f5a:	f7fd fb01 	bl	8011560 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_create_object_heap(name,
 8013f5e:	9a00      	ldr	r2, [sp, #0]
 8013f60:	490c      	ldr	r1, [pc, #48]	; (8013f94 <chFactoryCreateBuffer+0x44>)
 8013f62:	9801      	ldr	r0, [sp, #4]
 8013f64:	f7ff fe7c 	bl	8013c60 <dyn_create_object_heap>
 8013f68:	9003      	str	r0, [sp, #12]
                                               &ch_factory.buf_list,
                                               size);
  if (dbp != NULL) {
 8013f6a:	9b03      	ldr	r3, [sp, #12]
 8013f6c:	2b00      	cmp	r3, #0
 8013f6e:	d006      	beq.n	8013f7e <chFactoryCreateBuffer+0x2e>
    /* Initializing buffer object data.*/
    memset((void *)dbp->buffer, 0, size);
 8013f70:	9b03      	ldr	r3, [sp, #12]
 8013f72:	3310      	adds	r3, #16
 8013f74:	9a00      	ldr	r2, [sp, #0]
 8013f76:	2100      	movs	r1, #0
 8013f78:	4618      	mov	r0, r3
 8013f7a:	f001 fbb1 	bl	80156e0 <memset>
  }

  F_UNLOCK();
 8013f7e:	4804      	ldr	r0, [pc, #16]	; (8013f90 <chFactoryCreateBuffer+0x40>)
 8013f80:	f7fd fbbe 	bl	8011700 <chMtxUnlock>

  return dbp;
 8013f84:	9b03      	ldr	r3, [sp, #12]
}
 8013f86:	4618      	mov	r0, r3
 8013f88:	b005      	add	sp, #20
 8013f8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f8e:	bf00      	nop
 8013f90:	2000193c 	.word	0x2000193c
 8013f94:	20001960 	.word	0x20001960
	...

08013fa0 <chFactoryFindBuffer>:
 * @retval NULL         if a dynamic buffer object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_buffer_t *chFactoryFindBuffer(const char *name) {
 8013fa0:	b500      	push	{lr}
 8013fa2:	b085      	sub	sp, #20
 8013fa4:	9001      	str	r0, [sp, #4]
  dyn_buffer_t *dbp;

  F_LOCK();
 8013fa6:	4808      	ldr	r0, [pc, #32]	; (8013fc8 <chFactoryFindBuffer+0x28>)
 8013fa8:	f7fd fada 	bl	8011560 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_find_object(name, &ch_factory.buf_list);
 8013fac:	4907      	ldr	r1, [pc, #28]	; (8013fcc <chFactoryFindBuffer+0x2c>)
 8013fae:	9801      	ldr	r0, [sp, #4]
 8013fb0:	f7ff ff1e 	bl	8013df0 <dyn_find_object>
 8013fb4:	9003      	str	r0, [sp, #12]

  F_UNLOCK();
 8013fb6:	4804      	ldr	r0, [pc, #16]	; (8013fc8 <chFactoryFindBuffer+0x28>)
 8013fb8:	f7fd fba2 	bl	8011700 <chMtxUnlock>

  return dbp;
 8013fbc:	9b03      	ldr	r3, [sp, #12]
}
 8013fbe:	4618      	mov	r0, r3
 8013fc0:	b005      	add	sp, #20
 8013fc2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013fc6:	bf00      	nop
 8013fc8:	2000193c 	.word	0x2000193c
 8013fcc:	20001960 	.word	0x20001960

08013fd0 <chFactoryReleaseBuffer>:
 *
 * @param[in] dbp       dynamic buffer object reference
 *
 * @api
 */
void chFactoryReleaseBuffer(dyn_buffer_t *dbp) {
 8013fd0:	b500      	push	{lr}
 8013fd2:	b083      	sub	sp, #12
 8013fd4:	9001      	str	r0, [sp, #4]

  F_LOCK();
 8013fd6:	4807      	ldr	r0, [pc, #28]	; (8013ff4 <chFactoryReleaseBuffer+0x24>)
 8013fd8:	f7fd fac2 	bl	8011560 <chMtxLock>

  dyn_release_object_heap(&dbp->element, &ch_factory.buf_list);
 8013fdc:	9b01      	ldr	r3, [sp, #4]
 8013fde:	4906      	ldr	r1, [pc, #24]	; (8013ff8 <chFactoryReleaseBuffer+0x28>)
 8013fe0:	4618      	mov	r0, r3
 8013fe2:	f7ff fe75 	bl	8013cd0 <dyn_release_object_heap>

  F_UNLOCK();
 8013fe6:	4803      	ldr	r0, [pc, #12]	; (8013ff4 <chFactoryReleaseBuffer+0x24>)
 8013fe8:	f7fd fb8a 	bl	8011700 <chMtxUnlock>
}
 8013fec:	b003      	add	sp, #12
 8013fee:	f85d fb04 	ldr.w	pc, [sp], #4
 8013ff2:	bf00      	nop
 8013ff4:	2000193c 	.word	0x2000193c
 8013ff8:	20001960 	.word	0x20001960
 8013ffc:	00000000 	.word	0x00000000

08014000 <chFactoryCreateSemaphore>:
 * @retval NULL         if the dynamic semaphore object cannot be allocated or
 *                      a dynamic semaphore with the same name exists.
 *
 * @api
 */
dyn_semaphore_t *chFactoryCreateSemaphore(const char *name, cnt_t n) {
 8014000:	b500      	push	{lr}
 8014002:	b085      	sub	sp, #20
 8014004:	9001      	str	r0, [sp, #4]
 8014006:	9100      	str	r1, [sp, #0]
  dyn_semaphore_t *dsp;

  F_LOCK();
 8014008:	480c      	ldr	r0, [pc, #48]	; (801403c <chFactoryCreateSemaphore+0x3c>)
 801400a:	f7fd faa9 	bl	8011560 <chMtxLock>

  dsp = (dyn_semaphore_t *)dyn_create_object_pool(name,
 801400e:	4a0c      	ldr	r2, [pc, #48]	; (8014040 <chFactoryCreateSemaphore+0x40>)
 8014010:	490c      	ldr	r1, [pc, #48]	; (8014044 <chFactoryCreateSemaphore+0x44>)
 8014012:	9801      	ldr	r0, [sp, #4]
 8014014:	f7ff fe84 	bl	8013d20 <dyn_create_object_pool>
 8014018:	9003      	str	r0, [sp, #12]
                                                  &ch_factory.sem_list,
                                                  &ch_factory.sem_pool);
  if (dsp != NULL) {
 801401a:	9b03      	ldr	r3, [sp, #12]
 801401c:	2b00      	cmp	r3, #0
 801401e:	d005      	beq.n	801402c <chFactoryCreateSemaphore+0x2c>
    /* Initializing semaphore object dataa.*/
    chSemObjectInit(&dsp->sem, n);
 8014020:	9b03      	ldr	r3, [sp, #12]
 8014022:	3310      	adds	r3, #16
 8014024:	9900      	ldr	r1, [sp, #0]
 8014026:	4618      	mov	r0, r3
 8014028:	f7fc fefa 	bl	8010e20 <chSemObjectInit>
  }

  F_UNLOCK();
 801402c:	4803      	ldr	r0, [pc, #12]	; (801403c <chFactoryCreateSemaphore+0x3c>)
 801402e:	f7fd fb67 	bl	8011700 <chMtxUnlock>

  return dsp;
 8014032:	9b03      	ldr	r3, [sp, #12]
}
 8014034:	4618      	mov	r0, r3
 8014036:	b005      	add	sp, #20
 8014038:	f85d fb04 	ldr.w	pc, [sp], #4
 801403c:	2000193c 	.word	0x2000193c
 8014040:	20001968 	.word	0x20001968
 8014044:	20001964 	.word	0x20001964
	...

08014050 <chFactoryFindSemaphore>:
 * @retval NULL         if a dynamic semaphore object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_semaphore_t *chFactoryFindSemaphore(const char *name) {
 8014050:	b500      	push	{lr}
 8014052:	b085      	sub	sp, #20
 8014054:	9001      	str	r0, [sp, #4]
  dyn_semaphore_t *dsp;

  F_LOCK();
 8014056:	4808      	ldr	r0, [pc, #32]	; (8014078 <chFactoryFindSemaphore+0x28>)
 8014058:	f7fd fa82 	bl	8011560 <chMtxLock>

  dsp = (dyn_semaphore_t *)dyn_find_object(name, &ch_factory.sem_list);
 801405c:	4907      	ldr	r1, [pc, #28]	; (801407c <chFactoryFindSemaphore+0x2c>)
 801405e:	9801      	ldr	r0, [sp, #4]
 8014060:	f7ff fec6 	bl	8013df0 <dyn_find_object>
 8014064:	9003      	str	r0, [sp, #12]

  F_UNLOCK();
 8014066:	4804      	ldr	r0, [pc, #16]	; (8014078 <chFactoryFindSemaphore+0x28>)
 8014068:	f7fd fb4a 	bl	8011700 <chMtxUnlock>

  return dsp;
 801406c:	9b03      	ldr	r3, [sp, #12]
}
 801406e:	4618      	mov	r0, r3
 8014070:	b005      	add	sp, #20
 8014072:	f85d fb04 	ldr.w	pc, [sp], #4
 8014076:	bf00      	nop
 8014078:	2000193c 	.word	0x2000193c
 801407c:	20001964 	.word	0x20001964

08014080 <chFactoryReleaseSemaphore>:
 *
 * @param[in] dsp       dynamic semaphore object reference
 *
 * @api
 */
void chFactoryReleaseSemaphore(dyn_semaphore_t *dsp) {
 8014080:	b500      	push	{lr}
 8014082:	b083      	sub	sp, #12
 8014084:	9001      	str	r0, [sp, #4]

  F_LOCK();
 8014086:	4807      	ldr	r0, [pc, #28]	; (80140a4 <chFactoryReleaseSemaphore+0x24>)
 8014088:	f7fd fa6a 	bl	8011560 <chMtxLock>

  dyn_release_object_pool(&dsp->element,
 801408c:	9b01      	ldr	r3, [sp, #4]
 801408e:	4a06      	ldr	r2, [pc, #24]	; (80140a8 <chFactoryReleaseSemaphore+0x28>)
 8014090:	4906      	ldr	r1, [pc, #24]	; (80140ac <chFactoryReleaseSemaphore+0x2c>)
 8014092:	4618      	mov	r0, r3
 8014094:	f7ff fe7c 	bl	8013d90 <dyn_release_object_pool>
                          &ch_factory.sem_list,
                          &ch_factory.sem_pool);

  F_UNLOCK();
 8014098:	4802      	ldr	r0, [pc, #8]	; (80140a4 <chFactoryReleaseSemaphore+0x24>)
 801409a:	f7fd fb31 	bl	8011700 <chMtxUnlock>
}
 801409e:	b003      	add	sp, #12
 80140a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80140a4:	2000193c 	.word	0x2000193c
 80140a8:	20001968 	.word	0x20001968
 80140ac:	20001964 	.word	0x20001964

080140b0 <chFactoryCreateMailbox>:
 * @retval NULL         if the dynamic mailbox object cannot be allocated or
 *                      a dynamic mailbox object with the same name exists.
 *
 * @api
 */
dyn_mailbox_t *chFactoryCreateMailbox(const char *name, size_t n) {
 80140b0:	b500      	push	{lr}
 80140b2:	b085      	sub	sp, #20
 80140b4:	9001      	str	r0, [sp, #4]
 80140b6:	9100      	str	r1, [sp, #0]
  dyn_mailbox_t *dmp;

  F_LOCK();
 80140b8:	480f      	ldr	r0, [pc, #60]	; (80140f8 <chFactoryCreateMailbox+0x48>)
 80140ba:	f7fd fa51 	bl	8011560 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_create_object_heap(name,
 80140be:	9b00      	ldr	r3, [sp, #0]
 80140c0:	330e      	adds	r3, #14
 80140c2:	009b      	lsls	r3, r3, #2
 80140c4:	461a      	mov	r2, r3
 80140c6:	490d      	ldr	r1, [pc, #52]	; (80140fc <chFactoryCreateMailbox+0x4c>)
 80140c8:	9801      	ldr	r0, [sp, #4]
 80140ca:	f7ff fdc9 	bl	8013c60 <dyn_create_object_heap>
 80140ce:	9003      	str	r0, [sp, #12]
                                                &ch_factory.mbx_list,
                                                sizeof (dyn_mailbox_t) +
                                                (n * sizeof (msg_t)));
  if (dmp != NULL) {
 80140d0:	9b03      	ldr	r3, [sp, #12]
 80140d2:	2b00      	cmp	r3, #0
 80140d4:	d008      	beq.n	80140e8 <chFactoryCreateMailbox+0x38>
    /* Initializing mailbox object data.*/
    chMBObjectInit(&dmp->mbx, dmp->msgbuf, n);
 80140d6:	9b03      	ldr	r3, [sp, #12]
 80140d8:	f103 0010 	add.w	r0, r3, #16
 80140dc:	9b03      	ldr	r3, [sp, #12]
 80140de:	3338      	adds	r3, #56	; 0x38
 80140e0:	9a00      	ldr	r2, [sp, #0]
 80140e2:	4619      	mov	r1, r3
 80140e4:	f7fe fb84 	bl	80127f0 <chMBObjectInit>
  }

  F_UNLOCK();
 80140e8:	4803      	ldr	r0, [pc, #12]	; (80140f8 <chFactoryCreateMailbox+0x48>)
 80140ea:	f7fd fb09 	bl	8011700 <chMtxUnlock>

  return dmp;
 80140ee:	9b03      	ldr	r3, [sp, #12]
}
 80140f0:	4618      	mov	r0, r3
 80140f2:	b005      	add	sp, #20
 80140f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80140f8:	2000193c 	.word	0x2000193c
 80140fc:	20001978 	.word	0x20001978

08014100 <chFactoryFindMailbox>:
 * @retval NULL         if a dynamic mailbox object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_mailbox_t *chFactoryFindMailbox(const char *name) {
 8014100:	b500      	push	{lr}
 8014102:	b085      	sub	sp, #20
 8014104:	9001      	str	r0, [sp, #4]
  dyn_mailbox_t *dmp;

  F_LOCK();
 8014106:	4808      	ldr	r0, [pc, #32]	; (8014128 <chFactoryFindMailbox+0x28>)
 8014108:	f7fd fa2a 	bl	8011560 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_find_object(name, &ch_factory.mbx_list);
 801410c:	4907      	ldr	r1, [pc, #28]	; (801412c <chFactoryFindMailbox+0x2c>)
 801410e:	9801      	ldr	r0, [sp, #4]
 8014110:	f7ff fe6e 	bl	8013df0 <dyn_find_object>
 8014114:	9003      	str	r0, [sp, #12]

  F_UNLOCK();
 8014116:	4804      	ldr	r0, [pc, #16]	; (8014128 <chFactoryFindMailbox+0x28>)
 8014118:	f7fd faf2 	bl	8011700 <chMtxUnlock>

  return dmp;
 801411c:	9b03      	ldr	r3, [sp, #12]
}
 801411e:	4618      	mov	r0, r3
 8014120:	b005      	add	sp, #20
 8014122:	f85d fb04 	ldr.w	pc, [sp], #4
 8014126:	bf00      	nop
 8014128:	2000193c 	.word	0x2000193c
 801412c:	20001978 	.word	0x20001978

08014130 <chFactoryReleaseMailbox>:
 *
 * @param[in] dmp       dynamic mailbox object reference
 *
 * @api
 */
void chFactoryReleaseMailbox(dyn_mailbox_t *dmp) {
 8014130:	b500      	push	{lr}
 8014132:	b083      	sub	sp, #12
 8014134:	9001      	str	r0, [sp, #4]

  F_LOCK();
 8014136:	4807      	ldr	r0, [pc, #28]	; (8014154 <chFactoryReleaseMailbox+0x24>)
 8014138:	f7fd fa12 	bl	8011560 <chMtxLock>

  dyn_release_object_heap(&dmp->element, &ch_factory.mbx_list);
 801413c:	9b01      	ldr	r3, [sp, #4]
 801413e:	4906      	ldr	r1, [pc, #24]	; (8014158 <chFactoryReleaseMailbox+0x28>)
 8014140:	4618      	mov	r0, r3
 8014142:	f7ff fdc5 	bl	8013cd0 <dyn_release_object_heap>

  F_UNLOCK();
 8014146:	4803      	ldr	r0, [pc, #12]	; (8014154 <chFactoryReleaseMailbox+0x24>)
 8014148:	f7fd fada 	bl	8011700 <chMtxUnlock>
}
 801414c:	b003      	add	sp, #12
 801414e:	f85d fb04 	ldr.w	pc, [sp], #4
 8014152:	bf00      	nop
 8014154:	2000193c 	.word	0x2000193c
 8014158:	20001978 	.word	0x20001978
 801415c:	00000000 	.word	0x00000000

08014160 <chFactoryCreateObjectsFIFO>:
 * @api
 */
dyn_objects_fifo_t *chFactoryCreateObjectsFIFO(const char *name,
                                               size_t objsize,
                                               size_t objn,
                                               unsigned objalign) {
 8014160:	b500      	push	{lr}
 8014162:	b089      	sub	sp, #36	; 0x24
 8014164:	9005      	str	r0, [sp, #20]
 8014166:	9104      	str	r1, [sp, #16]
 8014168:	9203      	str	r2, [sp, #12]
 801416a:	9302      	str	r3, [sp, #8]
  dyn_objects_fifo_t *dofp;

  F_LOCK();
 801416c:	4816      	ldr	r0, [pc, #88]	; (80141c8 <chFactoryCreateObjectsFIFO+0x68>)
 801416e:	f7fd f9f7 	bl	8011560 <chMtxLock>

  dofp = (dyn_objects_fifo_t *)dyn_create_object_heap(name,
                                                      &ch_factory.fifo_list,
                                                      sizeof (dyn_objects_fifo_t) +
 8014172:	9b03      	ldr	r3, [sp, #12]
 8014174:	3315      	adds	r3, #21
 8014176:	009a      	lsls	r2, r3, #2
                                                      (objn * sizeof (msg_t)) +
                                                      (objn * objsize));
 8014178:	9b03      	ldr	r3, [sp, #12]
 801417a:	9904      	ldr	r1, [sp, #16]
 801417c:	fb01 f303 	mul.w	r3, r1, r3
  dofp = (dyn_objects_fifo_t *)dyn_create_object_heap(name,
 8014180:	4413      	add	r3, r2
 8014182:	461a      	mov	r2, r3
 8014184:	4911      	ldr	r1, [pc, #68]	; (80141cc <chFactoryCreateObjectsFIFO+0x6c>)
 8014186:	9805      	ldr	r0, [sp, #20]
 8014188:	f7ff fd6a 	bl	8013c60 <dyn_create_object_heap>
 801418c:	9007      	str	r0, [sp, #28]
  if (dofp != NULL) {
 801418e:	9b07      	ldr	r3, [sp, #28]
 8014190:	2b00      	cmp	r3, #0
 8014192:	d011      	beq.n	80141b8 <chFactoryCreateObjectsFIFO+0x58>
    /* Initializing mailbox object data.*/
    chFifoObjectInitAligned(&dofp->fifo, objsize, objn, objalign,
 8014194:	9b07      	ldr	r3, [sp, #28]
 8014196:	f103 0010 	add.w	r0, r3, #16
                            (void *)&dofp->msgbuf[objn], dofp->msgbuf);
 801419a:	9b03      	ldr	r3, [sp, #12]
 801419c:	3314      	adds	r3, #20
 801419e:	009b      	lsls	r3, r3, #2
 80141a0:	9a07      	ldr	r2, [sp, #28]
 80141a2:	4413      	add	r3, r2
 80141a4:	3304      	adds	r3, #4
 80141a6:	9a07      	ldr	r2, [sp, #28]
 80141a8:	3254      	adds	r2, #84	; 0x54
    chFifoObjectInitAligned(&dofp->fifo, objsize, objn, objalign,
 80141aa:	9201      	str	r2, [sp, #4]
 80141ac:	9300      	str	r3, [sp, #0]
 80141ae:	9b02      	ldr	r3, [sp, #8]
 80141b0:	9a03      	ldr	r2, [sp, #12]
 80141b2:	9904      	ldr	r1, [sp, #16]
 80141b4:	f7ff fcdc 	bl	8013b70 <chFifoObjectInitAligned>
  }

  F_UNLOCK();
 80141b8:	4803      	ldr	r0, [pc, #12]	; (80141c8 <chFactoryCreateObjectsFIFO+0x68>)
 80141ba:	f7fd faa1 	bl	8011700 <chMtxUnlock>

  return dofp;
 80141be:	9b07      	ldr	r3, [sp, #28]
}
 80141c0:	4618      	mov	r0, r3
 80141c2:	b009      	add	sp, #36	; 0x24
 80141c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80141c8:	2000193c 	.word	0x2000193c
 80141cc:	2000197c 	.word	0x2000197c

080141d0 <chFactoryFindObjectsFIFO>:
 * @retval NULL         if a dynamic "objects FIFO" object with the specified
 *                      name does not exist.
 *
 * @api
 */
dyn_objects_fifo_t *chFactoryFindObjectsFIFO(const char *name) {
 80141d0:	b500      	push	{lr}
 80141d2:	b085      	sub	sp, #20
 80141d4:	9001      	str	r0, [sp, #4]
  dyn_objects_fifo_t *dofp;

  F_LOCK();
 80141d6:	4808      	ldr	r0, [pc, #32]	; (80141f8 <chFactoryFindObjectsFIFO+0x28>)
 80141d8:	f7fd f9c2 	bl	8011560 <chMtxLock>

  dofp = (dyn_objects_fifo_t *)dyn_find_object(name, &ch_factory.fifo_list);
 80141dc:	4907      	ldr	r1, [pc, #28]	; (80141fc <chFactoryFindObjectsFIFO+0x2c>)
 80141de:	9801      	ldr	r0, [sp, #4]
 80141e0:	f7ff fe06 	bl	8013df0 <dyn_find_object>
 80141e4:	9003      	str	r0, [sp, #12]

  F_UNLOCK();
 80141e6:	4804      	ldr	r0, [pc, #16]	; (80141f8 <chFactoryFindObjectsFIFO+0x28>)
 80141e8:	f7fd fa8a 	bl	8011700 <chMtxUnlock>

  return dofp;
 80141ec:	9b03      	ldr	r3, [sp, #12]
}
 80141ee:	4618      	mov	r0, r3
 80141f0:	b005      	add	sp, #20
 80141f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80141f6:	bf00      	nop
 80141f8:	2000193c 	.word	0x2000193c
 80141fc:	2000197c 	.word	0x2000197c

08014200 <chFactoryReleaseObjectsFIFO>:
 *
 * @param[in] dofp      dynamic "objects FIFO" object reference
 *
 * @api
 */
void chFactoryReleaseObjectsFIFO(dyn_objects_fifo_t *dofp) {
 8014200:	b500      	push	{lr}
 8014202:	b083      	sub	sp, #12
 8014204:	9001      	str	r0, [sp, #4]

  F_LOCK();
 8014206:	4807      	ldr	r0, [pc, #28]	; (8014224 <chFactoryReleaseObjectsFIFO+0x24>)
 8014208:	f7fd f9aa 	bl	8011560 <chMtxLock>

  dyn_release_object_heap(&dofp->element, &ch_factory.fifo_list);
 801420c:	9b01      	ldr	r3, [sp, #4]
 801420e:	4906      	ldr	r1, [pc, #24]	; (8014228 <chFactoryReleaseObjectsFIFO+0x28>)
 8014210:	4618      	mov	r0, r3
 8014212:	f7ff fd5d 	bl	8013cd0 <dyn_release_object_heap>

  F_UNLOCK();
 8014216:	4803      	ldr	r0, [pc, #12]	; (8014224 <chFactoryReleaseObjectsFIFO+0x24>)
 8014218:	f7fd fa72 	bl	8011700 <chMtxUnlock>
}
 801421c:	b003      	add	sp, #12
 801421e:	f85d fb04 	ldr.w	pc, [sp], #4
 8014222:	bf00      	nop
 8014224:	2000193c 	.word	0x2000193c
 8014228:	2000197c 	.word	0x2000197c
 801422c:	00000000 	.word	0x00000000

08014230 <chFactoryCreatePipe>:
 *                      allocated or a dynamic pipe object with
 *                      the same name exists.
 *
 * @api
 */
dyn_pipe_t *chFactoryCreatePipe(const char *name, size_t size) {
 8014230:	b500      	push	{lr}
 8014232:	b085      	sub	sp, #20
 8014234:	9001      	str	r0, [sp, #4]
 8014236:	9100      	str	r1, [sp, #0]
  dyn_pipe_t *dpp;

  F_LOCK();
 8014238:	480f      	ldr	r0, [pc, #60]	; (8014278 <chFactoryCreatePipe+0x48>)
 801423a:	f7fd f991 	bl	8011560 <chMtxLock>

  dpp = (dyn_pipe_t *)dyn_create_object_heap(name,
 801423e:	9b00      	ldr	r3, [sp, #0]
 8014240:	3360      	adds	r3, #96	; 0x60
 8014242:	461a      	mov	r2, r3
 8014244:	490d      	ldr	r1, [pc, #52]	; (801427c <chFactoryCreatePipe+0x4c>)
 8014246:	9801      	ldr	r0, [sp, #4]
 8014248:	f7ff fd0a 	bl	8013c60 <dyn_create_object_heap>
 801424c:	9003      	str	r0, [sp, #12]
                                             &ch_factory.pipe_list,
                                             sizeof (dyn_pipe_t) + size);
  if (dpp != NULL) {
 801424e:	9b03      	ldr	r3, [sp, #12]
 8014250:	2b00      	cmp	r3, #0
 8014252:	d008      	beq.n	8014266 <chFactoryCreatePipe+0x36>
    /* Initializing mailbox object data.*/
    chPipeObjectInit(&dpp->pipe, dpp->buffer, size);
 8014254:	9b03      	ldr	r3, [sp, #12]
 8014256:	f103 0010 	add.w	r0, r3, #16
 801425a:	9b03      	ldr	r3, [sp, #12]
 801425c:	3360      	adds	r3, #96	; 0x60
 801425e:	9a00      	ldr	r2, [sp, #0]
 8014260:	4619      	mov	r1, r3
 8014262:	f7ff fb25 	bl	80138b0 <chPipeObjectInit>
  }

  F_UNLOCK();
 8014266:	4804      	ldr	r0, [pc, #16]	; (8014278 <chFactoryCreatePipe+0x48>)
 8014268:	f7fd fa4a 	bl	8011700 <chMtxUnlock>

  return dpp;
 801426c:	9b03      	ldr	r3, [sp, #12]
}
 801426e:	4618      	mov	r0, r3
 8014270:	b005      	add	sp, #20
 8014272:	f85d fb04 	ldr.w	pc, [sp], #4
 8014276:	bf00      	nop
 8014278:	2000193c 	.word	0x2000193c
 801427c:	20001980 	.word	0x20001980

08014280 <chFactoryFindPipe>:
 * @retval NULL         if a dynamic pipe object with the specified
 *                      name does not exist.
 *
 * @api
 */
dyn_pipe_t *chFactoryFindPipe(const char *name) {
 8014280:	b500      	push	{lr}
 8014282:	b085      	sub	sp, #20
 8014284:	9001      	str	r0, [sp, #4]
  dyn_pipe_t *dpp;

  F_LOCK();
 8014286:	4808      	ldr	r0, [pc, #32]	; (80142a8 <chFactoryFindPipe+0x28>)
 8014288:	f7fd f96a 	bl	8011560 <chMtxLock>

  dpp = (dyn_pipe_t *)dyn_find_object(name, &ch_factory.pipe_list);
 801428c:	4907      	ldr	r1, [pc, #28]	; (80142ac <chFactoryFindPipe+0x2c>)
 801428e:	9801      	ldr	r0, [sp, #4]
 8014290:	f7ff fdae 	bl	8013df0 <dyn_find_object>
 8014294:	9003      	str	r0, [sp, #12]

  F_UNLOCK();
 8014296:	4804      	ldr	r0, [pc, #16]	; (80142a8 <chFactoryFindPipe+0x28>)
 8014298:	f7fd fa32 	bl	8011700 <chMtxUnlock>

  return dpp;
 801429c:	9b03      	ldr	r3, [sp, #12]
}
 801429e:	4618      	mov	r0, r3
 80142a0:	b005      	add	sp, #20
 80142a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80142a6:	bf00      	nop
 80142a8:	2000193c 	.word	0x2000193c
 80142ac:	20001980 	.word	0x20001980

080142b0 <chFactoryReleasePipe>:
 *
 * @param[in] dpp       dynamic pipe object reference
 *
 * @api
 */
void chFactoryReleasePipe(dyn_pipe_t *dpp) {
 80142b0:	b500      	push	{lr}
 80142b2:	b083      	sub	sp, #12
 80142b4:	9001      	str	r0, [sp, #4]

  F_LOCK();
 80142b6:	4807      	ldr	r0, [pc, #28]	; (80142d4 <chFactoryReleasePipe+0x24>)
 80142b8:	f7fd f952 	bl	8011560 <chMtxLock>

  dyn_release_object_heap(&dpp->element, &ch_factory.pipe_list);
 80142bc:	9b01      	ldr	r3, [sp, #4]
 80142be:	4906      	ldr	r1, [pc, #24]	; (80142d8 <chFactoryReleasePipe+0x28>)
 80142c0:	4618      	mov	r0, r3
 80142c2:	f7ff fd05 	bl	8013cd0 <dyn_release_object_heap>

  F_UNLOCK();
 80142c6:	4803      	ldr	r0, [pc, #12]	; (80142d4 <chFactoryReleasePipe+0x24>)
 80142c8:	f7fd fa1a 	bl	8011700 <chMtxUnlock>
}
 80142cc:	b003      	add	sp, #12
 80142ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80142d2:	bf00      	nop
 80142d4:	2000193c 	.word	0x2000193c
 80142d8:	20001980 	.word	0x20001980
 80142dc:	00000000 	.word	0x00000000

080142e0 <port_lock.lto_priv.409>:
static inline void port_lock(void) {
 80142e0:	b082      	sub	sp, #8
 80142e2:	2320      	movs	r3, #32
 80142e4:	9301      	str	r3, [sp, #4]
 80142e6:	9b01      	ldr	r3, [sp, #4]
 80142e8:	f383 8811 	msr	BASEPRI, r3
}
 80142ec:	b002      	add	sp, #8
 80142ee:	4770      	bx	lr

080142f0 <port_unlock.lto_priv.378>:
static inline void port_unlock(void) {
 80142f0:	b082      	sub	sp, #8
 80142f2:	2300      	movs	r3, #0
 80142f4:	9301      	str	r3, [sp, #4]
 80142f6:	9b01      	ldr	r3, [sp, #4]
 80142f8:	f383 8811 	msr	BASEPRI, r3
}
 80142fc:	b002      	add	sp, #8
 80142fe:	4770      	bx	lr

08014300 <port_lock_from_isr.lto_priv.444>:
static inline void port_lock_from_isr(void) {
 8014300:	b508      	push	{r3, lr}
  port_lock();
 8014302:	f7ff ffed 	bl	80142e0 <port_lock.lto_priv.409>
}
 8014306:	bd08      	pop	{r3, pc}
	...

08014310 <port_unlock_from_isr.lto_priv.433>:
static inline void port_unlock_from_isr(void) {
 8014310:	b508      	push	{r3, lr}
  port_unlock();
 8014312:	f7ff ffed 	bl	80142f0 <port_unlock.lto_priv.378>
}
 8014316:	bd08      	pop	{r3, pc}
	...

08014320 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8014320:	b500      	push	{lr}
 8014322:	b085      	sub	sp, #20
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8014324:	f3ef 8309 	mrs	r3, PSP
 8014328:	9301      	str	r3, [sp, #4]
  return(result);
 801432a:	9b01      	ldr	r3, [sp, #4]
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 801432c:	9303      	str	r3, [sp, #12]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 801432e:	9b03      	ldr	r3, [sp, #12]
 8014330:	3320      	adds	r3, #32
 8014332:	9303      	str	r3, [sp, #12]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8014334:	9b03      	ldr	r3, [sp, #12]
 8014336:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8014338:	9b02      	ldr	r3, [sp, #8]
 801433a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 801433e:	f7ff ffe7 	bl	8014310 <port_unlock_from_isr.lto_priv.433>
}
 8014342:	b005      	add	sp, #20
 8014344:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08014350 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8014350:	b500      	push	{lr}
 8014352:	b085      	sub	sp, #20

  port_lock_from_isr();
 8014354:	f7ff ffd4 	bl	8014300 <port_lock_from_isr.lto_priv.444>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8014358:	4b14      	ldr	r3, [pc, #80]	; (80143ac <_port_irq_epilogue+0x5c>)
 801435a:	685b      	ldr	r3, [r3, #4]
 801435c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8014360:	2b00      	cmp	r3, #0
 8014362:	d01d      	beq.n	80143a0 <_port_irq_epilogue+0x50>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8014364:	f3ef 8309 	mrs	r3, PSP
 8014368:	9301      	str	r3, [sp, #4]
  return(result);
 801436a:	9b01      	ldr	r3, [sp, #4]
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 801436c:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 801436e:	9b03      	ldr	r3, [sp, #12]
 8014370:	3b20      	subs	r3, #32
 8014372:	9303      	str	r3, [sp, #12]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8014374:	9b03      	ldr	r3, [sp, #12]
 8014376:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 801437a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 801437c:	9b03      	ldr	r3, [sp, #12]
 801437e:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8014380:	9b02      	ldr	r3, [sp, #8]
 8014382:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8014386:	f7fb fda3 	bl	800fed0 <chSchIsPreemptionRequired>
 801438a:	4603      	mov	r3, r0
 801438c:	2b00      	cmp	r3, #0
 801438e:	d003      	beq.n	8014398 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8014390:	9b03      	ldr	r3, [sp, #12]
 8014392:	4a07      	ldr	r2, [pc, #28]	; (80143b0 <_port_irq_epilogue+0x60>)
 8014394:	619a      	str	r2, [r3, #24]
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8014396:	e005      	b.n	80143a4 <_port_irq_epilogue+0x54>
 8014398:	9b03      	ldr	r3, [sp, #12]
 801439a:	4a06      	ldr	r2, [pc, #24]	; (80143b4 <_port_irq_epilogue+0x64>)
 801439c:	619a      	str	r2, [r3, #24]
 801439e:	e001      	b.n	80143a4 <_port_irq_epilogue+0x54>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 80143a0:	f7ff ffb6 	bl	8014310 <port_unlock_from_isr.lto_priv.433>
}
 80143a4:	b005      	add	sp, #20
 80143a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80143aa:	bf00      	nop
 80143ac:	e000ed00 	.word	0xe000ed00
 80143b0:	08000305 	.word	0x08000305
 80143b4:	08000310 	.word	0x08000310
	...

080143c0 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 80143c0:	b088      	sub	sp, #32
 80143c2:	9003      	str	r0, [sp, #12]
 80143c4:	9102      	str	r1, [sp, #8]
 80143c6:	9201      	str	r2, [sp, #4]
 80143c8:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 80143ca:	9b02      	ldr	r3, [sp, #8]
 80143cc:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 80143ce:	9b00      	ldr	r3, [sp, #0]
 80143d0:	2b00      	cmp	r3, #0
 80143d2:	d102      	bne.n	80143da <long_to_string_with_divisor+0x1a>
    ll = num;
 80143d4:	9b02      	ldr	r3, [sp, #8]
 80143d6:	9304      	str	r3, [sp, #16]
 80143d8:	e001      	b.n	80143de <long_to_string_with_divisor+0x1e>
  } else {
    ll = divisor;
 80143da:	9b00      	ldr	r3, [sp, #0]
 80143dc:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 80143de:	9b03      	ldr	r3, [sp, #12]
 80143e0:	330b      	adds	r3, #11
 80143e2:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 80143e4:	9b05      	ldr	r3, [sp, #20]
 80143e6:	9a01      	ldr	r2, [sp, #4]
 80143e8:	fbb3 f2f2 	udiv	r2, r3, r2
 80143ec:	9901      	ldr	r1, [sp, #4]
 80143ee:	fb01 f202 	mul.w	r2, r1, r2
 80143f2:	1a9b      	subs	r3, r3, r2
 80143f4:	9307      	str	r3, [sp, #28]
    i += '0';
 80143f6:	9b07      	ldr	r3, [sp, #28]
 80143f8:	3330      	adds	r3, #48	; 0x30
 80143fa:	9307      	str	r3, [sp, #28]
    if (i > '9')
 80143fc:	9b07      	ldr	r3, [sp, #28]
 80143fe:	2b39      	cmp	r3, #57	; 0x39
 8014400:	dd02      	ble.n	8014408 <long_to_string_with_divisor+0x48>
      i += 'A' - '0' - 10;
 8014402:	9b07      	ldr	r3, [sp, #28]
 8014404:	3307      	adds	r3, #7
 8014406:	9307      	str	r3, [sp, #28]
    *--q = i;
 8014408:	9b06      	ldr	r3, [sp, #24]
 801440a:	3b01      	subs	r3, #1
 801440c:	9306      	str	r3, [sp, #24]
 801440e:	9b07      	ldr	r3, [sp, #28]
 8014410:	b2da      	uxtb	r2, r3
 8014412:	9b06      	ldr	r3, [sp, #24]
 8014414:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8014416:	9a05      	ldr	r2, [sp, #20]
 8014418:	9b01      	ldr	r3, [sp, #4]
 801441a:	fbb2 f3f3 	udiv	r3, r2, r3
 801441e:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8014420:	9a04      	ldr	r2, [sp, #16]
 8014422:	9b01      	ldr	r3, [sp, #4]
 8014424:	fbb2 f3f3 	udiv	r3, r2, r3
 8014428:	9304      	str	r3, [sp, #16]
 801442a:	9b04      	ldr	r3, [sp, #16]
 801442c:	2b00      	cmp	r3, #0
 801442e:	d1d9      	bne.n	80143e4 <long_to_string_with_divisor+0x24>

  i = (int)(p + MAX_FILLER - q);
 8014430:	9b03      	ldr	r3, [sp, #12]
 8014432:	330b      	adds	r3, #11
 8014434:	461a      	mov	r2, r3
 8014436:	9b06      	ldr	r3, [sp, #24]
 8014438:	1ad3      	subs	r3, r2, r3
 801443a:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 801443c:	9a06      	ldr	r2, [sp, #24]
 801443e:	1c53      	adds	r3, r2, #1
 8014440:	9306      	str	r3, [sp, #24]
 8014442:	9b03      	ldr	r3, [sp, #12]
 8014444:	1c59      	adds	r1, r3, #1
 8014446:	9103      	str	r1, [sp, #12]
 8014448:	7812      	ldrb	r2, [r2, #0]
 801444a:	701a      	strb	r2, [r3, #0]
  while (--i);
 801444c:	9b07      	ldr	r3, [sp, #28]
 801444e:	3b01      	subs	r3, #1
 8014450:	9307      	str	r3, [sp, #28]
 8014452:	9b07      	ldr	r3, [sp, #28]
 8014454:	2b00      	cmp	r3, #0
 8014456:	d1f1      	bne.n	801443c <long_to_string_with_divisor+0x7c>

  return p;
 8014458:	9b03      	ldr	r3, [sp, #12]
}
 801445a:	4618      	mov	r0, r3
 801445c:	b008      	add	sp, #32
 801445e:	4770      	bx	lr

08014460 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8014460:	b500      	push	{lr}
 8014462:	b085      	sub	sp, #20
 8014464:	9003      	str	r0, [sp, #12]
 8014466:	9102      	str	r1, [sp, #8]
 8014468:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 801446a:	2300      	movs	r3, #0
 801446c:	9a01      	ldr	r2, [sp, #4]
 801446e:	9902      	ldr	r1, [sp, #8]
 8014470:	9803      	ldr	r0, [sp, #12]
 8014472:	f7ff ffa5 	bl	80143c0 <long_to_string_with_divisor>
 8014476:	4603      	mov	r3, r0
}
 8014478:	4618      	mov	r0, r3
 801447a:	b005      	add	sp, #20
 801447c:	f85d fb04 	ldr.w	pc, [sp], #4

08014480 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8014480:	b500      	push	{lr}
 8014482:	b091      	sub	sp, #68	; 0x44
 8014484:	9003      	str	r0, [sp, #12]
 8014486:	9102      	str	r1, [sp, #8]
 8014488:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 801448a:	2300      	movs	r3, #0
 801448c:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 801448e:	9b02      	ldr	r3, [sp, #8]
 8014490:	1c5a      	adds	r2, r3, #1
 8014492:	9202      	str	r2, [sp, #8]
 8014494:	781b      	ldrb	r3, [r3, #0]
 8014496:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0)
 801449a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801449e:	2b00      	cmp	r3, #0
 80144a0:	d101      	bne.n	80144a6 <chvprintf+0x26>
      return n;
 80144a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80144a4:	e20b      	b.n	80148be <chvprintf+0x43e>
    if (c != '%') {
 80144a6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80144aa:	2b25      	cmp	r3, #37	; 0x25
 80144ac:	d00b      	beq.n	80144c6 <chvprintf+0x46>
      streamPut(chp, (uint8_t)c);
 80144ae:	9b03      	ldr	r3, [sp, #12]
 80144b0:	681b      	ldr	r3, [r3, #0]
 80144b2:	68db      	ldr	r3, [r3, #12]
 80144b4:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 80144b8:	4611      	mov	r1, r2
 80144ba:	9803      	ldr	r0, [sp, #12]
 80144bc:	4798      	blx	r3
      n++;
 80144be:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80144c0:	3301      	adds	r3, #1
 80144c2:	9309      	str	r3, [sp, #36]	; 0x24
 80144c4:	e7e3      	b.n	801448e <chvprintf+0xe>
      continue;
    }
    p = tmpbuf;
 80144c6:	ab04      	add	r3, sp, #16
 80144c8:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 80144ca:	ab04      	add	r3, sp, #16
 80144cc:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 80144ce:	2300      	movs	r3, #0
 80144d0:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 80144d4:	9b02      	ldr	r3, [sp, #8]
 80144d6:	781b      	ldrb	r3, [r3, #0]
 80144d8:	2b2d      	cmp	r3, #45	; 0x2d
 80144da:	d105      	bne.n	80144e8 <chvprintf+0x68>
      fmt++;
 80144dc:	9b02      	ldr	r3, [sp, #8]
 80144de:	3301      	adds	r3, #1
 80144e0:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 80144e2:	2301      	movs	r3, #1
 80144e4:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 80144e8:	2320      	movs	r3, #32
 80144ea:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 80144ee:	9b02      	ldr	r3, [sp, #8]
 80144f0:	781b      	ldrb	r3, [r3, #0]
 80144f2:	2b30      	cmp	r3, #48	; 0x30
 80144f4:	d105      	bne.n	8014502 <chvprintf+0x82>
      fmt++;
 80144f6:	9b02      	ldr	r3, [sp, #8]
 80144f8:	3301      	adds	r3, #1
 80144fa:	9302      	str	r3, [sp, #8]
      filler = '0';
 80144fc:	2330      	movs	r3, #48	; 0x30
 80144fe:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 8014502:	2300      	movs	r3, #0
 8014504:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 8014506:	9b02      	ldr	r3, [sp, #8]
 8014508:	1c5a      	adds	r2, r3, #1
 801450a:	9202      	str	r2, [sp, #8]
 801450c:	781b      	ldrb	r3, [r3, #0]
 801450e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
 8014512:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8014516:	2b2f      	cmp	r3, #47	; 0x2f
 8014518:	d909      	bls.n	801452e <chvprintf+0xae>
 801451a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801451e:	2b39      	cmp	r3, #57	; 0x39
 8014520:	d805      	bhi.n	801452e <chvprintf+0xae>
        c -= '0';
 8014522:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8014526:	3b30      	subs	r3, #48	; 0x30
 8014528:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 801452c:	e009      	b.n	8014542 <chvprintf+0xc2>
      else if (c == '*')
 801452e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8014532:	2b2a      	cmp	r3, #42	; 0x2a
 8014534:	d110      	bne.n	8014558 <chvprintf+0xd8>
        c = va_arg(ap, int);
 8014536:	9b01      	ldr	r3, [sp, #4]
 8014538:	1d1a      	adds	r2, r3, #4
 801453a:	9201      	str	r2, [sp, #4]
 801453c:	681b      	ldr	r3, [r3, #0]
 801453e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      else
        break;
      width = width * 10 + c;
 8014542:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8014544:	4613      	mov	r3, r2
 8014546:	009b      	lsls	r3, r3, #2
 8014548:	4413      	add	r3, r2
 801454a:	005b      	lsls	r3, r3, #1
 801454c:	461a      	mov	r2, r3
 801454e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8014552:	4413      	add	r3, r2
 8014554:	930a      	str	r3, [sp, #40]	; 0x28
 8014556:	e7d6      	b.n	8014506 <chvprintf+0x86>
    }
    precision = 0;
 8014558:	2300      	movs	r3, #0
 801455a:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 801455c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8014560:	2b2e      	cmp	r3, #46	; 0x2e
 8014562:	d129      	bne.n	80145b8 <chvprintf+0x138>
      while (TRUE) {
        c = *fmt++;
 8014564:	9b02      	ldr	r3, [sp, #8]
 8014566:	1c5a      	adds	r2, r3, #1
 8014568:	9202      	str	r2, [sp, #8]
 801456a:	781b      	ldrb	r3, [r3, #0]
 801456c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
 8014570:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8014574:	2b2f      	cmp	r3, #47	; 0x2f
 8014576:	d909      	bls.n	801458c <chvprintf+0x10c>
 8014578:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801457c:	2b39      	cmp	r3, #57	; 0x39
 801457e:	d805      	bhi.n	801458c <chvprintf+0x10c>
          c -= '0';
 8014580:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8014584:	3b30      	subs	r3, #48	; 0x30
 8014586:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 801458a:	e009      	b.n	80145a0 <chvprintf+0x120>
        else if (c == '*')
 801458c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8014590:	2b2a      	cmp	r3, #42	; 0x2a
 8014592:	d111      	bne.n	80145b8 <chvprintf+0x138>
          c = va_arg(ap, int);
 8014594:	9b01      	ldr	r3, [sp, #4]
 8014596:	1d1a      	adds	r2, r3, #4
 8014598:	9201      	str	r2, [sp, #4]
 801459a:	681b      	ldr	r3, [r3, #0]
 801459c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        else
          break;
        precision *= 10;
 80145a0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80145a2:	4613      	mov	r3, r2
 80145a4:	009b      	lsls	r3, r3, #2
 80145a6:	4413      	add	r3, r2
 80145a8:	005b      	lsls	r3, r3, #1
 80145aa:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 80145ac:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80145b0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80145b2:	4413      	add	r3, r2
 80145b4:	930b      	str	r3, [sp, #44]	; 0x2c
 80145b6:	e7d5      	b.n	8014564 <chvprintf+0xe4>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80145b8:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80145bc:	2b6c      	cmp	r3, #108	; 0x6c
 80145be:	d003      	beq.n	80145c8 <chvprintf+0x148>
 80145c0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80145c4:	2b4c      	cmp	r3, #76	; 0x4c
 80145c6:	d10d      	bne.n	80145e4 <chvprintf+0x164>
      is_long = TRUE;
 80145c8:	2301      	movs	r3, #1
 80145ca:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 80145ce:	9b02      	ldr	r3, [sp, #8]
 80145d0:	781b      	ldrb	r3, [r3, #0]
 80145d2:	2b00      	cmp	r3, #0
 80145d4:	d01a      	beq.n	801460c <chvprintf+0x18c>
        c = *fmt++;
 80145d6:	9b02      	ldr	r3, [sp, #8]
 80145d8:	1c5a      	adds	r2, r3, #1
 80145da:	9202      	str	r2, [sp, #8]
 80145dc:	781b      	ldrb	r3, [r3, #0]
 80145de:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80145e2:	e014      	b.n	801460e <chvprintf+0x18e>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 80145e4:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80145e8:	2b40      	cmp	r3, #64	; 0x40
 80145ea:	d905      	bls.n	80145f8 <chvprintf+0x178>
 80145ec:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80145f0:	2b5a      	cmp	r3, #90	; 0x5a
 80145f2:	d801      	bhi.n	80145f8 <chvprintf+0x178>
 80145f4:	2301      	movs	r3, #1
 80145f6:	e000      	b.n	80145fa <chvprintf+0x17a>
 80145f8:	2300      	movs	r3, #0
 80145fa:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 80145fe:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8014602:	f003 0301 	and.w	r3, r3, #1
 8014606:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 801460a:	e000      	b.n	801460e <chvprintf+0x18e>
        c = *fmt++;
 801460c:	bf00      	nop

    /* Command decoding.*/
    switch (c) {
 801460e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8014612:	3b44      	subs	r3, #68	; 0x44
 8014614:	2b34      	cmp	r3, #52	; 0x34
 8014616:	f200 80e2 	bhi.w	80147de <chvprintf+0x35e>
 801461a:	a201      	add	r2, pc, #4	; (adr r2, 8014620 <chvprintf+0x1a0>)
 801461c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014620:	08014757 	.word	0x08014757
 8014624:	080147df 	.word	0x080147df
 8014628:	080147df 	.word	0x080147df
 801462c:	080147df 	.word	0x080147df
 8014630:	080147df 	.word	0x080147df
 8014634:	08014757 	.word	0x08014757
 8014638:	080147df 	.word	0x080147df
 801463c:	080147df 	.word	0x080147df
 8014640:	080147df 	.word	0x080147df
 8014644:	080147df 	.word	0x080147df
 8014648:	080147df 	.word	0x080147df
 801464c:	080147a9 	.word	0x080147a9
 8014650:	080147df 	.word	0x080147df
 8014654:	080147df 	.word	0x080147df
 8014658:	080147df 	.word	0x080147df
 801465c:	080147df 	.word	0x080147df
 8014660:	080147df 	.word	0x080147df
 8014664:	080147a1 	.word	0x080147a1
 8014668:	080147df 	.word	0x080147df
 801466c:	080147df 	.word	0x080147df
 8014670:	08014799 	.word	0x08014799
 8014674:	080147df 	.word	0x080147df
 8014678:	080147df 	.word	0x080147df
 801467c:	080147df 	.word	0x080147df
 8014680:	080147df 	.word	0x080147df
 8014684:	080147df 	.word	0x080147df
 8014688:	080147df 	.word	0x080147df
 801468c:	080147df 	.word	0x080147df
 8014690:	080147df 	.word	0x080147df
 8014694:	080147df 	.word	0x080147df
 8014698:	080147df 	.word	0x080147df
 801469c:	080146f5 	.word	0x080146f5
 80146a0:	08014757 	.word	0x08014757
 80146a4:	080147df 	.word	0x080147df
 80146a8:	080147df 	.word	0x080147df
 80146ac:	080147df 	.word	0x080147df
 80146b0:	080147df 	.word	0x080147df
 80146b4:	08014757 	.word	0x08014757
 80146b8:	080147df 	.word	0x080147df
 80146bc:	080147df 	.word	0x080147df
 80146c0:	080147df 	.word	0x080147df
 80146c4:	080147df 	.word	0x080147df
 80146c8:	080147df 	.word	0x080147df
 80146cc:	080147a9 	.word	0x080147a9
 80146d0:	080147df 	.word	0x080147df
 80146d4:	080147df 	.word	0x080147df
 80146d8:	080147df 	.word	0x080147df
 80146dc:	0801470f 	.word	0x0801470f
 80146e0:	080147df 	.word	0x080147df
 80146e4:	080147a1 	.word	0x080147a1
 80146e8:	080147df 	.word	0x080147df
 80146ec:	080147df 	.word	0x080147df
 80146f0:	08014799 	.word	0x08014799
    case 'c':
      filler = ' ';
 80146f4:	2320      	movs	r3, #32
 80146f6:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 80146fa:	9b01      	ldr	r3, [sp, #4]
 80146fc:	1d1a      	adds	r2, r3, #4
 80146fe:	9201      	str	r2, [sp, #4]
 8014700:	6819      	ldr	r1, [r3, #0]
 8014702:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8014704:	1c5a      	adds	r2, r3, #1
 8014706:	920f      	str	r2, [sp, #60]	; 0x3c
 8014708:	b2ca      	uxtb	r2, r1
 801470a:	701a      	strb	r2, [r3, #0]
 801470c:	e06d      	b.n	80147ea <chvprintf+0x36a>
      break;
    case 's':
      filler = ' ';
 801470e:	2320      	movs	r3, #32
 8014710:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 8014714:	9b01      	ldr	r3, [sp, #4]
 8014716:	1d1a      	adds	r2, r3, #4
 8014718:	9201      	str	r2, [sp, #4]
 801471a:	681b      	ldr	r3, [r3, #0]
 801471c:	930e      	str	r3, [sp, #56]	; 0x38
 801471e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8014720:	2b00      	cmp	r3, #0
 8014722:	d101      	bne.n	8014728 <chvprintf+0x2a8>
        s = "(null)";
 8014724:	4b68      	ldr	r3, [pc, #416]	; (80148c8 <chvprintf+0x448>)
 8014726:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 8014728:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801472a:	2b00      	cmp	r3, #0
 801472c:	d102      	bne.n	8014734 <chvprintf+0x2b4>
        precision = 32767;
 801472e:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8014732:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 8014734:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8014736:	930f      	str	r3, [sp, #60]	; 0x3c
 8014738:	e002      	b.n	8014740 <chvprintf+0x2c0>
 801473a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801473c:	3301      	adds	r3, #1
 801473e:	930f      	str	r3, [sp, #60]	; 0x3c
 8014740:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8014742:	781b      	ldrb	r3, [r3, #0]
 8014744:	2b00      	cmp	r3, #0
 8014746:	d050      	beq.n	80147ea <chvprintf+0x36a>
 8014748:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801474a:	3b01      	subs	r3, #1
 801474c:	930b      	str	r3, [sp, #44]	; 0x2c
 801474e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014750:	2b00      	cmp	r3, #0
 8014752:	daf2      	bge.n	801473a <chvprintf+0x2ba>
 8014754:	e049      	b.n	80147ea <chvprintf+0x36a>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 8014756:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 801475a:	2b00      	cmp	r3, #0
 801475c:	d005      	beq.n	801476a <chvprintf+0x2ea>
        l = va_arg(ap, long);
 801475e:	9b01      	ldr	r3, [sp, #4]
 8014760:	1d1a      	adds	r2, r3, #4
 8014762:	9201      	str	r2, [sp, #4]
 8014764:	681b      	ldr	r3, [r3, #0]
 8014766:	9307      	str	r3, [sp, #28]
 8014768:	e004      	b.n	8014774 <chvprintf+0x2f4>
      else
        l = va_arg(ap, int);
 801476a:	9b01      	ldr	r3, [sp, #4]
 801476c:	1d1a      	adds	r2, r3, #4
 801476e:	9201      	str	r2, [sp, #4]
 8014770:	681b      	ldr	r3, [r3, #0]
 8014772:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 8014774:	9b07      	ldr	r3, [sp, #28]
 8014776:	2b00      	cmp	r3, #0
 8014778:	da07      	bge.n	801478a <chvprintf+0x30a>
        *p++ = '-';
 801477a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801477c:	1c5a      	adds	r2, r3, #1
 801477e:	920f      	str	r2, [sp, #60]	; 0x3c
 8014780:	222d      	movs	r2, #45	; 0x2d
 8014782:	701a      	strb	r2, [r3, #0]
        l = -l;
 8014784:	9b07      	ldr	r3, [sp, #28]
 8014786:	425b      	negs	r3, r3
 8014788:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 801478a:	220a      	movs	r2, #10
 801478c:	9907      	ldr	r1, [sp, #28]
 801478e:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8014790:	f7ff fe66 	bl	8014460 <ch_ltoa>
 8014794:	900f      	str	r0, [sp, #60]	; 0x3c
 8014796:	e028      	b.n	80147ea <chvprintf+0x36a>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8014798:	2310      	movs	r3, #16
 801479a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 801479e:	e006      	b.n	80147ae <chvprintf+0x32e>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 80147a0:	230a      	movs	r3, #10
 80147a2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80147a6:	e002      	b.n	80147ae <chvprintf+0x32e>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 80147a8:	2308      	movs	r3, #8
 80147aa:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 80147ae:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80147b2:	2b00      	cmp	r3, #0
 80147b4:	d005      	beq.n	80147c2 <chvprintf+0x342>
        l = va_arg(ap, unsigned long);
 80147b6:	9b01      	ldr	r3, [sp, #4]
 80147b8:	1d1a      	adds	r2, r3, #4
 80147ba:	9201      	str	r2, [sp, #4]
 80147bc:	681b      	ldr	r3, [r3, #0]
 80147be:	9307      	str	r3, [sp, #28]
 80147c0:	e004      	b.n	80147cc <chvprintf+0x34c>
      else
        l = va_arg(ap, unsigned int);
 80147c2:	9b01      	ldr	r3, [sp, #4]
 80147c4:	1d1a      	adds	r2, r3, #4
 80147c6:	9201      	str	r2, [sp, #4]
 80147c8:	681b      	ldr	r3, [r3, #0]
 80147ca:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 80147cc:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80147d0:	461a      	mov	r2, r3
 80147d2:	9907      	ldr	r1, [sp, #28]
 80147d4:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80147d6:	f7ff fe43 	bl	8014460 <ch_ltoa>
 80147da:	900f      	str	r0, [sp, #60]	; 0x3c
 80147dc:	e005      	b.n	80147ea <chvprintf+0x36a>
      break;
    default:
      *p++ = c;
 80147de:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80147e0:	1c5a      	adds	r2, r3, #1
 80147e2:	920f      	str	r2, [sp, #60]	; 0x3c
 80147e4:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 80147e8:	701a      	strb	r2, [r3, #0]
      break;
    }
    i = (int)(p - s);
 80147ea:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80147ec:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80147ee:	1ad3      	subs	r3, r2, r3
 80147f0:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 80147f2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80147f4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80147f6:	1ad3      	subs	r3, r2, r3
 80147f8:	930a      	str	r3, [sp, #40]	; 0x28
 80147fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80147fc:	2b00      	cmp	r3, #0
 80147fe:	da01      	bge.n	8014804 <chvprintf+0x384>
      width = 0;
 8014800:	2300      	movs	r3, #0
 8014802:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 8014804:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 8014808:	f083 0301 	eor.w	r3, r3, #1
 801480c:	b2db      	uxtb	r3, r3
 801480e:	2b00      	cmp	r3, #0
 8014810:	d002      	beq.n	8014818 <chvprintf+0x398>
      width = -width;
 8014812:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014814:	425b      	negs	r3, r3
 8014816:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 8014818:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801481a:	2b00      	cmp	r3, #0
 801481c:	da36      	bge.n	801488c <chvprintf+0x40c>
      if (*s == '-' && filler == '0') {
 801481e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8014820:	781b      	ldrb	r3, [r3, #0]
 8014822:	2b2d      	cmp	r3, #45	; 0x2d
 8014824:	d113      	bne.n	801484e <chvprintf+0x3ce>
 8014826:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 801482a:	2b30      	cmp	r3, #48	; 0x30
 801482c:	d10f      	bne.n	801484e <chvprintf+0x3ce>
        streamPut(chp, (uint8_t)*s++);
 801482e:	9b03      	ldr	r3, [sp, #12]
 8014830:	681b      	ldr	r3, [r3, #0]
 8014832:	68da      	ldr	r2, [r3, #12]
 8014834:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8014836:	1c59      	adds	r1, r3, #1
 8014838:	910e      	str	r1, [sp, #56]	; 0x38
 801483a:	781b      	ldrb	r3, [r3, #0]
 801483c:	4619      	mov	r1, r3
 801483e:	9803      	ldr	r0, [sp, #12]
 8014840:	4790      	blx	r2
        n++;
 8014842:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014844:	3301      	adds	r3, #1
 8014846:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 8014848:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801484a:	3b01      	subs	r3, #1
 801484c:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 801484e:	9b03      	ldr	r3, [sp, #12]
 8014850:	681b      	ldr	r3, [r3, #0]
 8014852:	68db      	ldr	r3, [r3, #12]
 8014854:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 8014858:	4611      	mov	r1, r2
 801485a:	9803      	ldr	r0, [sp, #12]
 801485c:	4798      	blx	r3
        n++;
 801485e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014860:	3301      	adds	r3, #1
 8014862:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 8014864:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014866:	3301      	adds	r3, #1
 8014868:	930a      	str	r3, [sp, #40]	; 0x28
 801486a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801486c:	2b00      	cmp	r3, #0
 801486e:	d1ee      	bne.n	801484e <chvprintf+0x3ce>
 8014870:	e00c      	b.n	801488c <chvprintf+0x40c>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8014872:	9b03      	ldr	r3, [sp, #12]
 8014874:	681b      	ldr	r3, [r3, #0]
 8014876:	68da      	ldr	r2, [r3, #12]
 8014878:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801487a:	1c59      	adds	r1, r3, #1
 801487c:	910e      	str	r1, [sp, #56]	; 0x38
 801487e:	781b      	ldrb	r3, [r3, #0]
 8014880:	4619      	mov	r1, r3
 8014882:	9803      	ldr	r0, [sp, #12]
 8014884:	4790      	blx	r2
      n++;
 8014886:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014888:	3301      	adds	r3, #1
 801488a:	9309      	str	r3, [sp, #36]	; 0x24
    while (--i >= 0) {
 801488c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801488e:	3b01      	subs	r3, #1
 8014890:	930c      	str	r3, [sp, #48]	; 0x30
 8014892:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8014894:	2b00      	cmp	r3, #0
 8014896:	daec      	bge.n	8014872 <chvprintf+0x3f2>
 8014898:	e00d      	b.n	80148b6 <chvprintf+0x436>
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 801489a:	9b03      	ldr	r3, [sp, #12]
 801489c:	681b      	ldr	r3, [r3, #0]
 801489e:	68db      	ldr	r3, [r3, #12]
 80148a0:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 80148a4:	4611      	mov	r1, r2
 80148a6:	9803      	ldr	r0, [sp, #12]
 80148a8:	4798      	blx	r3
      n++;
 80148aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80148ac:	3301      	adds	r3, #1
 80148ae:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 80148b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80148b2:	3b01      	subs	r3, #1
 80148b4:	930a      	str	r3, [sp, #40]	; 0x28
    while (width) {
 80148b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80148b8:	2b00      	cmp	r3, #0
 80148ba:	d1ee      	bne.n	801489a <chvprintf+0x41a>
 80148bc:	e5e7      	b.n	801448e <chvprintf+0xe>
    }
  }
}
 80148be:	4618      	mov	r0, r3
 80148c0:	b011      	add	sp, #68	; 0x44
 80148c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80148c6:	bf00      	nop
 80148c8:	08018e38 	.word	0x08018e38
 80148cc:	00000000 	.word	0x00000000

080148d0 <chprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80148d0:	b40e      	push	{r1, r2, r3}
 80148d2:	b500      	push	{lr}
 80148d4:	b084      	sub	sp, #16
 80148d6:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80148d8:	ab06      	add	r3, sp, #24
 80148da:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80148dc:	9a02      	ldr	r2, [sp, #8]
 80148de:	9905      	ldr	r1, [sp, #20]
 80148e0:	9801      	ldr	r0, [sp, #4]
 80148e2:	f7ff fdcd 	bl	8014480 <chvprintf>
 80148e6:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 80148e8:	9b03      	ldr	r3, [sp, #12]
}
 80148ea:	4618      	mov	r0, r3
 80148ec:	b004      	add	sp, #16
 80148ee:	f85d eb04 	ldr.w	lr, [sp], #4
 80148f2:	b003      	add	sp, #12
 80148f4:	4770      	bx	lr
 80148f6:	bf00      	nop
	...

08014900 <port_lock.lto_priv.410>:
static inline void port_lock(void) {
 8014900:	b082      	sub	sp, #8
 8014902:	2320      	movs	r3, #32
 8014904:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014906:	9b01      	ldr	r3, [sp, #4]
 8014908:	f383 8811 	msr	BASEPRI, r3
}
 801490c:	b002      	add	sp, #8
 801490e:	4770      	bx	lr

08014910 <chSysLock.lto_priv.335>:
static inline void chSysLock(void) {
 8014910:	b508      	push	{r3, lr}
  port_lock();
 8014912:	f7ff fff5 	bl	8014900 <port_lock.lto_priv.410>
  _dbg_check_lock();
 8014916:	f7fa fcd3 	bl	800f2c0 <_dbg_check_lock>
}
 801491a:	bd08      	pop	{r3, pc}
 801491c:	0000      	movs	r0, r0
	...

08014920 <chThdGetSelfX.lto_priv.418>:
  return ch.rlist.current;
 8014920:	4b01      	ldr	r3, [pc, #4]	; (8014928 <chThdGetSelfX.lto_priv.418+0x8>)
 8014922:	699b      	ldr	r3, [r3, #24]
}
 8014924:	4618      	mov	r0, r3
 8014926:	4770      	bx	lr
 8014928:	20001090 	.word	0x20001090
 801492c:	00000000 	.word	0x00000000

08014930 <chThdShouldTerminateX>:
static inline bool chThdShouldTerminateX(void) {
 8014930:	b508      	push	{r3, lr}
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8014932:	f7ff fff5 	bl	8014920 <chThdGetSelfX.lto_priv.418>
 8014936:	4603      	mov	r3, r0
 8014938:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 801493c:	f003 0304 	and.w	r3, r3, #4
 8014940:	2b00      	cmp	r3, #0
 8014942:	bf14      	ite	ne
 8014944:	2301      	movne	r3, #1
 8014946:	2300      	moveq	r3, #0
 8014948:	b2db      	uxtb	r3, r3
}
 801494a:	4618      	mov	r0, r3
 801494c:	bd08      	pop	{r3, pc}
 801494e:	bf00      	nop

08014950 <chEvtObjectInit.lto_priv.422>:
static inline void chEvtObjectInit(event_source_t *esp) {
 8014950:	b082      	sub	sp, #8
 8014952:	9001      	str	r0, [sp, #4]
  esp->next = (event_listener_t *)esp;
 8014954:	9b01      	ldr	r3, [sp, #4]
 8014956:	9a01      	ldr	r2, [sp, #4]
 8014958:	601a      	str	r2, [r3, #0]
}
 801495a:	b002      	add	sp, #8
 801495c:	4770      	bx	lr
 801495e:	bf00      	nop

08014960 <chEvtBroadcastI>:
static inline void chEvtBroadcastI(event_source_t *esp) {
 8014960:	b500      	push	{lr}
 8014962:	b083      	sub	sp, #12
 8014964:	9001      	str	r0, [sp, #4]
  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8014966:	2100      	movs	r1, #0
 8014968:	9801      	ldr	r0, [sp, #4]
 801496a:	f7fd fab9 	bl	8011ee0 <chEvtBroadcastFlagsI>
}
 801496e:	b003      	add	sp, #12
 8014970:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08014980 <parse_arguments>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *parse_arguments(char *str, char **saveptr) {
 8014980:	b500      	push	{lr}
 8014982:	b085      	sub	sp, #20
 8014984:	9001      	str	r0, [sp, #4]
 8014986:	9100      	str	r1, [sp, #0]
  char *p;

  if (str != NULL)
 8014988:	9b01      	ldr	r3, [sp, #4]
 801498a:	2b00      	cmp	r3, #0
 801498c:	d002      	beq.n	8014994 <parse_arguments+0x14>
    *saveptr = str;
 801498e:	9b00      	ldr	r3, [sp, #0]
 8014990:	9a01      	ldr	r2, [sp, #4]
 8014992:	601a      	str	r2, [r3, #0]

  p = *saveptr;
 8014994:	9b00      	ldr	r3, [sp, #0]
 8014996:	681b      	ldr	r3, [r3, #0]
 8014998:	9303      	str	r3, [sp, #12]
  if (!p) {
 801499a:	9b03      	ldr	r3, [sp, #12]
 801499c:	2b00      	cmp	r3, #0
 801499e:	d101      	bne.n	80149a4 <parse_arguments+0x24>
    return NULL;
 80149a0:	2300      	movs	r3, #0
 80149a2:	e02f      	b.n	8014a04 <parse_arguments+0x84>
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");
 80149a4:	4919      	ldr	r1, [pc, #100]	; (8014a0c <parse_arguments+0x8c>)
 80149a6:	9803      	ldr	r0, [sp, #12]
 80149a8:	f000 fff8 	bl	801599c <strspn>
 80149ac:	4602      	mov	r2, r0
 80149ae:	9b03      	ldr	r3, [sp, #12]
 80149b0:	4413      	add	r3, r2
 80149b2:	9303      	str	r3, [sp, #12]

  if (*p == '"') {
 80149b4:	9b03      	ldr	r3, [sp, #12]
 80149b6:	781b      	ldrb	r3, [r3, #0]
 80149b8:	2b22      	cmp	r3, #34	; 0x22
 80149ba:	d10a      	bne.n	80149d2 <parse_arguments+0x52>
    /* If an argument starts with a double quote then its delimiter is another
       quote.*/
    p++;
 80149bc:	9b03      	ldr	r3, [sp, #12]
 80149be:	3301      	adds	r3, #1
 80149c0:	9303      	str	r3, [sp, #12]
    *saveptr = strpbrk(p, "\"");
 80149c2:	2122      	movs	r1, #34	; 0x22
 80149c4:	9803      	ldr	r0, [sp, #12]
 80149c6:	f000 fed5 	bl	8015774 <strchr>
 80149ca:	4602      	mov	r2, r0
 80149cc:	9b00      	ldr	r3, [sp, #0]
 80149ce:	601a      	str	r2, [r3, #0]
 80149d0:	e006      	b.n	80149e0 <parse_arguments+0x60>
  }
  else {
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
 80149d2:	490e      	ldr	r1, [pc, #56]	; (8014a0c <parse_arguments+0x8c>)
 80149d4:	9803      	ldr	r0, [sp, #12]
 80149d6:	f000 ffbf 	bl	8015958 <strpbrk>
 80149da:	4602      	mov	r2, r0
 80149dc:	9b00      	ldr	r3, [sp, #0]
 80149de:	601a      	str	r2, [r3, #0]
  }

  /* Replacing the delimiter with a zero.*/
  if (*saveptr != NULL) {
 80149e0:	9b00      	ldr	r3, [sp, #0]
 80149e2:	681b      	ldr	r3, [r3, #0]
 80149e4:	2b00      	cmp	r3, #0
 80149e6:	d006      	beq.n	80149f6 <parse_arguments+0x76>
    *(*saveptr)++ = '\0';
 80149e8:	9b00      	ldr	r3, [sp, #0]
 80149ea:	681b      	ldr	r3, [r3, #0]
 80149ec:	1c59      	adds	r1, r3, #1
 80149ee:	9a00      	ldr	r2, [sp, #0]
 80149f0:	6011      	str	r1, [r2, #0]
 80149f2:	2200      	movs	r2, #0
 80149f4:	701a      	strb	r2, [r3, #0]
  }

  return *p != '\0' ? p : NULL;
 80149f6:	9b03      	ldr	r3, [sp, #12]
 80149f8:	781b      	ldrb	r3, [r3, #0]
 80149fa:	2b00      	cmp	r3, #0
 80149fc:	d001      	beq.n	8014a02 <parse_arguments+0x82>
 80149fe:	9b03      	ldr	r3, [sp, #12]
 8014a00:	e000      	b.n	8014a04 <parse_arguments+0x84>
 8014a02:	2300      	movs	r3, #0
}
 8014a04:	4618      	mov	r0, r3
 8014a06:	b005      	add	sp, #20
 8014a08:	f85d fb04 	ldr.w	pc, [sp], #4
 8014a0c:	08018e40 	.word	0x08018e40

08014a10 <list_commands>:

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {
 8014a10:	b500      	push	{lr}
 8014a12:	b083      	sub	sp, #12
 8014a14:	9001      	str	r0, [sp, #4]
 8014a16:	9100      	str	r1, [sp, #0]
 8014a18:	e009      	b.n	8014a2e <list_commands+0x1e>

  while (scp->sc_name != NULL) {
    chprintf(chp, "%s ", scp->sc_name);
 8014a1a:	9b00      	ldr	r3, [sp, #0]
 8014a1c:	681b      	ldr	r3, [r3, #0]
 8014a1e:	461a      	mov	r2, r3
 8014a20:	4906      	ldr	r1, [pc, #24]	; (8014a3c <list_commands+0x2c>)
 8014a22:	9801      	ldr	r0, [sp, #4]
 8014a24:	f7ff ff54 	bl	80148d0 <chprintf>
    scp++;
 8014a28:	9b00      	ldr	r3, [sp, #0]
 8014a2a:	3308      	adds	r3, #8
 8014a2c:	9300      	str	r3, [sp, #0]
  while (scp->sc_name != NULL) {
 8014a2e:	9b00      	ldr	r3, [sp, #0]
 8014a30:	681b      	ldr	r3, [r3, #0]
 8014a32:	2b00      	cmp	r3, #0
 8014a34:	d1f1      	bne.n	8014a1a <list_commands+0xa>
  }
}
 8014a36:	b003      	add	sp, #12
 8014a38:	f85d fb04 	ldr.w	pc, [sp], #4
 8014a3c:	08018e44 	.word	0x08018e44

08014a40 <cmdexec>:

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {
 8014a40:	b500      	push	{lr}
 8014a42:	b085      	sub	sp, #20
 8014a44:	9003      	str	r0, [sp, #12]
 8014a46:	9102      	str	r1, [sp, #8]
 8014a48:	9201      	str	r2, [sp, #4]
 8014a4a:	9300      	str	r3, [sp, #0]
 8014a4c:	e013      	b.n	8014a76 <cmdexec+0x36>

  while (scp->sc_name != NULL) {
    if (strcmp(scp->sc_name, name) == 0) {
 8014a4e:	9b03      	ldr	r3, [sp, #12]
 8014a50:	681b      	ldr	r3, [r3, #0]
 8014a52:	9901      	ldr	r1, [sp, #4]
 8014a54:	4618      	mov	r0, r3
 8014a56:	f7eb fd07 	bl	8000468 <strcmp>
 8014a5a:	4603      	mov	r3, r0
 8014a5c:	2b00      	cmp	r3, #0
 8014a5e:	d107      	bne.n	8014a70 <cmdexec+0x30>
      scp->sc_function(chp, argc, argv);
 8014a60:	9b03      	ldr	r3, [sp, #12]
 8014a62:	685b      	ldr	r3, [r3, #4]
 8014a64:	9a06      	ldr	r2, [sp, #24]
 8014a66:	9900      	ldr	r1, [sp, #0]
 8014a68:	9802      	ldr	r0, [sp, #8]
 8014a6a:	4798      	blx	r3
      return false;
 8014a6c:	2300      	movs	r3, #0
 8014a6e:	e007      	b.n	8014a80 <cmdexec+0x40>
    }
    scp++;
 8014a70:	9b03      	ldr	r3, [sp, #12]
 8014a72:	3308      	adds	r3, #8
 8014a74:	9303      	str	r3, [sp, #12]
  while (scp->sc_name != NULL) {
 8014a76:	9b03      	ldr	r3, [sp, #12]
 8014a78:	681b      	ldr	r3, [r3, #0]
 8014a7a:	2b00      	cmp	r3, #0
 8014a7c:	d1e7      	bne.n	8014a4e <cmdexec+0xe>
  }
  return true;
 8014a7e:	2301      	movs	r3, #1
}
 8014a80:	4618      	mov	r0, r3
 8014a82:	b005      	add	sp, #20
 8014a84:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08014a90 <shellThread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
 8014a90:	b500      	push	{lr}
 8014a92:	b0a3      	sub	sp, #140	; 0x8c
 8014a94:	9003      	str	r0, [sp, #12]
  int n;
  ShellConfig *scfg = p;
 8014a96:	9b03      	ldr	r3, [sp, #12]
 8014a98:	931f      	str	r3, [sp, #124]	; 0x7c
  BaseSequentialStream *chp = scfg->sc_channel;
 8014a9a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8014a9c:	681b      	ldr	r3, [r3, #0]
 8014a9e:	931e      	str	r3, [sp, #120]	; 0x78
  const ShellCommand *scp = scfg->sc_commands;
 8014aa0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8014aa2:	685b      	ldr	r3, [r3, #4]
 8014aa4:	931d      	str	r3, [sp, #116]	; 0x74
                       0,
                       0
  };
  ShellHistory *shp = &hist;
#else
  ShellHistory *shp = NULL;
 8014aa6:	2300      	movs	r3, #0
 8014aa8:	931c      	str	r3, [sp, #112]	; 0x70
#endif

  chprintf(chp, SHELL_NEWLINE_STR);
 8014aaa:	4953      	ldr	r1, [pc, #332]	; (8014bf8 <shellThread+0x168>)
 8014aac:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014aae:	f7ff ff0f 	bl	80148d0 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
 8014ab2:	4952      	ldr	r1, [pc, #328]	; (8014bfc <shellThread+0x16c>)
 8014ab4:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014ab6:	f7ff ff0b 	bl	80148d0 <chprintf>
 8014aba:	e08d      	b.n	8014bd8 <shellThread+0x148>
#if !defined(_CHIBIOS_NIL_)
  while (!chThdShouldTerminateX()) {
#else
  while (true) {
#endif
    chprintf(chp, SHELL_PROMPT_STR);
 8014abc:	4950      	ldr	r1, [pc, #320]	; (8014c00 <shellThread+0x170>)
 8014abe:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014ac0:	f7ff ff06 	bl	80148d0 <chprintf>
    if (shellGetLine(scfg, line, sizeof(line), shp)) {
 8014ac4:	a90a      	add	r1, sp, #40	; 0x28
 8014ac6:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8014ac8:	2240      	movs	r2, #64	; 0x40
 8014aca:	981f      	ldr	r0, [sp, #124]	; 0x7c
 8014acc:	f000 f8c8 	bl	8014c60 <shellGetLine>
 8014ad0:	4603      	mov	r3, r0
 8014ad2:	2b00      	cmp	r3, #0
 8014ad4:	d008      	beq.n	8014ae8 <shellThread+0x58>
#if (SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)
      chprintf(chp, SHELL_NEWLINE_STR);
 8014ad6:	4948      	ldr	r1, [pc, #288]	; (8014bf8 <shellThread+0x168>)
 8014ad8:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014ada:	f7ff fef9 	bl	80148d0 <chprintf>
      chprintf(chp, "logout");
 8014ade:	4949      	ldr	r1, [pc, #292]	; (8014c04 <shellThread+0x174>)
 8014ae0:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014ae2:	f7ff fef5 	bl	80148d0 <chprintf>
 8014ae6:	e080      	b.n	8014bea <shellThread+0x15a>
      /* Putting a delay in order to avoid an endless loop trying to read
         an unavailable stream.*/
      osalThreadSleepMilliseconds(100);
#endif
    }
    lp = parse_arguments(line, &tokp);
 8014ae8:	aa1a      	add	r2, sp, #104	; 0x68
 8014aea:	ab0a      	add	r3, sp, #40	; 0x28
 8014aec:	4611      	mov	r1, r2
 8014aee:	4618      	mov	r0, r3
 8014af0:	f7ff ff46 	bl	8014980 <parse_arguments>
 8014af4:	901b      	str	r0, [sp, #108]	; 0x6c
    cmd = lp;
 8014af6:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8014af8:	9320      	str	r3, [sp, #128]	; 0x80
    n = 0;
 8014afa:	2300      	movs	r3, #0
 8014afc:	9321      	str	r3, [sp, #132]	; 0x84
 8014afe:	e012      	b.n	8014b26 <shellThread+0x96>
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
      if (n >= SHELL_MAX_ARGUMENTS) {
 8014b00:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014b02:	2b03      	cmp	r3, #3
 8014b04:	dd06      	ble.n	8014b14 <shellThread+0x84>
        chprintf(chp, "too many arguments" SHELL_NEWLINE_STR);
 8014b06:	4940      	ldr	r1, [pc, #256]	; (8014c08 <shellThread+0x178>)
 8014b08:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014b0a:	f7ff fee1 	bl	80148d0 <chprintf>
        cmd = NULL;
 8014b0e:	2300      	movs	r3, #0
 8014b10:	9320      	str	r3, [sp, #128]	; 0x80
 8014b12:	e011      	b.n	8014b38 <shellThread+0xa8>
        break;
      }
      args[n++] = lp;
 8014b14:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014b16:	1c5a      	adds	r2, r3, #1
 8014b18:	9221      	str	r2, [sp, #132]	; 0x84
 8014b1a:	009b      	lsls	r3, r3, #2
 8014b1c:	aa22      	add	r2, sp, #136	; 0x88
 8014b1e:	4413      	add	r3, r2
 8014b20:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8014b22:	f843 2c74 	str.w	r2, [r3, #-116]
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8014b26:	ab1a      	add	r3, sp, #104	; 0x68
 8014b28:	4619      	mov	r1, r3
 8014b2a:	2000      	movs	r0, #0
 8014b2c:	f7ff ff28 	bl	8014980 <parse_arguments>
 8014b30:	901b      	str	r0, [sp, #108]	; 0x6c
 8014b32:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8014b34:	2b00      	cmp	r3, #0
 8014b36:	d1e3      	bne.n	8014b00 <shellThread+0x70>
    }
    args[n] = NULL;
 8014b38:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014b3a:	009b      	lsls	r3, r3, #2
 8014b3c:	aa22      	add	r2, sp, #136	; 0x88
 8014b3e:	4413      	add	r3, r2
 8014b40:	2200      	movs	r2, #0
 8014b42:	f843 2c74 	str.w	r2, [r3, #-116]
    if (cmd != NULL) {
 8014b46:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8014b48:	2b00      	cmp	r3, #0
 8014b4a:	d045      	beq.n	8014bd8 <shellThread+0x148>
      if (strcmp(cmd, "help") == 0) {
 8014b4c:	492f      	ldr	r1, [pc, #188]	; (8014c0c <shellThread+0x17c>)
 8014b4e:	9820      	ldr	r0, [sp, #128]	; 0x80
 8014b50:	f7eb fc8a 	bl	8000468 <strcmp>
 8014b54:	4603      	mov	r3, r0
 8014b56:	2b00      	cmp	r3, #0
 8014b58:	d11c      	bne.n	8014b94 <shellThread+0x104>
        if (n > 0) {
 8014b5a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014b5c:	2b00      	cmp	r3, #0
 8014b5e:	dd05      	ble.n	8014b6c <shellThread+0xdc>
          shellUsage(chp, "help");
 8014b60:	4a2a      	ldr	r2, [pc, #168]	; (8014c0c <shellThread+0x17c>)
 8014b62:	492b      	ldr	r1, [pc, #172]	; (8014c10 <shellThread+0x180>)
 8014b64:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014b66:	f7ff feb3 	bl	80148d0 <chprintf>
 8014b6a:	e035      	b.n	8014bd8 <shellThread+0x148>
          continue;
        }
        chprintf(chp, "Commands: help ");
 8014b6c:	4929      	ldr	r1, [pc, #164]	; (8014c14 <shellThread+0x184>)
 8014b6e:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014b70:	f7ff feae 	bl	80148d0 <chprintf>
        list_commands(chp, shell_local_commands);
 8014b74:	4928      	ldr	r1, [pc, #160]	; (8014c18 <shellThread+0x188>)
 8014b76:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014b78:	f7ff ff4a 	bl	8014a10 <list_commands>
        if (scp != NULL)
 8014b7c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8014b7e:	2b00      	cmp	r3, #0
 8014b80:	d003      	beq.n	8014b8a <shellThread+0xfa>
          list_commands(chp, scp);
 8014b82:	991d      	ldr	r1, [sp, #116]	; 0x74
 8014b84:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014b86:	f7ff ff43 	bl	8014a10 <list_commands>
        chprintf(chp, SHELL_NEWLINE_STR);
 8014b8a:	491b      	ldr	r1, [pc, #108]	; (8014bf8 <shellThread+0x168>)
 8014b8c:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014b8e:	f7ff fe9f 	bl	80148d0 <chprintf>
 8014b92:	e021      	b.n	8014bd8 <shellThread+0x148>
      }
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 8014b94:	ab05      	add	r3, sp, #20
 8014b96:	9300      	str	r3, [sp, #0]
 8014b98:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014b9a:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8014b9c:	991e      	ldr	r1, [sp, #120]	; 0x78
 8014b9e:	481e      	ldr	r0, [pc, #120]	; (8014c18 <shellThread+0x188>)
 8014ba0:	f7ff ff4e 	bl	8014a40 <cmdexec>
 8014ba4:	4603      	mov	r3, r0
 8014ba6:	2b00      	cmp	r3, #0
 8014ba8:	d016      	beq.n	8014bd8 <shellThread+0x148>
 8014baa:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8014bac:	2b00      	cmp	r3, #0
 8014bae:	d00a      	beq.n	8014bc6 <shellThread+0x136>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 8014bb0:	ab05      	add	r3, sp, #20
 8014bb2:	9300      	str	r3, [sp, #0]
 8014bb4:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014bb6:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8014bb8:	991e      	ldr	r1, [sp, #120]	; 0x78
 8014bba:	981d      	ldr	r0, [sp, #116]	; 0x74
 8014bbc:	f7ff ff40 	bl	8014a40 <cmdexec>
 8014bc0:	4603      	mov	r3, r0
 8014bc2:	2b00      	cmp	r3, #0
 8014bc4:	d008      	beq.n	8014bd8 <shellThread+0x148>
        chprintf(chp, "%s", cmd);
 8014bc6:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8014bc8:	4914      	ldr	r1, [pc, #80]	; (8014c1c <shellThread+0x18c>)
 8014bca:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014bcc:	f7ff fe80 	bl	80148d0 <chprintf>
        chprintf(chp, " ?" SHELL_NEWLINE_STR);
 8014bd0:	4913      	ldr	r1, [pc, #76]	; (8014c20 <shellThread+0x190>)
 8014bd2:	981e      	ldr	r0, [sp, #120]	; 0x78
 8014bd4:	f7ff fe7c 	bl	80148d0 <chprintf>
  while (!chThdShouldTerminateX()) {
 8014bd8:	f7ff feaa 	bl	8014930 <chThdShouldTerminateX>
 8014bdc:	4603      	mov	r3, r0
 8014bde:	f083 0301 	eor.w	r3, r3, #1
 8014be2:	b2db      	uxtb	r3, r3
 8014be4:	2b00      	cmp	r3, #0
 8014be6:	f47f af69 	bne.w	8014abc <shellThread+0x2c>
      }
    }
  }
#if !defined(_CHIBIOS_NIL_)
  shellExit(MSG_OK);
 8014bea:	2000      	movs	r0, #0
 8014bec:	f000 f828 	bl	8014c40 <shellExit>
#endif
}
 8014bf0:	b023      	add	sp, #140	; 0x8c
 8014bf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014bf6:	bf00      	nop
 8014bf8:	08018bbc 	.word	0x08018bbc
 8014bfc:	08018e48 	.word	0x08018e48
 8014c00:	08018e5c 	.word	0x08018e5c
 8014c04:	08018e64 	.word	0x08018e64
 8014c08:	08018e6c 	.word	0x08018e6c
 8014c0c:	08018e84 	.word	0x08018e84
 8014c10:	08018e8c 	.word	0x08018e8c
 8014c14:	08018e98 	.word	0x08018e98
 8014c18:	08017190 	.word	0x08017190
 8014c1c:	08018ea8 	.word	0x08018ea8
 8014c20:	08018eac 	.word	0x08018eac
	...

08014c30 <shellInit>:
/**
 * @brief   Shell manager initialization.
 *
 * @api
 */
void shellInit(void) {
 8014c30:	b508      	push	{r3, lr}

#if !defined(_CHIBIOS_NIL_)
  chEvtObjectInit(&shell_terminated);
 8014c32:	4802      	ldr	r0, [pc, #8]	; (8014c3c <shellInit+0xc>)
 8014c34:	f7ff fe8c 	bl	8014950 <chEvtObjectInit.lto_priv.422>
#endif
}
 8014c38:	bd08      	pop	{r3, pc}
 8014c3a:	bf00      	nop
 8014c3c:	20001984 	.word	0x20001984

08014c40 <shellExit>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 8014c40:	b500      	push	{lr}
 8014c42:	b083      	sub	sp, #12
 8014c44:	9001      	str	r0, [sp, #4]

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
 8014c46:	f7ff fe63 	bl	8014910 <chSysLock.lto_priv.335>
  chEvtBroadcastI(&shell_terminated);
 8014c4a:	4804      	ldr	r0, [pc, #16]	; (8014c5c <shellExit+0x1c>)
 8014c4c:	f7ff fe88 	bl	8014960 <chEvtBroadcastI>
  chThdExitS(msg);
 8014c50:	9801      	ldr	r0, [sp, #4]
 8014c52:	f7fb fd0d 	bl	8010670 <chThdExitS>
}
 8014c56:	b003      	add	sp, #12
 8014c58:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c5c:	20001984 	.word	0x20001984

08014c60 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
 8014c60:	b500      	push	{lr}
 8014c62:	b089      	sub	sp, #36	; 0x24
 8014c64:	9003      	str	r0, [sp, #12]
 8014c66:	9102      	str	r1, [sp, #8]
 8014c68:	9201      	str	r2, [sp, #4]
 8014c6a:	9300      	str	r3, [sp, #0]
  char *p = line;
 8014c6c:	9b02      	ldr	r3, [sp, #8]
 8014c6e:	9307      	str	r3, [sp, #28]
  BaseSequentialStream *chp = scfg->sc_channel;
 8014c70:	9b03      	ldr	r3, [sp, #12]
 8014c72:	681b      	ldr	r3, [r3, #0]
 8014c74:	9306      	str	r3, [sp, #24]
#endif

  while (true) {
    char c;

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8014c76:	9b06      	ldr	r3, [sp, #24]
 8014c78:	681b      	ldr	r3, [r3, #0]
 8014c7a:	689b      	ldr	r3, [r3, #8]
 8014c7c:	f10d 0117 	add.w	r1, sp, #23
 8014c80:	2201      	movs	r2, #1
 8014c82:	9806      	ldr	r0, [sp, #24]
 8014c84:	4798      	blx	r3
 8014c86:	4603      	mov	r3, r0
 8014c88:	2b00      	cmp	r3, #0
 8014c8a:	d101      	bne.n	8014c90 <shellGetLine+0x30>
      return true;
 8014c8c:	2301      	movs	r3, #1
 8014c8e:	e056      	b.n	8014d3e <shellGetLine+0xde>
      }
      continue;
    }
#endif
#if (SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)
    if (c == 4) {
 8014c90:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8014c94:	2b04      	cmp	r3, #4
 8014c96:	d105      	bne.n	8014ca4 <shellGetLine+0x44>
      chprintf(chp, "^D");
 8014c98:	492b      	ldr	r1, [pc, #172]	; (8014d48 <shellGetLine+0xe8>)
 8014c9a:	9806      	ldr	r0, [sp, #24]
 8014c9c:	f7ff fe18 	bl	80148d0 <chprintf>
      return true;
 8014ca0:	2301      	movs	r3, #1
      return true;
 8014ca2:	e04c      	b.n	8014d3e <shellGetLine+0xde>
    }
#endif
    if ((c == 8) || (c == 127)) {
 8014ca4:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8014ca8:	2b08      	cmp	r3, #8
 8014caa:	d003      	beq.n	8014cb4 <shellGetLine+0x54>
 8014cac:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8014cb0:	2b7f      	cmp	r3, #127	; 0x7f
 8014cb2:	d119      	bne.n	8014ce8 <shellGetLine+0x88>
      if (p != line) {
 8014cb4:	9a07      	ldr	r2, [sp, #28]
 8014cb6:	9b02      	ldr	r3, [sp, #8]
 8014cb8:	429a      	cmp	r2, r3
 8014cba:	d03c      	beq.n	8014d36 <shellGetLine+0xd6>
        streamPut(chp, 0x08);
 8014cbc:	9b06      	ldr	r3, [sp, #24]
 8014cbe:	681b      	ldr	r3, [r3, #0]
 8014cc0:	68db      	ldr	r3, [r3, #12]
 8014cc2:	2108      	movs	r1, #8
 8014cc4:	9806      	ldr	r0, [sp, #24]
 8014cc6:	4798      	blx	r3
        streamPut(chp, 0x20);
 8014cc8:	9b06      	ldr	r3, [sp, #24]
 8014cca:	681b      	ldr	r3, [r3, #0]
 8014ccc:	68db      	ldr	r3, [r3, #12]
 8014cce:	2120      	movs	r1, #32
 8014cd0:	9806      	ldr	r0, [sp, #24]
 8014cd2:	4798      	blx	r3
        streamPut(chp, 0x08);
 8014cd4:	9b06      	ldr	r3, [sp, #24]
 8014cd6:	681b      	ldr	r3, [r3, #0]
 8014cd8:	68db      	ldr	r3, [r3, #12]
 8014cda:	2108      	movs	r1, #8
 8014cdc:	9806      	ldr	r0, [sp, #24]
 8014cde:	4798      	blx	r3
        p--;
 8014ce0:	9b07      	ldr	r3, [sp, #28]
 8014ce2:	3b01      	subs	r3, #1
 8014ce4:	9307      	str	r3, [sp, #28]
 8014ce6:	e7c6      	b.n	8014c76 <shellGetLine+0x16>
      }
      continue;
    }
    if (c == '\r') {
 8014ce8:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8014cec:	2b0d      	cmp	r3, #13
 8014cee:	d108      	bne.n	8014d02 <shellGetLine+0xa2>
      chprintf(chp, SHELL_NEWLINE_STR);
 8014cf0:	4916      	ldr	r1, [pc, #88]	; (8014d4c <shellGetLine+0xec>)
 8014cf2:	9806      	ldr	r0, [sp, #24]
 8014cf4:	f7ff fdec 	bl	80148d0 <chprintf>
#if SHELL_USE_HISTORY == TRUE
      save_history(shp, line, p - line);
#endif
      *p = 0;
 8014cf8:	9b07      	ldr	r3, [sp, #28]
 8014cfa:	2200      	movs	r2, #0
 8014cfc:	701a      	strb	r2, [r3, #0]
      return false;
 8014cfe:	2300      	movs	r3, #0
      return true;
 8014d00:	e01d      	b.n	8014d3e <shellGetLine+0xde>
        p = line + len;
      }
      continue;
    }
#endif
    if (c < 0x20)
 8014d02:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8014d06:	2b1f      	cmp	r3, #31
 8014d08:	d917      	bls.n	8014d3a <shellGetLine+0xda>
      continue;
    if (p < line + size - 1) {
 8014d0a:	9b01      	ldr	r3, [sp, #4]
 8014d0c:	3b01      	subs	r3, #1
 8014d0e:	9a02      	ldr	r2, [sp, #8]
 8014d10:	4413      	add	r3, r2
 8014d12:	9a07      	ldr	r2, [sp, #28]
 8014d14:	429a      	cmp	r2, r3
 8014d16:	d2ae      	bcs.n	8014c76 <shellGetLine+0x16>
      streamPut(chp, c);
 8014d18:	9b06      	ldr	r3, [sp, #24]
 8014d1a:	681b      	ldr	r3, [r3, #0]
 8014d1c:	68db      	ldr	r3, [r3, #12]
 8014d1e:	f89d 2017 	ldrb.w	r2, [sp, #23]
 8014d22:	4611      	mov	r1, r2
 8014d24:	9806      	ldr	r0, [sp, #24]
 8014d26:	4798      	blx	r3
      *p++ = (char)c;
 8014d28:	9b07      	ldr	r3, [sp, #28]
 8014d2a:	1c5a      	adds	r2, r3, #1
 8014d2c:	9207      	str	r2, [sp, #28]
 8014d2e:	f89d 2017 	ldrb.w	r2, [sp, #23]
 8014d32:	701a      	strb	r2, [r3, #0]
 8014d34:	e79f      	b.n	8014c76 <shellGetLine+0x16>
      continue;
 8014d36:	bf00      	nop
 8014d38:	e79d      	b.n	8014c76 <shellGetLine+0x16>
      continue;
 8014d3a:	bf00      	nop
 8014d3c:	e79b      	b.n	8014c76 <shellGetLine+0x16>
    }
  }
}
 8014d3e:	4618      	mov	r0, r3
 8014d40:	b009      	add	sp, #36	; 0x24
 8014d42:	f85d fb04 	ldr.w	pc, [sp], #4
 8014d46:	bf00      	nop
 8014d48:	08018eb4 	.word	0x08018eb4
 8014d4c:	08018bbc 	.word	0x08018bbc

08014d50 <port_lock.lto_priv.411>:
static inline void port_lock(void) {
 8014d50:	b082      	sub	sp, #8
 8014d52:	2320      	movs	r3, #32
 8014d54:	9301      	str	r3, [sp, #4]
 8014d56:	9b01      	ldr	r3, [sp, #4]
 8014d58:	f383 8811 	msr	BASEPRI, r3
}
 8014d5c:	b002      	add	sp, #8
 8014d5e:	4770      	bx	lr

08014d60 <port_unlock.lto_priv.379>:
static inline void port_unlock(void) {
 8014d60:	b082      	sub	sp, #8
 8014d62:	2300      	movs	r3, #0
 8014d64:	9301      	str	r3, [sp, #4]
 8014d66:	9b01      	ldr	r3, [sp, #4]
 8014d68:	f383 8811 	msr	BASEPRI, r3
}
 8014d6c:	b002      	add	sp, #8
 8014d6e:	4770      	bx	lr

08014d70 <st_lld_get_counter.lto_priv.348>:
  return (systime_t)STM32_ST_TIM->CNT;
 8014d70:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8014d74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8014d76:	4618      	mov	r0, r3
 8014d78:	4770      	bx	lr
 8014d7a:	bf00      	nop
 8014d7c:	0000      	movs	r0, r0
	...

08014d80 <port_timer_get_time.lto_priv.342>:
static inline systime_t port_timer_get_time(void) {
 8014d80:	b508      	push	{r3, lr}
  return stGetCounter();
 8014d82:	f7ff fff5 	bl	8014d70 <st_lld_get_counter.lto_priv.348>
 8014d86:	4603      	mov	r3, r0
}
 8014d88:	4618      	mov	r0, r3
 8014d8a:	bd08      	pop	{r3, pc}
 8014d8c:	0000      	movs	r0, r0
	...

08014d90 <chSysLock.lto_priv.336>:
static inline void chSysLock(void) {
 8014d90:	b508      	push	{r3, lr}
  port_lock();
 8014d92:	f7ff ffdd 	bl	8014d50 <port_lock.lto_priv.411>
  _dbg_check_lock();
 8014d96:	f7fa fa93 	bl	800f2c0 <_dbg_check_lock>
}
 8014d9a:	bd08      	pop	{r3, pc}
 8014d9c:	0000      	movs	r0, r0
	...

08014da0 <chSysUnlock.lto_priv.311>:
static inline void chSysUnlock(void) {
 8014da0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8014da2:	f7fa faa5 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8014da6:	4b09      	ldr	r3, [pc, #36]	; (8014dcc <chSysUnlock.lto_priv.311+0x2c>)
 8014da8:	681b      	ldr	r3, [r3, #0]
 8014daa:	4a08      	ldr	r2, [pc, #32]	; (8014dcc <chSysUnlock.lto_priv.311+0x2c>)
 8014dac:	4293      	cmp	r3, r2
 8014dae:	d00a      	beq.n	8014dc6 <chSysUnlock.lto_priv.311+0x26>
 8014db0:	4b06      	ldr	r3, [pc, #24]	; (8014dcc <chSysUnlock.lto_priv.311+0x2c>)
 8014db2:	699b      	ldr	r3, [r3, #24]
 8014db4:	689a      	ldr	r2, [r3, #8]
 8014db6:	4b05      	ldr	r3, [pc, #20]	; (8014dcc <chSysUnlock.lto_priv.311+0x2c>)
 8014db8:	681b      	ldr	r3, [r3, #0]
 8014dba:	689b      	ldr	r3, [r3, #8]
 8014dbc:	429a      	cmp	r2, r3
 8014dbe:	d202      	bcs.n	8014dc6 <chSysUnlock.lto_priv.311+0x26>
 8014dc0:	4803      	ldr	r0, [pc, #12]	; (8014dd0 <chSysUnlock.lto_priv.311+0x30>)
 8014dc2:	f7fa f90d 	bl	800efe0 <chSysHalt>
  port_unlock();
 8014dc6:	f7ff ffcb 	bl	8014d60 <port_unlock.lto_priv.379>
}
 8014dca:	bd08      	pop	{r3, pc}
 8014dcc:	20001090 	.word	0x20001090
 8014dd0:	080171d0 	.word	0x080171d0
	...

08014de0 <chVTGetSystemTimeX.lto_priv.287>:
static inline systime_t chVTGetSystemTimeX(void) {
 8014de0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8014de2:	f7ff ffcd 	bl	8014d80 <port_timer_get_time.lto_priv.342>
 8014de6:	4603      	mov	r3, r0
}
 8014de8:	4618      	mov	r0, r3
 8014dea:	bd08      	pop	{r3, pc}
 8014dec:	0000      	movs	r0, r0
	...

08014df0 <chVTGetSystemTime>:
static inline systime_t chVTGetSystemTime(void) {
 8014df0:	b500      	push	{lr}
 8014df2:	b083      	sub	sp, #12
  chSysLock();
 8014df4:	f7ff ffcc 	bl	8014d90 <chSysLock.lto_priv.336>
  systime = chVTGetSystemTimeX();
 8014df8:	f7ff fff2 	bl	8014de0 <chVTGetSystemTimeX.lto_priv.287>
 8014dfc:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8014dfe:	f7ff ffcf 	bl	8014da0 <chSysUnlock.lto_priv.311>
  return systime;
 8014e02:	9b01      	ldr	r3, [sp, #4]
}
 8014e04:	4618      	mov	r0, r3
 8014e06:	b003      	add	sp, #12
 8014e08:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e0c:	0000      	movs	r0, r0
	...

08014e10 <chThdGetSelfX.lto_priv.419>:
  return ch.rlist.current;
 8014e10:	4b01      	ldr	r3, [pc, #4]	; (8014e18 <chThdGetSelfX.lto_priv.419+0x8>)
 8014e12:	699b      	ldr	r3, [r3, #24]
}
 8014e14:	4618      	mov	r0, r3
 8014e16:	4770      	bx	lr
 8014e18:	20001090 	.word	0x20001090
 8014e1c:	00000000 	.word	0x00000000

08014e20 <chThdGetPriorityX>:
static inline tprio_t chThdGetPriorityX(void) {
 8014e20:	b508      	push	{r3, lr}
  return chThdGetSelfX()->prio;
 8014e22:	f7ff fff5 	bl	8014e10 <chThdGetSelfX.lto_priv.419>
 8014e26:	4603      	mov	r3, r0
 8014e28:	689b      	ldr	r3, [r3, #8]
}
 8014e2a:	4618      	mov	r0, r3
 8014e2c:	bd08      	pop	{r3, pc}
 8014e2e:	bf00      	nop

08014e30 <cmd_exit.lto_priv.136>:
/* Module local functions.                                                   */
/*===========================================================================*/

#if ((SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)) ||        \
    defined(__DOXYGEN__)
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {
 8014e30:	b500      	push	{lr}
 8014e32:	b085      	sub	sp, #20
 8014e34:	9003      	str	r0, [sp, #12]
 8014e36:	9102      	str	r1, [sp, #8]
 8014e38:	9201      	str	r2, [sp, #4]

  (void)argv;
  if (argc > 0) {
 8014e3a:	9b02      	ldr	r3, [sp, #8]
 8014e3c:	2b00      	cmp	r3, #0
 8014e3e:	dd05      	ble.n	8014e4c <cmd_exit.lto_priv.136+0x1c>
    shellUsage(chp, "exit");
 8014e40:	4a05      	ldr	r2, [pc, #20]	; (8014e58 <cmd_exit.lto_priv.136+0x28>)
 8014e42:	4906      	ldr	r1, [pc, #24]	; (8014e5c <cmd_exit.lto_priv.136+0x2c>)
 8014e44:	9803      	ldr	r0, [sp, #12]
 8014e46:	f7ff fd43 	bl	80148d0 <chprintf>
 8014e4a:	e002      	b.n	8014e52 <cmd_exit.lto_priv.136+0x22>
    return;
  }

  shellExit(MSG_OK);
 8014e4c:	2000      	movs	r0, #0
 8014e4e:	f7ff fef7 	bl	8014c40 <shellExit>
}
 8014e52:	b005      	add	sp, #20
 8014e54:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e58:	080161e8 	.word	0x080161e8
 8014e5c:	08018e8c 	.word	0x08018e8c

08014e60 <cmd_info.lto_priv.137>:
#endif

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8014e60:	b500      	push	{lr}
 8014e62:	b087      	sub	sp, #28
 8014e64:	9005      	str	r0, [sp, #20]
 8014e66:	9104      	str	r1, [sp, #16]
 8014e68:	9203      	str	r2, [sp, #12]

  (void)argv;
  if (argc > 0) {
 8014e6a:	9b04      	ldr	r3, [sp, #16]
 8014e6c:	2b00      	cmp	r3, #0
 8014e6e:	dd05      	ble.n	8014e7c <cmd_info.lto_priv.137+0x1c>
    shellUsage(chp, "info");
 8014e70:	4a19      	ldr	r2, [pc, #100]	; (8014ed8 <cmd_info.lto_priv.137+0x78>)
 8014e72:	491a      	ldr	r1, [pc, #104]	; (8014edc <cmd_info.lto_priv.137+0x7c>)
 8014e74:	9805      	ldr	r0, [sp, #20]
 8014e76:	f7ff fd2b 	bl	80148d0 <chprintf>
 8014e7a:	e02a      	b.n	8014ed2 <cmd_info.lto_priv.137+0x72>
    return;
  }

  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8014e7c:	4a18      	ldr	r2, [pc, #96]	; (8014ee0 <cmd_info.lto_priv.137+0x80>)
 8014e7e:	4919      	ldr	r1, [pc, #100]	; (8014ee4 <cmd_info.lto_priv.137+0x84>)
 8014e80:	9805      	ldr	r0, [sp, #20]
 8014e82:	f7ff fd25 	bl	80148d0 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s" SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
 8014e86:	4a18      	ldr	r2, [pc, #96]	; (8014ee8 <cmd_info.lto_priv.137+0x88>)
 8014e88:	4918      	ldr	r1, [pc, #96]	; (8014eec <cmd_info.lto_priv.137+0x8c>)
 8014e8a:	9805      	ldr	r0, [sp, #20]
 8014e8c:	f7ff fd20 	bl	80148d0 <chprintf>
#endif
  chprintf(chp, "Architecture: %s" SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 8014e90:	4a17      	ldr	r2, [pc, #92]	; (8014ef0 <cmd_info.lto_priv.137+0x90>)
 8014e92:	4918      	ldr	r1, [pc, #96]	; (8014ef4 <cmd_info.lto_priv.137+0x94>)
 8014e94:	9805      	ldr	r0, [sp, #20]
 8014e96:	f7ff fd1b 	bl	80148d0 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s" SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
 8014e9a:	4a17      	ldr	r2, [pc, #92]	; (8014ef8 <cmd_info.lto_priv.137+0x98>)
 8014e9c:	4917      	ldr	r1, [pc, #92]	; (8014efc <cmd_info.lto_priv.137+0x9c>)
 8014e9e:	9805      	ldr	r0, [sp, #20]
 8014ea0:	f7ff fd16 	bl	80148d0 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s" SHELL_NEWLINE_STR, PORT_INFO);
 8014ea4:	4a16      	ldr	r2, [pc, #88]	; (8014f00 <cmd_info.lto_priv.137+0xa0>)
 8014ea6:	4917      	ldr	r1, [pc, #92]	; (8014f04 <cmd_info.lto_priv.137+0xa4>)
 8014ea8:	9805      	ldr	r0, [sp, #20]
 8014eaa:	f7ff fd11 	bl	80148d0 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s" SHELL_NEWLINE_STR, PLATFORM_NAME);
 8014eae:	4a16      	ldr	r2, [pc, #88]	; (8014f08 <cmd_info.lto_priv.137+0xa8>)
 8014eb0:	4916      	ldr	r1, [pc, #88]	; (8014f0c <cmd_info.lto_priv.137+0xac>)
 8014eb2:	9805      	ldr	r0, [sp, #20]
 8014eb4:	f7ff fd0c 	bl	80148d0 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s" SHELL_NEWLINE_STR, BOARD_NAME);
 8014eb8:	4a15      	ldr	r2, [pc, #84]	; (8014f10 <cmd_info.lto_priv.137+0xb0>)
 8014eba:	4916      	ldr	r1, [pc, #88]	; (8014f14 <cmd_info.lto_priv.137+0xb4>)
 8014ebc:	9805      	ldr	r0, [sp, #20]
 8014ebe:	f7ff fd07 	bl	80148d0 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s" SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 8014ec2:	4b15      	ldr	r3, [pc, #84]	; (8014f18 <cmd_info.lto_priv.137+0xb8>)
 8014ec4:	9300      	str	r3, [sp, #0]
 8014ec6:	4b15      	ldr	r3, [pc, #84]	; (8014f1c <cmd_info.lto_priv.137+0xbc>)
 8014ec8:	4a15      	ldr	r2, [pc, #84]	; (8014f20 <cmd_info.lto_priv.137+0xc0>)
 8014eca:	4916      	ldr	r1, [pc, #88]	; (8014f24 <cmd_info.lto_priv.137+0xc4>)
 8014ecc:	9805      	ldr	r0, [sp, #20]
 8014ece:	f7ff fcff 	bl	80148d0 <chprintf>
#endif
#endif
}
 8014ed2:	b007      	add	sp, #28
 8014ed4:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ed8:	080161f0 	.word	0x080161f0
 8014edc:	08018e8c 	.word	0x08018e8c
 8014ee0:	080175c8 	.word	0x080175c8
 8014ee4:	08018eb8 	.word	0x08018eb8
 8014ee8:	0801741c 	.word	0x0801741c
 8014eec:	08018ecc 	.word	0x08018ecc
 8014ef0:	080173ac 	.word	0x080173ac
 8014ef4:	08018ee0 	.word	0x08018ee0
 8014ef8:	080173e4 	.word	0x080173e4
 8014efc:	08018ef4 	.word	0x08018ef4
 8014f00:	08017490 	.word	0x08017490
 8014f04:	08018f08 	.word	0x08018f08
 8014f08:	08017238 	.word	0x08017238
 8014f0c:	08018f1c 	.word	0x08018f1c
 8014f10:	08017278 	.word	0x08017278
 8014f14:	08018f30 	.word	0x08018f30
 8014f18:	08018f6c 	.word	0x08018f6c
 8014f1c:	08018f44 	.word	0x08018f44
 8014f20:	08018f48 	.word	0x08018f48
 8014f24:	08018f54 	.word	0x08018f54
	...

08014f30 <cmd_echo.lto_priv.138>:
#endif

#if (SHELL_CMD_ECHO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_echo(BaseSequentialStream *chp, int argc, char *argv[]) {
 8014f30:	b500      	push	{lr}
 8014f32:	b085      	sub	sp, #20
 8014f34:	9003      	str	r0, [sp, #12]
 8014f36:	9102      	str	r1, [sp, #8]
 8014f38:	9201      	str	r2, [sp, #4]

  (void)argv;
  if (argc != 1) {
 8014f3a:	9b02      	ldr	r3, [sp, #8]
 8014f3c:	2b01      	cmp	r3, #1
 8014f3e:	d005      	beq.n	8014f4c <cmd_echo.lto_priv.138+0x1c>
    shellUsage(chp, "echo \"message\"");
 8014f40:	4a07      	ldr	r2, [pc, #28]	; (8014f60 <cmd_echo.lto_priv.138+0x30>)
 8014f42:	4908      	ldr	r1, [pc, #32]	; (8014f64 <cmd_echo.lto_priv.138+0x34>)
 8014f44:	9803      	ldr	r0, [sp, #12]
 8014f46:	f7ff fcc3 	bl	80148d0 <chprintf>
 8014f4a:	e006      	b.n	8014f5a <cmd_echo.lto_priv.138+0x2a>
    return;
  }
  chprintf(chp, "%s" SHELL_NEWLINE_STR, argv[0]);
 8014f4c:	9b01      	ldr	r3, [sp, #4]
 8014f4e:	681b      	ldr	r3, [r3, #0]
 8014f50:	461a      	mov	r2, r3
 8014f52:	4905      	ldr	r1, [pc, #20]	; (8014f68 <cmd_echo.lto_priv.138+0x38>)
 8014f54:	9803      	ldr	r0, [sp, #12]
 8014f56:	f7ff fcbb 	bl	80148d0 <chprintf>
}
 8014f5a:	b005      	add	sp, #20
 8014f5c:	f85d fb04 	ldr.w	pc, [sp], #4
 8014f60:	08018f78 	.word	0x08018f78
 8014f64:	08018e8c 	.word	0x08018e8c
 8014f68:	08018f88 	.word	0x08018f88
 8014f6c:	00000000 	.word	0x00000000

08014f70 <cmd_systime.lto_priv.139>:
#endif

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 8014f70:	b500      	push	{lr}
 8014f72:	b085      	sub	sp, #20
 8014f74:	9003      	str	r0, [sp, #12]
 8014f76:	9102      	str	r1, [sp, #8]
 8014f78:	9201      	str	r2, [sp, #4]

  (void)argv;
  if (argc > 0) {
 8014f7a:	9b02      	ldr	r3, [sp, #8]
 8014f7c:	2b00      	cmp	r3, #0
 8014f7e:	dd05      	ble.n	8014f8c <cmd_systime.lto_priv.139+0x1c>
    shellUsage(chp, "systime");
 8014f80:	4a08      	ldr	r2, [pc, #32]	; (8014fa4 <cmd_systime.lto_priv.139+0x34>)
 8014f82:	4909      	ldr	r1, [pc, #36]	; (8014fa8 <cmd_systime.lto_priv.139+0x38>)
 8014f84:	9803      	ldr	r0, [sp, #12]
 8014f86:	f7ff fca3 	bl	80148d0 <chprintf>
 8014f8a:	e007      	b.n	8014f9c <cmd_systime.lto_priv.139+0x2c>
    return;
  }
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 8014f8c:	f7ff ff30 	bl	8014df0 <chVTGetSystemTime>
 8014f90:	4603      	mov	r3, r0
 8014f92:	461a      	mov	r2, r3
 8014f94:	4905      	ldr	r1, [pc, #20]	; (8014fac <cmd_systime.lto_priv.139+0x3c>)
 8014f96:	9803      	ldr	r0, [sp, #12]
 8014f98:	f7ff fc9a 	bl	80148d0 <chprintf>
}
 8014f9c:	b005      	add	sp, #20
 8014f9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8014fa2:	bf00      	nop
 8014fa4:	08016200 	.word	0x08016200
 8014fa8:	08018e8c 	.word	0x08018e8c
 8014fac:	08018f90 	.word	0x08018f90

08014fb0 <cmd_mem.lto_priv.140>:
#endif

#if (SHELL_CMD_MEM_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8014fb0:	b500      	push	{lr}
 8014fb2:	b089      	sub	sp, #36	; 0x24
 8014fb4:	9003      	str	r0, [sp, #12]
 8014fb6:	9102      	str	r1, [sp, #8]
 8014fb8:	9201      	str	r2, [sp, #4]
  size_t n, total, largest;

  (void)argv;
  if (argc > 0) {
 8014fba:	9b02      	ldr	r3, [sp, #8]
 8014fbc:	2b00      	cmp	r3, #0
 8014fbe:	dd05      	ble.n	8014fcc <cmd_mem.lto_priv.140+0x1c>
    shellUsage(chp, "mem");
 8014fc0:	4a14      	ldr	r2, [pc, #80]	; (8015014 <cmd_mem.lto_priv.140+0x64>)
 8014fc2:	4915      	ldr	r1, [pc, #84]	; (8015018 <cmd_mem.lto_priv.140+0x68>)
 8014fc4:	9803      	ldr	r0, [sp, #12]
 8014fc6:	f7ff fc83 	bl	80148d0 <chprintf>
 8014fca:	e01f      	b.n	801500c <cmd_mem.lto_priv.140+0x5c>
    return;
  }
  n = chHeapStatus(NULL, &total, &largest);
 8014fcc:	aa05      	add	r2, sp, #20
 8014fce:	ab06      	add	r3, sp, #24
 8014fd0:	4619      	mov	r1, r3
 8014fd2:	2000      	movs	r0, #0
 8014fd4:	f7fe f904 	bl	80131e0 <chHeapStatus>
 8014fd8:	9007      	str	r0, [sp, #28]
  chprintf(chp, "core free memory : %u bytes" SHELL_NEWLINE_STR, chCoreGetStatusX());
 8014fda:	f7fd ff31 	bl	8012e40 <chCoreGetStatusX>
 8014fde:	4603      	mov	r3, r0
 8014fe0:	461a      	mov	r2, r3
 8014fe2:	490e      	ldr	r1, [pc, #56]	; (801501c <cmd_mem.lto_priv.140+0x6c>)
 8014fe4:	9803      	ldr	r0, [sp, #12]
 8014fe6:	f7ff fc73 	bl	80148d0 <chprintf>
  chprintf(chp, "heap fragments   : %u" SHELL_NEWLINE_STR, n);
 8014fea:	9a07      	ldr	r2, [sp, #28]
 8014fec:	490c      	ldr	r1, [pc, #48]	; (8015020 <cmd_mem.lto_priv.140+0x70>)
 8014fee:	9803      	ldr	r0, [sp, #12]
 8014ff0:	f7ff fc6e 	bl	80148d0 <chprintf>
  chprintf(chp, "heap free total  : %u bytes" SHELL_NEWLINE_STR, total);
 8014ff4:	9b06      	ldr	r3, [sp, #24]
 8014ff6:	461a      	mov	r2, r3
 8014ff8:	490a      	ldr	r1, [pc, #40]	; (8015024 <cmd_mem.lto_priv.140+0x74>)
 8014ffa:	9803      	ldr	r0, [sp, #12]
 8014ffc:	f7ff fc68 	bl	80148d0 <chprintf>
  chprintf(chp, "heap free largest: %u bytes" SHELL_NEWLINE_STR, largest);
 8015000:	9b05      	ldr	r3, [sp, #20]
 8015002:	461a      	mov	r2, r3
 8015004:	4908      	ldr	r1, [pc, #32]	; (8015028 <cmd_mem.lto_priv.140+0x78>)
 8015006:	9803      	ldr	r0, [sp, #12]
 8015008:	f7ff fc62 	bl	80148d0 <chprintf>
}
 801500c:	b009      	add	sp, #36	; 0x24
 801500e:	f85d fb04 	ldr.w	pc, [sp], #4
 8015012:	bf00      	nop
 8015014:	08016208 	.word	0x08016208
 8015018:	08018e8c 	.word	0x08018e8c
 801501c:	08018f98 	.word	0x08018f98
 8015020:	08018fb8 	.word	0x08018fb8
 8015024:	08018fd0 	.word	0x08018fd0
 8015028:	08018ff0 	.word	0x08018ff0
 801502c:	00000000 	.word	0x00000000

08015030 <cmd_threads.lto_priv.141>:
#endif

#if (SHELL_CMD_THREADS_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8015030:	b530      	push	{r4, r5, lr}
 8015032:	b08d      	sub	sp, #52	; 0x34
 8015034:	9009      	str	r0, [sp, #36]	; 0x24
 8015036:	9108      	str	r1, [sp, #32]
 8015038:	9207      	str	r2, [sp, #28]
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 801503a:	9b08      	ldr	r3, [sp, #32]
 801503c:	2b00      	cmp	r3, #0
 801503e:	dd05      	ble.n	801504c <cmd_threads.lto_priv.141+0x1c>
    shellUsage(chp, "threads");
 8015040:	4a1e      	ldr	r2, [pc, #120]	; (80150bc <cmd_threads.lto_priv.141+0x8c>)
 8015042:	491f      	ldr	r1, [pc, #124]	; (80150c0 <cmd_threads.lto_priv.141+0x90>)
 8015044:	9809      	ldr	r0, [sp, #36]	; 0x24
 8015046:	f7ff fc43 	bl	80148d0 <chprintf>
 801504a:	e034      	b.n	80150b6 <cmd_threads.lto_priv.141+0x86>
    return;
  }
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
 801504c:	491d      	ldr	r1, [pc, #116]	; (80150c4 <cmd_threads.lto_priv.141+0x94>)
 801504e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8015050:	f7ff fc3e 	bl	80148d0 <chprintf>
  tp = chRegFirstThread();
 8015054:	f7fb fdcc 	bl	8010bf0 <chRegFirstThread>
 8015058:	900b      	str	r0, [sp, #44]	; 0x2c
  do {
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
 801505a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801505c:	69db      	ldr	r3, [r3, #28]
 801505e:	930a      	str	r3, [sp, #40]	; 0x28
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
 8015060:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8015062:	68db      	ldr	r3, [r3, #12]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8015064:	461d      	mov	r5, r3
 8015066:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8015068:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801506a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 801506e:	1e59      	subs	r1, r3, #1
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8015070:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8015072:	6898      	ldr	r0, [r3, #8]
 8015074:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8015076:	f893 3020 	ldrb.w	r3, [r3, #32]
 801507a:	461c      	mov	r4, r3
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 801507c:	4b12      	ldr	r3, [pc, #72]	; (80150c8 <cmd_threads.lto_priv.141+0x98>)
 801507e:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
             tp->name == NULL ? "" : tp->name);
 8015082:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8015084:	699b      	ldr	r3, [r3, #24]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8015086:	2b00      	cmp	r3, #0
 8015088:	d002      	beq.n	8015090 <cmd_threads.lto_priv.141+0x60>
 801508a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801508c:	699b      	ldr	r3, [r3, #24]
 801508e:	e000      	b.n	8015092 <cmd_threads.lto_priv.141+0x62>
 8015090:	4b0e      	ldr	r3, [pc, #56]	; (80150cc <cmd_threads.lto_priv.141+0x9c>)
 8015092:	9304      	str	r3, [sp, #16]
 8015094:	9403      	str	r4, [sp, #12]
 8015096:	9002      	str	r0, [sp, #8]
 8015098:	9101      	str	r1, [sp, #4]
 801509a:	9200      	str	r2, [sp, #0]
 801509c:	462b      	mov	r3, r5
 801509e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80150a0:	490b      	ldr	r1, [pc, #44]	; (80150d0 <cmd_threads.lto_priv.141+0xa0>)
 80150a2:	9809      	ldr	r0, [sp, #36]	; 0x24
 80150a4:	f7ff fc14 	bl	80148d0 <chprintf>
    tp = chRegNextThread(tp);
 80150a8:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80150aa:	f7fb fdb9 	bl	8010c20 <chRegNextThread>
 80150ae:	900b      	str	r0, [sp, #44]	; 0x2c
  } while (tp != NULL);
 80150b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80150b2:	2b00      	cmp	r3, #0
 80150b4:	d1d1      	bne.n	801505a <cmd_threads.lto_priv.141+0x2a>
}
 80150b6:	b00d      	add	sp, #52	; 0x34
 80150b8:	bd30      	pop	{r4, r5, pc}
 80150ba:	bf00      	nop
 80150bc:	080167e4 	.word	0x080167e4
 80150c0:	08018e8c 	.word	0x08018e8c
 80150c4:	08019010 	.word	0x08019010
 80150c8:	20000808 	.word	0x20000808
 80150cc:	08018d94 	.word	0x08018d94
 80150d0:	08019050 	.word	0x08019050
	...

080150e0 <test_rt>:
#endif

#if (SHELL_CMD_TEST_ENABLED == TRUE) || defined(__DOXYGEN__)
static THD_FUNCTION(test_rt, arg) {
 80150e0:	b500      	push	{lr}
 80150e2:	b085      	sub	sp, #20
 80150e4:	9001      	str	r0, [sp, #4]
  BaseSequentialStream *chp = (BaseSequentialStream *)arg;
 80150e6:	9b01      	ldr	r3, [sp, #4]
 80150e8:	9303      	str	r3, [sp, #12]
  test_execute(chp, &rt_test_suite);
 80150ea:	4903      	ldr	r1, [pc, #12]	; (80150f8 <test_rt+0x18>)
 80150ec:	9803      	ldr	r0, [sp, #12]
 80150ee:	f7eb fca7 	bl	8000a40 <test_execute>
}
 80150f2:	b005      	add	sp, #20
 80150f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80150f8:	08017358 	.word	0x08017358
 80150fc:	00000000 	.word	0x00000000

08015100 <test_oslib>:

static THD_FUNCTION(test_oslib, arg) {
 8015100:	b500      	push	{lr}
 8015102:	b085      	sub	sp, #20
 8015104:	9001      	str	r0, [sp, #4]
  BaseSequentialStream *chp = (BaseSequentialStream *)arg;
 8015106:	9b01      	ldr	r3, [sp, #4]
 8015108:	9303      	str	r3, [sp, #12]
  test_execute(chp, &oslib_test_suite);
 801510a:	4903      	ldr	r1, [pc, #12]	; (8015118 <test_oslib+0x18>)
 801510c:	9803      	ldr	r0, [sp, #12]
 801510e:	f7eb fc97 	bl	8000a40 <test_execute>
}
 8015112:	b005      	add	sp, #20
 8015114:	f85d fb04 	ldr.w	pc, [sp], #4
 8015118:	0801874c 	.word	0x0801874c
 801511c:	00000000 	.word	0x00000000

08015120 <cmd_test.lto_priv.142>:

static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 8015120:	b500      	push	{lr}
 8015122:	b089      	sub	sp, #36	; 0x24
 8015124:	9005      	str	r0, [sp, #20]
 8015126:	9104      	str	r1, [sp, #16]
 8015128:	9203      	str	r2, [sp, #12]
  thread_t *tp;
  tfunc_t tfp;

  (void)argv;
  if (argc != 1) {
 801512a:	9b04      	ldr	r3, [sp, #16]
 801512c:	2b01      	cmp	r3, #1
 801512e:	d005      	beq.n	801513c <cmd_test.lto_priv.142+0x1c>
    shellUsage(chp, "test rt|oslib");
 8015130:	4a20      	ldr	r2, [pc, #128]	; (80151b4 <cmd_test.lto_priv.142+0x94>)
 8015132:	4921      	ldr	r1, [pc, #132]	; (80151b8 <cmd_test.lto_priv.142+0x98>)
 8015134:	9805      	ldr	r0, [sp, #20]
 8015136:	f7ff fbcb 	bl	80148d0 <chprintf>
 801513a:	e037      	b.n	80151ac <cmd_test.lto_priv.142+0x8c>
    return;
  }
  if (!strcmp(argv[0], "rt")) {
 801513c:	9b03      	ldr	r3, [sp, #12]
 801513e:	681b      	ldr	r3, [r3, #0]
 8015140:	491e      	ldr	r1, [pc, #120]	; (80151bc <cmd_test.lto_priv.142+0x9c>)
 8015142:	4618      	mov	r0, r3
 8015144:	f7eb f990 	bl	8000468 <strcmp>
 8015148:	4603      	mov	r3, r0
 801514a:	2b00      	cmp	r3, #0
 801514c:	d102      	bne.n	8015154 <cmd_test.lto_priv.142+0x34>
    tfp = test_rt;
 801514e:	4b1c      	ldr	r3, [pc, #112]	; (80151c0 <cmd_test.lto_priv.142+0xa0>)
 8015150:	9307      	str	r3, [sp, #28]
 8015152:	e011      	b.n	8015178 <cmd_test.lto_priv.142+0x58>
  }
  else if (!strcmp(argv[0], "oslib")) {
 8015154:	9b03      	ldr	r3, [sp, #12]
 8015156:	681b      	ldr	r3, [r3, #0]
 8015158:	491a      	ldr	r1, [pc, #104]	; (80151c4 <cmd_test.lto_priv.142+0xa4>)
 801515a:	4618      	mov	r0, r3
 801515c:	f7eb f984 	bl	8000468 <strcmp>
 8015160:	4603      	mov	r3, r0
 8015162:	2b00      	cmp	r3, #0
 8015164:	d102      	bne.n	801516c <cmd_test.lto_priv.142+0x4c>
    tfp = test_oslib;
 8015166:	4b18      	ldr	r3, [pc, #96]	; (80151c8 <cmd_test.lto_priv.142+0xa8>)
 8015168:	9307      	str	r3, [sp, #28]
 801516a:	e005      	b.n	8015178 <cmd_test.lto_priv.142+0x58>
  }
  else {
    shellUsage(chp, "test rt|oslib");
 801516c:	4a11      	ldr	r2, [pc, #68]	; (80151b4 <cmd_test.lto_priv.142+0x94>)
 801516e:	4912      	ldr	r1, [pc, #72]	; (80151b8 <cmd_test.lto_priv.142+0x98>)
 8015170:	9805      	ldr	r0, [sp, #20]
 8015172:	f7ff fbad 	bl	80148d0 <chprintf>
 8015176:	e019      	b.n	80151ac <cmd_test.lto_priv.142+0x8c>
    return;
  }
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
 8015178:	f7ff fe52 	bl	8014e20 <chThdGetPriorityX>
 801517c:	4602      	mov	r2, r0
 801517e:	9b05      	ldr	r3, [sp, #20]
 8015180:	9301      	str	r3, [sp, #4]
 8015182:	9b07      	ldr	r3, [sp, #28]
 8015184:	9300      	str	r3, [sp, #0]
 8015186:	4613      	mov	r3, r2
 8015188:	4a10      	ldr	r2, [pc, #64]	; (80151cc <cmd_test.lto_priv.142+0xac>)
 801518a:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 801518e:	2000      	movs	r0, #0
 8015190:	f7fd fa16 	bl	80125c0 <chThdCreateFromHeap>
 8015194:	9006      	str	r0, [sp, #24]
                           "test", chThdGetPriorityX(),
                           tfp, chp);
  if (tp == NULL) {
 8015196:	9b06      	ldr	r3, [sp, #24]
 8015198:	2b00      	cmp	r3, #0
 801519a:	d104      	bne.n	80151a6 <cmd_test.lto_priv.142+0x86>
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
 801519c:	490c      	ldr	r1, [pc, #48]	; (80151d0 <cmd_test.lto_priv.142+0xb0>)
 801519e:	9805      	ldr	r0, [sp, #20]
 80151a0:	f7ff fb96 	bl	80148d0 <chprintf>
 80151a4:	e002      	b.n	80151ac <cmd_test.lto_priv.142+0x8c>
    return;
  }
  chThdWait(tp);
 80151a6:	9806      	ldr	r0, [sp, #24]
 80151a8:	f7fb faa2 	bl	80106f0 <chThdWait>
}
 80151ac:	b009      	add	sp, #36	; 0x24
 80151ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80151b2:	bf00      	nop
 80151b4:	08019078 	.word	0x08019078
 80151b8:	08018e8c 	.word	0x08018e8c
 80151bc:	08019088 	.word	0x08019088
 80151c0:	080150e1 	.word	0x080150e1
 80151c4:	08019080 	.word	0x08019080
 80151c8:	08015101 	.word	0x08015101
 80151cc:	080163ec 	.word	0x080163ec
 80151d0:	0801908c 	.word	0x0801908c
	...

080151e0 <chTimeIsInRangeX.lto_priv.414>:
                                    systime_t end) {
 80151e0:	b084      	sub	sp, #16
 80151e2:	9003      	str	r0, [sp, #12]
 80151e4:	9102      	str	r1, [sp, #8]
 80151e6:	9201      	str	r2, [sp, #4]
  return (bool)((time - start) < (end - start));
 80151e8:	9a03      	ldr	r2, [sp, #12]
 80151ea:	9b02      	ldr	r3, [sp, #8]
 80151ec:	1ad2      	subs	r2, r2, r3
 80151ee:	9901      	ldr	r1, [sp, #4]
 80151f0:	9b02      	ldr	r3, [sp, #8]
 80151f2:	1acb      	subs	r3, r1, r3
 80151f4:	429a      	cmp	r2, r3
 80151f6:	bf34      	ite	cc
 80151f8:	2301      	movcc	r3, #1
 80151fa:	2300      	movcs	r3, #0
 80151fc:	b2db      	uxtb	r3, r3
}
 80151fe:	4618      	mov	r0, r3
 8015200:	b004      	add	sp, #16
 8015202:	4770      	bx	lr
	...

08015210 <port_lock.lto_priv.412>:
static inline void port_lock(void) {
 8015210:	b082      	sub	sp, #8
 8015212:	2320      	movs	r3, #32
 8015214:	9301      	str	r3, [sp, #4]
 8015216:	9b01      	ldr	r3, [sp, #4]
 8015218:	f383 8811 	msr	BASEPRI, r3
}
 801521c:	b002      	add	sp, #8
 801521e:	4770      	bx	lr

08015220 <port_unlock.lto_priv.380>:
static inline void port_unlock(void) {
 8015220:	b082      	sub	sp, #8
 8015222:	2300      	movs	r3, #0
 8015224:	9301      	str	r3, [sp, #4]
 8015226:	9b01      	ldr	r3, [sp, #4]
 8015228:	f383 8811 	msr	BASEPRI, r3
}
 801522c:	b002      	add	sp, #8
 801522e:	4770      	bx	lr

08015230 <st_lld_get_counter.lto_priv.349>:
  return (systime_t)STM32_ST_TIM->CNT;
 8015230:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8015234:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8015236:	4618      	mov	r0, r3
 8015238:	4770      	bx	lr
 801523a:	bf00      	nop
 801523c:	0000      	movs	r0, r0
	...

08015240 <port_timer_get_time.lto_priv.343>:
static inline systime_t port_timer_get_time(void) {
 8015240:	b508      	push	{r3, lr}
  return stGetCounter();
 8015242:	f7ff fff5 	bl	8015230 <st_lld_get_counter.lto_priv.349>
 8015246:	4603      	mov	r3, r0
}
 8015248:	4618      	mov	r0, r3
 801524a:	bd08      	pop	{r3, pc}
 801524c:	0000      	movs	r0, r0
	...

08015250 <chSysLock.lto_priv.337>:
static inline void chSysLock(void) {
 8015250:	b508      	push	{r3, lr}
  port_lock();
 8015252:	f7ff ffdd 	bl	8015210 <port_lock.lto_priv.412>
  _dbg_check_lock();
 8015256:	f7fa f833 	bl	800f2c0 <_dbg_check_lock>
}
 801525a:	bd08      	pop	{r3, pc}
 801525c:	0000      	movs	r0, r0
	...

08015260 <chSysUnlock.lto_priv.312>:
static inline void chSysUnlock(void) {
 8015260:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8015262:	f7fa f845 	bl	800f2f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8015266:	4b09      	ldr	r3, [pc, #36]	; (801528c <chSysUnlock.lto_priv.312+0x2c>)
 8015268:	681b      	ldr	r3, [r3, #0]
 801526a:	4a08      	ldr	r2, [pc, #32]	; (801528c <chSysUnlock.lto_priv.312+0x2c>)
 801526c:	4293      	cmp	r3, r2
 801526e:	d00a      	beq.n	8015286 <chSysUnlock.lto_priv.312+0x26>
 8015270:	4b06      	ldr	r3, [pc, #24]	; (801528c <chSysUnlock.lto_priv.312+0x2c>)
 8015272:	699b      	ldr	r3, [r3, #24]
 8015274:	689a      	ldr	r2, [r3, #8]
 8015276:	4b05      	ldr	r3, [pc, #20]	; (801528c <chSysUnlock.lto_priv.312+0x2c>)
 8015278:	681b      	ldr	r3, [r3, #0]
 801527a:	689b      	ldr	r3, [r3, #8]
 801527c:	429a      	cmp	r2, r3
 801527e:	d202      	bcs.n	8015286 <chSysUnlock.lto_priv.312+0x26>
 8015280:	4803      	ldr	r0, [pc, #12]	; (8015290 <chSysUnlock.lto_priv.312+0x30>)
 8015282:	f7f9 fead 	bl	800efe0 <chSysHalt>
  port_unlock();
 8015286:	f7ff ffcb 	bl	8015220 <port_unlock.lto_priv.380>
}
 801528a:	bd08      	pop	{r3, pc}
 801528c:	20001090 	.word	0x20001090
 8015290:	08017320 	.word	0x08017320
	...

080152a0 <chVTGetSystemTimeX.lto_priv.288>:
static inline systime_t chVTGetSystemTimeX(void) {
 80152a0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 80152a2:	f7ff ffcd 	bl	8015240 <port_timer_get_time.lto_priv.343>
 80152a6:	4603      	mov	r3, r0
}
 80152a8:	4618      	mov	r0, r3
 80152aa:	bd08      	pop	{r3, pc}
 80152ac:	0000      	movs	r0, r0
	...

080152b0 <osalSysLock.lto_priv.282>:
static inline void osalSysLock(void) {
 80152b0:	b508      	push	{r3, lr}
  chSysLock();
 80152b2:	f7ff ffcd 	bl	8015250 <chSysLock.lto_priv.337>
}
 80152b6:	bd08      	pop	{r3, pc}
	...

080152c0 <osalSysUnlock.lto_priv.273>:
static inline void osalSysUnlock(void) {
 80152c0:	b508      	push	{r3, lr}
  chSysUnlock();
 80152c2:	f7ff ffcd 	bl	8015260 <chSysUnlock.lto_priv.312>
}
 80152c6:	bd08      	pop	{r3, pc}
	...

080152d0 <osalOsGetSystemTimeX>:
static inline systime_t osalOsGetSystemTimeX(void) {
 80152d0:	b508      	push	{r3, lr}
  return chVTGetSystemTimeX();
 80152d2:	f7ff ffe5 	bl	80152a0 <chVTGetSystemTimeX.lto_priv.288>
 80152d6:	4603      	mov	r3, r0
}
 80152d8:	4618      	mov	r0, r3
 80152da:	bd08      	pop	{r3, pc}
 80152dc:	0000      	movs	r0, r0
	...

080152e0 <osalTimeIsInRangeX>:
                                      systime_t end) {
 80152e0:	b500      	push	{lr}
 80152e2:	b085      	sub	sp, #20
 80152e4:	9003      	str	r0, [sp, #12]
 80152e6:	9102      	str	r1, [sp, #8]
 80152e8:	9201      	str	r2, [sp, #4]
  return chTimeIsInRangeX(time, start, end);
 80152ea:	9a01      	ldr	r2, [sp, #4]
 80152ec:	9902      	ldr	r1, [sp, #8]
 80152ee:	9803      	ldr	r0, [sp, #12]
 80152f0:	f7ff ff76 	bl	80151e0 <chTimeIsInRangeX.lto_priv.414>
 80152f4:	4603      	mov	r3, r0
}
 80152f6:	4618      	mov	r0, r3
 80152f8:	b005      	add	sp, #20
 80152fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80152fe:	bf00      	nop

08015300 <osalThreadSleep.lto_priv.258>:
static inline void osalThreadSleep(sysinterval_t delay) {
 8015300:	b500      	push	{lr}
 8015302:	b083      	sub	sp, #12
 8015304:	9001      	str	r0, [sp, #4]
  chThdSleep(delay);
 8015306:	9801      	ldr	r0, [sp, #4]
 8015308:	f7fb fa82 	bl	8010810 <chThdSleep>
}
 801530c:	b003      	add	sp, #12
 801530e:	f85d fb04 	ldr.w	pc, [sp], #4
 8015312:	bf00      	nop
	...

08015320 <clear_tokens>:
  test_tokp = test_tokens_buffer;
 8015320:	4b01      	ldr	r3, [pc, #4]	; (8015328 <clear_tokens+0x8>)
 8015322:	4a02      	ldr	r2, [pc, #8]	; (801532c <clear_tokens+0xc>)
 8015324:	601a      	str	r2, [r3, #0]
}
 8015326:	4770      	bx	lr
 8015328:	200019a4 	.word	0x200019a4
 801532c:	20001994 	.word	0x20001994

08015330 <print_tokens.lto_priv.256>:
static void print_tokens(void) {
 8015330:	b500      	push	{lr}
 8015332:	b083      	sub	sp, #12
  char *cp = test_tokens_buffer;
 8015334:	4b0b      	ldr	r3, [pc, #44]	; (8015364 <print_tokens.lto_priv.256+0x34>)
 8015336:	9301      	str	r3, [sp, #4]
 8015338:	e00b      	b.n	8015352 <print_tokens.lto_priv.256+0x22>
    streamPut(test_chp, *cp++);
 801533a:	4b0b      	ldr	r3, [pc, #44]	; (8015368 <print_tokens.lto_priv.256+0x38>)
 801533c:	681b      	ldr	r3, [r3, #0]
 801533e:	681b      	ldr	r3, [r3, #0]
 8015340:	68da      	ldr	r2, [r3, #12]
 8015342:	4b09      	ldr	r3, [pc, #36]	; (8015368 <print_tokens.lto_priv.256+0x38>)
 8015344:	6818      	ldr	r0, [r3, #0]
 8015346:	9b01      	ldr	r3, [sp, #4]
 8015348:	1c59      	adds	r1, r3, #1
 801534a:	9101      	str	r1, [sp, #4]
 801534c:	781b      	ldrb	r3, [r3, #0]
 801534e:	4619      	mov	r1, r3
 8015350:	4790      	blx	r2
  while (cp < test_tokp)
 8015352:	4b06      	ldr	r3, [pc, #24]	; (801536c <print_tokens.lto_priv.256+0x3c>)
 8015354:	681b      	ldr	r3, [r3, #0]
 8015356:	9a01      	ldr	r2, [sp, #4]
 8015358:	429a      	cmp	r2, r3
 801535a:	d3ee      	bcc.n	801533a <print_tokens.lto_priv.256+0xa>
}
 801535c:	b003      	add	sp, #12
 801535e:	f85d fb04 	ldr.w	pc, [sp], #4
 8015362:	bf00      	nop
 8015364:	20001994 	.word	0x20001994
 8015368:	200019a8 	.word	0x200019a8
 801536c:	200019a4 	.word	0x200019a4

08015370 <execute_test.lto_priv.257>:
static void execute_test(const testcase_t *tcp) {
 8015370:	b500      	push	{lr}
 8015372:	b083      	sub	sp, #12
 8015374:	9001      	str	r0, [sp, #4]
  clear_tokens();
 8015376:	f7ff ffd3 	bl	8015320 <clear_tokens>
  test_local_fail = false;
 801537a:	4b0b      	ldr	r3, [pc, #44]	; (80153a8 <execute_test.lto_priv.257+0x38>)
 801537c:	2200      	movs	r2, #0
 801537e:	701a      	strb	r2, [r3, #0]
  if (tcp->setup != NULL)
 8015380:	9b01      	ldr	r3, [sp, #4]
 8015382:	685b      	ldr	r3, [r3, #4]
 8015384:	2b00      	cmp	r3, #0
 8015386:	d002      	beq.n	801538e <execute_test.lto_priv.257+0x1e>
    tcp->setup();
 8015388:	9b01      	ldr	r3, [sp, #4]
 801538a:	685b      	ldr	r3, [r3, #4]
 801538c:	4798      	blx	r3
  tcp->execute();
 801538e:	9b01      	ldr	r3, [sp, #4]
 8015390:	68db      	ldr	r3, [r3, #12]
 8015392:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8015394:	9b01      	ldr	r3, [sp, #4]
 8015396:	689b      	ldr	r3, [r3, #8]
 8015398:	2b00      	cmp	r3, #0
 801539a:	d002      	beq.n	80153a2 <execute_test.lto_priv.257+0x32>
    tcp->teardown();
 801539c:	9b01      	ldr	r3, [sp, #4]
 801539e:	689b      	ldr	r3, [r3, #8]
 80153a0:	4798      	blx	r3
}
 80153a2:	b003      	add	sp, #12
 80153a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80153a8:	2000198d 	.word	0x2000198d
 80153ac:	00000000 	.word	0x00000000

080153b0 <print_line.lto_priv.255>:
static void print_line(void) {
 80153b0:	b500      	push	{lr}
 80153b2:	b083      	sub	sp, #12
  for (i = 0; i < 76; i++)
 80153b4:	2300      	movs	r3, #0
 80153b6:	9301      	str	r3, [sp, #4]
 80153b8:	e00b      	b.n	80153d2 <print_line.lto_priv.255+0x22>
    streamPut(test_chp, '-');
 80153ba:	4b0d      	ldr	r3, [pc, #52]	; (80153f0 <print_line.lto_priv.255+0x40>)
 80153bc:	681b      	ldr	r3, [r3, #0]
 80153be:	681b      	ldr	r3, [r3, #0]
 80153c0:	68db      	ldr	r3, [r3, #12]
 80153c2:	4a0b      	ldr	r2, [pc, #44]	; (80153f0 <print_line.lto_priv.255+0x40>)
 80153c4:	6812      	ldr	r2, [r2, #0]
 80153c6:	212d      	movs	r1, #45	; 0x2d
 80153c8:	4610      	mov	r0, r2
 80153ca:	4798      	blx	r3
  for (i = 0; i < 76; i++)
 80153cc:	9b01      	ldr	r3, [sp, #4]
 80153ce:	3301      	adds	r3, #1
 80153d0:	9301      	str	r3, [sp, #4]
 80153d2:	9b01      	ldr	r3, [sp, #4]
 80153d4:	2b4b      	cmp	r3, #75	; 0x4b
 80153d6:	d9f0      	bls.n	80153ba <print_line.lto_priv.255+0xa>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 80153d8:	4b05      	ldr	r3, [pc, #20]	; (80153f0 <print_line.lto_priv.255+0x40>)
 80153da:	681b      	ldr	r3, [r3, #0]
 80153dc:	681b      	ldr	r3, [r3, #0]
 80153de:	685b      	ldr	r3, [r3, #4]
 80153e0:	4a03      	ldr	r2, [pc, #12]	; (80153f0 <print_line.lto_priv.255+0x40>)
 80153e2:	6810      	ldr	r0, [r2, #0]
 80153e4:	2202      	movs	r2, #2
 80153e6:	4903      	ldr	r1, [pc, #12]	; (80153f4 <print_line.lto_priv.255+0x44>)
 80153e8:	4798      	blx	r3
}
 80153ea:	b003      	add	sp, #12
 80153ec:	f85d fb04 	ldr.w	pc, [sp], #4
 80153f0:	200019a8 	.word	0x200019a8
 80153f4:	08018bbc 	.word	0x08018bbc
	...

08015400 <print_fat_line.lto_priv.259>:
static void print_fat_line(void) {
 8015400:	b500      	push	{lr}
 8015402:	b083      	sub	sp, #12
  for (i = 0; i < 76; i++)
 8015404:	2300      	movs	r3, #0
 8015406:	9301      	str	r3, [sp, #4]
 8015408:	e00b      	b.n	8015422 <print_fat_line.lto_priv.259+0x22>
    streamPut(test_chp, '=');
 801540a:	4b0d      	ldr	r3, [pc, #52]	; (8015440 <print_fat_line.lto_priv.259+0x40>)
 801540c:	681b      	ldr	r3, [r3, #0]
 801540e:	681b      	ldr	r3, [r3, #0]
 8015410:	68db      	ldr	r3, [r3, #12]
 8015412:	4a0b      	ldr	r2, [pc, #44]	; (8015440 <print_fat_line.lto_priv.259+0x40>)
 8015414:	6812      	ldr	r2, [r2, #0]
 8015416:	213d      	movs	r1, #61	; 0x3d
 8015418:	4610      	mov	r0, r2
 801541a:	4798      	blx	r3
  for (i = 0; i < 76; i++)
 801541c:	9b01      	ldr	r3, [sp, #4]
 801541e:	3301      	adds	r3, #1
 8015420:	9301      	str	r3, [sp, #4]
 8015422:	9b01      	ldr	r3, [sp, #4]
 8015424:	2b4b      	cmp	r3, #75	; 0x4b
 8015426:	d9f0      	bls.n	801540a <print_fat_line.lto_priv.259+0xa>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8015428:	4b05      	ldr	r3, [pc, #20]	; (8015440 <print_fat_line.lto_priv.259+0x40>)
 801542a:	681b      	ldr	r3, [r3, #0]
 801542c:	681b      	ldr	r3, [r3, #0]
 801542e:	685b      	ldr	r3, [r3, #4]
 8015430:	4a03      	ldr	r2, [pc, #12]	; (8015440 <print_fat_line.lto_priv.259+0x40>)
 8015432:	6810      	ldr	r0, [r2, #0]
 8015434:	2202      	movs	r2, #2
 8015436:	4903      	ldr	r1, [pc, #12]	; (8015444 <print_fat_line.lto_priv.259+0x44>)
 8015438:	4798      	blx	r3
}
 801543a:	b003      	add	sp, #12
 801543c:	f85d fb04 	ldr.w	pc, [sp], #4
 8015440:	200019a8 	.word	0x200019a8
 8015444:	08018bbc 	.word	0x08018bbc
	...

08015450 <_test_fail>:
bool _test_fail(const char *msg) {
 8015450:	b082      	sub	sp, #8
 8015452:	9001      	str	r0, [sp, #4]
  test_local_fail      = true;
 8015454:	4b06      	ldr	r3, [pc, #24]	; (8015470 <_test_fail+0x20>)
 8015456:	2201      	movs	r2, #1
 8015458:	701a      	strb	r2, [r3, #0]
  test_global_fail     = true;
 801545a:	4b06      	ldr	r3, [pc, #24]	; (8015474 <_test_fail+0x24>)
 801545c:	2201      	movs	r2, #1
 801545e:	701a      	strb	r2, [r3, #0]
  test_failure_message = msg;
 8015460:	4a05      	ldr	r2, [pc, #20]	; (8015478 <_test_fail+0x28>)
 8015462:	9b01      	ldr	r3, [sp, #4]
 8015464:	6013      	str	r3, [r2, #0]
  return true;
 8015466:	2301      	movs	r3, #1
}
 8015468:	4618      	mov	r0, r3
 801546a:	b002      	add	sp, #8
 801546c:	4770      	bx	lr
 801546e:	bf00      	nop
 8015470:	2000198d 	.word	0x2000198d
 8015474:	2000198c 	.word	0x2000198c
 8015478:	20001990 	.word	0x20001990
 801547c:	00000000 	.word	0x00000000

08015480 <_test_assert>:
bool _test_assert(bool condition, const char *msg) {
 8015480:	b500      	push	{lr}
 8015482:	b083      	sub	sp, #12
 8015484:	4603      	mov	r3, r0
 8015486:	9100      	str	r1, [sp, #0]
 8015488:	f88d 3007 	strb.w	r3, [sp, #7]
  if (!condition)
 801548c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8015490:	f083 0301 	eor.w	r3, r3, #1
 8015494:	b2db      	uxtb	r3, r3
 8015496:	2b00      	cmp	r3, #0
 8015498:	d004      	beq.n	80154a4 <_test_assert+0x24>
    return _test_fail(msg);
 801549a:	9800      	ldr	r0, [sp, #0]
 801549c:	f7ff ffd8 	bl	8015450 <_test_fail>
 80154a0:	4603      	mov	r3, r0
 80154a2:	e000      	b.n	80154a6 <_test_assert+0x26>
  return false;
 80154a4:	2300      	movs	r3, #0
}
 80154a6:	4618      	mov	r0, r3
 80154a8:	b003      	add	sp, #12
 80154aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80154ae:	bf00      	nop

080154b0 <_test_assert_sequence>:
bool _test_assert_sequence(char *expected, const char *msg) {
 80154b0:	b500      	push	{lr}
 80154b2:	b085      	sub	sp, #20
 80154b4:	9001      	str	r0, [sp, #4]
 80154b6:	9100      	str	r1, [sp, #0]
  char *cp = test_tokens_buffer;
 80154b8:	4b13      	ldr	r3, [pc, #76]	; (8015508 <_test_assert_sequence+0x58>)
 80154ba:	9303      	str	r3, [sp, #12]
 80154bc:	e00e      	b.n	80154dc <_test_assert_sequence+0x2c>
    if (*cp++ != *expected++)
 80154be:	9b03      	ldr	r3, [sp, #12]
 80154c0:	1c5a      	adds	r2, r3, #1
 80154c2:	9203      	str	r2, [sp, #12]
 80154c4:	781a      	ldrb	r2, [r3, #0]
 80154c6:	9b01      	ldr	r3, [sp, #4]
 80154c8:	1c59      	adds	r1, r3, #1
 80154ca:	9101      	str	r1, [sp, #4]
 80154cc:	781b      	ldrb	r3, [r3, #0]
 80154ce:	429a      	cmp	r2, r3
 80154d0:	d004      	beq.n	80154dc <_test_assert_sequence+0x2c>
     return _test_fail(msg);
 80154d2:	9800      	ldr	r0, [sp, #0]
 80154d4:	f7ff ffbc 	bl	8015450 <_test_fail>
 80154d8:	4603      	mov	r3, r0
 80154da:	e010      	b.n	80154fe <_test_assert_sequence+0x4e>
  while (cp < test_tokp) {
 80154dc:	4b0b      	ldr	r3, [pc, #44]	; (801550c <_test_assert_sequence+0x5c>)
 80154de:	681b      	ldr	r3, [r3, #0]
 80154e0:	9a03      	ldr	r2, [sp, #12]
 80154e2:	429a      	cmp	r2, r3
 80154e4:	d3eb      	bcc.n	80154be <_test_assert_sequence+0xe>
  if (*expected)
 80154e6:	9b01      	ldr	r3, [sp, #4]
 80154e8:	781b      	ldrb	r3, [r3, #0]
 80154ea:	2b00      	cmp	r3, #0
 80154ec:	d004      	beq.n	80154f8 <_test_assert_sequence+0x48>
    return _test_fail(msg);
 80154ee:	9800      	ldr	r0, [sp, #0]
 80154f0:	f7ff ffae 	bl	8015450 <_test_fail>
 80154f4:	4603      	mov	r3, r0
 80154f6:	e002      	b.n	80154fe <_test_assert_sequence+0x4e>
  clear_tokens();
 80154f8:	f7ff ff12 	bl	8015320 <clear_tokens>
  return false;
 80154fc:	2300      	movs	r3, #0
}
 80154fe:	4618      	mov	r0, r3
 8015500:	b005      	add	sp, #20
 8015502:	f85d fb04 	ldr.w	pc, [sp], #4
 8015506:	bf00      	nop
 8015508:	20001994 	.word	0x20001994
 801550c:	200019a4 	.word	0x200019a4

08015510 <_test_assert_time_window>:
                              const char *msg) {
 8015510:	b500      	push	{lr}
 8015512:	b085      	sub	sp, #20
 8015514:	9003      	str	r0, [sp, #12]
 8015516:	9102      	str	r1, [sp, #8]
 8015518:	9201      	str	r2, [sp, #4]
  return _test_assert(osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end),
 801551a:	f7ff fed9 	bl	80152d0 <osalOsGetSystemTimeX>
 801551e:	4603      	mov	r3, r0
 8015520:	9a02      	ldr	r2, [sp, #8]
 8015522:	9903      	ldr	r1, [sp, #12]
 8015524:	4618      	mov	r0, r3
 8015526:	f7ff fedb 	bl	80152e0 <osalTimeIsInRangeX>
 801552a:	4603      	mov	r3, r0
 801552c:	9901      	ldr	r1, [sp, #4]
 801552e:	4618      	mov	r0, r3
 8015530:	f7ff ffa6 	bl	8015480 <_test_assert>
 8015534:	4603      	mov	r3, r0
}
 8015536:	4618      	mov	r0, r3
 8015538:	b005      	add	sp, #20
 801553a:	f85d fb04 	ldr.w	pc, [sp], #4
 801553e:	bf00      	nop

08015540 <test_printn>:
void test_printn(uint32_t n) {
 8015540:	b500      	push	{lr}
 8015542:	b089      	sub	sp, #36	; 0x24
 8015544:	9001      	str	r0, [sp, #4]
  if (!n)
 8015546:	9b01      	ldr	r3, [sp, #4]
 8015548:	2b00      	cmp	r3, #0
 801554a:	d109      	bne.n	8015560 <test_printn+0x20>
    streamPut(test_chp, '0');
 801554c:	4b1d      	ldr	r3, [pc, #116]	; (80155c4 <test_printn+0x84>)
 801554e:	681b      	ldr	r3, [r3, #0]
 8015550:	681b      	ldr	r3, [r3, #0]
 8015552:	68db      	ldr	r3, [r3, #12]
 8015554:	4a1b      	ldr	r2, [pc, #108]	; (80155c4 <test_printn+0x84>)
 8015556:	6812      	ldr	r2, [r2, #0]
 8015558:	2130      	movs	r1, #48	; 0x30
 801555a:	4610      	mov	r0, r2
 801555c:	4798      	blx	r3
 801555e:	e02e      	b.n	80155be <test_printn+0x7e>
    p = buf;
 8015560:	ab03      	add	r3, sp, #12
 8015562:	9307      	str	r3, [sp, #28]
 8015564:	e016      	b.n	8015594 <test_printn+0x54>
      *p++ = (n % 10) + '0', n /= 10;
 8015566:	9901      	ldr	r1, [sp, #4]
 8015568:	4b17      	ldr	r3, [pc, #92]	; (80155c8 <test_printn+0x88>)
 801556a:	fba3 2301 	umull	r2, r3, r3, r1
 801556e:	08da      	lsrs	r2, r3, #3
 8015570:	4613      	mov	r3, r2
 8015572:	009b      	lsls	r3, r3, #2
 8015574:	4413      	add	r3, r2
 8015576:	005b      	lsls	r3, r3, #1
 8015578:	1aca      	subs	r2, r1, r3
 801557a:	b2d2      	uxtb	r2, r2
 801557c:	9b07      	ldr	r3, [sp, #28]
 801557e:	1c59      	adds	r1, r3, #1
 8015580:	9107      	str	r1, [sp, #28]
 8015582:	3230      	adds	r2, #48	; 0x30
 8015584:	b2d2      	uxtb	r2, r2
 8015586:	701a      	strb	r2, [r3, #0]
 8015588:	9b01      	ldr	r3, [sp, #4]
 801558a:	4a0f      	ldr	r2, [pc, #60]	; (80155c8 <test_printn+0x88>)
 801558c:	fba2 2303 	umull	r2, r3, r2, r3
 8015590:	08db      	lsrs	r3, r3, #3
 8015592:	9301      	str	r3, [sp, #4]
    while (n)
 8015594:	9b01      	ldr	r3, [sp, #4]
 8015596:	2b00      	cmp	r3, #0
 8015598:	d1e5      	bne.n	8015566 <test_printn+0x26>
 801559a:	e00c      	b.n	80155b6 <test_printn+0x76>
      streamPut(test_chp, *--p);
 801559c:	4b09      	ldr	r3, [pc, #36]	; (80155c4 <test_printn+0x84>)
 801559e:	681b      	ldr	r3, [r3, #0]
 80155a0:	681b      	ldr	r3, [r3, #0]
 80155a2:	68db      	ldr	r3, [r3, #12]
 80155a4:	4a07      	ldr	r2, [pc, #28]	; (80155c4 <test_printn+0x84>)
 80155a6:	6810      	ldr	r0, [r2, #0]
 80155a8:	9a07      	ldr	r2, [sp, #28]
 80155aa:	3a01      	subs	r2, #1
 80155ac:	9207      	str	r2, [sp, #28]
 80155ae:	9a07      	ldr	r2, [sp, #28]
 80155b0:	7812      	ldrb	r2, [r2, #0]
 80155b2:	4611      	mov	r1, r2
 80155b4:	4798      	blx	r3
    while (p > buf)
 80155b6:	ab03      	add	r3, sp, #12
 80155b8:	9a07      	ldr	r2, [sp, #28]
 80155ba:	429a      	cmp	r2, r3
 80155bc:	d8ee      	bhi.n	801559c <test_printn+0x5c>
}
 80155be:	b009      	add	sp, #36	; 0x24
 80155c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80155c4:	200019a8 	.word	0x200019a8
 80155c8:	cccccccd 	.word	0xcccccccd
 80155cc:	00000000 	.word	0x00000000

080155d0 <test_print>:
void test_print(const char *msgp) {
 80155d0:	b500      	push	{lr}
 80155d2:	b083      	sub	sp, #12
 80155d4:	9001      	str	r0, [sp, #4]
 80155d6:	e00b      	b.n	80155f0 <test_print+0x20>
    streamPut(test_chp, *msgp++);
 80155d8:	4b09      	ldr	r3, [pc, #36]	; (8015600 <test_print+0x30>)
 80155da:	681b      	ldr	r3, [r3, #0]
 80155dc:	681b      	ldr	r3, [r3, #0]
 80155de:	68da      	ldr	r2, [r3, #12]
 80155e0:	4b07      	ldr	r3, [pc, #28]	; (8015600 <test_print+0x30>)
 80155e2:	6818      	ldr	r0, [r3, #0]
 80155e4:	9b01      	ldr	r3, [sp, #4]
 80155e6:	1c59      	adds	r1, r3, #1
 80155e8:	9101      	str	r1, [sp, #4]
 80155ea:	781b      	ldrb	r3, [r3, #0]
 80155ec:	4619      	mov	r1, r3
 80155ee:	4790      	blx	r2
  while (*msgp)
 80155f0:	9b01      	ldr	r3, [sp, #4]
 80155f2:	781b      	ldrb	r3, [r3, #0]
 80155f4:	2b00      	cmp	r3, #0
 80155f6:	d1ef      	bne.n	80155d8 <test_print+0x8>
}
 80155f8:	b003      	add	sp, #12
 80155fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80155fe:	bf00      	nop
 8015600:	200019a8 	.word	0x200019a8
	...

08015610 <test_println>:
void test_println(const char *msgp) {
 8015610:	b500      	push	{lr}
 8015612:	b083      	sub	sp, #12
 8015614:	9001      	str	r0, [sp, #4]
  test_print(msgp);
 8015616:	9801      	ldr	r0, [sp, #4]
 8015618:	f7ff ffda 	bl	80155d0 <test_print>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 801561c:	4b05      	ldr	r3, [pc, #20]	; (8015634 <test_println+0x24>)
 801561e:	681b      	ldr	r3, [r3, #0]
 8015620:	681b      	ldr	r3, [r3, #0]
 8015622:	685b      	ldr	r3, [r3, #4]
 8015624:	4a03      	ldr	r2, [pc, #12]	; (8015634 <test_println+0x24>)
 8015626:	6810      	ldr	r0, [r2, #0]
 8015628:	2202      	movs	r2, #2
 801562a:	4903      	ldr	r1, [pc, #12]	; (8015638 <test_println+0x28>)
 801562c:	4798      	blx	r3
}
 801562e:	b003      	add	sp, #12
 8015630:	f85d fb04 	ldr.w	pc, [sp], #4
 8015634:	200019a8 	.word	0x200019a8
 8015638:	08018bbc 	.word	0x08018bbc
 801563c:	00000000 	.word	0x00000000

08015640 <test_emit_token>:
void test_emit_token(char token) {
 8015640:	b500      	push	{lr}
 8015642:	b083      	sub	sp, #12
 8015644:	4603      	mov	r3, r0
 8015646:	f88d 3007 	strb.w	r3, [sp, #7]
  osalSysLock();
 801564a:	f7ff fe31 	bl	80152b0 <osalSysLock.lto_priv.282>
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 801564e:	4b09      	ldr	r3, [pc, #36]	; (8015674 <test_emit_token+0x34>)
 8015650:	681b      	ldr	r3, [r3, #0]
 8015652:	4a09      	ldr	r2, [pc, #36]	; (8015678 <test_emit_token+0x38>)
 8015654:	4293      	cmp	r3, r2
 8015656:	d207      	bcs.n	8015668 <test_emit_token+0x28>
    *test_tokp++ = token;
 8015658:	4b06      	ldr	r3, [pc, #24]	; (8015674 <test_emit_token+0x34>)
 801565a:	681b      	ldr	r3, [r3, #0]
 801565c:	1c5a      	adds	r2, r3, #1
 801565e:	4905      	ldr	r1, [pc, #20]	; (8015674 <test_emit_token+0x34>)
 8015660:	600a      	str	r2, [r1, #0]
 8015662:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8015666:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8015668:	f7ff fe2a 	bl	80152c0 <osalSysUnlock.lto_priv.273>
}
 801566c:	b003      	add	sp, #12
 801566e:	f85d fb04 	ldr.w	pc, [sp], #4
 8015672:	bf00      	nop
 8015674:	200019a4 	.word	0x200019a4
 8015678:	200019a4 	.word	0x200019a4

0801567c <memcmp>:
 801567c:	2a03      	cmp	r2, #3
 801567e:	b470      	push	{r4, r5, r6}
 8015680:	d914      	bls.n	80156ac <memcmp+0x30>
 8015682:	ea40 0501 	orr.w	r5, r0, r1
 8015686:	07ad      	lsls	r5, r5, #30
 8015688:	4604      	mov	r4, r0
 801568a:	460b      	mov	r3, r1
 801568c:	d122      	bne.n	80156d4 <memcmp+0x58>
 801568e:	681d      	ldr	r5, [r3, #0]
 8015690:	6826      	ldr	r6, [r4, #0]
 8015692:	42ae      	cmp	r6, r5
 8015694:	4619      	mov	r1, r3
 8015696:	4620      	mov	r0, r4
 8015698:	f103 0304 	add.w	r3, r3, #4
 801569c:	f104 0404 	add.w	r4, r4, #4
 80156a0:	d118      	bne.n	80156d4 <memcmp+0x58>
 80156a2:	3a04      	subs	r2, #4
 80156a4:	2a03      	cmp	r2, #3
 80156a6:	4620      	mov	r0, r4
 80156a8:	4619      	mov	r1, r3
 80156aa:	d8f0      	bhi.n	801568e <memcmp+0x12>
 80156ac:	1e54      	subs	r4, r2, #1
 80156ae:	b172      	cbz	r2, 80156ce <memcmp+0x52>
 80156b0:	7802      	ldrb	r2, [r0, #0]
 80156b2:	780b      	ldrb	r3, [r1, #0]
 80156b4:	429a      	cmp	r2, r3
 80156b6:	bf08      	it	eq
 80156b8:	1864      	addeq	r4, r4, r1
 80156ba:	d006      	beq.n	80156ca <memcmp+0x4e>
 80156bc:	e00c      	b.n	80156d8 <memcmp+0x5c>
 80156be:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 80156c2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80156c6:	429a      	cmp	r2, r3
 80156c8:	d106      	bne.n	80156d8 <memcmp+0x5c>
 80156ca:	42a1      	cmp	r1, r4
 80156cc:	d1f7      	bne.n	80156be <memcmp+0x42>
 80156ce:	2000      	movs	r0, #0
 80156d0:	bc70      	pop	{r4, r5, r6}
 80156d2:	4770      	bx	lr
 80156d4:	1e54      	subs	r4, r2, #1
 80156d6:	e7eb      	b.n	80156b0 <memcmp+0x34>
 80156d8:	1ad0      	subs	r0, r2, r3
 80156da:	bc70      	pop	{r4, r5, r6}
 80156dc:	4770      	bx	lr
 80156de:	bf00      	nop

080156e0 <memset>:
 80156e0:	b4f0      	push	{r4, r5, r6, r7}
 80156e2:	0786      	lsls	r6, r0, #30
 80156e4:	d043      	beq.n	801576e <memset+0x8e>
 80156e6:	1e54      	subs	r4, r2, #1
 80156e8:	2a00      	cmp	r2, #0
 80156ea:	d03e      	beq.n	801576a <memset+0x8a>
 80156ec:	b2ca      	uxtb	r2, r1
 80156ee:	4603      	mov	r3, r0
 80156f0:	e002      	b.n	80156f8 <memset+0x18>
 80156f2:	f114 34ff 	adds.w	r4, r4, #4294967295
 80156f6:	d338      	bcc.n	801576a <memset+0x8a>
 80156f8:	f803 2b01 	strb.w	r2, [r3], #1
 80156fc:	079d      	lsls	r5, r3, #30
 80156fe:	d1f8      	bne.n	80156f2 <memset+0x12>
 8015700:	2c03      	cmp	r4, #3
 8015702:	d92b      	bls.n	801575c <memset+0x7c>
 8015704:	b2cd      	uxtb	r5, r1
 8015706:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 801570a:	2c0f      	cmp	r4, #15
 801570c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8015710:	d916      	bls.n	8015740 <memset+0x60>
 8015712:	f1a4 0710 	sub.w	r7, r4, #16
 8015716:	093f      	lsrs	r7, r7, #4
 8015718:	f103 0620 	add.w	r6, r3, #32
 801571c:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 8015720:	f103 0210 	add.w	r2, r3, #16
 8015724:	e942 5504 	strd	r5, r5, [r2, #-16]
 8015728:	e942 5502 	strd	r5, r5, [r2, #-8]
 801572c:	3210      	adds	r2, #16
 801572e:	42b2      	cmp	r2, r6
 8015730:	d1f8      	bne.n	8015724 <memset+0x44>
 8015732:	f004 040f 	and.w	r4, r4, #15
 8015736:	3701      	adds	r7, #1
 8015738:	2c03      	cmp	r4, #3
 801573a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 801573e:	d90d      	bls.n	801575c <memset+0x7c>
 8015740:	461e      	mov	r6, r3
 8015742:	4622      	mov	r2, r4
 8015744:	3a04      	subs	r2, #4
 8015746:	2a03      	cmp	r2, #3
 8015748:	f846 5b04 	str.w	r5, [r6], #4
 801574c:	d8fa      	bhi.n	8015744 <memset+0x64>
 801574e:	1f22      	subs	r2, r4, #4
 8015750:	f022 0203 	bic.w	r2, r2, #3
 8015754:	3204      	adds	r2, #4
 8015756:	4413      	add	r3, r2
 8015758:	f004 0403 	and.w	r4, r4, #3
 801575c:	b12c      	cbz	r4, 801576a <memset+0x8a>
 801575e:	b2c9      	uxtb	r1, r1
 8015760:	441c      	add	r4, r3
 8015762:	f803 1b01 	strb.w	r1, [r3], #1
 8015766:	429c      	cmp	r4, r3
 8015768:	d1fb      	bne.n	8015762 <memset+0x82>
 801576a:	bcf0      	pop	{r4, r5, r6, r7}
 801576c:	4770      	bx	lr
 801576e:	4614      	mov	r4, r2
 8015770:	4603      	mov	r3, r0
 8015772:	e7c5      	b.n	8015700 <memset+0x20>

08015774 <strchr>:
 8015774:	b2c9      	uxtb	r1, r1
 8015776:	f000 0303 	and.w	r3, r0, #3
 801577a:	2900      	cmp	r1, #0
 801577c:	d043      	beq.n	8015806 <strchr+0x92>
 801577e:	b17b      	cbz	r3, 80157a0 <strchr+0x2c>
 8015780:	7803      	ldrb	r3, [r0, #0]
 8015782:	2b00      	cmp	r3, #0
 8015784:	d067      	beq.n	8015856 <strchr+0xe2>
 8015786:	4299      	cmp	r1, r3
 8015788:	d03c      	beq.n	8015804 <strchr+0x90>
 801578a:	1c43      	adds	r3, r0, #1
 801578c:	e005      	b.n	801579a <strchr+0x26>
 801578e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8015792:	2a00      	cmp	r2, #0
 8015794:	d05d      	beq.n	8015852 <strchr+0xde>
 8015796:	428a      	cmp	r2, r1
 8015798:	d034      	beq.n	8015804 <strchr+0x90>
 801579a:	079a      	lsls	r2, r3, #30
 801579c:	4618      	mov	r0, r3
 801579e:	d1f6      	bne.n	801578e <strchr+0x1a>
 80157a0:	b470      	push	{r4, r5, r6}
 80157a2:	6804      	ldr	r4, [r0, #0]
 80157a4:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 80157a8:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 80157ac:	ea86 0504 	eor.w	r5, r6, r4
 80157b0:	f1a5 3301 	sub.w	r3, r5, #16843009	; 0x1010101
 80157b4:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 80157b8:	ea23 0305 	bic.w	r3, r3, r5
 80157bc:	ea22 0204 	bic.w	r2, r2, r4
 80157c0:	4313      	orrs	r3, r2
 80157c2:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80157c6:	d10f      	bne.n	80157e8 <strchr+0x74>
 80157c8:	f850 4f04 	ldr.w	r4, [r0, #4]!
 80157cc:	ea84 0506 	eor.w	r5, r4, r6
 80157d0:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
 80157d4:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
 80157d8:	ea22 0205 	bic.w	r2, r2, r5
 80157dc:	ea23 0304 	bic.w	r3, r3, r4
 80157e0:	4313      	orrs	r3, r2
 80157e2:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80157e6:	d0ef      	beq.n	80157c8 <strchr+0x54>
 80157e8:	7803      	ldrb	r3, [r0, #0]
 80157ea:	b143      	cbz	r3, 80157fe <strchr+0x8a>
 80157ec:	4299      	cmp	r1, r3
 80157ee:	d102      	bne.n	80157f6 <strchr+0x82>
 80157f0:	e006      	b.n	8015800 <strchr+0x8c>
 80157f2:	428b      	cmp	r3, r1
 80157f4:	d004      	beq.n	8015800 <strchr+0x8c>
 80157f6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80157fa:	2b00      	cmp	r3, #0
 80157fc:	d1f9      	bne.n	80157f2 <strchr+0x7e>
 80157fe:	4618      	mov	r0, r3
 8015800:	bc70      	pop	{r4, r5, r6}
 8015802:	4770      	bx	lr
 8015804:	4770      	bx	lr
 8015806:	b15b      	cbz	r3, 8015820 <strchr+0xac>
 8015808:	7803      	ldrb	r3, [r0, #0]
 801580a:	2b00      	cmp	r3, #0
 801580c:	d0fa      	beq.n	8015804 <strchr+0x90>
 801580e:	1c43      	adds	r3, r0, #1
 8015810:	e003      	b.n	801581a <strchr+0xa6>
 8015812:	7802      	ldrb	r2, [r0, #0]
 8015814:	3301      	adds	r3, #1
 8015816:	2a00      	cmp	r2, #0
 8015818:	d0f4      	beq.n	8015804 <strchr+0x90>
 801581a:	0799      	lsls	r1, r3, #30
 801581c:	4618      	mov	r0, r3
 801581e:	d1f8      	bne.n	8015812 <strchr+0x9e>
 8015820:	6802      	ldr	r2, [r0, #0]
 8015822:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8015826:	ea23 0302 	bic.w	r3, r3, r2
 801582a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 801582e:	d108      	bne.n	8015842 <strchr+0xce>
 8015830:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8015834:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8015838:	ea23 0302 	bic.w	r3, r3, r2
 801583c:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8015840:	d0f6      	beq.n	8015830 <strchr+0xbc>
 8015842:	7803      	ldrb	r3, [r0, #0]
 8015844:	2b00      	cmp	r3, #0
 8015846:	d0dd      	beq.n	8015804 <strchr+0x90>
 8015848:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 801584c:	2b00      	cmp	r3, #0
 801584e:	d1fb      	bne.n	8015848 <strchr+0xd4>
 8015850:	4770      	bx	lr
 8015852:	4610      	mov	r0, r2
 8015854:	4770      	bx	lr
 8015856:	4618      	mov	r0, r3
 8015858:	4770      	bx	lr
 801585a:	bf00      	nop

0801585c <strncmp>:
 801585c:	2a00      	cmp	r2, #0
 801585e:	d041      	beq.n	80158e4 <strncmp+0x88>
 8015860:	ea40 0301 	orr.w	r3, r0, r1
 8015864:	f013 0303 	ands.w	r3, r3, #3
 8015868:	b4f0      	push	{r4, r5, r6, r7}
 801586a:	d125      	bne.n	80158b8 <strncmp+0x5c>
 801586c:	2a03      	cmp	r2, #3
 801586e:	d923      	bls.n	80158b8 <strncmp+0x5c>
 8015870:	6804      	ldr	r4, [r0, #0]
 8015872:	680d      	ldr	r5, [r1, #0]
 8015874:	42ac      	cmp	r4, r5
 8015876:	d11f      	bne.n	80158b8 <strncmp+0x5c>
 8015878:	3a04      	subs	r2, #4
 801587a:	d035      	beq.n	80158e8 <strncmp+0x8c>
 801587c:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8015880:	ea25 0404 	bic.w	r4, r5, r4
 8015884:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8015888:	d131      	bne.n	80158ee <strncmp+0x92>
 801588a:	1d07      	adds	r7, r0, #4
 801588c:	1d0d      	adds	r5, r1, #4
 801588e:	e00d      	b.n	80158ac <strncmp+0x50>
 8015890:	f857 3b04 	ldr.w	r3, [r7], #4
 8015894:	680e      	ldr	r6, [r1, #0]
 8015896:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 801589a:	42b3      	cmp	r3, r6
 801589c:	ea24 0403 	bic.w	r4, r4, r3
 80158a0:	d10a      	bne.n	80158b8 <strncmp+0x5c>
 80158a2:	3a04      	subs	r2, #4
 80158a4:	d020      	beq.n	80158e8 <strncmp+0x8c>
 80158a6:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 80158aa:	d11d      	bne.n	80158e8 <strncmp+0x8c>
 80158ac:	2a03      	cmp	r2, #3
 80158ae:	4629      	mov	r1, r5
 80158b0:	4638      	mov	r0, r7
 80158b2:	f105 0504 	add.w	r5, r5, #4
 80158b6:	d8eb      	bhi.n	8015890 <strncmp+0x34>
 80158b8:	7803      	ldrb	r3, [r0, #0]
 80158ba:	780c      	ldrb	r4, [r1, #0]
 80158bc:	429c      	cmp	r4, r3
 80158be:	f102 32ff 	add.w	r2, r2, #4294967295
 80158c2:	d10c      	bne.n	80158de <strncmp+0x82>
 80158c4:	b182      	cbz	r2, 80158e8 <strncmp+0x8c>
 80158c6:	b914      	cbnz	r4, 80158ce <strncmp+0x72>
 80158c8:	e00e      	b.n	80158e8 <strncmp+0x8c>
 80158ca:	b16a      	cbz	r2, 80158e8 <strncmp+0x8c>
 80158cc:	b17b      	cbz	r3, 80158ee <strncmp+0x92>
 80158ce:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80158d2:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80158d6:	42a3      	cmp	r3, r4
 80158d8:	f102 32ff 	add.w	r2, r2, #4294967295
 80158dc:	d0f5      	beq.n	80158ca <strncmp+0x6e>
 80158de:	1b18      	subs	r0, r3, r4
 80158e0:	bcf0      	pop	{r4, r5, r6, r7}
 80158e2:	4770      	bx	lr
 80158e4:	4610      	mov	r0, r2
 80158e6:	4770      	bx	lr
 80158e8:	2000      	movs	r0, #0
 80158ea:	bcf0      	pop	{r4, r5, r6, r7}
 80158ec:	4770      	bx	lr
 80158ee:	4618      	mov	r0, r3
 80158f0:	e7f6      	b.n	80158e0 <strncmp+0x84>
 80158f2:	bf00      	nop

080158f4 <strncpy>:
 80158f4:	ea40 0301 	orr.w	r3, r0, r1
 80158f8:	079b      	lsls	r3, r3, #30
 80158fa:	b470      	push	{r4, r5, r6}
 80158fc:	d12a      	bne.n	8015954 <strncpy+0x60>
 80158fe:	2a03      	cmp	r2, #3
 8015900:	d928      	bls.n	8015954 <strncpy+0x60>
 8015902:	460c      	mov	r4, r1
 8015904:	4603      	mov	r3, r0
 8015906:	4621      	mov	r1, r4
 8015908:	f854 6b04 	ldr.w	r6, [r4], #4
 801590c:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
 8015910:	ea25 0506 	bic.w	r5, r5, r6
 8015914:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 8015918:	d106      	bne.n	8015928 <strncpy+0x34>
 801591a:	3a04      	subs	r2, #4
 801591c:	2a03      	cmp	r2, #3
 801591e:	f843 6b04 	str.w	r6, [r3], #4
 8015922:	4621      	mov	r1, r4
 8015924:	d8ef      	bhi.n	8015906 <strncpy+0x12>
 8015926:	b19a      	cbz	r2, 8015950 <strncpy+0x5c>
 8015928:	780c      	ldrb	r4, [r1, #0]
 801592a:	701c      	strb	r4, [r3, #0]
 801592c:	3a01      	subs	r2, #1
 801592e:	3301      	adds	r3, #1
 8015930:	b13c      	cbz	r4, 8015942 <strncpy+0x4e>
 8015932:	b16a      	cbz	r2, 8015950 <strncpy+0x5c>
 8015934:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8015938:	f803 4b01 	strb.w	r4, [r3], #1
 801593c:	3a01      	subs	r2, #1
 801593e:	2c00      	cmp	r4, #0
 8015940:	d1f7      	bne.n	8015932 <strncpy+0x3e>
 8015942:	b12a      	cbz	r2, 8015950 <strncpy+0x5c>
 8015944:	441a      	add	r2, r3
 8015946:	2100      	movs	r1, #0
 8015948:	f803 1b01 	strb.w	r1, [r3], #1
 801594c:	4293      	cmp	r3, r2
 801594e:	d1fb      	bne.n	8015948 <strncpy+0x54>
 8015950:	bc70      	pop	{r4, r5, r6}
 8015952:	4770      	bx	lr
 8015954:	4603      	mov	r3, r0
 8015956:	e7e6      	b.n	8015926 <strncpy+0x32>

08015958 <strpbrk>:
 8015958:	b430      	push	{r4, r5}
 801595a:	7804      	ldrb	r4, [r0, #0]
 801595c:	b1dc      	cbz	r4, 8015996 <strpbrk+0x3e>
 801595e:	780d      	ldrb	r5, [r1, #0]
 8015960:	b19d      	cbz	r5, 801598a <strpbrk+0x32>
 8015962:	42ac      	cmp	r4, r5
 8015964:	d00f      	beq.n	8015986 <strpbrk+0x2e>
 8015966:	460a      	mov	r2, r1
 8015968:	e001      	b.n	801596e <strpbrk+0x16>
 801596a:	429c      	cmp	r4, r3
 801596c:	d00b      	beq.n	8015986 <strpbrk+0x2e>
 801596e:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8015972:	2b00      	cmp	r3, #0
 8015974:	d1f9      	bne.n	801596a <strpbrk+0x12>
 8015976:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 801597a:	2c00      	cmp	r4, #0
 801597c:	d1f0      	bne.n	8015960 <strpbrk+0x8>
 801597e:	7813      	ldrb	r3, [r2, #0]
 8015980:	2b00      	cmp	r3, #0
 8015982:	bf08      	it	eq
 8015984:	2000      	moveq	r0, #0
 8015986:	bc30      	pop	{r4, r5}
 8015988:	4770      	bx	lr
 801598a:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 801598e:	460a      	mov	r2, r1
 8015990:	2c00      	cmp	r4, #0
 8015992:	d1e5      	bne.n	8015960 <strpbrk+0x8>
 8015994:	e7f3      	b.n	801597e <strpbrk+0x26>
 8015996:	4620      	mov	r0, r4
 8015998:	e7f5      	b.n	8015986 <strpbrk+0x2e>
 801599a:	bf00      	nop

0801599c <strspn>:
 801599c:	b470      	push	{r4, r5, r6}
 801599e:	7804      	ldrb	r4, [r0, #0]
 80159a0:	b1a4      	cbz	r4, 80159cc <strspn+0x30>
 80159a2:	780d      	ldrb	r5, [r1, #0]
 80159a4:	4606      	mov	r6, r0
 80159a6:	b14d      	cbz	r5, 80159bc <strspn+0x20>
 80159a8:	42a5      	cmp	r5, r4
 80159aa:	d00a      	beq.n	80159c2 <strspn+0x26>
 80159ac:	460a      	mov	r2, r1
 80159ae:	e001      	b.n	80159b4 <strspn+0x18>
 80159b0:	42a3      	cmp	r3, r4
 80159b2:	d006      	beq.n	80159c2 <strspn+0x26>
 80159b4:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80159b8:	2b00      	cmp	r3, #0
 80159ba:	d1f9      	bne.n	80159b0 <strspn+0x14>
 80159bc:	1b80      	subs	r0, r0, r6
 80159be:	bc70      	pop	{r4, r5, r6}
 80159c0:	4770      	bx	lr
 80159c2:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80159c6:	2c00      	cmp	r4, #0
 80159c8:	d1ed      	bne.n	80159a6 <strspn+0xa>
 80159ca:	e7f7      	b.n	80159bc <strspn+0x20>
 80159cc:	4620      	mov	r0, r4
 80159ce:	e7f6      	b.n	80159be <strspn+0x22>
